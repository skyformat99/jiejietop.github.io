<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>闲谈：我为什么热爱开源。</title>
      <link href="/open-source/"/>
      <url>/open-source/</url>
      
        <content type="html"><![CDATA[<p>hello！公众号的兄弟姐妹们大家好，我们今天来聊一聊我热爱的事情——<strong>开源</strong>。</p><p>回想几年前，我刚学C语言的时候，觉得这东西很好玩，也很有兴趣，居然能让我操控电脑，虽然能做的东西不对，也就打印点字符在屏幕上，但这确实却让我喜欢上了它，也许以前没有接触过这些高大上的东西，也许以前玩电脑只会打游戏，也许是高中的时候曾有过一段时间热衷于刷机（那时候刷安卓机系统，知其然不知其所以然，但仍觉得有趣）。。。总之，接触了代码后，我确实喜欢上了它 ღ( ´･ᴗ･` )~</p><p>后面的学习过程中，接触了单片机，我发现这东西也很有趣，能做点小东西，做个时钟、小车、LED小蛮腰。。。那时候我是跟着师兄学习的，做硬件，抄电路、拉线，腐蚀pcb板子，然后再写代码，让我的大学生活充满了乐趣，毕竟我这种不听话的学生，压根就不喜欢上课，呆在实验室还比较好玩，而且认识了很多好基友，现在每天都在吹牛扯淡打游戏聊妹纸，生活也非常愉快。。。</p><p>在大学的时候，我一直在混论坛社区，也非常喜欢分享自己的学习、代码，总是写帖子，混着混着就成为了几个论坛的版主，虽然很水，但也乐在其中。说起来我是大二的时候就开始捣鼓这些的，当年是参加了电赛，然后分享了电赛的经验，还开源了代码，这是我<strong>第一次</strong>开源，然后从此以后就奠定了在论坛混的基础，哪段时间我发的帖子非常热门，以至于到每年的电赛前后，我的帖子依旧有人在回复。</p><p>后续，我就逐渐退出论坛了，原因有两点：</p><ol><li><p><strong>国内论坛质量太差</strong>。没有太多有技术含量的东西，到了后面基本是在水贴，感觉会浪费我太多的时间。</p></li><li><p><strong>伸手党太多</strong>。等着喂饭的人太多了，实在是不好在论坛混。</p></li></ol><p>在大三的时候，系统性学习了git相关的知识，虽说记不住太多东西，但是也已经够我日常使用了，那时候学习的操作系统，<strong>朱天龙</strong>大佬对我影响甚大（是我第一个follow的大佬），他一直在为开源做贡献，写的框架非常好，代码规范，在嵌入式领域中，这样子的大神并不多见，so，我得向大神学习，那时候就觉得，我以后也要写出点<strong>像样</strong>的代码。。。</p><p>自此以后，就走在了开源的道路上，以前写的代码，几乎都使用了GPL开源协议，目的是为了让更多的人开源起来，然而比较尴尬的是，效果并不明显哈哈哈哈，国内（个人）开源的氛围确实很惨淡，这也是没办法的事情，一些很好的软件代码，几乎都是企业在维护，我曾经见过不少个人的开源项目（发布的时间是几年前的），到现在就几乎没有在GitHub上push的记录了，也就是说，这个开发者可能退出了开源社区，可能开发者事业上升了，成为了管理层，可能成家立业没有时间去维护了，但是就是这样子一个开源项目得不到维护了，这是很<strong>可惜</strong>的一件事情。。。我不知道我能坚持开源多久，<strong>但我希望我能一直做下去</strong>。</p><p>那我为什么会开源呢？很重要的是个人原因，我就一个行业内的小菜鸟，我开源的出发点绝大部分是<strong>为了自己</strong>，其次才是为社会贡献，毕竟我也有一个骚气的理想——“<strong>希望在赚钱的同时能为世界做一点点贡献，实在没有就算了</strong>”。</p><p>我喜欢开源的原因无非以下几点：</p><ul><li><p>首先吧，开源的代码代表着别人能看到，就像你将你的内裤给别人看了，有漏洞，想要面子上过得去，那你就尽量别穿有洞的内裤是不是，那就会自觉地将代码写得更干净更标准一点，然后加点注释，如果有人给你的代码<strong>反馈</strong>了，那这就更有意义了，你会思考到用户是怎么去使用你的代码的，反馈的多了你就知道<strong>如何去将代码写得更好，更实用</strong>。其次，如果你写一个代码，那你就会去<strong>了解它的原理</strong>，然后也会参考<strong>现有代码</strong>的实现方式，阅读别人的源码，<strong>吸取他们的编程思想</strong>，这是一个非常好的学习方式，一般来说我的学习过程基本就是先看理论知识，弄懂了这个理论，再去看源码，而看源码的时候，我会查阅很多博客、书籍，在源码中更深入连接这个知识，这是我自认为更适合我自己的学习方式，而且也非常有效果。</p></li><li><p>GitHub是一个很好的<strong>展示面</strong>，如果你是要找工作的，我建议你一定要多写开源的代码，毕竟公司会很好奇你写的代码质量如何，光从面试实在看不出太多。所以很多公司会非常喜欢看你的开源项目，来评估一下你的代码质量如何。同样，如果你面试的时候告诉公司，“我有个开源项目，你们可以去看看”，这将是个不错的加分项，至少我是这么认为的，如果是我面试别人，我肯定会看一下。当然啦，做开源不是一两天就能完成的，临时抱佛脚是完全不可能的，还是需要<strong>坚持</strong>。</p></li><li><p>开源的代码，能建立起你个人的“<strong>品牌</strong>”，一个优质的开源项目，<strong>是提升你自己影响力的好方法</strong>，我并不是在自吹自擂哈，毕竟我是小菜鸟，认识我的人也不多，而且这两年以来我几乎都是小型讨论组聊技术，水群比较少，这种小讨论组能很有效提升自身的技术，毕竟能相互讨论的，都可以共同进步，而在<strong>大群聊</strong>多半是<strong>吹水</strong>居多，但是有好几次我在群里分享一些开源的代码，有些群友就发现原来他一直用的代码是我写的。哈哈哈哈，这我感觉还是很棒的，<strong>极大的满足感</strong>，如果你能写出一些很好的轮子，然后让成百上千的开发者依赖你写的代码，<strong>我想没有什么能比这更棒的事情了</strong>。</p></li><li><p>最后就是能够通过这些代码认识一些<strong>其他开发者</strong>，这些开发者是有很有水平的，毕竟能在开源上与你讨论代码的，早已不是伸手党了，这样子就能排除一部分伸手党。比如我就认识了一些大厂的人，有百度的、腾讯的、阿里的以及其他在业内排名靠前的公司的开发者等等，而且我写公众号，也认识了不少业内公众号的号主，也是时不时聊聊天，总之让我的人脉变的更广一点了，这对我来说也是很好的一件事情。而且能收到大神的点赞与认可，这是非常值得开心的事情，也让我更有自信写出更好的代码。</p></li><li><p>还有很重要的一点是，开源代码在一开始可能并不会受到大家的青睐，但是随着时间的推移，会有越来越多的开发者知道并尝试使用它，这是一个细水长流的东西，<strong>需要时间的打磨</strong>，越到后面能产生的效应也就越大，所以这总是非常nice的。</p></li><li><p>当然啦，我也非常希望自己的代码能<strong>为世界做一丢丢贡献</strong>，能点个灯也不错。</p></li></ul><p>当然，相对于写公众号，我更喜欢写代码，我每天都在写代码，几乎从不间断，我最近一两年写的开源项目，我来说说消耗的时间吧，基本上是5个月能写出一个算是比较稳定的版本，一般一个开源项目最起码要提交上百次，才能算是逐步趋向稳定，后续就慢慢打磨咯，而上百次的提交，需要的时间几乎就是2-3个月，然后后面的就是不断打磨打磨，4-5个月就差不多是比较稳定的了，再往后就是修bug，迭代。。。当然这只是我的项目，那种大型的开源项目，需要的时间更久。。。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 闲谈开源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲谈 </tag>
            
            <tag> 开源 </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【libuv高效编程】libuv学习超详细教程11 —— libuv stream 流句柄解读</title>
      <link href="/libuv-11/"/>
      <url>/libuv-11/</url>
      
        <content type="html"><![CDATA[<h1 id="libuv系列文章"><a href="#libuv系列文章" class="headerlink" title="libuv系列文章"></a>libuv系列文章</h1><ul><li><p><a href="https://jiedev.com/libuv-1/">【libuv高效编程】libuv学习超详细教程1——libuv的编译与安装</a></p></li><li><p><a href="https://jiedev.com/libuv-2/">【libuv高效编程】libuv学习超详细教程2——libuv框架初窥</a></p></li><li><p><a href="https://jiedev.com/libuv-3/">【libuv高效编程】libuv学习超详细教程3——libuv事件循环</a></p></li><li><p><a href="https://jiedev.com/libuv-4/">【libuv高效编程】libuv学习超详细教程4——libuv idle 空闲句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-5/">【libuv高效编程】libuv学习超详细教程5——libuv prepare 准备句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-6/">【libuv高效编程】libuv学习超详细教程6——libuv check 检查句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-7/">【libuv高效编程】libuv学习超详细教程7——libuv thread 线程句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-8/">【libuv高效编程】libuv学习超详细教程8——libuv signal 信号句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-9/">【libuv高效编程】libuv学习超详细教程9——libuv async异步句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-10/">【libuv高效编程】libuv学习超详细教程10 —— libuv stream 流句柄解读【上】</a></p></li><li><p><a href="https://jiedev.com/libuv-11/">【libuv高效编程】libuv学习超详细教程11 —— libuv stream 流句柄解读【下】</a></p></li></ul><h1 id="stream-handle-的外部API"><a href="#stream-handle-的外部API" class="headerlink" title="stream handle 的外部API"></a>stream handle 的外部API</h1><p>我们接着上一篇文章接着讲解流操作的API。这些api接口我们会很经常使用到，比如在读取tcp、udp、文件数据的时候，就会用到，同理写数据的时候也会用到。</p><h1 id="uv-shutdown"><a href="#uv-shutdown" class="headerlink" title="uv_shutdown()"></a>uv_shutdown()</h1><p>关闭流的写端口，它会等待未完成的写操作，在关闭后通过uv_shutdown_cb指定的回调函数告知应用层。</p><p><strong>注意了，它并不是关闭stream handle，只是关闭了写入端。</strong></p><p>参数：</p><ul><li>req：指定关闭的请求。</li><li>stream：指定stream handle。</li><li>cb：在关闭后告知应用层的回调函数。</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_shutdown</span><span class="token punctuation">(</span>uv_shutdown_t<span class="token operator">*</span> req<span class="token punctuation">,</span> uv_stream_t<span class="token operator">*</span> stream<span class="token punctuation">,</span> uv_shutdown_cb cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/* 校验相关信息，只有 UV_TCP UV_TTY UV_NAMED_PIPE 类型的stream handle 才可以用*/</span>  <span class="token function">assert</span><span class="token punctuation">(</span>stream<span class="token operator">-></span>type <span class="token operator">==</span> UV_TCP <span class="token operator">||</span>         stream<span class="token operator">-></span>type <span class="token operator">==</span> UV_TTY <span class="token operator">||</span>         stream<span class="token operator">-></span>type <span class="token operator">==</span> UV_NAMED_PIPE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>stream<span class="token operator">-></span>flags <span class="token operator">&amp;</span> UV_HANDLE_WRITABLE<span class="token punctuation">)</span> <span class="token operator">||</span>      stream<span class="token operator">-></span>flags <span class="token operator">&amp;</span> UV_HANDLE_SHUT <span class="token operator">||</span>      stream<span class="token operator">-></span>flags <span class="token operator">&amp;</span> UV_HANDLE_SHUTTING <span class="token operator">||</span>      <span class="token function">uv__is_closing</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> UV_ENOTCONN<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">uv__stream_fd</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 初始化请求 */</span>  <span class="token function">uv__req_init</span><span class="token punctuation">(</span>stream<span class="token operator">-></span>loop<span class="token punctuation">,</span> req<span class="token punctuation">,</span> UV_SHUTDOWN<span class="token punctuation">)</span><span class="token punctuation">;</span>  req<span class="token operator">-></span>handle <span class="token operator">=</span> stream<span class="token punctuation">;</span>  req<span class="token operator">-></span>cb <span class="token operator">=</span> cb<span class="token punctuation">;</span>  stream<span class="token operator">-></span>shutdown_req <span class="token operator">=</span> req<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 设置关闭标志位 */</span>  stream<span class="token operator">-></span>flags <span class="token operator">|</span><span class="token operator">=</span> UV_HANDLE_SHUTTING<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 初始化io观察者，将 io 观察者加入到队列中后，以便在事件循环的特定阶段进行处理 */</span>  <span class="token function">uv__io_start</span><span class="token punctuation">(</span>stream<span class="token operator">-></span>loop<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stream<span class="token operator">-></span>io_watcher<span class="token punctuation">,</span> POLLOUT<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">uv__stream_osx_interrupt_select</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="uv-listen"><a href="#uv-listen" class="headerlink" title="uv_listen()"></a>uv_listen()</h1><p>开始侦听新来的连接，如果你学习过TCP协议，那么对listen应该很熟悉，它就是用于监听连接的请求的。</p><p>函数实现：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_listen</span><span class="token punctuation">(</span>uv_stream_t<span class="token operator">*</span> stream<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">,</span> uv_connection_cb cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> err<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 根据类型处理，只有UV_TCP  UV_NAMED_PIPE 才可以 */</span>  <span class="token keyword">switch</span> <span class="token punctuation">(</span>stream<span class="token operator">-></span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">case</span> UV_TCP<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">/* tcp连接，调用tcp的listen去处理 */</span>    err <span class="token operator">=</span> <span class="token function">uv_tcp_listen</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uv_tcp_t<span class="token operator">*</span><span class="token punctuation">)</span>stream<span class="token punctuation">,</span> backlog<span class="token punctuation">,</span> cb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token keyword">case</span> UV_NAMED_PIPE<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">/* pipe连接，调用pipe的listen去处理 */</span>    err <span class="token operator">=</span> <span class="token function">uv_pipe_listen</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uv_pipe_t<span class="token operator">*</span><span class="token punctuation">)</span>stream<span class="token punctuation">,</span> backlog<span class="token punctuation">,</span> cb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token keyword">default</span><span class="token punctuation">:</span>    err <span class="token operator">=</span> UV_EINVAL<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">uv__handle_start</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> err<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数：</p><ul><li><p>stream：指定stream handle。</p></li><li><p>backlog：指定libuv监听的最大的连接数。</p></li><li><p>cb：连接的回调函数，当接受到新来的连接时，调用 uv_connection_cb 回调函数。</p></li></ul><p>注意，这个函数只有tcp或者pipe类型的stream handle才可使用。</p><h1 id="uv-accept"><a href="#uv-accept" class="headerlink" title="uv_accept()"></a>uv_accept()</h1><p>调用用来配合 uv_listen() 接受新来的连接。一般来说会在 uv_connection_cb 的回调函数中去调用这个 uv_accept() 函数以接受连接，这与tcp协议的处理是非常像的。 </p><p><strong>注意：在调用这个函数前，客户端句柄必须被初始化。</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_accept</span><span class="token punctuation">(</span>uv_stream_t<span class="token operator">*</span> server<span class="token punctuation">,</span> uv_stream_t<span class="token operator">*</span> client<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> err<span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>server<span class="token operator">-></span>loop <span class="token operator">==</span> client<span class="token operator">-></span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token operator">-></span>accepted_fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> UV_EAGAIN<span class="token punctuation">;</span>  <span class="token keyword">switch</span> <span class="token punctuation">(</span>client<span class="token operator">-></span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> UV_NAMED_PIPE<span class="token punctuation">:</span>    <span class="token keyword">case</span> UV_TCP<span class="token punctuation">:</span>      <span class="token comment" spellcheck="true">/* 获取文件描述符，并赋值给 client->io_watcher.fd */</span>      err <span class="token operator">=</span> <span class="token function">uv__stream_open</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span>                            server<span class="token operator">-></span>accepted_fd<span class="token punctuation">,</span>                            UV_HANDLE_READABLE <span class="token operator">|</span> UV_HANDLE_WRITABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 出现错误就关闭 */</span>        <span class="token function">uv__close</span><span class="token punctuation">(</span>server<span class="token operator">-></span>accepted_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> done<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> UV_UDP<span class="token punctuation">:</span>          <span class="token comment" spellcheck="true">/* 对于udp协议，通过uv_udp_open去获取文件描述符 */</span>      err <span class="token operator">=</span> <span class="token function">uv_udp_open</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uv_udp_t<span class="token operator">*</span><span class="token punctuation">)</span> client<span class="token punctuation">,</span> server<span class="token operator">-></span>accepted_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">uv__close</span><span class="token punctuation">(</span>server<span class="token operator">-></span>accepted_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> done<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>      <span class="token keyword">return</span> UV_EINVAL<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  client<span class="token operator">-></span>flags <span class="token operator">|</span><span class="token operator">=</span> UV_HANDLE_BOUND<span class="token punctuation">;</span>done<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">/* 处理在排队的连接请求 */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token operator">-></span>queued_fds <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    uv__stream_queued_fds_t<span class="token operator">*</span> queued_fds<span class="token punctuation">;</span>    queued_fds <span class="token operator">=</span> server<span class="token operator">-></span>queued_fds<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 处理第一个排队的 */</span>    server<span class="token operator">-></span>accepted_fd <span class="token operator">=</span> queued_fds<span class="token operator">-></span>fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* All read, free */</span>    <span class="token function">assert</span><span class="token punctuation">(</span>queued_fds<span class="token operator">-></span>offset <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>queued_fds<span class="token operator">-></span>offset <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">uv__free</span><span class="token punctuation">(</span>queued_fds<span class="token punctuation">)</span><span class="token punctuation">;</span>      server<span class="token operator">-></span>queued_fds <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/* Shift rest */</span>      <span class="token function">memmove</span><span class="token punctuation">(</span>queued_fds<span class="token operator">-></span>fds<span class="token punctuation">,</span>              queued_fds<span class="token operator">-></span>fds <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>              queued_fds<span class="token operator">-></span>offset <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>queued_fds<span class="token operator">-></span>fds<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    server<span class="token operator">-></span>accepted_fd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token function">uv__io_start</span><span class="token punctuation">(</span>server<span class="token operator">-></span>loop<span class="token punctuation">,</span> <span class="token operator">&amp;</span>server<span class="token operator">-></span>io_watcher<span class="token punctuation">,</span> POLLIN<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> err<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="uv-read-start"><a href="#uv-read-start" class="headerlink" title="uv_read_start()"></a>uv_read_start()</h2><p>当连接成功后，可以调用<code>uv_read_start()</code>函数去监听流的读取端，当有数据可读的时候，将会调用<code>uv_read_cb</code>指定的回调函数，递交到用户去处理这些数据。</p><ul><li>函数原型</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_read_start</span><span class="token punctuation">(</span>uv_stream_t<span class="token operator">*</span> stream<span class="token punctuation">,</span>                  uv_alloc_cb alloc_cb<span class="token punctuation">,</span>                  uv_read_cb read_cb<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>参数：</p><ul><li><p>stream：指定stream handle。</p></li><li><p>alloc_cb：读取数据时调用该函数分配内存空间。</p></li><li><p>read_cb：读取成功后触发异步回调。</p></li></ul><p>函数源码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_read_start</span><span class="token punctuation">(</span>uv_stream_t<span class="token operator">*</span> stream<span class="token punctuation">,</span>                  uv_alloc_cb alloc_cb<span class="token punctuation">,</span>                  uv_read_cb read_cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">assert</span><span class="token punctuation">(</span>stream<span class="token operator">-></span>type <span class="token operator">==</span> UV_TCP <span class="token operator">||</span> stream<span class="token operator">-></span>type <span class="token operator">==</span> UV_NAMED_PIPE <span class="token operator">||</span>      stream<span class="token operator">-></span>type <span class="token operator">==</span> UV_TTY<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>stream<span class="token operator">-></span>flags <span class="token operator">&amp;</span> UV_HANDLE_CLOSING<span class="token punctuation">)</span>    <span class="token keyword">return</span> UV_EINVAL<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>stream<span class="token operator">-></span>flags <span class="token operator">&amp;</span> UV_HANDLE_READABLE<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> UV_ENOTCONN<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 设置标志位，表示此时流正在被使用读取 */</span>  stream<span class="token operator">-></span>flags <span class="token operator">|</span><span class="token operator">=</span> UV_HANDLE_READING<span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">uv__stream_fd</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>alloc_cb<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 注册回调函数 */</span>  stream<span class="token operator">-></span>read_cb <span class="token operator">=</span> read_cb<span class="token punctuation">;</span>  stream<span class="token operator">-></span>alloc_cb <span class="token operator">=</span> alloc_cb<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 启动io观察者 */</span>  <span class="token function">uv__io_start</span><span class="token punctuation">(</span>stream<span class="token operator">-></span>loop<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stream<span class="token operator">-></span>io_watcher<span class="token punctuation">,</span> POLLIN<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">uv__handle_start</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">uv__stream_osx_interrupt_select</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="uv-read-stop"><a href="#uv-read-stop" class="headerlink" title="uv_read_stop()"></a>uv_read_stop()</h2><p>与<code>uv_read_start()</code>函数刚好相反，<code>uv_read_stop()</code>函数是停止从流读取数据。 <code>uv_read_cb</code> 回调函数将不再被调用。</p><p>参数：</p><ul><li>stream：指定stream handle。</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_read_stop</span><span class="token punctuation">(</span>uv_stream_t<span class="token operator">*</span> stream<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/* 如果它未被设置为 UV_HANDLE_READING 读取占用标志位，则不需要停止 */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>stream<span class="token operator">-></span>flags <span class="token operator">&amp;</span> UV_HANDLE_READING<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 取消设置 UV_HANDLE_READING 标志位 */</span>  stream<span class="token operator">-></span>flags <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span>UV_HANDLE_READING<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 停止流读取，关闭流io观察者 */</span>  <span class="token function">uv__io_stop</span><span class="token punctuation">(</span>stream<span class="token operator">-></span>loop<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stream<span class="token operator">-></span>io_watcher<span class="token punctuation">,</span> POLLIN<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 当且仅当io观察者不处于活跃时才关闭这个 stream handle */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">uv__io_active</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stream<span class="token operator">-></span>io_watcher<span class="token punctuation">,</span> POLLOUT<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">uv__handle_stop</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">uv__stream_osx_interrupt_select</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 取消注册回调函数 */</span>  stream<span class="token operator">-></span>read_cb <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  stream<span class="token operator">-></span>alloc_cb <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="uv-write"><a href="#uv-write" class="headerlink" title="uv_write()"></a>uv_write()</h2><p>向stream handle 写入数据，实际上是调用<code>uv_write2()</code>这个函数。</p><p>参数：</p><ul><li><p>req：请求。</p></li><li><p>handle：指定的stream handle</p></li><li><p>bufs：要写入的buf数据。</p></li><li><p>nbufs：要写入数据的大小。</p></li><li><p>cb：当写操作完成后，调用的回调函数。</p></li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_write</span><span class="token punctuation">(</span>uv_write_t<span class="token operator">*</span> req<span class="token punctuation">,</span>             uv_stream_t<span class="token operator">*</span> handle<span class="token punctuation">,</span>             <span class="token keyword">const</span> uv_buf_t bufs<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>             <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nbufs<span class="token punctuation">,</span>             uv_write_cb cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">uv_write2</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> handle<span class="token punctuation">,</span> bufs<span class="token punctuation">,</span> nbufs<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> cb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="uv-write2-函数"><a href="#uv-write2-函数" class="headerlink" title="uv_write2()函数"></a>uv_write2()函数</h2><p>扩展的写函数，可用于在管道上发送数据。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_write2</span><span class="token punctuation">(</span>uv_write_t<span class="token operator">*</span> req<span class="token punctuation">,</span>              uv_stream_t<span class="token operator">*</span> stream<span class="token punctuation">,</span>              <span class="token keyword">const</span> uv_buf_t bufs<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>              <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nbufs<span class="token punctuation">,</span>              uv_stream_t<span class="token operator">*</span> send_handle<span class="token punctuation">,</span>              uv_write_cb cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> empty_queue<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 健壮性的判断，只有tcp pipe tty类型的handle才可用改函数 */</span>  <span class="token function">assert</span><span class="token punctuation">(</span>nbufs <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token punctuation">(</span>stream<span class="token operator">-></span>type <span class="token operator">==</span> UV_TCP <span class="token operator">||</span>          stream<span class="token operator">-></span>type <span class="token operator">==</span> UV_NAMED_PIPE <span class="token operator">||</span>          stream<span class="token operator">-></span>type <span class="token operator">==</span> UV_TTY<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>         <span class="token string">"uv_write (unix) does not yet support other types of streams"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">uv__stream_fd</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> UV_EBADF<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>stream<span class="token operator">-></span>flags <span class="token operator">&amp;</span> UV_HANDLE_WRITABLE<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> UV_EPIPE<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>send_handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>stream<span class="token operator">-></span>type <span class="token operator">!=</span> UV_NAMED_PIPE <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uv_pipe_t<span class="token operator">*</span><span class="token punctuation">)</span>stream<span class="token punctuation">)</span><span class="token operator">-></span>ipc<span class="token punctuation">)</span>      <span class="token keyword">return</span> UV_EINVAL<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">uv__handle_fd</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uv_handle_t<span class="token operator">*</span><span class="token punctuation">)</span> send_handle<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> UV_EBADF<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> defined(__CYGWIN__) || defined(__MSYS__)</span>    <span class="token comment" spellcheck="true">/* Cygwin recvmsg always sets msg_controllen to zero, so we cannot send it.       See https://github.com/mirror/newlib-cygwin/blob/86fc4bf0/winsup/cygwin/fhandler_socket.cc#L1736-L1743 */</span>    <span class="token keyword">return</span> UV_ENOSYS<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/* 即使write_queue为空，write_queue_size> 0也合法；这意味着write_completed_queue中存在错误状态请求，这些错误状态请求将在以后修改write_queue_size */</span>  empty_queue <span class="token operator">=</span> <span class="token punctuation">(</span>stream<span class="token operator">-></span>write_queue_size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 初始化请求 */</span>  <span class="token function">uv__req_init</span><span class="token punctuation">(</span>stream<span class="token operator">-></span>loop<span class="token punctuation">,</span> req<span class="token punctuation">,</span> UV_WRITE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 注册回调函数，注册请求的stream handle */</span>  req<span class="token operator">-></span>cb <span class="token operator">=</span> cb<span class="token punctuation">;</span>  req<span class="token operator">-></span>handle <span class="token operator">=</span> stream<span class="token punctuation">;</span>  req<span class="token operator">-></span>error <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  req<span class="token operator">-></span>send_handle <span class="token operator">=</span> send_handle<span class="token punctuation">;</span>  <span class="token function">QUEUE_INIT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>req<span class="token operator">-></span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>  req<span class="token operator">-></span>bufs <span class="token operator">=</span> req<span class="token operator">-></span>bufsml<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>nbufs <span class="token operator">></span> <span class="token function">ARRAY_SIZE</span><span class="token punctuation">(</span>req<span class="token operator">-></span>bufsml<span class="token punctuation">)</span><span class="token punctuation">)</span>    req<span class="token operator">-></span>bufs <span class="token operator">=</span> <span class="token function">uv__malloc</span><span class="token punctuation">(</span>nbufs <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>bufs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token operator">-></span>bufs <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> UV_ENOMEM<span class="token punctuation">;</span>  <span class="token function">memcpy</span><span class="token punctuation">(</span>req<span class="token operator">-></span>bufs<span class="token punctuation">,</span> bufs<span class="token punctuation">,</span> nbufs <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>bufs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  req<span class="token operator">-></span>nbufs <span class="token operator">=</span> nbufs<span class="token punctuation">;</span>  req<span class="token operator">-></span>write_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  stream<span class="token operator">-></span>write_queue_size <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">uv__count_bufs</span><span class="token punctuation">(</span>bufs<span class="token punctuation">,</span> nbufs<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 将请求追加到write_queue。 */</span>  <span class="token function">QUEUE_INSERT_TAIL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stream<span class="token operator">-></span>write_queue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>req<span class="token operator">-></span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 如果此函数开始时队列为空，则应尝试立即进行写操作。否则，启动write_watcher并等待fd变为可写状态。 */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>stream<span class="token operator">-></span>connect_req<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 仍在连接，什么也不做. */</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>empty_queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">uv__write</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 阻塞流永远不会在队列中有任何东西。 */</span>    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>stream<span class="token operator">-></span>flags <span class="token operator">&amp;</span> UV_HANDLE_BLOCKING_WRITES<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv__io_start</span><span class="token punctuation">(</span>stream<span class="token operator">-></span>loop<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stream<span class="token operator">-></span>io_watcher<span class="token punctuation">,</span> POLLOUT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv__stream_osx_interrupt_select</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://libuv-docs-chinese.readthedocs.io/zh/latest/stream.html" target="_blank" rel="noopener">libuv官方文档</a></p><h1 id="例程代码获取"><a href="#例程代码获取" class="headerlink" title="例程代码获取"></a>例程代码获取</h1><p><a href="https://github.com/jiejieTop/libuv-learning-code" target="_blank" rel="noopener">libuv-learning-code</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> libuv </tag>
            
            <tag> 网络 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【libuv高效编程】libuv学习超详细教程10 —— libuv stream 流句柄解读</title>
      <link href="/libuv-10/"/>
      <url>/libuv-10/</url>
      
        <content type="html"><![CDATA[<h1 id="libuv系列文章"><a href="#libuv系列文章" class="headerlink" title="libuv系列文章"></a>libuv系列文章</h1><ul><li><p><a href="https://jiedev.com/libuv-1/">【libuv高效编程】libuv学习超详细教程1——libuv的编译与安装</a></p></li><li><p><a href="https://jiedev.com/libuv-2/">【libuv高效编程】libuv学习超详细教程2——libuv框架初窥</a></p></li><li><p><a href="https://jiedev.com/libuv-3/">【libuv高效编程】libuv学习超详细教程3——libuv事件循环</a></p></li><li><p><a href="https://jiedev.com/libuv-4/">【libuv高效编程】libuv学习超详细教程4——libuv idle 空闲句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-5/">【libuv高效编程】libuv学习超详细教程5——libuv prepare 准备句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-6/">【libuv高效编程】libuv学习超详细教程6——libuv check 检查句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-7/">【libuv高效编程】libuv学习超详细教程7——libuv thread 线程句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-8/">【libuv高效编程】libuv学习超详细教程8——libuv signal 信号句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-9/">【libuv高效编程】libuv学习超详细教程9——libuv async异步句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-10/">【libuv高效编程】libuv学习超详细教程10 —— libuv stream 流句柄解读</a></p></li></ul><h1 id="stream-handle"><a href="#stream-handle" class="headerlink" title="stream handle"></a>stream handle</h1><p><code>stream handle</code>可以被译为流句柄，它在 <code>libuv</code> 中是一个抽象的数据类型，为 <code>libuv</code> 提供了全双工的通信方式，可以说它只是一个父类，通过它派生出 <code>uv_tcp_t、uv_pipe_t、uv_tty_t</code> 这 3 个子类，在这些<code>handle</code>中，都使用了<code>stream handle</code> 的成员变量及处理方法。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>通过 uv_stream_t 可以定义一个 <code>stream handle</code>的实例。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> uv_stream_s uv_stream_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> uv_stream_s <span class="token punctuation">{</span>  UV_HANDLE_FIELDS  UV_STREAM_FIELDS<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">define</span> UV_STREAM_FIELDS                                                      \  </span><span class="token comment" spellcheck="true">/* 等待写的字节数 */</span>                                                        \  size_t write_queue_size<span class="token punctuation">;</span>                                                    \  <span class="token comment" spellcheck="true">/* 分配内存的函数 */</span>                                                        \  uv_alloc_cb alloc_cb<span class="token punctuation">;</span>                                                       \  <span class="token comment" spellcheck="true">/* 读取完成时候执行的回调函数 */</span>                                            \  uv_read_cb read_cb<span class="token punctuation">;</span>                                                         \  <span class="token comment" spellcheck="true">/* private */</span>                                                               \  UV_STREAM_PRIVATE_FIELDS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实 <code>stream handle</code> 是属于<code>handle</code>的子类，因此它的数据结构中包含了handle的成员变量，还包含它自身的一个成员变量 <code>UV_STREAM_FIELDS</code> ，它分为公有字段与私有字段，公有字段只有 <code>write_queue_size、 alloc_cb 、 read_cb</code>，私有字段就是 <code>UV_STREAM_PRIVATE_FIELDS</code> ，它是分为<code>Windows</code>平台与<code>linux</code>平台的，此处以linux为例。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> UV_STREAM_PRIVATE_FIELDS                                              \  uv_connect_t *connect_req;                                                  \  uv_shutdown_t *shutdown_req;                                                \  uv__io_t io_watcher;                                                        \  void* write_queue[2];                                                       \  void* write_completed_queue[2];                                             \  uv_connection_cb connection_cb;                                             \  int delayed_error;                                                          \  int accepted_fd;                                                            \  void* queued_fds;                                                           \  UV_STREAM_PRIVATE_PLATFORM_FIELDS                                           </span>\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>connect_req：其实 <code>uv_connect_t</code> 是一个请求，从前面的文章我们也知道，在<code>libuv</code>存在 <code>handle</code> 与 <code>request</code>，很明显<code>connect_req</code>就是一个请求，它的作用就是请求建立连接，比如类似建立tcp连接。</p></li><li><p>shutdown_req：<code>uv_shutdown_t</code>也是一个请求，它的作用与<code>uv_connect_t</code>刚好相反，关闭一个连接。</p></li><li><p>io_watcher：抽象出来的<code>io观察者</code>。</p></li><li><p>write_queue：写数据队列。</p></li><li><p>write_completed_queue：完成的写数据队列。</p></li><li><p>connection_cb：有新连接时的回调函数。</p></li><li><p>delayed_error：延时的错误代码。</p></li><li><p>accepted_fd：接受连接的描述符 <code>fd</code>。</p></li><li><p>queued_fds：<code>fd</code> 队列，可能有多个<code>fd</code>在排队。</p></li><li><p>UV_STREAM_PRIVATE_PLATFORM_FIELDS：目前为空。</p></li></ul><p>其实现在不太了解无所谓，就先看下去，我在写文章的时候其实也没有完全理解透彻。</p><p>总结一下它的框架示意图，如下：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/libuv007.png" alt="libuv007"></p><h1 id="内部API"><a href="#内部API" class="headerlink" title="内部API"></a>内部API</h1><p><code>stream handle</code>其实并未提供用户的<code>API</code>接口，但提供了内部的<code>API</code>接口，供子类使用，比如在创建一个<code>tcp</code>的时候，就会通过<code>uv__stream_init()</code>函数去初始化一个 <code>stream handle</code>，又比如在读写流操作的时候肯定是通过<code>stream handle</code>去操作的，因此它又需要实现内部的读写操作接口，相关的函数如下:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">uv__stream_init</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">,</span>                     uv_stream_t<span class="token operator">*</span> stream<span class="token punctuation">,</span>                     uv_handle_type type<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">uv__stream_connect</span><span class="token punctuation">(</span>uv_stream_t<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">uv__write</span><span class="token punctuation">(</span>uv_stream_t<span class="token operator">*</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">uv__read</span><span class="token punctuation">(</span>uv_stream_t<span class="token operator">*</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">uv__stream_io</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">,</span> uv__io_t<span class="token operator">*</span> w<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> events<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">uv__write_callbacks</span><span class="token punctuation">(</span>uv_stream_t<span class="token operator">*</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> size_t <span class="token function">uv__write_req_size</span><span class="token punctuation">(</span>uv_write_t<span class="token operator">*</span> req<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="uv-stream-init"><a href="#uv-stream-init" class="headerlink" title="uv__stream_init()"></a>uv__stream_init()</h2><p>初始化一个<code>stream handle</code>，设置</p><p>函数原型：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">uv__stream_init</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">,</span>                     uv_stream_t<span class="token operator">*</span> stream<span class="token punctuation">,</span>                     uv_handle_type type<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>参数：</p><ul><li>loop：传入了事件循环的句柄。</li><li>stream：指定初始化的<code>stream handle</code>。</li><li>type：指定<code>stream handle</code>的类型，注意看它的类型参数是<code>handle</code>类型的，而<code>handle</code>类型有很多，但是对与这个<code>stream handle</code>来说可选的值基本上只有<code>UV_TCP、UV_TTY、UV_PIPE</code>。</li></ul><p>源码的实现：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">uv__stream_init</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">,</span>                     uv_stream_t<span class="token operator">*</span> stream<span class="token punctuation">,</span>                     uv_handle_type type<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> err<span class="token punctuation">;</span>  <span class="token function">uv__handle_init</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span> <span class="token punctuation">(</span>uv_handle_t<span class="token operator">*</span><span class="token punctuation">)</span>stream<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>  stream<span class="token operator">-></span>read_cb <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  stream<span class="token operator">-></span>alloc_cb <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  stream<span class="token operator">-></span>close_cb <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  stream<span class="token operator">-></span>connection_cb <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  stream<span class="token operator">-></span>connect_req <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  stream<span class="token operator">-></span>shutdown_req <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  stream<span class="token operator">-></span>accepted_fd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  stream<span class="token operator">-></span>queued_fds <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  stream<span class="token operator">-></span>delayed_error <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">QUEUE_INIT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stream<span class="token operator">-></span>write_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">QUEUE_INIT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stream<span class="token operator">-></span>write_completed_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>  stream<span class="token operator">-></span>write_queue_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>loop<span class="token operator">-></span>emfile_fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    err <span class="token operator">=</span> <span class="token function">uv__open_cloexec</span><span class="token punctuation">(</span><span class="token string">"/dev/null"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">/* In the rare case that "/dev/null" isn't mounted open "/"         * instead.         */</span>        err <span class="token operator">=</span> <span class="token function">uv__open_cloexec</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>      loop<span class="token operator">-></span>emfile_fd <span class="token operator">=</span> err<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">if</span> defined(__APPLE__)</span>  stream<span class="token operator">-></span>select <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">/* defined(__APPLE_) */</span>  <span class="token function">uv__io_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stream<span class="token operator">-></span>io_watcher<span class="token punctuation">,</span> uv__stream_io<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说说处理的逻辑：</p><ol><li><p>调用<code>uv__handle_init()</code>函数将<code>stream handle</code>初始化，主要设置<code>loop</code>、<code>类型</code>、以及<code>UV_HANDLE_REF</code>标记。</p></li><li><p>初始化<code>stream handle</code>中的成员变量。</p></li><li><p>初始化<code>write_queue</code>与<code>write_completed_queue</code>队列，可能有人有疑问了，为啥要写队列还要 写完成 两个队列，因为啊libuv是为了实现异步，写操作为了实现异步非阻塞，你不能直接写，你得通过写队列去操作，它会首先将数据丢到队列中，下层 io 观察者触发可写事件时才去写入，当写完了就告诉你。</p></li><li><p>最后调用uv__io_init()函数去初始化<code>io观察者</code>，并设置<code>stream</code>的回调处理函数<code>uv__stream_io()</code>，这个处理回调函数后续慢慢讲解吧，先来看看<code>stream handle</code> 的读写操作。</p></li></ol><h2 id="uv-read"><a href="#uv-read" class="headerlink" title="uv__read()"></a>uv__read()</h2><p>当<code>io观察者</code>发现<code>stream handle</code>有可读事件时，<code>uv__read()</code>函数会被调用，其实是被<code>uv__stream_io()</code>函数调用，因为<code>io观察者</code>发现了底层有数据可读。所以该函数是用于从底层读取数据，这也是<code>stream handle</code>的读取操作。</p><p>uv__read()函数是通过 read() 函数从底层文件描述符读取数据，读取的数据写入由 <code>stream-&gt;alloc_cb</code> 分配到内存块中，并在完成读取后由 <code>stream-&gt;read_cb</code> 回调函数传递到用户。因为数据已经由底层准备好，直接读取即可，效率非常高，是不需要等待的。而当底层没有数据的情况时，read() 系统调用也会阻塞，而是直接返回，因为文件描述符工作在非阻塞模式下，即使底层还没有数据，它也不会阻塞的，而真正阻塞的地方是在io循环中。</p><p>简单看看函数源码吧：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">uv__read</span><span class="token punctuation">(</span>uv_stream_t<span class="token operator">*</span> stream<span class="token punctuation">)</span> <span class="token punctuation">{</span>  uv_buf_t buf<span class="token punctuation">;</span>  ssize_t nread<span class="token punctuation">;</span>  <span class="token keyword">struct</span> msghdr msg<span class="token punctuation">;</span>  <span class="token keyword">char</span> cmsg_space<span class="token punctuation">[</span><span class="token function">CMSG_SPACE</span><span class="token punctuation">(</span>UV__CMSG_FD_SIZE<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> count<span class="token punctuation">;</span>  <span class="token keyword">int</span> err<span class="token punctuation">;</span>  <span class="token keyword">int</span> is_ipc<span class="token punctuation">;</span>  stream<span class="token operator">-></span>flags <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span>UV_HANDLE_READ_PARTIAL<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* Prevent loop starvation when the data comes in as fast as (or faster than)   * we can read it. XXX Need to rearm fd if we switch to edge-triggered I/O.   */</span>  count <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 看看是不是管道，IPC通讯机制 */</span>  is_ipc <span class="token operator">=</span> stream<span class="token operator">-></span>type <span class="token operator">==</span> UV_NAMED_PIPE <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uv_pipe_t<span class="token operator">*</span><span class="token punctuation">)</span> stream<span class="token punctuation">)</span><span class="token operator">-></span>ipc<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* XXX: Maybe instead of having UV_HANDLE_READING we just test if   * tcp->read_cb is NULL or not?   */</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>stream<span class="token operator">-></span>read_cb      <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>stream<span class="token operator">-></span>flags <span class="token operator">&amp;</span> UV_HANDLE_READING<span class="token punctuation">)</span>      <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>count<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assert</span><span class="token punctuation">(</span>stream<span class="token operator">-></span>alloc_cb <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    buf <span class="token operator">=</span> <span class="token function">uv_buf_init</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 分配内存 */</span>    stream<span class="token operator">-></span><span class="token function">alloc_cb</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uv_handle_t<span class="token operator">*</span><span class="token punctuation">)</span>stream<span class="token punctuation">,</span> <span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>buf<span class="token punctuation">.</span>base <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> buf<span class="token punctuation">.</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/* 如果内存分配失败或者buffer的长度是0则无法读取 */</span>      stream<span class="token operator">-></span><span class="token function">read_cb</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> UV_ENOBUFS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* 断言，保证有内存空间与stream handle的文件描述符是存在的 */</span>    <span class="token function">assert</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span>base <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">uv__stream_fd</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 如果不是pipe */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_ipc<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 通过read()去读取底层数据 */</span>        nread <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token function">uv__stream_fd</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">,</span> buf<span class="token punctuation">.</span>base<span class="token punctuation">,</span> buf<span class="token punctuation">.</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">/* 直到读取完毕 */</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>nread <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/* ipc 需要使用 recvmsg() 函数去读取 */</span>      msg<span class="token punctuation">.</span>msg_flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      msg<span class="token punctuation">.</span>msg_iov <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> iovec<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">;</span>      msg<span class="token punctuation">.</span>msg_iovlen <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      msg<span class="token punctuation">.</span>msg_name <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>      msg<span class="token punctuation">.</span>msg_namelen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* Set up to receive a descriptor even if one isn't in the message */</span>      msg<span class="token punctuation">.</span>msg_controllen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cmsg_space<span class="token punctuation">)</span><span class="token punctuation">;</span>      msg<span class="token punctuation">.</span>msg_control <span class="token operator">=</span> cmsg_space<span class="token punctuation">;</span>      <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 读取ipc机制的数据 */</span>        nread <span class="token operator">=</span> <span class="token function">uv__recvmsg</span><span class="token punctuation">(</span><span class="token function">uv__stream_fd</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>nread <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* 读取数据错误 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nread <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/* Error */</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EAGAIN <span class="token operator">||</span> errno <span class="token operator">==</span> EWOULDBLOCK<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 开始下一次的等待. */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>stream<span class="token operator">-></span>flags <span class="token operator">&amp;</span> UV_HANDLE_READING<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">/* 重新设置io观察者活跃 */</span>          <span class="token function">uv__io_start</span><span class="token punctuation">(</span>stream<span class="token operator">-></span>loop<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stream<span class="token operator">-></span>io_watcher<span class="token punctuation">,</span> POLLIN<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">uv__stream_osx_interrupt_select</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        stream<span class="token operator">-></span><span class="token function">read_cb</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> defined(__CYGWIN__) || defined(__MSYS__)</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> ECONNRESET <span class="token operator">&amp;&amp;</span> stream<span class="token operator">-></span>type <span class="token operator">==</span> UV_NAMED_PIPE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">uv__stream_eof</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 错误，用户应该调用uv_close()关闭 */</span>        stream<span class="token operator">-></span><span class="token function">read_cb</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> <span class="token function">UV__ERR</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>stream<span class="token operator">-></span>flags <span class="token operator">&amp;</span> UV_HANDLE_READING<span class="token punctuation">)</span> <span class="token punctuation">{</span>          stream<span class="token operator">-></span>flags <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span>UV_HANDLE_READING<span class="token punctuation">;</span>          <span class="token function">uv__io_stop</span><span class="token punctuation">(</span>stream<span class="token operator">-></span>loop<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stream<span class="token operator">-></span>io_watcher<span class="token punctuation">,</span> POLLIN<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">uv__io_active</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stream<span class="token operator">-></span>io_watcher<span class="token punctuation">,</span> POLLOUT<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">uv__handle_stop</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">uv__stream_osx_interrupt_select</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nread <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">uv__stream_eof</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/* 成功读取到数据 */</span>      ssize_t buflen <span class="token operator">=</span> buf<span class="token punctuation">.</span>len<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* ipc就这样子读取 */</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>is_ipc<span class="token punctuation">)</span> <span class="token punctuation">{</span>        err <span class="token operator">=</span> <span class="token function">uv__stream_recv_cmsg</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          stream<span class="token operator">-></span><span class="token function">read_cb</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">if</span> defined(__MVS__)</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>is_ipc <span class="token operator">&amp;&amp;</span> msg<span class="token punctuation">.</span>msg_controllen <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        uv_buf_t blankbuf<span class="token punctuation">;</span>        <span class="token keyword">int</span> nread<span class="token punctuation">;</span>        <span class="token keyword">struct</span> iovec <span class="token operator">*</span>old<span class="token punctuation">;</span>        blankbuf<span class="token punctuation">.</span>base <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        blankbuf<span class="token punctuation">.</span>len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        old <span class="token operator">=</span> msg<span class="token punctuation">.</span>msg_iov<span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>msg_iov <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> iovec<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>blankbuf<span class="token punctuation">;</span>        nread <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>          nread <span class="token operator">=</span> <span class="token function">uv__recvmsg</span><span class="token punctuation">(</span><span class="token function">uv__stream_fd</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          err <span class="token operator">=</span> <span class="token function">uv__stream_recv_cmsg</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            stream<span class="token operator">-></span><span class="token function">read_cb</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>            msg<span class="token punctuation">.</span>msg_iov <span class="token operator">=</span> old<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>nread <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> msg<span class="token punctuation">.</span>msg_controllen <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>msg_iov <span class="token operator">=</span> old<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>      <span class="token comment" spellcheck="true">/* 通过回调函数告诉应用层读取完成 */</span>      stream<span class="token operator">-></span><span class="token function">read_cb</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> nread<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* 如果没有填满缓冲区，则返回没有更多数据可读取。 */</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>nread <span class="token operator">&lt;</span> buflen<span class="token punctuation">)</span> <span class="token punctuation">{</span>        stream<span class="token operator">-></span>flags <span class="token operator">|</span><span class="token operator">=</span> UV_HANDLE_READ_PARTIAL<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="uv-write"><a href="#uv-write" class="headerlink" title="uv__write()"></a>uv__write()</h2><p>同理地，当 <code>io 观察者</code>发现要写入数据的时候，它也会去将数据写入到底层，函数 <code>uv__write()</code> 会被调用，那什么时候才是可写呢，回顾 <code>stream handle</code> 的成员变量，它有两个队列，当 <code>stream-&gt;write_queue</code> 队列存在数据时，表示可以写入，如果队列为空则表示没有数据可以写。</p><p>libuv的异步处理都是差不多的，都是通过<code>io观察者</code>去发现是否有可读可写，写数据的过程大致如下：用户将数据丢到写队列中就直接返回了，<code>io观察者</code>发现队列有数据，<code>stream handle</code> 的处理 <code>uv__stream_io()</code>函数被调用，开始写入操作，这个写入的操作是依赖系统的函数接口的，比如<code>write()</code>等，等写完了就通知用户即可。</p><p>源码的实现:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">uv__write</span><span class="token punctuation">(</span>uv_stream_t<span class="token operator">*</span> stream<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">struct</span> iovec<span class="token operator">*</span> iov<span class="token punctuation">;</span>  QUEUE<span class="token operator">*</span> q<span class="token punctuation">;</span>  uv_write_t<span class="token operator">*</span> req<span class="token punctuation">;</span>  <span class="token keyword">int</span> iovmax<span class="token punctuation">;</span>  <span class="token keyword">int</span> iovcnt<span class="token punctuation">;</span>  ssize_t n<span class="token punctuation">;</span>  <span class="token keyword">int</span> err<span class="token punctuation">;</span>start<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">/* 健壮性的处理，断言，确保存在stream handle的fd、队列存在等 */</span>  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">uv__stream_fd</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">QUEUE_EMPTY</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stream<span class="token operator">-></span>write_queue<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  q <span class="token operator">=</span> <span class="token function">QUEUE_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stream<span class="token operator">-></span>write_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>  req <span class="token operator">=</span> <span class="token function">QUEUE_DATA</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> uv_write_t<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>req<span class="token operator">-></span>handle <span class="token operator">==</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 转换为iovec。我们必须拥有自己的uv_buf_t而不是iovec，因为Windows的WSABUF不是iovec。 */</span>  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>uv_buf_t<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> iovec<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  iov <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> iovec<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>req<span class="token operator">-></span>bufs<span class="token punctuation">[</span>req<span class="token operator">-></span>write_index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  iovcnt <span class="token operator">=</span> req<span class="token operator">-></span>nbufs <span class="token operator">-</span> req<span class="token operator">-></span>write_index<span class="token punctuation">;</span>  iovmax <span class="token operator">=</span> <span class="token function">uv__getiovmax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 限制iov计数以避免来自writev()的EINVAL */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>iovcnt <span class="token operator">></span> iovmax<span class="token punctuation">)</span>    iovcnt <span class="token operator">=</span> iovmax<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token operator">-></span>send_handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> fd_to_send<span class="token punctuation">;</span>    <span class="token keyword">struct</span> msghdr msg<span class="token punctuation">;</span>    <span class="token keyword">struct</span> cmsghdr <span class="token operator">*</span>cmsg<span class="token punctuation">;</span>    <span class="token keyword">union</span> <span class="token punctuation">{</span>      <span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">struct</span> cmsghdr alias<span class="token punctuation">;</span>    <span class="token punctuation">}</span> scratch<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">uv__is_closing</span><span class="token punctuation">(</span>req<span class="token operator">-></span>send_handle<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      err <span class="token operator">=</span> UV_EBADF<span class="token punctuation">;</span>      <span class="token keyword">goto</span> error<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    fd_to_send <span class="token operator">=</span> <span class="token function">uv__handle_fd</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uv_handle_t<span class="token operator">*</span><span class="token punctuation">)</span> req<span class="token operator">-></span>send_handle<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>scratch<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>scratch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>fd_to_send <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>msg_name <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>msg_namelen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>msg_iov <span class="token operator">=</span> iov<span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>msg_iovlen <span class="token operator">=</span> iovcnt<span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>msg_flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>msg_control <span class="token operator">=</span> <span class="token operator">&amp;</span>scratch<span class="token punctuation">.</span>alias<span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>msg_controllen <span class="token operator">=</span> <span class="token function">CMSG_SPACE</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>fd_to_send<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cmsg <span class="token operator">=</span> <span class="token function">CMSG_FIRSTHDR</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    cmsg<span class="token operator">-></span>cmsg_level <span class="token operator">=</span> SOL_SOCKET<span class="token punctuation">;</span>    cmsg<span class="token operator">-></span>cmsg_type <span class="token operator">=</span> SCM_RIGHTS<span class="token punctuation">;</span>    cmsg<span class="token operator">-></span>cmsg_len <span class="token operator">=</span> <span class="token function">CMSG_LEN</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>fd_to_send<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* silence aliasing warning */</span>    <span class="token punctuation">{</span>      <span class="token keyword">void</span><span class="token operator">*</span> pv <span class="token operator">=</span> <span class="token function">CMSG_DATA</span><span class="token punctuation">(</span>cmsg<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span><span class="token operator">*</span> pi <span class="token operator">=</span> pv<span class="token punctuation">;</span>      <span class="token operator">*</span>pi <span class="token operator">=</span> fd_to_send<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">do</span>      n <span class="token operator">=</span> <span class="token function">sendmsg</span><span class="token punctuation">(</span><span class="token function">uv__stream_fd</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">RETRY_ON_WRITE_ERROR</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Ensure the handle isn't sent again in case this is a partial write. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>      req<span class="token operator">-></span>send_handle <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">do</span>      <span class="token comment" spellcheck="true">/* 写操作 */</span>      n <span class="token operator">=</span> <span class="token function">uv__writev</span><span class="token punctuation">(</span><span class="token function">uv__stream_fd</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">,</span> iov<span class="token punctuation">,</span> iovcnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">RETRY_ON_WRITE_ERROR</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">IS_TRANSIENT_WRITE_ERROR</span><span class="token punctuation">(</span>errno<span class="token punctuation">,</span> req<span class="token operator">-></span>send_handle<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    err <span class="token operator">=</span> <span class="token function">UV__ERR</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">goto</span> error<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">uv__write_req_update</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> req<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">uv__write_req_finish</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* TODO(bnoordhuis) Start trying to write the next request. */</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/* If this is a blocking stream, try again. */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>stream<span class="token operator">-></span>flags <span class="token operator">&amp;</span> UV_HANDLE_BLOCKING_WRITES<span class="token punctuation">)</span>    <span class="token keyword">goto</span> start<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 重新启动io观察者. */</span>  <span class="token function">uv__io_start</span><span class="token punctuation">(</span>stream<span class="token operator">-></span>loop<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stream<span class="token operator">-></span>io_watcher<span class="token punctuation">,</span> POLLOUT<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* Notify select() thread about state change */</span>  <span class="token function">uv__stream_osx_interrupt_select</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span><span class="token punctuation">;</span>error<span class="token punctuation">:</span>  req<span class="token operator">-></span>error <span class="token operator">=</span> err<span class="token punctuation">;</span>  <span class="token function">uv__write_req_finish</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">uv__io_stop</span><span class="token punctuation">(</span>stream<span class="token operator">-></span>loop<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stream<span class="token operator">-></span>io_watcher<span class="token punctuation">,</span> POLLOUT<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">uv__io_active</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stream<span class="token operator">-></span>io_watcher<span class="token punctuation">,</span> POLLIN<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">uv__handle_stop</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">uv__stream_osx_interrupt_select</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="uv-stream-io"><a href="#uv-stream-io" class="headerlink" title="uv__stream_io()"></a>uv__stream_io()</h2><p><code>uv__stream_io()</code> 函数是 <code>stream handle</code> 的事件处理函数，它在<code>uv__io_init()</code>函数就被注册了，在调用 <code>uv__stream_io()</code> 函数时，传递了事件循环对象、<code>io 观察者</code>对象、事件类型等信息。</p><p>我们来看看<code>stream handle</code>是如何处理可读写事件的：</p><ol><li><p>通过<code>container_of()</code>函数获取 <code>stream handle</code> 的实例，其实是计算出来的。</p></li><li><p>如果 <code>stream-&gt;connect_req</code>存在，说明 该 <code>stream handle</code> 需要进行连接，于是调用 <code>uv__stream_connect()</code> 函数请求建立连接。</p></li><li><p>满足可读取数据的条件，调用<code>uv__read()</code>函数进行数据读取</p></li><li><p>如果满足流结束条件 调用 <code>uv__stream_eof()</code> 进行相关处理。</p></li><li><p>如果满足可写条件，调用 <code>uv__write()</code> 函数去写入数据，当然，数据会被放在 <code>stream-&gt;write_queue</code> 队列中。</p></li><li><p>在写完数据后，调用 <code>uv__write_callbacks()</code> 函数去清除队列的数据，并通知应用层已经写完了。</p></li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">uv__stream_io</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">,</span> uv__io_t<span class="token operator">*</span> w<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> events<span class="token punctuation">)</span> <span class="token punctuation">{</span>  uv_stream_t<span class="token operator">*</span> stream<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 获取 stream handle 的实例 */</span>  stream <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> uv_stream_t<span class="token punctuation">,</span> io_watcher<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 断言，判断是否满足类型 */</span>  <span class="token function">assert</span><span class="token punctuation">(</span>stream<span class="token operator">-></span>type <span class="token operator">==</span> UV_TCP <span class="token operator">||</span>         stream<span class="token operator">-></span>type <span class="token operator">==</span> UV_NAMED_PIPE <span class="token operator">||</span>         stream<span class="token operator">-></span>type <span class="token operator">==</span> UV_TTY<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>stream<span class="token operator">-></span>flags <span class="token operator">&amp;</span> UV_HANDLE_CLOSING<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>stream<span class="token operator">-></span>connect_req<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 如果需要建立连接，则请求建立连接 */</span>    <span class="token function">uv__stream_connect</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/* 断言 */</span>  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">uv__stream_fd</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 满足读数据条件，进行数据读取 */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>events <span class="token operator">&amp;</span> <span class="token punctuation">(</span>POLLIN <span class="token operator">|</span> POLLERR <span class="token operator">|</span> POLLHUP<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">uv__read</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* read_cb 可能会关闭 stream，此处判断一下是否需要关闭fd */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">uv__stream_fd</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* read_cb closed stream. */</span>  <span class="token comment" spellcheck="true">/* 如果满足流结束条件 调用 uv__stream_eof() 进行相关处理。 */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>events <span class="token operator">&amp;</span> POLLHUP<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>      <span class="token punctuation">(</span>stream<span class="token operator">-></span>flags <span class="token operator">&amp;</span> UV_HANDLE_READING<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>      <span class="token punctuation">(</span>stream<span class="token operator">-></span>flags <span class="token operator">&amp;</span> UV_HANDLE_READ_PARTIAL<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>      <span class="token operator">!</span><span class="token punctuation">(</span>stream<span class="token operator">-></span>flags <span class="token operator">&amp;</span> UV_HANDLE_READ_EOF<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    uv_buf_t buf <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">uv__stream_eof</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">uv__stream_fd</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* read_cb closed stream. */</span>  <span class="token comment" spellcheck="true">/* 如果有数据要写入，则调用uv__write()去写数据，写完了调用uv__write_callbacks()函数 */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>events <span class="token operator">&amp;</span> <span class="token punctuation">(</span>POLLOUT <span class="token operator">|</span> POLLERR <span class="token operator">|</span> POLLHUP<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">uv__write</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv__write_callbacks</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Write queue drained. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">QUEUE_EMPTY</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stream<span class="token operator">-></span>write_queue<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token function">uv__drain</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="uv-write-callbacks"><a href="#uv-write-callbacks" class="headerlink" title="uv__write_callbacks()"></a>uv__write_callbacks()</h2><p>清理 <code>stream-&gt;write_completed_queue</code> 已完成写请求的队列，清理空间，并调用回调函数。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">uv__write_callbacks</span><span class="token punctuation">(</span>uv_stream_t<span class="token operator">*</span> stream<span class="token punctuation">)</span> <span class="token punctuation">{</span>  uv_write_t<span class="token operator">*</span> req<span class="token punctuation">;</span>  QUEUE<span class="token operator">*</span> q<span class="token punctuation">;</span>  QUEUE pq<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">QUEUE_EMPTY</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stream<span class="token operator">-></span>write_completed_queue<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 从写完成队列获取队列 */</span>  <span class="token function">QUEUE_MOVE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stream<span class="token operator">-></span>write_completed_queue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pq<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 队列不为空 */</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">QUEUE_EMPTY</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pq<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 获取队列头部节点 */</span>    q <span class="token operator">=</span> <span class="token function">QUEUE_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pq<span class="token punctuation">)</span><span class="token punctuation">;</span>    req <span class="token operator">=</span> <span class="token function">QUEUE_DATA</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> uv_write_t<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">QUEUE_REMOVE</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv__req_unregister</span><span class="token punctuation">(</span>stream<span class="token operator">-></span>loop<span class="token punctuation">,</span> req<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 清除并释放内存 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token operator">-></span>bufs <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      stream<span class="token operator">-></span>write_queue_size <span class="token operator">-</span><span class="token operator">=</span> <span class="token function">uv__write_req_size</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token operator">-></span>bufs <span class="token operator">!=</span> req<span class="token operator">-></span>bufsml<span class="token punctuation">)</span>        <span class="token function">uv__free</span><span class="token punctuation">(</span>req<span class="token operator">-></span>bufs<span class="token punctuation">)</span><span class="token punctuation">;</span>      req<span class="token operator">-></span>bufs <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* 通知应用层 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token operator">-></span>cb<span class="token punctuation">)</span>      req<span class="token operator">-></span><span class="token function">cb</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> req<span class="token operator">-></span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="外部API"><a href="#外部API" class="headerlink" title="外部API"></a>外部API</h1><p>内容较多，在下一章讲解吧。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://libuv-docs-chinese.readthedocs.io/zh/latest/stream.html" target="_blank" rel="noopener">libuv官方文档</a></p><h1 id="例程代码获取"><a href="#例程代码获取" class="headerlink" title="例程代码获取"></a>例程代码获取</h1><p><a href="https://github.com/jiejieTop/libuv-learning-code" target="_blank" rel="noopener">libuv-learning-code</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> libuv </tag>
            
            <tag> 网络 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【libuv高效编程】libuv学习超详细教程9——libuv async异步句柄解读</title>
      <link href="/libuv-9/"/>
      <url>/libuv-9/</url>
      
        <content type="html"><![CDATA[<h1 id="libuv系列文章"><a href="#libuv系列文章" class="headerlink" title="libuv系列文章"></a>libuv系列文章</h1><ul><li><p><a href="https://jiedev.com/libuv-1/">【libuv高效编程】libuv学习超详细教程1——libuv的编译与安装</a></p></li><li><p><a href="https://jiedev.com/libuv-2/">【libuv高效编程】libuv学习超详细教程2——libuv框架初窥</a></p></li><li><p><a href="https://jiedev.com/libuv-3/">【libuv高效编程】libuv学习超详细教程3——libuv事件循环</a></p></li><li><p><a href="https://jiedev.com/libuv-4/">【libuv高效编程】libuv学习超详细教程4——libuv idle 空闲句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-5/">【libuv高效编程】libuv学习超详细教程5——libuv prepare 准备句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-6/">【libuv高效编程】libuv学习超详细教程6——libuv check 检查句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-7/">【libuv高效编程】libuv学习超详细教程7——libuv thread 线程句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-8/">【libuv高效编程】libuv学习超详细教程8——libuv signal 信号句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-9/">【libuv高效编程】libuv学习超详细教程9——libuv async异步句柄解读</a></p></li></ul><h1 id="async-handle"><a href="#async-handle" class="headerlink" title="async handle"></a>async handle</h1><p>async handle可译为异步句柄，它主要是用于提供异步唤醒的功能，比如在用户线程中唤醒主事件循环线程，并且触发对应的回调函数。</p><p>从事件循环线程的处理过程可知，它在io循环时会进入阻塞状态，而阻塞的具体时间则通过计算得到，那么在某些情况下，我们想要唤醒事件循环线程，就可以通过ansyc去操作，比如当线程池的线程处理完事件后，执行的结果是需要交给事件循环线程的，这时就需要用到唤醒事件循环线程，当然方法也是很简单，调用一下uv_async_send()函数通知事件循环线程即可。libuv线程池中的线程就是利用这个机制和主事件循环线程通讯。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>通过 uv_async_t 可以定义一个async handle的实例。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> uv_async_s uv_async_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>uv_async_t是属于handle的子类，并且还包含了一个UV_ASYNC_PRIVATE_FIELDS数据类型，里面包括它的回调函数async_cb、队列、以及一个pending成员变量。</p><p>结构比较简单，async_cb 保存回调函数指针，queue 作为队列节点插入 loop-&gt;async_handles，pending 字段的作用主要是用于保护操作，在唤醒的时候使用，初始化为 0, 在调用唤醒函数的时候会被设置为 1，为什么要这样子做呢，因为async handle是异步句柄，这可能不止一个线程会尝试唤醒事件循环，这一个async handle不能同时被多个线程操作，因此需要进行原子保护，当它为1的时候表示有其他线程在操作这个async handle。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> uv_async_s <span class="token punctuation">{</span>  UV_HANDLE_FIELDS  UV_ASYNC_PRIVATE_FIELDS<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">define</span> UV_ASYNC_PRIVATE_FIELDS                                               \  uv_async_cb async_cb;                                                       \  void* queue[2];                                                             \  int pending;                                                                </span>\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>uv_async_cb回调函数:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>uv_async_cb<span class="token punctuation">)</span><span class="token punctuation">(</span>uv_async_t<span class="token operator">*</span> handle<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>async handle相关的API非常简单，就一个初始化uv_async_init()，还有一个异步通知的函数uv_async_send()</p><h2 id="uv-async-init"><a href="#uv-async-init" class="headerlink" title="uv_async_init()"></a>uv_async_init()</h2><p>函数原型：</p><pre class="line-numbers language-c"><code class="language-c">UV_EXTERN <span class="token keyword">int</span> <span class="token function">uv_async_init</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span><span class="token punctuation">,</span>                            uv_async_t<span class="token operator">*</span> async<span class="token punctuation">,</span>                            uv_async_cb async_cb<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>参数：</p><ul><li>uv_loop_t：传入了事件循环的句柄。</li><li>async：指定初始化的async handle。</li><li>async_cb：指定async handle的回调函数。</li></ul><p>uv_async_init()初始化函数不同于其他handle的初始化函数，因为它会立即将async handle设置为活跃状态，所以 async handle 没有 start 相关的函数。</p><p>其实深入看uv__async_start()源码你就会发现，它实际上也是通过pipe管道进行唤醒的，因为主线程的io循环其实是在观察是否有可读写的io，libuv将管道等都抽象为io观察者了，在io循环中观察管道的读取端，当有数据到来则唤醒，越是深入了解libuv，你就会发现其实就是各个线程、进程间的通信，一种异步的通信，只不过libuv处理的很好，抽象了很多数据结构，并且衍生出了很多子类。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_async_init</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">,</span> uv_async_t<span class="token operator">*</span> handle<span class="token punctuation">,</span> uv_async_cb async_cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> err<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 其实这个函数的内部主要做了以下操作：创建一个管道，并且将管道注册到loop->async_io_watcher，并且start */</span>  err <span class="token operator">=</span> <span class="token function">uv__async_start</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token keyword">return</span> err<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 设置UV_HANDLE_REF标记，并且将async handle 插入loop->handle_queue */</span>  <span class="token function">uv__handle_init</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span> <span class="token punctuation">(</span>uv_handle_t<span class="token operator">*</span><span class="token punctuation">)</span>handle<span class="token punctuation">,</span> UV_ASYNC<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 注册回调函数、将 pending 字段初始化为0 */</span>  handle<span class="token operator">-></span>async_cb <span class="token operator">=</span> async_cb<span class="token punctuation">;</span>  handle<span class="token operator">-></span>pending <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* queue 作为队列节点插入 loop->async_handles */</span>  <span class="token function">QUEUE_INSERT_TAIL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-></span>async_handles<span class="token punctuation">,</span> <span class="token operator">&amp;</span>handle<span class="token operator">-></span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">uv__handle_start</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">uv__async_start</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> pipefd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> err<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>loop<span class="token operator">-></span>async_io_watcher<span class="token punctuation">.</span>fd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 创建管道 */</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> __linux__</span>  err <span class="token operator">=</span> <span class="token function">eventfd</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> EFD_CLOEXEC <span class="token operator">|</span> EFD_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">UV__ERR</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">;</span>  pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> err<span class="token punctuation">;</span>  pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">else</span></span>  err <span class="token operator">=</span> <span class="token function">uv__make_pipe</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">,</span> UV__F_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> err<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>  <span class="token comment" spellcheck="true">/* 初始化并启动了 loop->async_io_watcher */</span>  <span class="token function">uv__io_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-></span>async_io_watcher<span class="token punctuation">,</span> uv__async_io<span class="token punctuation">,</span> pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">uv__io_start</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span> <span class="token operator">&amp;</span>loop<span class="token operator">-></span>async_io_watcher<span class="token punctuation">,</span> POLLIN<span class="token punctuation">)</span><span class="token punctuation">;</span>  loop<span class="token operator">-></span>async_wfd <span class="token operator">=</span> pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="uv-async-send"><a href="#uv-async-send" class="headerlink" title="uv_async_send()"></a>uv_async_send()</h2><p>函数原型：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_async_send</span><span class="token punctuation">(</span>uv_async_t<span class="token operator">*</span> handle<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数：</p><ul><li>handle：要唤醒指定的async handle。</li></ul><p>uv_async_send()函数发送消息唤醒事件循环线程并触发回调函数调用，其实我们不难想象出来，它的唤醒就是将消息写入管道中，让io观察者发现管道有数据从而唤醒事件循环线程，并随之处理这个async handle。</p><p>其实真正的唤醒操作是uv__async_send()函数，它往管道中写入消息就行了。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_async_send</span><span class="token punctuation">(</span>uv_async_t<span class="token operator">*</span> handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ACCESS_ONCE</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> handle<span class="token operator">-></span>pending<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 将handle->pending设置为1，表示此时有线程在操作这个async handle */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cmpxchgi</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>handle<span class="token operator">-></span>pending<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 唤醒事件循环线程 */</span>  <span class="token function">uv__async_send</span><span class="token punctuation">(</span>handle<span class="token operator">-></span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 操作完成 */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cmpxchgi</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>handle<span class="token operator">-></span>pending<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">uv__async_send</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> buf<span class="token punctuation">;</span>  ssize_t len<span class="token punctuation">;</span>  <span class="token keyword">int</span> fd<span class="token punctuation">;</span>  <span class="token keyword">int</span> r<span class="token punctuation">;</span>  buf <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>  len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  fd <span class="token operator">=</span> loop<span class="token operator">-></span>async_wfd<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> defined(__linux__)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> uint64_t val <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    buf <span class="token operator">=</span> <span class="token operator">&amp;</span>val<span class="token punctuation">;</span>    len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    fd <span class="token operator">=</span> loop<span class="token operator">-></span>async_io_watcher<span class="token punctuation">.</span>fd<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* eventfd */</span>  <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>  <span class="token keyword">do</span>    r <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> len<span class="token punctuation">)</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EAGAIN <span class="token operator">||</span> errno <span class="token operator">==</span> EWOULDBLOCK<span class="token punctuation">)</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="async的处理过程"><a href="#async的处理过程" class="headerlink" title="async的处理过程"></a>async的处理过程</h1><p>前面所介绍的都是初始化与通知的方式，那么在事件循环中怎么去处理async handle呢？</p><p>我们注意到<code>uv_async_init()</code>函数可能多次被调用，初始化多个async handle，但是 loop-&gt;async_io_watcher 只有一个，那么问题来了，那么多个async handle都共用一个io观察者（假设loop是一个），那么在 loop-&gt;async_io_watcher 上有 I/O 事件时，并不知道是哪个 async handle 发送的，因此我们要知道async handle是如何处理这些的。</p><p>我们也知道从uv__io_init()函数中已经注册了一个uv__async_io()函数用于处理loop-&gt;async_io_watcher 的 I/O 事件，那么我们就看uv__async_io()函数的处理过程即可：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">uv__async_io</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">,</span> uv__io_t<span class="token operator">*</span> w<span class="token punctuation">,</span> unsigned int events<span class="token punctuation">)</span> <span class="token punctuation">{</span>  char buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  ssize_t r<span class="token punctuation">;</span>  QUEUE queue<span class="token punctuation">;</span>  QUEUE<span class="token operator">*</span> q<span class="token punctuation">;</span>  uv_async_t<span class="token operator">*</span> h<span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>w <span class="token operator">==</span> <span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>async_io_watcher<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 不断的读取 w->fd 上的数据到 buf 中直到为空，buf 中的数据无实际用途 */</span>    r <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>w<span class="token operator">-</span><span class="token operator">></span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token function">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token function">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 读取到数据跳出循环 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EAGAIN <span class="token operator">||</span> errno <span class="token operator">==</span> EWOULDBLOCK<span class="token punctuation">)</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span>      <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">QUEUE_MOVE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>async_handles<span class="token punctuation">,</span> <span class="token operator">&amp;</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 遍历队列 */</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">QUEUE_EMPTY</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    q <span class="token operator">=</span> <span class="token function">QUEUE_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 获取async handle */</span>    h <span class="token operator">=</span> <span class="token function">QUEUE_DATA</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> uv_async_t<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">QUEUE_REMOVE</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 重新插入队列 */</span>    <span class="token function">QUEUE_INSERT_TAIL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>async_handles<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> <span class="token function">uv__async_spin</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token keyword">continue</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* Not pending. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>h<span class="token operator">-</span><span class="token operator">></span>async_cb <span class="token operator">==</span> NULL<span class="token punctuation">)</span>      <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 调用async 的回调函数 */</span>    h<span class="token operator">-</span><span class="token operator">></span><span class="token function">async_cb</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="example"><a href="#example" class="headerlink" title="example"></a>example</h1><p>接着来一个例子吧，都是非常简单的，创建1个线程，在事件循环中等待async handle。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;uv.h></span></span><span class="token keyword">void</span> <span class="token function">wake_entry</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wake_entry running, wake async!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_async_send</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uv_async_t<span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_stop</span><span class="token punctuation">(</span><span class="token function">uv_default_loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">my_async_cb</span><span class="token punctuation">(</span>uv_async_t<span class="token operator">*</span> handle<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"my async running!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    uv_thread_t wake<span class="token punctuation">;</span>    uv_async_t async<span class="token punctuation">;</span>    <span class="token function">uv_async_init</span><span class="token punctuation">(</span><span class="token function">uv_default_loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>async<span class="token punctuation">,</span> my_async_cb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_thread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wake<span class="token punctuation">,</span> wake_entry<span class="token punctuation">,</span> <span class="token operator">&amp;</span>async<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_run</span><span class="token punctuation">(</span><span class="token function">uv_default_loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> UV_RUN_DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_thread_join</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wake<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://libuv-docs-chinese.readthedocs.io/zh/latest/async.html" target="_blank" rel="noopener">libuv官方文档</a></p><h1 id="例程代码获取"><a href="#例程代码获取" class="headerlink" title="例程代码获取"></a>例程代码获取</h1><p><a href="https://github.com/jiejieTop/libuv-learning-code" target="_blank" rel="noopener">libuv-learning-code</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> libuv </tag>
            
            <tag> 网络 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【libuv高效编程】libuv学习超详细教程8—— signal 信号句柄解读</title>
      <link href="/libuv-8/"/>
      <url>/libuv-8/</url>
      
        <content type="html"><![CDATA[<h1 id="libuv系列文章"><a href="#libuv系列文章" class="headerlink" title="libuv系列文章"></a>libuv系列文章</h1><ul><li><p><a href="https://jiedev.com/libuv-1/">【libuv高效编程】libuv学习超详细教程1——libuv的编译与安装</a></p></li><li><p><a href="https://jiedev.com/libuv-2/">【libuv高效编程】libuv学习超详细教程2——libuv框架初窥</a></p></li><li><p><a href="https://jiedev.com/libuv-3/">【libuv高效编程】libuv学习超详细教程3——libuv事件循环</a></p></li><li><p><a href="https://jiedev.com/libuv-4/">【libuv高效编程】libuv学习超详细教程4——libuv idle 空闲句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-5/">【libuv高效编程】libuv学习超详细教程5——libuv prepare 准备句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-6/">【libuv高效编程】libuv学习超详细教程6——libuv check 检查句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-7/">【libuv高效编程】libuv学习超详细教程7——libuv thread 线程句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-8/">【libuv高效编程】libuv学习超详细教程8——libuv signal 信号句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-9/">【libuv高效编程】libuv学习超详细教程9——libuv async异步句柄解读</a></p><h1 id="linux信号"><a href="#linux信号" class="headerlink" title="linux信号"></a>linux信号</h1></li></ul><p>信号（signal），又称为软中断信号，用于通知进程发生了异步事件，它是Linux系统响应某些条件而产生的一个事件，它是在软件层次上对中断机制的一种模拟，是一种异步通信方式，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。</p><p>信号是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。正如我们所了解的中断服务函数一样，在中断发生的时候，就会进入中断服务函数中去处理，同样的，当进程接收到一个信号的时候，也会相应地采取一些行动。我们可以使用术语”生成（raise）”表示一个信号的产生，使用术语”捕获（catch）”表示进程接收到一个信号。</p><p>在Linux系统中，信号可能是由于系统中某些错误而产生，也可以是某个进程主动生成的一个信号。由于某些错误条件而生成的信号：如内存段冲突、浮点处理器错误或非法指令等，它们由shell和终端处理器生成并且引起中断。由进程主动生成的信号可以作为在进程间传递通知或修改行为的一种方式，它可以明确地由一个进程发送给另一个进程，当进程捕获了这个信号就会按照程序进行相应并且去处理它。无论何种情况，它们的编程接口都是相同的，信号可以被生成、捕获、响应或忽略。进程之间可以互相发送信号，内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。</p><h1 id="Linux信号种类与描述"><a href="#Linux信号种类与描述" class="headerlink" title="Linux信号种类与描述"></a>Linux信号种类与描述</h1><table><thead><tr><th>信号值</th><th>名称</th><th>描述</th><th>默认处理</th></tr></thead><tbody><tr><td>1</td><td>SIGHUP</td><td>控制终端被关闭时产生。</td><td>终止</td></tr><tr><td>2</td><td>SIGINT</td><td>程序终止(interrupt)信号，在用户键入INTR字符（通常是Ctrl + C）时发出，用于通知前台进程组终止进程。</td><td>终止</td></tr><tr><td>3</td><td>SIGQUIT</td><td>SIGQUIT     和SIGINT类似，但由QUIT字符（通常是Ctrl + \）来控制，进程在因收到SIGQUIT退出时会产生core文件，在这个意义上类似于一个程序错误信号。</td><td>终止并产生转储文件（core文件）</td></tr><tr><td>4</td><td>SIGILL</td><td>CPU检测到某进程执行了非法指令时产生，通常是因为可执行文件本身出现错误， 或者试图执行数据段、堆栈溢出时也有可能产生这个信号。</td><td>终止并产生转储文件（core文件）</td></tr><tr><td>5</td><td>SIGTRAP</td><td>由断点指令或其它trap指令产生，由debugger使用。</td><td>终止并产生转储文件（core文件）</td></tr><tr><td>6</td><td>SIGABRT</td><td>调用系统函数 abort()时产生。</td><td>终止并产生转储文件（core文件）</td></tr><tr><td>7</td><td>SIGBUS</td><td>总线错误时产生。一般是非法地址，包括内存地址对齐（alignment）出错。比如访问一个四个字长的整数，但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的（如访问不属于自己存储空间或只读存储空间）。</td><td>终止并产生转储文件（core文件）</td></tr><tr><td>8</td><td>SIGFPE</td><td>处理器出现致命的算术运算错误时产生，不仅包括浮点运算错误，还包括溢出及除数为0等其它所有的算术的错误。</td><td>终止并产生转储文件（core文件）</td></tr><tr><td>9</td><td>SIGKILL</td><td>系统杀戮信号。用来立即结束程序的运行，本信号不能被阻塞、处理和忽略。如果管理员发现某个进程终止不了，可尝试发送这个信号将进程杀死。</td><td>终止</td></tr><tr><td>10</td><td>SIGUSR1</td><td>用户自定义信号。</td><td>终止</td></tr><tr><td>11</td><td>SIGSEGV</td><td>访问非法内存时产生，进程试图访问未分配给自己的内存，或试图往没有写权限的内存地址写数据。</td><td>终止</td></tr><tr><td>12</td><td>SIGUSR2</td><td>用户自定义信号。</td><td>终止</td></tr><tr><td>13</td><td>SIGPIPE</td><td>这个信号通常在进程间通信产生，比如采用FIFO（管道）通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到SIGPIPE信号。此外用Socket通信的两个进程，写进程在写Socket的时候，读进程已经终止，也会产生这个信号。</td><td>终止</td></tr><tr><td>14</td><td>SIGALRM</td><td>定时器到期信号，计算的是实际的时间或时钟时间，alarm函数使用该信号。</td><td>终止</td></tr><tr><td>15</td><td>SIGTERM</td><td>程序结束（terminate）信号，与SIGKILL不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出，shell命令kill缺省产生这个信号，如果进程终止不了，才会尝试SIGKILL。</td><td>终止</td></tr><tr><td>16</td><td>SIGSTKFLT</td><td>已废弃。</td><td>终止</td></tr><tr><td>17</td><td>SIGCHLD</td><td>子进程暂停或终止时产生，父进程将收到这个信号，如果父进程没有处理这个信号，也没有等待（wait）子进程，子进程虽然终止，但是还会在内核进程表中占有表项，这时的子进程称为僵尸进程，这种情况我们应该避免。父进程默认是忽略SIGCHILD信号的，我们可以捕捉它，做成异步等待它派生的子进程终止，或者父进程先终止，这时子进程的终止自动由init进程来接管。</td><td>忽略</td></tr><tr><td>18</td><td>SIGCONT</td><td>系统恢复运行信号，让一个停止（stopped）的进程继续执行，本信号不能被阻塞，可以用一个handler来让程序在由stopped状态变为继续执行时完成特定的工作</td><td>恢复运行</td></tr><tr><td>19</td><td>SIGSTOP</td><td>系统暂停信号，停止进程的执行。注意它和terminate以及interrupt的区别：该进程还未结束，只是暂停执行，本信号不能被阻塞，处理或忽略。</td><td>暂停</td></tr><tr><td>20</td><td>SIGTSTP</td><td>由控制终端发起的暂停信号，停止进程的运行，但该信号可以被处理和忽略，比如用户键入SUSP字符时（通常是Ctrl+Z）发出这个信号。</td><td>暂停</td></tr><tr><td>21</td><td>SIGTTIN</td><td>后台进程发起输入请求时控制终端产生该信号。</td><td>暂停</td></tr><tr><td>22</td><td>SIGTTOU</td><td>后台进程发起输出请求时控制终端产生该信号。</td><td>暂停</td></tr><tr><td>23</td><td>SIGURG</td><td>套接字上出现紧急数据时产生。</td><td>忽略</td></tr><tr><td>24</td><td>SIGXCPU</td><td>处理器占用时间超出限制值时产生。</td><td>终止并产生转储文件（core文件）</td></tr><tr><td>25</td><td>SIGXFSZ</td><td>文件尺寸超出限制值时产生。</td><td>终止并产生转储文件（core文件）</td></tr><tr><td>26</td><td>SIGVTALRM</td><td>由虚拟定时器产生的虚拟时钟信号，类似于SIGALRM，但是计算的是该进程占用的CPU时间。</td><td>终止</td></tr><tr><td>27</td><td>SIGPROF</td><td>类似于SIGALRM / SIGVTALRM，但包括该进程用的CPU时间以及系统调用的时间。</td><td>终止</td></tr><tr><td>28</td><td>SIGWINCH</td><td>窗口大小改变时发出。</td><td>忽略</td></tr><tr><td>29</td><td>SIGIO</td><td>文件描述符准备就绪, 可以开始进行输入/输出操作。</td><td>终止</td></tr><tr><td>30</td><td>SIGPWR</td><td>启动失败时产生。</td><td>终止</td></tr><tr><td>31</td><td>SIGUNUSED</td><td>非法的系统调用。</td><td>终止并产生转储文件（core文件）</td></tr></tbody></table><p>对于表格有几点需要注意的地方：</p><ol><li>信号的“值”在 x86、PowerPC 和 ARM平台下是有效的，但是别的平台的信号值也许跟这个表的不一致。</li><li>“描述”中注明的一些情况发生时会产生相应的信号，但并不是说该信号的产生就一定发生了这个事件。事实上，任何进程都可以使用kill()函数来产生任何信号。</li><li>信号 SIGKILL 和 SIGSTOP 是两个特殊的信号，他们不能被忽略、阻塞或捕捉，只能按缺省动作来响应。</li><li>一般而言，信号的响应处理过程如下：如果该信号被阻塞，那么将该信号挂起，不对其做任何处理，等到解除对其阻塞为止。如果该信号被捕获，那么进一步判断捕获的类型，如果设置了响应函数，那么执行该响应函数；如果设置为忽略，那么直接丢弃该信号。最后才执行信号的默认处理。</li></ol><h1 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h1><p>生成信号的事件一般可以归为3大类：程序错误、外部事件以及显式请求。例如零作除数、非法存储访问等，这种情况通常是由硬件而不是由Linux内核检测到的，但由内核向发生此错误的那个进程发送相应的信号；例如当用户在终端按下某些键时产生终端生成的信号，当进程超越了CPU或文件大小的限制时，内核会生成一个信号通知进程；例如使用kill()函数允许进程发送任何信号给其他进程或进程组。</p><p>信号的生成既可以是同步的，也可以是异步的。同步信号大多数是程序执行过程中出现了某个错误而产生的，由进程显式请求生成的给自己的信号也是同步的。</p><p>异步信号是接收进程可控制之外的事件所生成的信号，这类信号一般是进程无法控制的，只能被动接收，因为进程也不知道这个信号会何时发生，只能在发生的时候去处理它。一般外部事件总是异步地生成信号，异步信号可在进程运行中的任意时刻产生，进程无法预期信号到达的时刻，它所能做的只是告诉Linux内核假如有信号生成时应当采取什么行动（这相当于注册信号对应的处理）。</p><p>无论是同步还是异步信号，当信号发生时，我们可以告诉Linux内核采取如下3种动作中的任意一种：</p><ul><li>忽略信号。大部分信号都可以被忽略，但有两个除外：SIGSTOP和SIGKILL绝不会被忽略。不能忽略这两个信号的原因是为了给超级用户提供杀掉或停止任何进程的一种手段。此外，尽管其他信号都可以被忽略，但其中有一些却不宜忽略。例如，若忽略硬件例外（非法指令）信号，则会导致进程的行为不确定。</li><li>捕获信号。这种处理是要告诉Linux内核，当信号出现时调用专门提供的一个函数。这个函数称为信号处理函数，它专门对产生信号的事件作出处理。</li><li>让信号默认动作起作用。系统为每种信号规定了一个默认动作，这个动作由Linux内核来完成，有以下几种可能的默认动作：</li></ul><ol><li>终止进程并且生成内存转储文件，即写出进程的地址空间内容和寄存器上下文至进程当前目录下名为cone的文件中；</li><li>终止终止进程但不生成core文件。</li><li>忽略信号。</li><li>暂停进程。</li><li>若进程是暂停暂停，恢复进程，否则将忽略信号。</li></ol><h1 id="libuv的信号"><a href="#libuv的信号" class="headerlink" title="libuv的信号"></a>libuv的信号</h1><p>因为libuv是一个跨平台的框架，它的底层处理可以在Windows、也可以在linux，所以libuv信号的实现也是视平台而定的，在这里我们只讲解linux平台下的处理，当然对应的Windows也是差不多的。</p><p>信号是有生命周期的，可以把信号当做一个handle，那么libuv的信号就是<code>signal handle</code>，如果创建了<code>signal handle</code>实例并且start了，那么当<code>signal handle</code>指定的信号发生时，将进入对应的回调函数去处理该信号，这与linux的信号处理是差不多的，只不过libuv在系统的处理之上进行抽象，形成与平台无关的处理，仅此而已。</p><p>关于libuv的signal handle有几个点要知悉：</p><ul><li><p>以编程方式调用raise()或abort()触发的信号不会被libuv检测到;所以这些信号不会对应的回调函数。</p></li><li><p>SIGKILL和SIGSTOP是不可能被捕捉到的。</p></li><li><p>通过libuv处理SIGBUS、SIGFPE、SIGILL或SIGSEGV会导致未定义的行为。</p></li><li><p>libuv的信号与平台的信号基本上是一样的，也就是说信号可以从系统中其他进程发出。</p></li><li><p>libuv的信号依赖管道进行通信。</p></li></ul><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p><code>uv_signal_t</code> 是 thread handle 的数据类型，通过它可以定义一个 thread handle 的实例。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> uv_signal_s uv_signal_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在<code>libuv/include/uv.h</code>文件中存在以下的定义，它继承了<code>UV_HANDLE_FIELDS</code>相关的字段，因此它属于handle，同时还定义了signal的回调函数signal_cb，以及记录触发的信号值signum，当然还有一个UV_SIGNAL_PRIVATE_FIELDS，其实就是定义了红黑树的数据结构与记录触发信号的次数与处理信号的次数。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> uv_signal_s <span class="token punctuation">{</span>  UV_HANDLE_FIELDS  uv_signal_cb signal_cb<span class="token punctuation">;</span>  <span class="token keyword">int</span> signum<span class="token punctuation">;</span>  UV_SIGNAL_PRIVATE_FIELDS<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">define</span> UV_SIGNAL_PRIVATE_FIELDS                                              \  </span><span class="token comment" spellcheck="true">/* 红黑树的节点 */</span>                                                          \  <span class="token keyword">struct</span> <span class="token punctuation">{</span>                                                                    \    <span class="token keyword">struct</span> uv_signal_s<span class="token operator">*</span> rbe_left<span class="token punctuation">;</span>                                             \    <span class="token keyword">struct</span> uv_signal_s<span class="token operator">*</span> rbe_right<span class="token punctuation">;</span>                                            \    <span class="token keyword">struct</span> uv_signal_s<span class="token operator">*</span> rbe_parent<span class="token punctuation">;</span>                                           \    <span class="token keyword">int</span> rbe_color<span class="token punctuation">;</span>                                                            \  <span class="token punctuation">}</span> tree_entry<span class="token punctuation">;</span>                                                               \  <span class="token comment" spellcheck="true">/* 分别记录了触发信号的次数与处理信号的次数 */</span>                               \  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> caught_signals<span class="token punctuation">;</span>                                                \  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> dispatched_signals<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="回调函数："><a href="#回调函数：" class="headerlink" title="回调函数："></a>回调函数：</h1><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>uv_signal_cb<span class="token punctuation">)</span><span class="token punctuation">(</span>uv_signal_t<span class="token operator">*</span> handle<span class="token punctuation">,</span> <span class="token keyword">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>uv_signal_t：传入了触发信号的句柄。</li><li>signum：传入触发信号的值，这个值可能跟系统的值不一样，不过无所谓。</li></ul><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="uv-signal-init"><a href="#uv-signal-init" class="headerlink" title="uv_signal_init()"></a>uv_signal_init()</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_signal_init</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">,</span> uv_signal_t<span class="token operator">*</span> handle<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>初始化信号句柄，将<code>signal handle</code>绑定到指定的loop事件循环中。</p><p>具体的初始化操作过程是：libuv申请一个管道，用于其他进程（libuv进程或fork出来的进程）和libuv进程通信。然后往libuv的io观察者队列注册一个观察者，这其实就是观察这个管道是否可读，libuv在轮询I/O的阶段会把观察者加到<code>epoll</code>中。io观察者里保存了管道读端的文件描述符loop-&gt;signal_pipefd[0]和回调函数uv__signal_event。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_signal_init</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">,</span> uv_signal_t<span class="token operator">*</span> handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> err<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 初始化loop，它只会被初始化一次 */</span>  err <span class="token operator">=</span> <span class="token function">uv__signal_loop_once_init</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token keyword">return</span> err<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 初始化handle的类型，并且插入loop的handle队列，因为所有的handle都会被放到该队列管理 */</span>  <span class="token function">uv__handle_init</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span> <span class="token punctuation">(</span>uv_handle_t<span class="token operator">*</span><span class="token punctuation">)</span> handle<span class="token punctuation">,</span> UV_SIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span>  handle<span class="token operator">-></span>signum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  handle<span class="token operator">-></span>caught_signals <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  handle<span class="token operator">-></span>dispatched_signals <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 申请和libuv的通信管道并且注册io观察者 */</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">uv__signal_loop_once_init</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> err<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 如果已经初始化则返回 */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>loop<span class="token operator">-></span>signal_pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 申请两个管道，用于其他进程和libuv主进程通信，并设置非阻塞标记 */</span>  err <span class="token operator">=</span> <span class="token function">uv__make_pipe</span><span class="token punctuation">(</span>loop<span class="token operator">-></span>signal_pipefd<span class="token punctuation">,</span> UV__F_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token keyword">return</span> err<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 置信号io观察者的处理函数和文件描述符，libuv在循环I/O的时候，     如果发现管道读端loop->signal_pipefd[0]可读，则执行对应的回调函数uv__signal_event */</span>  <span class="token function">uv__io_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-></span>signal_io_watcher<span class="token punctuation">,</span>              uv__signal_event<span class="token punctuation">,</span>              loop<span class="token operator">-></span>signal_pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 插入libuv的signal io观察者队列，当管道可读的时候，执行uv__signal_event */</span>  <span class="token function">uv__io_start</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span> <span class="token operator">&amp;</span>loop<span class="token operator">-></span>signal_io_watcher<span class="token punctuation">,</span> POLLIN<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="uv-signal-start"><a href="#uv-signal-start" class="headerlink" title="uv_signal_start()"></a>uv_signal_start()</h2><p>启动<code>signal handle</code>，并函数注册信号和对应的处理函数，并且设置信号句柄处于活跃状态。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_signal_start</span><span class="token punctuation">(</span>uv_signal_t<span class="token operator">*</span> handle<span class="token punctuation">,</span>                    uv_signal_cb signal_cb<span class="token punctuation">,</span>                    <span class="token keyword">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>handle：信号句柄。</li><li>signal_cb：信号的回调函数。</li><li>signum：信号的值。</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_signal_start</span><span class="token punctuation">(</span>uv_signal_t<span class="token operator">*</span> handle<span class="token punctuation">,</span> uv_signal_cb signal_cb<span class="token punctuation">,</span> <span class="token keyword">int</span> signum<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">uv__signal_start</span><span class="token punctuation">(</span>handle<span class="token punctuation">,</span> signal_cb<span class="token punctuation">,</span> signum<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">uv__signal_start</span><span class="token punctuation">(</span>uv_signal_t<span class="token operator">*</span> handle<span class="token punctuation">,</span>                            uv_signal_cb signal_cb<span class="token punctuation">,</span>                            <span class="token keyword">int</span> signum<span class="token punctuation">,</span>                            <span class="token keyword">int</span> oneshot<span class="token punctuation">)</span> <span class="token punctuation">{</span>  sigset_t saved_sigmask<span class="token punctuation">;</span>  <span class="token keyword">int</span> err<span class="token punctuation">;</span>  uv_signal_t<span class="token operator">*</span> first_handle<span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">uv__is_closing</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 如果用户提供的signum == 0，则返回错误。 */</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>signum <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> UV_EINVAL<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 这个信号已经注册过了，重新设置回调处理函数就行。 */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>signum <span class="token operator">==</span> handle<span class="token operator">-></span>signum<span class="token punctuation">)</span> <span class="token punctuation">{</span>    handle<span class="token operator">-></span>signal_cb <span class="token operator">=</span> signal_cb<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/* 如果信号处理程序已经处于活动状态，请先停止它。 */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>handle<span class="token operator">-></span>signum <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">uv__signal_stop</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/* 暂时屏蔽所有信号 */</span>  <span class="token function">uv__signal_block_and_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>saved_sigmask<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 如果此时没有用于该信号的活动信号监视程序（在任何循环中），则给进程注册一个信号和信号处理函数。主要是调用操作系统的sigaction()函数来处理的。 */</span>  first_handle <span class="token operator">=</span> <span class="token function">uv__signal_first_handle</span><span class="token punctuation">(</span>signum<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>first_handle <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span>      <span class="token punctuation">(</span><span class="token operator">!</span>oneshot <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>first_handle<span class="token operator">-></span>flags <span class="token operator">&amp;</span> UV_SIGNAL_ONE_SHOT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    err <span class="token operator">=</span> <span class="token function">uv__signal_register_handler</span><span class="token punctuation">(</span>signum<span class="token punctuation">,</span> oneshot<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/* 注册信号失败 */</span>      <span class="token function">uv__signal_unlock_and_unblock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>saved_sigmask<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> err<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  handle<span class="token operator">-></span>signum <span class="token operator">=</span> signum<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 设置UV_SIGNAL_ONE_SHOT标记，表示libuv只响应一次信号 */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>oneshot<span class="token punctuation">)</span>    handle<span class="token operator">-></span>flags <span class="token operator">|</span><span class="token operator">=</span> UV_SIGNAL_ONE_SHOT<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 插入红黑树 */</span>  <span class="token function">RB_INSERT</span><span class="token punctuation">(</span>uv__signal_tree_s<span class="token punctuation">,</span> <span class="token operator">&amp;</span>uv__signal_tree<span class="token punctuation">,</span> handle<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 接触屏蔽信号 */</span>  <span class="token function">uv__signal_unlock_and_unblock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>saved_sigmask<span class="token punctuation">)</span><span class="token punctuation">;</span>  handle<span class="token operator">-></span>signal_cb <span class="token operator">=</span> signal_cb<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 设置handle的标志UV_HANDLE_ACTIVE，表示处于活跃状态 */</span>  <span class="token function">uv__handle_start</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="uv-signal-start-oneshot"><a href="#uv-signal-start-oneshot" class="headerlink" title="uv_signal_start_oneshot()"></a>uv_signal_start_oneshot()</h2><p>libuv只响应一次信号，在响应一次后恢复系统默认的信号处理。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_signal_start_oneshot</span><span class="token punctuation">(</span>uv_signal_t<span class="token operator">*</span> handle<span class="token punctuation">,</span>                            uv_signal_cb signal_cb<span class="token punctuation">,</span>                            <span class="token keyword">int</span> signum<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">uv__signal_start</span><span class="token punctuation">(</span>handle<span class="token punctuation">,</span> signal_cb<span class="token punctuation">,</span> signum<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="uv-signal-stop"><a href="#uv-signal-stop" class="headerlink" title="uv_signal_stop()"></a>uv_signal_stop()</h2><p>停止signal handle，将信号句柄设置为非活跃状态，事件循环中不在对它进行轮询。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_signal_stop</span><span class="token punctuation">(</span>uv_signal_t<span class="token operator">*</span> handle<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_signal_stop</span><span class="token punctuation">(</span>uv_signal_t<span class="token operator">*</span> handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">uv__is_closing</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">uv__signal_stop</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">uv__signal_stop</span><span class="token punctuation">(</span>uv_signal_t<span class="token operator">*</span> handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>  uv_signal_t<span class="token operator">*</span> removed_handle<span class="token punctuation">;</span>  sigset_t saved_sigmask<span class="token punctuation">;</span>  uv_signal_t<span class="token operator">*</span> first_handle<span class="token punctuation">;</span>  <span class="token keyword">int</span> rem_oneshot<span class="token punctuation">;</span>  <span class="token keyword">int</span> first_oneshot<span class="token punctuation">;</span>  <span class="token keyword">int</span> ret<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 如果没有启动观察程序，则该操作无效。 */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>handle<span class="token operator">-></span>signum <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 暂时屏蔽所有信号 */</span>  <span class="token function">uv__signal_block_and_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>saved_sigmask<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 从红黑树取出信号节点 */</span>  removed_handle <span class="token operator">=</span> <span class="token function">RB_REMOVE</span><span class="token punctuation">(</span>uv__signal_tree_s<span class="token punctuation">,</span> <span class="token operator">&amp;</span>uv__signal_tree<span class="token punctuation">,</span> handle<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>removed_handle <span class="token operator">==</span> handle<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> removed_handle<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 检查是否还有其他活动的信号监视程序正在观察此信号。如果没有了则注销信号处理程序。*/</span>  first_handle <span class="token operator">=</span> <span class="token function">uv__signal_first_handle</span><span class="token punctuation">(</span>handle<span class="token operator">-></span>signum<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>first_handle <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 注销信号，还是依赖系统的函数sigaction() */</span>    <span class="token function">uv__signal_unregister_handler</span><span class="token punctuation">(</span>handle<span class="token operator">-></span>signum<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    rem_oneshot <span class="token operator">=</span> handle<span class="token operator">-></span>flags <span class="token operator">&amp;</span> UV_SIGNAL_ONE_SHOT<span class="token punctuation">;</span>    first_oneshot <span class="token operator">=</span> first_handle<span class="token operator">-></span>flags <span class="token operator">&amp;</span> UV_SIGNAL_ONE_SHOT<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>first_oneshot <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>rem_oneshot<span class="token punctuation">)</span> <span class="token punctuation">{</span>      ret <span class="token operator">=</span> <span class="token function">uv__signal_register_handler</span><span class="token punctuation">(</span>handle<span class="token operator">-></span>signum<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">assert</span><span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/* 解除屏蔽所有信号 */</span>  <span class="token function">uv__signal_unlock_and_unblock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>saved_sigmask<span class="token punctuation">)</span><span class="token punctuation">;</span>  handle<span class="token operator">-></span>signum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">uv__handle_stop</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="信号的处理过程"><a href="#信号的处理过程" class="headerlink" title="信号的处理过程"></a>信号的处理过程</h1><p>libuv的信号分为两个部分，一个部分是用于通知，另一部分才是真正的处理，当系统有信号到达后，libuv会通过管道通知到libuv的事件循环中，然后在事件循环中处理信号，这里的事件循环其实是一个笼统的概念，具体的处理是在poll io阶段，即I/O轮询阶段，因为在等待信号的过程中，它可能会进入阻塞状态。</p><p>在libuv的处理中，无论有什么信号到来，它都通过uv__signal_handler()函数去处理信号。为什么呢，因为我们在注册的时候是通过uv__signal_register_handler()函数进行注册的，而这个函数中就将对应的回调处理设置为uv__signal_handler()函数。</p><h2 id="信号通知"><a href="#信号通知" class="headerlink" title="信号通知"></a>信号通知</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">uv__signal_register_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> <span class="token keyword">int</span> oneshot<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/* When this function is called, the signal lock must be held. */</span>  <span class="token keyword">struct</span> sigaction sa<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* XXX use a separate signal stack? */</span>  <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sa<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sa<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sigfillset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sa<span class="token punctuation">.</span>sa_mask<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 注册回调函数uv__signal_handler */</span>  sa<span class="token punctuation">.</span>sa_handler <span class="token operator">=</span> uv__signal_handler<span class="token punctuation">;</span>  sa<span class="token punctuation">.</span>sa_flags <span class="token operator">=</span> SA_RESTART<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>oneshot<span class="token punctuation">)</span>    sa<span class="token punctuation">.</span>sa_flags <span class="token operator">|</span><span class="token operator">=</span> SA_RESETHAND<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* XXX save old action so we can restore it later on? */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sigaction</span><span class="token punctuation">(</span>signum<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sa<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">UV__ERR</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来看看<code>uv__signal_handler()</code>函数的处理过程，该函数遍历红黑树，找到注册了该信号的handle，然后封装一个msg写入管道（即libuv的通信管道）。信号的通知处理就完成了。我们看看这个函数的代码。：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">uv__signal_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">)</span> <span class="token punctuation">{</span>  uv__signal_msg_t msg<span class="token punctuation">;</span>  uv_signal_t<span class="token operator">*</span> handle<span class="token punctuation">;</span>  <span class="token keyword">int</span> saved_errno<span class="token punctuation">;</span>  saved_errno <span class="token operator">=</span> errno<span class="token punctuation">;</span>  <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">uv__signal_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    errno <span class="token operator">=</span> saved_errno<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/* 获取signal handle */</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>handle <span class="token operator">=</span> <span class="token function">uv__signal_first_handle</span><span class="token punctuation">(</span>signum<span class="token punctuation">)</span><span class="token punctuation">;</span>       handle <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> handle<span class="token operator">-></span>signum <span class="token operator">==</span> signum<span class="token punctuation">;</span>       handle <span class="token operator">=</span> <span class="token function">RB_NEXT</span><span class="token punctuation">(</span>uv__signal_tree_s<span class="token punctuation">,</span> <span class="token operator">&amp;</span>uv__signal_tree<span class="token punctuation">,</span> handle<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> r<span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>signum <span class="token operator">=</span> signum<span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>handle <span class="token operator">=</span> handle<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 往signal_pipefd管道写入数据，就是通知libuv，拿些signal handle需要处理信号，这是在事件循环中处理的 */</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>      r <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>handle<span class="token operator">-></span>loop<span class="token operator">-></span>signal_pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token keyword">sizeof</span> msg <span class="token operator">||</span>           <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EAGAIN <span class="token operator">||</span> errno <span class="token operator">==</span> EWOULDBLOCK<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 记录该signal handle收到信号的次数 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>      handle<span class="token operator">-></span>caught_signals<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">uv__signal_unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  errno <span class="token operator">=</span> saved_errno<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><p>在信号通知完成后，事件循环中管道读取数据段有消息到达，此时事件循环将接收到消息，接下来在libuv的<code>poll io</code>阶段才做真正的处理。从<code>uv__io_init()</code>函数的处理过程得知，它把管道的读取端<code>loop-&gt;signal_pipefd[0]</code>看作是一个io观察者，在poll io阶段，epoll会检测到管道<code>loop-&gt;signal_pipefd[0]</code>是否可读，如果可读，然后会执行<code>uv__signal_event()</code>函数。在这个<code>uv__signal_event()</code>函数中，libuv将从管道读取刚才写入的一个个msg，从msg中取出对应的handle，然后执行里面保存的回调函数：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">uv__signal_event</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">,</span>                             uv__io_t<span class="token operator">*</span> w<span class="token punctuation">,</span>                             <span class="token keyword">unsigned</span> <span class="token keyword">int</span> events<span class="token punctuation">)</span> <span class="token punctuation">{</span>  uv__signal_msg_t<span class="token operator">*</span> msg<span class="token punctuation">;</span>  uv_signal_t<span class="token operator">*</span> handle<span class="token punctuation">;</span>  <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>uv__signal_msg_t<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  size_t bytes<span class="token punctuation">,</span> end<span class="token punctuation">,</span> i<span class="token punctuation">;</span>  <span class="token keyword">int</span> r<span class="token punctuation">;</span>  bytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 读取管道里的消息，处理所有的信号消息 */</span>  <span class="token keyword">do</span> <span class="token punctuation">{</span>    r <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>loop<span class="token operator">-></span>signal_pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf <span class="token operator">+</span> bytes<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span> <span class="token operator">-</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span>      <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EAGAIN <span class="token operator">||</span> errno <span class="token operator">==</span> EWOULDBLOCK<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* Other errors really should never happen. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>      <span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bytes <span class="token operator">+</span><span class="token operator">=</span> r<span class="token punctuation">;</span>    end <span class="token operator">=</span> <span class="token punctuation">(</span>bytes <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>uv__signal_msg_t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>uv__signal_msg_t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> i <span class="token operator">+</span><span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>uv__signal_msg_t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      msg <span class="token operator">=</span> <span class="token punctuation">(</span>uv__signal_msg_t<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>buf <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>      handle <span class="token operator">=</span> msg<span class="token operator">-></span>handle<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* 如果收到的信号与预期的信号是一致的，则执行回调函数 */</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token operator">-></span>signum <span class="token operator">==</span> handle<span class="token operator">-></span>signum<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>handle<span class="token operator">-></span>flags <span class="token operator">&amp;</span> UV_HANDLE_CLOSING<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* signal 回调函数 */</span>        handle<span class="token operator">-></span><span class="token function">signal_cb</span><span class="token punctuation">(</span>handle<span class="token punctuation">,</span> handle<span class="token operator">-></span>signum<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">/* 记录处理的信号个数 */</span>      handle<span class="token operator">-></span>dispatched_signals<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* 只响应一次，需要回复系统默认的处理函数 */</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>handle<span class="token operator">-></span>flags <span class="token operator">&amp;</span> UV_SIGNAL_ONE_SHOT<span class="token punctuation">)</span>        <span class="token function">uv__signal_stop</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    bytes <span class="token operator">-</span><span class="token operator">=</span> end<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">memmove</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> buf <span class="token operator">+</span> end<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">==</span> <span class="token keyword">sizeof</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="example"><a href="#example" class="headerlink" title="example"></a>example</h1><p>我们从example来讲解相关的函数使用吧，本次实验主要是是创建两个线程，其中一个线程等待SIGUSR1信号，另一个线程发送SIGUSR1信号，在处理完信号后退出。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;uv.h></span></span><span class="token keyword">void</span> <span class="token function">signal_handler</span><span class="token punctuation">(</span>uv_signal_t <span class="token operator">*</span>handle<span class="token punctuation">,</span> <span class="token keyword">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"signal received: %d\n"</span><span class="token punctuation">,</span> signum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_signal_stop</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">thread1_entry</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>userp<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">kill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> SIGUSR1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">thread2_entry</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>userp<span class="token punctuation">)</span><span class="token punctuation">{</span>    uv_signal_t signal<span class="token punctuation">;</span>    <span class="token function">uv_signal_init</span><span class="token punctuation">(</span><span class="token function">uv_default_loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>signal<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_signal_start</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>signal<span class="token punctuation">,</span> signal_handler<span class="token punctuation">,</span> SIGUSR1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_run</span><span class="token punctuation">(</span><span class="token function">uv_default_loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> UV_RUN_DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    uv_thread_t thread1<span class="token punctuation">,</span> thread2<span class="token punctuation">;</span>    <span class="token function">uv_thread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread1<span class="token punctuation">,</span> thread1_entry<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_thread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread2<span class="token punctuation">,</span> thread2_entry<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_thread_join</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_thread_join</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/THEANARKH/article/details/103881356" target="_blank" rel="noopener">libuv源码解析之信号处理</a></p><h1 id="例程代码获取"><a href="#例程代码获取" class="headerlink" title="例程代码获取"></a>例程代码获取</h1><p><a href="https://github.com/jiejieTop/libuv-learning-code" target="_blank" rel="noopener">libuv-learning-code</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> libuv </tag>
            
            <tag> 网络 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【libuv高效编程】libuv学习超详细教程7——libuv线程解读</title>
      <link href="/libuv-7/"/>
      <url>/libuv-7/</url>
      
        <content type="html"><![CDATA[<h1 id="libuv系列文章"><a href="#libuv系列文章" class="headerlink" title="libuv系列文章"></a>libuv系列文章</h1><ul><li><p><a href="https://jiedev.com/libuv-1/">【libuv高效编程】libuv学习超详细教程1——libuv的编译与安装</a></p></li><li><p><a href="https://jiedev.com/libuv-2/">【libuv高效编程】libuv学习超详细教程2——libuv框架初窥</a></p></li><li><p><a href="https://jiedev.com/libuv-3/">【libuv高效编程】libuv学习超详细教程3——libuv事件循环</a></p></li><li><p><a href="https://jiedev.com/libuv-4/">【libuv高效编程】libuv学习超详细教程4——libuv idle 空闲句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-5/">【libuv高效编程】libuv学习超详细教程5——libuv prepare 准备句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-6/">【libuv高效编程】libuv学习超详细教程6——libuv check 检查句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-7/">【libuv高效编程】libuv学习超详细教程7——libuv thread 线程句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-8/">【libuv高效编程】libuv学习超详细教程8——libuv signal 信号句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-9/">【libuv高效编程】libuv学习超详细教程9——libuv async异步句柄解读</a></p></li></ul><h1 id="linux线程"><a href="#linux线程" class="headerlink" title="linux线程"></a>linux线程</h1><p>从很多Linux的书籍我们都可以这样子描述进程和线程的：进程是资源管理的最小单位，线程是程序执行的最小单位。</p><p>libuv是的底层其实有使用线程池对多个线程进行管理，而且它也提供了用户创建线程的功能，今天我们来学习一下libuv线程相关的知识。</p><p>线程是操作系统能够调度和执行的基本单位，在Linux中也被称之为轻量级进程。在Linux系统中，一个进程至少需要一个线程作为它的指令执行体，进程管理着资源（比如cpu、内存、文件等等），而将线程分配到某个cpu上执行。一个进程可以拥有多个线程，它还可以同时使用多个cpu来执行各个线程，以达到最大程度的并行，提高工作的效率；同时，即使是在单cpu的机器上，也依然可以采用多线程模型来设计程序，使设计更简洁、功能更完备，程序的执行效率也更高。</p><p>从上面的这些概念我们不难得出一个非常重要的结论：线程的本质是一个进程内部的一个控制序列，它是进程里面的东西，一个进程可以拥有一个线程或者多个线程。</p><h2 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h2><p>我们可以先了解一个标准：可移植操作系统接口（英语：Portable Operating System Interface，缩写为POSIX），POSIX是IEEE为要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联的标准的总称，其正式称呼为IEEE Std 1003，而国际标准名称为ISO/IEC 9945。此标准源于一个大约开始于1985年的项目。POSIX这个名称是由理查德·斯托曼（RMS）应IEEE的要求而提议的一个易于记忆的名称。它基本上是Portable Operating System Interface（可移植操作系统接口）的缩写，而X则表明其对Unix API的传承。</p><blockquote><p>注：以上介绍来自维基百科：<a href="https://zh.wikipedia.org/wiki/POSIX" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/POSIX</a></p></blockquote><p>在Linux系统下的多线程遵循POSIX标准，而其中的一套常用的线程库是 pthread ，它是一套通用的线程库，是由 POSIX 提出的，因此具有很好的可移植性，我们学习多线程编程，就是使用它，必须包含以下头文件：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>除此之外在链接时需要使用库libpthread.a。因为pthread的库不是Linux系统的库，所以在编译时要加上 -lpthread 选项。</p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p><code>pthread_create()</code>函数是用于创建一个线程的，创建线程实际上就是确定调用该线程函数的入口点，在线程创建后，就开始运行相关的线程函数。若线程创建成功，则返回0。若线程创建失败，则返回对应的错误代码。</p><p>函数原型：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span>pthread_t <span class="token operator">*</span>thread<span class="token punctuation">,</span> <span class="token keyword">const</span> pthread_attr_t <span class="token operator">*</span>attr<span class="token punctuation">,</span>                    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>start_routine<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>参数：</p><ul><li>thread：指向线程标识符的指针。</li><li>attr：设置线程属性。</li><li>start_routine：start_routine是一个函数指针，指向要运行的线程入口。</li><li>arg：运行线程时传入的参数。</li></ul><h2 id="线程的分离状态"><a href="#线程的分离状态" class="headerlink" title="线程的分离状态"></a>线程的分离状态</h2><p>什么是线程的分离状态呢？在任何一个时间点上，线程是可结合的（joinable），或者是分离的（detached）。一个可结合的线程能够被其他线程收回其资源和杀死；在被其他线程回收之前，它的存储器资源（如栈）是不释放的。相反，一个分离的线程是不能被其他线程回收或杀死的，它的存储器资源在它终止时由系统自动释放。</p><p>总而言之：线程的分离状态决定一个线程以什么样的方式来终止自己。</p><p>进程中的线程可以调用以下函数来等待某个线程的终止，获得该线程的终止状态，并收回所占的资源，如果对线程的返回状态不感兴趣，可以将rval_ptr设置为NULL。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span>pthread_t tid<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>rval_ptr<span class="token punctuation">)</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>除此之外线程也可以调用以下函数将此线程设置为分离状态，设置为分离状态的线程在线程结束时，操作系统会自动收回它所占的资源。设置为分离状态的线程，不能再调用pthread_join()等待其结束。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_detach</span><span class="token punctuation">(</span>pthread_t tid<span class="token punctuation">)</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果一个线程是可结合的，意味着这条线程在退出时不会自动释放自身资源，而会成为僵尸线程，同时意味着该线程的退出值可以被其他线程获取。因此，如果不需要某条线程的退出值的话，那么最好将线程设置为分离状态，以保证该线程不会成为僵尸线程。</p><p>如果在创建线程时就知道不需要了解线程的终止状态，那么可以通过修改pthread_attr_t结构中的detachstate属性，让线程以分离状态启动，调用函数如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_attr_setdetachstate</span><span class="token punctuation">(</span>pthread_attr_t <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token keyword">int</span> detachstate<span class="token punctuation">)</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果想要获取某个线程的分离状态，那么可以通过以下函数：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_attr_getdetachstate</span><span class="token punctuation">(</span><span class="token keyword">const</span> pthread_attr_t <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>detachstate<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若函数调用成功返回0，否则返回对应的错误代码。</p><p>参数：</p><ul><li>attr：指向一个线程属性的指针。</li><li>detachstate：如果值为PTHREAD_CREATE_DETACHED，则表示线程是分离状态，如果值为PTHREAD_CREATE_JOINABLE则表示线程是结合状态。</li></ul><p>其实linux线程库中还有其他的api函数，这里就不做过多的赘述。</p><h1 id="libuv的线程处理"><a href="#libuv的线程处理" class="headerlink" title="libuv的线程处理"></a>libuv的线程处理</h1><p>因为libuv是一个跨平台的框架，它的底层处理可以在Windows、可以在linux，所以线程的实现它也是视平台而定的，在这里我们只讲解linux平台下的处理，当然对应的Windows也是差不多的。</p><p>线程也是有生命周期的，可以把线程当做一个handle，那么libuv的线程就是thread handle。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><code>uv_thread_t</code> 是 thread handle 的数据类型，通过它可以定义一个 thread handle 的实例。</p><pre class="line-numbers language-c"><code class="language-c">uv_thread_t<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在<code>github/libuv/include/uv/unix.h</code>文件中存在以下的定义，它就是linux下线程的数据结构，实际上就是使用了linux平台本身的线程库 <code>pthread</code>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> pthread_t uv_thread_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="线程主体"><a href="#线程主体" class="headerlink" title="线程主体"></a>线程主体</h2><p>既然能创建线程就必须有一个线程主体去执行线程里面的工作，在linux线程库 <code>pthread</code> 中定义的线程主体是<code>void *(*start_routine) (void *)</code>类型，而libuv则是以下类型：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>entry<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>传入了一个参数arg，它由用户创建线程时指定。</li></ul><h1 id="libuv创建线程"><a href="#libuv创建线程" class="headerlink" title="libuv创建线程"></a>libuv创建线程</h1><p>因为线程是一个handle，所以在使用的时候也是需要创建的，libuv创建线程的函数是<code>uv_thread_create()</code>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_thread_create</span><span class="token punctuation">(</span>uv_thread_t <span class="token operator">*</span>tid<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>entry<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>传入的参数：</p><ul><li>tid：线程句柄</li><li>entry：线程主体。</li><li>arg：线程参数。</li></ul><p>源码的实现如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_thread_create</span><span class="token punctuation">(</span>uv_thread_t <span class="token operator">*</span>tid<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>entry<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  uv_thread_options_t params<span class="token punctuation">;</span>  params<span class="token punctuation">.</span>flags <span class="token operator">=</span> UV_THREAD_NO_FLAGS<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">uv_thread_create_ex</span><span class="token punctuation">(</span>tid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>params<span class="token punctuation">,</span> entry<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 这才是真正创建线程的地方 */</span><span class="token keyword">int</span> <span class="token function">uv_thread_create_ex</span><span class="token punctuation">(</span>uv_thread_t<span class="token operator">*</span> tid<span class="token punctuation">,</span>                        <span class="token keyword">const</span> uv_thread_options_t<span class="token operator">*</span> params<span class="token punctuation">,</span>                        <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>entry<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">,</span>                        <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> err<span class="token punctuation">;</span>  pthread_attr_t<span class="token operator">*</span> attr<span class="token punctuation">;</span>  pthread_attr_t attr_storage<span class="token punctuation">;</span>  size_t pagesize<span class="token punctuation">;</span>  size_t stack_size<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* Used to squelch a -Wcast-function-type warning. */</span>  <span class="token keyword">union</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>in<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>out<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> f<span class="token punctuation">;</span>  stack_size <span class="token operator">=</span>      params<span class="token operator">-></span>flags <span class="token operator">&amp;</span> UV_THREAD_HAS_STACK_SIZE <span class="token operator">?</span> params<span class="token operator">-></span>stack_size <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>  attr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>stack_size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    stack_size <span class="token operator">=</span> <span class="token function">thread_stack_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    pagesize <span class="token operator">=</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span><span class="token function">getpagesize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Round up to the nearest page boundary. */</span>    stack_size <span class="token operator">=</span> <span class="token punctuation">(</span>stack_size <span class="token operator">+</span> pagesize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token operator">~</span> <span class="token punctuation">(</span>pagesize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> PTHREAD_STACK_MIN</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>stack_size <span class="token operator">&lt;</span> PTHREAD_STACK_MIN<span class="token punctuation">)</span>      stack_size <span class="token operator">=</span> PTHREAD_STACK_MIN<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>stack_size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    attr <span class="token operator">=</span> <span class="token operator">&amp;</span>attr_storage<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pthread_attr_init</span><span class="token punctuation">(</span>attr<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pthread_attr_setstacksize</span><span class="token punctuation">(</span>attr<span class="token punctuation">,</span> stack_size<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/* 最终调用线程库 pthread 的pthread_create()函数创建线程*/</span>  f<span class="token punctuation">.</span>in <span class="token operator">=</span> entry<span class="token punctuation">;</span>  err <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span>tid<span class="token punctuation">,</span> attr<span class="token punctuation">,</span> f<span class="token punctuation">.</span>out<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>attr <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token function">pthread_attr_destroy</span><span class="token punctuation">(</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">UV__ERR</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="libuv的线程分离状态"><a href="#libuv的线程分离状态" class="headerlink" title="libuv的线程分离状态"></a>libuv的线程分离状态</h1><p>其实这个就非常简单了，直接是依赖linux的线程库的函数，具体见：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_thread_join</span><span class="token punctuation">(</span>uv_thread_t <span class="token operator">*</span>tid<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">UV__ERR</span><span class="token punctuation">(</span><span class="token function">pthread_join</span><span class="token punctuation">(</span><span class="token operator">*</span>tid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="libuv线程的其他API"><a href="#libuv线程的其他API" class="headerlink" title="libuv线程的其他API"></a>libuv线程的其他API</h1><p>这里面的API很多都是依赖linux的线程库的函数，我就简单列举一下：</p><ul><li>获取线程句柄：</li></ul><pre class="line-numbers language-c"><code class="language-c">uv_thread_t <span class="token function">uv_thread_self</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>判断线程是否相同:</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_thread_equal</span><span class="token punctuation">(</span><span class="token keyword">const</span> uv_thread_t<span class="token operator">*</span> t1<span class="token punctuation">,</span> <span class="token keyword">const</span> uv_thread_t<span class="token operator">*</span> t2<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">pthread_equal</span><span class="token punctuation">(</span><span class="token operator">*</span>t1<span class="token punctuation">,</span> <span class="token operator">*</span>t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当然啦，其实还有很多互斥锁、信号量相关的实现都是差不多的，说白了就是在操作系统之上抽象了一个操作系统模拟层。</p><h1 id="example"><a href="#example" class="headerlink" title="example"></a>example</h1><p>本章的学习是下一章的基础，就简单用一个龟兔赛跑的故事来实现两个线程吧，在例程中创建两个线程句柄，分别为tortoise、hare，他们在长度固定的跑到比赛，假设为10米，乌龟慢一点，3秒跑一米，兔子快一点，1秒跑一米，代码的实现如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;uv.h></span></span><span class="token keyword">void</span> <span class="token function">hare_entry</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> track_len <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>track_len<span class="token punctuation">)</span> <span class="token punctuation">{</span>        track_len<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hare ran another step\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hare done running!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">tortoise_entry</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> track_len <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>track_len<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        track_len<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"tortoise ran another step\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"tortoise done running!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> track_len <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    uv_thread_t hare<span class="token punctuation">;</span>    uv_thread_t tortoise<span class="token punctuation">;</span>    <span class="token function">uv_thread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hare<span class="token punctuation">,</span> hare_entry<span class="token punctuation">,</span> <span class="token operator">&amp;</span>track_len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_thread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tortoise<span class="token punctuation">,</span> tortoise_entry<span class="token punctuation">,</span> <span class="token operator">&amp;</span>track_len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_thread_join</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hare<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_thread_join</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tortoise<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译运行后的结果如下：</p><pre class="line-numbers language-bash"><code class="language-bash">tortoise ran another stephare ran another stephare ran another steptortoise ran another stephare ran another stephare ran another stephare ran another steptortoise ran another stephare ran another stephare ran another stephare ran another steptortoise ran another stephare ran another stephare ran another stephare <span class="token keyword">done</span> running<span class="token operator">!</span>tortoise ran another steptortoise ran another steptortoise ran another steptortoise ran another steptortoise ran another steptortoise ran another steptortoise <span class="token keyword">done</span> running<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/libuv/libuv/blob/v1.x/docs/code/thread-create/main.c" target="_blank" rel="noopener">libuv官方文档</a></p><h1 id="例程代码获取"><a href="#例程代码获取" class="headerlink" title="例程代码获取"></a>例程代码获取</h1><p><a href="https://github.com/jiejieTop/libuv-learning-code" target="_blank" rel="noopener">libuv-learning-code</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> libuv </tag>
            
            <tag> 网络 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【libuv高效编程】libuv学习超详细教程6——check handle解读</title>
      <link href="/libuv-6/"/>
      <url>/libuv-6/</url>
      
        <content type="html"><![CDATA[<h1 id="libuv系列文章"><a href="#libuv系列文章" class="headerlink" title="libuv系列文章"></a>libuv系列文章</h1><ul><li><p><a href="https://jiedev.com/libuv-1/">【libuv高效编程】libuv学习超详细教程1——libuv的编译与安装</a></p></li><li><p><a href="https://jiedev.com/libuv-2/">【libuv高效编程】libuv学习超详细教程2——libuv框架初窥</a></p></li><li><p><a href="https://jiedev.com/libuv-3/">【libuv高效编程】libuv学习超详细教程3——libuv事件循环</a></p></li><li><p><a href="https://jiedev.com/libuv-4/">【libuv高效编程】libuv学习超详细教程4——libuv idle 空闲句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-5/">【libuv高效编程】libuv学习超详细教程5——libuv prepare 准备句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-6/">【libuv高效编程】libuv学习超详细教程6——libuv check 检查句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-7/">【libuv高效编程】libuv学习超详细教程7——libuv thread 线程句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-8/">【libuv高效编程】libuv学习超详细教程8——libuv signal 信号句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-9/">【libuv高效编程】libuv学习超详细教程9——libuv async异步句柄解读</a></p><h1 id="check-handle"><a href="#check-handle" class="headerlink" title="check handle"></a>check handle</h1></li></ul><p>check handle可以被译为检查句柄，如果程序中启动了check handle后，在事件循环中，每当I/O循环退出阻塞的时候都会被执行一遍，它与prepare刚好是相互呼应的，prepare是在I/O循环进入阻塞前，check是在I/O循环退出阻塞后被调用。</p><p>这种设计机制应该是libuv留个用户的接口，在退出I/O循环的阻塞状态后执行用户自定义的校验操作。</p><p>回顾一下libuv的事件循环过程，它有一个<code>uv__run_check()</code>函数会被执行，就是在事件循环迭代的过程中处理check handle。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><code>uv_check_t</code> 是check handle的数据类型，通过它可以定义一个 check handle 的实例。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> uv_check_s uv_check_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="check-handle的回调函数"><a href="#check-handle的回调函数" class="headerlink" title="check handle的回调函数"></a>check handle的回调函数</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>uv_check_cb<span class="token punctuation">)</span><span class="token punctuation">(</span>uv_check_t<span class="token operator">*</span> handle<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果 check handle 的实例想要执行回调函数，则需要传递一个<code>uv_check_cb</code>类型的回调函数到<code>uv_check_start()</code>函数中。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul><li>初始化句柄。</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_check_init</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">,</span> uv_check_t<span class="token operator">*</span> check<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>以给定的回调函数开始句柄。</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_check_start</span><span class="token punctuation">(</span>uv_check_t<span class="token operator">*</span> check<span class="token punctuation">,</span> uv_check_cb cb<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>停止句柄，回调函数将不会再被调用。</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_check_stop</span><span class="token punctuation">(</span>uv_check_t<span class="token operator">*</span> check<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="example"><a href="#example" class="headerlink" title="example"></a>example</h1><p>说了那么多，首先方个check handle的例子吧，通过例子去讲解check handle相关的知识。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;uv.h></span></span>int64_t num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">my_idle_cb</span><span class="token punctuation">(</span>uv_idle_t<span class="token operator">*</span> handle<span class="token punctuation">)</span><span class="token punctuation">{</span>    num<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"idle callback\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">>=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"idle stop, num = %ld\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">uv_stop</span><span class="token punctuation">(</span><span class="token function">uv_default_loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">my_check_cb</span><span class="token punctuation">(</span>uv_check_t <span class="token operator">*</span>handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"check callback\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    uv_idle_t idler<span class="token punctuation">;</span>    uv_check_t check<span class="token punctuation">;</span>    <span class="token function">uv_idle_init</span><span class="token punctuation">(</span><span class="token function">uv_default_loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>idler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_idle_start</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>idler<span class="token punctuation">,</span> my_idle_cb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_check_init</span><span class="token punctuation">(</span><span class="token function">uv_default_loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>check<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_check_start</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>check<span class="token punctuation">,</span> my_check_cb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_run</span><span class="token punctuation">(</span><span class="token function">uv_default_loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> UV_RUN_DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main函数的处理过程：</p><ul><li>定义idler实例。</li><li>定义check实例。</li><li>初始化idler实例。</li><li>初始化check实例。</li><li>启动idler实例，并传入对应的回调函数<code>my_idler_cb</code>。</li><li>启动check实例，并传入对应的回调函数<code>my_check_cb</code>。</li><li>启动事件循环。</li><li>在结束后退出。</li></ul><p>my_check_cb回调函数的处理：</p><ul><li>打印相关的信息</li></ul><p>my_idle_cb回调函数的处理：</p><ul><li>在每次调用回调函数的时候，对全局变量计数。</li><li>在计数值达到<code>5</code>后，停止事件循环<code>uv_stop()</code>。</li></ul><p>其实你如果直接全局搜索uv_check_init这个函数的话，是找不到它的，因为libuv做了很骚的操作，将check、prepare以及check相关的函数都通过C语言的<code>##</code>连接符统一用宏定义了，并且在编译器预处理的时候产生对应的函数代码，具体源码如下：</p><p><code>src\unix\loop-watcher.c文件内容</code></p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"uv.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"internal.h"</span></span><span class="token macro property">#<span class="token directive keyword">define</span> UV_LOOP_WATCHER_DEFINE(name, type)                                    \  int uv_##name##_init(uv_loop_t* loop, uv_##name##_t* handle) {              \    uv__handle_init(loop, (uv_handle_t*)handle, UV_##type);                   \    handle->name##_cb = NULL;                                                 \    return 0;                                                                 \  }                                                                           \                                                                              \  int uv_##name##_start(uv_##name##_t* handle, uv_##name##_cb cb) {           \    if (uv__is_active(handle)) return 0;                                      \    if (cb == NULL) return UV_EINVAL;                                         \    QUEUE_INSERT_HEAD(&amp;handle->loop->name##_handles, &amp;handle->queue);         \    handle->name##_cb = cb;                                                   \    uv__handle_start(handle);                                                 \    return 0;                                                                 \  }                                                                           \                                                                              \  int uv_##name##_stop(uv_##name##_t* handle) {                               \    if (!uv__is_active(handle)) return 0;                                     \    QUEUE_REMOVE(&amp;handle->queue);                                             \    uv__handle_stop(handle);                                                  \    return 0;                                                                 \  }                                                                           \                                                                              \  void uv__run_##name(uv_loop_t* loop) {                                      \    uv_##name##_t* h;                                                         \    QUEUE queue;                                                              \    QUEUE* q;                                                                 \    QUEUE_MOVE(&amp;loop->name##_handles, &amp;queue);                                \    while (!QUEUE_EMPTY(&amp;queue)) {                                            \      q = QUEUE_HEAD(&amp;queue);                                                 \      h = QUEUE_DATA(q, uv_##name##_t, queue);                                \      QUEUE_REMOVE(q);                                                        \      QUEUE_INSERT_TAIL(&amp;loop->name##_handles, q);                            \      h->name##_cb(h);                                                        \    }                                                                         \  }                                                                           \                                                                              \  void uv__##name##_close(uv_##name##_t* handle) {                            \    uv_##name##_stop(handle);                                                 \  }</span><span class="token function">UV_LOOP_WATCHER_DEFINE</span><span class="token punctuation">(</span>prepare<span class="token punctuation">,</span> PREPARE<span class="token punctuation">)</span><span class="token function">UV_LOOP_WATCHER_DEFINE</span><span class="token punctuation">(</span>check<span class="token punctuation">,</span> CHECK<span class="token punctuation">)</span><span class="token function">UV_LOOP_WATCHER_DEFINE</span><span class="token punctuation">(</span>idle<span class="token punctuation">,</span> IDLE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它利用宏定义，在预处理阶段拓展成三个不同类型，但是处理逻辑一样的代码。有三种类型，分别是prepare，check，check。</p><p>如果你将代码中的<code>##name</code>或者<code>name##</code>或者<code>##name##</code>替换为<code>check</code>，<code>##type</code>替换为<code>IDLE</code>，就可以得到以下的代码：</p><ul><li>这就是编译器预处理生成的check handle相关的代码：</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_check_init</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">,</span> uv_check_t<span class="token operator">*</span> handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 初始化handle的类型，所属loop，设置UV_HANDLE_REF标志，并且把handle插入loop->handle_queue队列的队尾 */</span>    <span class="token function">uv__handle_init</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span> <span class="token punctuation">(</span>uv_handle_t<span class="token operator">*</span><span class="token punctuation">)</span>handle<span class="token punctuation">,</span> UV_IDLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    handle<span class="token operator">-></span>check_cb <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">uv_check_start</span><span class="token punctuation">(</span>uv_check_t<span class="token operator">*</span> handle<span class="token punctuation">,</span> uv_check_cb cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">/* 如果已经执行过start函数则直接返回 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">uv__is_active</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 回调函数不允许为空 */</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>cb <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> UV_EINVAL<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 把handle插入loop中check_handles队列，loop有prepare，check和check三个队列 */</span>    <span class="token function">QUEUE_INSERT_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>handle<span class="token operator">-></span>loop<span class="token operator">-></span>check_handles<span class="token punctuation">,</span> <span class="token operator">&amp;</span>handle<span class="token operator">-></span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 指定回调函数，在事件循环迭代的时候被执行 */</span>    handle<span class="token operator">-></span>check_cb <span class="token operator">=</span> cb<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 启动check handle，设置UV_HANDLE_ACTIVE标记并且将loop中的handle的active计数加一，       init的时候只是把handle挂载到loop，start的时候handle才处于激活态 */</span>    <span class="token function">uv__handle_start</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">uv_check_stop</span><span class="token punctuation">(</span>uv_check_t<span class="token operator">*</span> handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">/* 如果check handle没有被启动则直接返回 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">uv__is_active</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 把handle从loop中相应的队列移除，但是还挂载到handle_queue中 */</span>    <span class="token function">QUEUE_REMOVE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>handle<span class="token operator">-></span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 清除UV_HANDLE_ACTIVE标记并且减去loop中handle的active计数 */</span>    <span class="token function">uv__handle_stop</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 在每一轮循环中执行该函数，具体见uv_run */</span><span class="token keyword">void</span> <span class="token function">uv__run_check</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">)</span> <span class="token punctuation">{</span>     uv_check_t<span class="token operator">*</span> h<span class="token punctuation">;</span>    QUEUE queue<span class="token punctuation">;</span>    QUEUE<span class="token operator">*</span> q<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 把loop的check_handles队列中所有节点摘下来挂载到queue变量 */</span>    <span class="token function">QUEUE_MOVE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-></span>check_handles<span class="token punctuation">,</span> <span class="token operator">&amp;</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* while循环遍历队列，执行每个节点里面的函数 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">QUEUE_EMPTY</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 取下当前待处理的节点 */</span>        q <span class="token operator">=</span> <span class="token function">QUEUE_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 取得该节点对应的整个结构体的基地址 */</span>        h <span class="token operator">=</span> <span class="token function">QUEUE_DATA</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> uv_check_t<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 把该节点移出当前队列 */</span>        <span class="token function">QUEUE_REMOVE</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* 重新插入loop->check_handles队列 */</span>        <span class="token function">QUEUE_INSERT_TAIL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-></span>check_handles<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* 执行对应的回调函数 */</span>        h<span class="token operator">-></span><span class="token function">check_cb</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 关闭这个check handle */</span><span class="token keyword">void</span> <span class="token function">uv__check_close</span><span class="token punctuation">(</span>uv_check_t<span class="token operator">*</span> handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">uv_check_stop</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://docs.libuv.org/en/v1.x/check.html" target="_blank" rel="noopener">libuv官方文档</a></p><h1 id="例程代码获取"><a href="#例程代码获取" class="headerlink" title="例程代码获取"></a>例程代码获取</h1><p><a href="https://github.com/jiejieTop/libuv-learning-code" target="_blank" rel="noopener">libuv-learning-code</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> libuv </tag>
            
            <tag> 网络 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【libuv高效编程】libuv学习超详细教程5——prepare handle解读</title>
      <link href="/libuv-5/"/>
      <url>/libuv-5/</url>
      
        <content type="html"><![CDATA[<h1 id="libuv系列文章"><a href="#libuv系列文章" class="headerlink" title="libuv系列文章"></a>libuv系列文章</h1><ul><li><p><a href="https://jiedev.com/libuv-1/">【libuv高效编程】libuv学习超详细教程1——libuv的编译与安装</a></p></li><li><p><a href="https://jiedev.com/libuv-2/">【libuv高效编程】libuv学习超详细教程2——libuv框架初窥</a></p></li><li><p><a href="https://jiedev.com/libuv-3/">【libuv高效编程】libuv学习超详细教程3——libuv事件循环</a></p></li><li><p><a href="https://jiedev.com/libuv-4/">【libuv高效编程】libuv学习超详细教程4——libuv idle 空闲句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-5/">【libuv高效编程】libuv学习超详细教程5——libuv prepare 准备句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-6/">【libuv高效编程】libuv学习超详细教程6——libuv check 检查句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-7/">【libuv高效编程】libuv学习超详细教程7——libuv thread 线程句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-8/">【libuv高效编程】libuv学习超详细教程8——libuv signal 信号句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-9/">【libuv高效编程】libuv学习超详细教程9——libuv async异步句柄解读</a></p></li></ul><h1 id="prepare-handle"><a href="#prepare-handle" class="headerlink" title="prepare handle"></a>prepare handle</h1><p>prepare handle可以被译为准备句柄，如果程序中启动了prepare handle后，那么它在每次事件循环的时候都会被执行一遍，并且在I/O轮询之前被执行，注意，虽然它的原理与idle handle差不多，但是还是有一些差别的。</p><p>回顾上一篇文章，idle句柄在每次循环迭代中运行一次给定的回调，而且执行顺序是在prepare handle之前。它与prepare句柄的显著区别在于：当存在活动的空闲句柄时，循环将执行零超时轮询，而不是阻塞I/O，idle句柄的回调一般用来执行一些低优先级的任务，如果没有idle handle，那么事件循环将进入I/O的阻塞中。</p><p>我为什么在上一节不讲清楚这个原理呢，原因有两点，一开始我没有注意到，在写这篇文章的时候我注意到了源码，第二点原因是我想放在这里形成对比，产生的结果应该更明显，能让大家区分idle与prepare handle，其实在计算阻塞时间的函数uv_backend_timeout()中，我们可以看到一句话</p><pre class="line-numbers language-c"><code class="language-c">  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">QUEUE_EMPTY</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-></span>idle_handles<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这意味着当还存在idle handle处于活跃状态时，事件循环将不会进入阻塞状态的，或者说<strong>循环将执行零超时轮询</strong>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_backend_timeout</span><span class="token punctuation">(</span><span class="token keyword">const</span> uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>loop<span class="token operator">-></span>stop_flag <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">uv__has_active_handles</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">uv__has_active_reqs</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">QUEUE_EMPTY</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-></span>idle_handles<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>loop<span class="token operator">-></span>closing_handles<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">uv__next_timeout</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回顾一下libuv的事件循环过程，它有一个<code>uv__run_prepare()</code>函数会被执行，就是在事件循环迭代的过程中处理prepare handle。</p><p>总之你可以理解为：idle与prepare handle几乎是一样的东西，只不过产生他们的handle处于活跃状态的时候对事件循环会产生不同的影响，仅此而已。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><code>uv_prepare_t</code> 是prepare handle的数据类型，通过它可以定义一个 prepare handle 的实例。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> uv_prepare_s uv_prepare_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="prepare-handle的回调函数"><a href="#prepare-handle的回调函数" class="headerlink" title="prepare handle的回调函数"></a>prepare handle的回调函数</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>uv_prepare_cb<span class="token punctuation">)</span><span class="token punctuation">(</span>uv_prepare_t<span class="token operator">*</span> handle<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果 prepare handle 的实例想要执行回调函数，则需要传递一个<code>uv_prepare_cb</code>类型的回调函数到<code>uv_prepare_start()</code>函数中。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul><li>初始化句柄。</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_prepare_init</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">,</span> uv_prepare_t<span class="token operator">*</span> prepare<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>以给定的回调函数开始句柄。</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_prepare_start</span><span class="token punctuation">(</span>uv_prepare_t<span class="token operator">*</span> prepare<span class="token punctuation">,</span> uv_prepare_cb cb<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>停止句柄，回调函数将不会再被调用。</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_prepare_stop</span><span class="token punctuation">(</span>uv_prepare_t<span class="token operator">*</span> prepare<span class="token punctuation">)</span>```c<span class="token macro property"># example</span>说了那么多，首先方个prepare handle的例子吧，通过例子去讲解prepare handle相关的知识。```c<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;uv.h></span></span>int64_t num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">my_idle_cb</span><span class="token punctuation">(</span>uv_idle_t<span class="token operator">*</span> handle<span class="token punctuation">)</span><span class="token punctuation">{</span>    num<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"idle callback\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">>=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"idle stop, num = %ld\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">uv_stop</span><span class="token punctuation">(</span><span class="token function">uv_default_loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">my_prep_cb</span><span class="token punctuation">(</span>uv_prepare_t <span class="token operator">*</span>handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"prep callback\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    uv_idle_t idler<span class="token punctuation">;</span>    uv_prepare_t prep<span class="token punctuation">;</span>    <span class="token function">uv_idle_init</span><span class="token punctuation">(</span><span class="token function">uv_default_loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>idler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_idle_start</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>idler<span class="token punctuation">,</span> my_idle_cb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_prepare_init</span><span class="token punctuation">(</span><span class="token function">uv_default_loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>prep<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_prepare_start</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>prep<span class="token punctuation">,</span> my_prep_cb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_run</span><span class="token punctuation">(</span><span class="token function">uv_default_loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> UV_RUN_DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main函数的处理过程：</p><ul><li>定义idler实例。</li><li>定义prep实例。</li><li>初始化idler实例。</li><li>初始化prep实例。</li><li>启动idler实例，并传入对应的回调函数<code>my_idler_cb</code>。</li><li>启动prep实例，并传入对应的回调函数<code>my_prep_cb</code>。</li><li>启动事件循环。</li><li>在结束后退出。</li></ul><p>my_prep_cb回调函数的处理：</p><ul><li>打印相关的信息</li></ul><p>my_idle_cb回调函数的处理：</p><ul><li>在每次调用回调函数的时候，对全局变量计数。</li><li>在计数值达到<code>5</code>后，停止事件循环<code>uv_stop()</code>。</li></ul><h1 id="uv-prepare-init"><a href="#uv-prepare-init" class="headerlink" title="uv_prepare_init()"></a>uv_prepare_init()</h1><p>其实你如果直接全局搜索uv_prepare_init这个函数的话，是找不到它的，因为libuv做了很骚的操作，将prepare、prepare以及check相关的函数都通过C语言的<code>##</code>连接符统一用宏定义了，并且在编译器预处理的时候产生对应的函数代码，具体源码如下：</p><p><code>src\unix\loop-watcher.c文件内容</code></p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"uv.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"internal.h"</span></span><span class="token macro property">#<span class="token directive keyword">define</span> UV_LOOP_WATCHER_DEFINE(name, type)                                    \  int uv_##name##_init(uv_loop_t* loop, uv_##name##_t* handle) {              \    uv__handle_init(loop, (uv_handle_t*)handle, UV_##type);                   \    handle->name##_cb = NULL;                                                 \    return 0;                                                                 \  }                                                                           \                                                                              \  int uv_##name##_start(uv_##name##_t* handle, uv_##name##_cb cb) {           \    if (uv__is_active(handle)) return 0;                                      \    if (cb == NULL) return UV_EINVAL;                                         \    QUEUE_INSERT_HEAD(&amp;handle->loop->name##_handles, &amp;handle->queue);         \    handle->name##_cb = cb;                                                   \    uv__handle_start(handle);                                                 \    return 0;                                                                 \  }                                                                           \                                                                              \  int uv_##name##_stop(uv_##name##_t* handle) {                               \    if (!uv__is_active(handle)) return 0;                                     \    QUEUE_REMOVE(&amp;handle->queue);                                             \    uv__handle_stop(handle);                                                  \    return 0;                                                                 \  }                                                                           \                                                                              \  void uv__run_##name(uv_loop_t* loop) {                                      \    uv_##name##_t* h;                                                         \    QUEUE queue;                                                              \    QUEUE* q;                                                                 \    QUEUE_MOVE(&amp;loop->name##_handles, &amp;queue);                                \    while (!QUEUE_EMPTY(&amp;queue)) {                                            \      q = QUEUE_HEAD(&amp;queue);                                                 \      h = QUEUE_DATA(q, uv_##name##_t, queue);                                \      QUEUE_REMOVE(q);                                                        \      QUEUE_INSERT_TAIL(&amp;loop->name##_handles, q);                            \      h->name##_cb(h);                                                        \    }                                                                         \  }                                                                           \                                                                              \  void uv__##name##_close(uv_##name##_t* handle) {                            \    uv_##name##_stop(handle);                                                 \  }</span><span class="token function">UV_LOOP_WATCHER_DEFINE</span><span class="token punctuation">(</span>prepare<span class="token punctuation">,</span> PREPARE<span class="token punctuation">)</span><span class="token function">UV_LOOP_WATCHER_DEFINE</span><span class="token punctuation">(</span>check<span class="token punctuation">,</span> CHECK<span class="token punctuation">)</span><span class="token function">UV_LOOP_WATCHER_DEFINE</span><span class="token punctuation">(</span>idle<span class="token punctuation">,</span> IDLE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它利用宏定义，在预处理阶段拓展成三个不同类型，但是处理逻辑一样的代码。有三种类型，分别是prepare，check，prepare。</p><p>如果你将代码中的<code>##name</code>或者<code>name##</code>或者<code>##name##</code>替换为<code>prepare</code>，<code>##type</code>替换为<code>PREPARE</code>，就可以得到以下的代码：</p><ul><li>这就是编译器预处理生成的prepare handle相关的代码：</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_prepare_init</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">,</span> uv_prepare_t<span class="token operator">*</span> handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 初始化handle的类型，所属loop，设置UV_HANDLE_REF标志，并且把handle插入loop->handle_queue队列的队尾 */</span>    <span class="token function">uv__handle_init</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span> <span class="token punctuation">(</span>uv_handle_t<span class="token operator">*</span><span class="token punctuation">)</span>handle<span class="token punctuation">,</span> UV_IDLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    handle<span class="token operator">-></span>prepare_cb <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">uv_prepare_start</span><span class="token punctuation">(</span>uv_prepare_t<span class="token operator">*</span> handle<span class="token punctuation">,</span> uv_prepare_cb cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">/* 如果已经执行过start函数则直接返回 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">uv__is_active</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 回调函数不允许为空 */</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>cb <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> UV_EINVAL<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 把handle插入loop中prepare_handles队列，loop有prepare，prepare和check三个队列 */</span>    <span class="token function">QUEUE_INSERT_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>handle<span class="token operator">-></span>loop<span class="token operator">-></span>prepare_handles<span class="token punctuation">,</span> <span class="token operator">&amp;</span>handle<span class="token operator">-></span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 指定回调函数，在事件循环迭代的时候被执行 */</span>    handle<span class="token operator">-></span>prepare_cb <span class="token operator">=</span> cb<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 启动prepare handle，设置UV_HANDLE_ACTIVE标记并且将loop中的handle的active计数加一，       init的时候只是把handle挂载到loop，start的时候handle才处于激活态 */</span>    <span class="token function">uv__handle_start</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">uv_prepare_stop</span><span class="token punctuation">(</span>uv_prepare_t<span class="token operator">*</span> handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">/* 如果prepare handle没有被启动则直接返回 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">uv__is_active</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 把handle从loop中相应的队列移除，但是还挂载到handle_queue中 */</span>    <span class="token function">QUEUE_REMOVE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>handle<span class="token operator">-></span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 清除UV_HANDLE_ACTIVE标记并且减去loop中handle的active计数 */</span>    <span class="token function">uv__handle_stop</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 在每一轮循环中执行该函数，具体见uv_run */</span><span class="token keyword">void</span> <span class="token function">uv__run_prepare</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">)</span> <span class="token punctuation">{</span>     uv_prepare_t<span class="token operator">*</span> h<span class="token punctuation">;</span>    QUEUE queue<span class="token punctuation">;</span>    QUEUE<span class="token operator">*</span> q<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 把loop的prepare_handles队列中所有节点摘下来挂载到queue变量 */</span>    <span class="token function">QUEUE_MOVE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-></span>prepare_handles<span class="token punctuation">,</span> <span class="token operator">&amp;</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* while循环遍历队列，执行每个节点里面的函数 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">QUEUE_EMPTY</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 取下当前待处理的节点 */</span>        q <span class="token operator">=</span> <span class="token function">QUEUE_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 取得该节点对应的整个结构体的基地址 */</span>        h <span class="token operator">=</span> <span class="token function">QUEUE_DATA</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> uv_prepare_t<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 把该节点移出当前队列 */</span>        <span class="token function">QUEUE_REMOVE</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* 重新插入loop->prepare_handles队列 */</span>        <span class="token function">QUEUE_INSERT_TAIL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-></span>prepare_handles<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* 执行对应的回调函数 */</span>        h<span class="token operator">-></span><span class="token function">prepare_cb</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 关闭这个prepare handle */</span><span class="token keyword">void</span> <span class="token function">uv__prepare_close</span><span class="token punctuation">(</span>uv_prepare_t<span class="token operator">*</span> handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">uv_prepare_stop</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://docs.libuv.org/en/v1.x/idle.html" target="_blank" rel="noopener">libuv官方文档</a></p><h1 id="例程代码获取"><a href="#例程代码获取" class="headerlink" title="例程代码获取"></a>例程代码获取</h1><p><a href="https://github.com/jiejieTop/libuv-learning-code" target="_blank" rel="noopener">libuv-learning-code</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> libuv </tag>
            
            <tag> 网络 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【libuv高效编程】libuv学习超详细教程4——idle handle解读</title>
      <link href="/libuv-4/"/>
      <url>/libuv-4/</url>
      
        <content type="html"><![CDATA[<h1 id="libuv系列文章"><a href="#libuv系列文章" class="headerlink" title="libuv系列文章"></a>libuv系列文章</h1><ul><li><p><a href="https://jiedev.com/libuv-1/">【libuv高效编程】libuv学习超详细教程1——libuv的编译与安装</a></p></li><li><p><a href="https://jiedev.com/libuv-2/">【libuv高效编程】libuv学习超详细教程2——libuv框架初窥</a></p></li><li><p><a href="https://jiedev.com/libuv-3/">【libuv高效编程】libuv学习超详细教程3——libuv事件循环</a></p></li><li><p><a href="https://jiedev.com/libuv-4/">【libuv高效编程】libuv学习超详细教程4——libuv idle 空闲句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-5/">【libuv高效编程】libuv学习超详细教程5——libuv prepare 准备句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-6/">【libuv高效编程】libuv学习超详细教程6——libuv check 检查句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-7/">【libuv高效编程】libuv学习超详细教程7——libuv thread 线程句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-8/">【libuv高效编程】libuv学习超详细教程8——libuv signal 信号句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-9/">【libuv高效编程】libuv学习超详细教程9——libuv async异步句柄解读</a></p></li></ul><h1 id="idle-handle"><a href="#idle-handle" class="headerlink" title="idle handle"></a>idle handle</h1><p>idle handle可以被译为空闲句柄，如果程序中启动了idle handle后，那么它在每次事件循环的时候都会被执行一遍。</p><p>回顾一下libuv的事件循环过程，它有一个<code>uv__run_idle()</code>函数会被执行，就是在事件循环迭代的过程中处理idle handle。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><code>uv_idle_t</code> 是idle handle的数据类型，通过它可以定义一个 idle handle 的实例。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> uv_idle_s uv_idle_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="idle-handle的回调函数"><a href="#idle-handle的回调函数" class="headerlink" title="idle handle的回调函数"></a>idle handle的回调函数</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>uv_idle_cb<span class="token punctuation">)</span><span class="token punctuation">(</span>uv_idle_t<span class="token operator">*</span> handle<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果 idle handle 的实例想要执行回调函数，则需要传递一个<code>uv_idle_cb</code>类型的回调函数到<code>uv_idle_start()</code>函数中。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul><li>初始化句柄。</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_idle_init</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">,</span> uv_idle_t<span class="token operator">*</span> idle<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>以给定的回调函数开始句柄。</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_idle_start</span><span class="token punctuation">(</span>uv_idle_t<span class="token operator">*</span> idle<span class="token punctuation">,</span> uv_idle_cb cb<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>停止句柄，回调函数将不会再被调用。</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_idle_stop</span><span class="token punctuation">(</span>uv_idle_t<span class="token operator">*</span> idle<span class="token punctuation">)</span>```c<span class="token macro property"># example</span>说了那么多，首先方个idle handle的例子吧，通过例子去讲解idle handle相关的知识。```c<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;uv.h></span></span>int64_t num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">my_idle_cb</span><span class="token punctuation">(</span>uv_idle_t<span class="token operator">*</span> handle<span class="token punctuation">)</span><span class="token punctuation">{</span>    num<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">>=</span> <span class="token number">10e6</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"idle stop, num = %ld\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">uv_idle_stop</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    uv_idle_t idler<span class="token punctuation">;</span>    <span class="token function">uv_idle_init</span><span class="token punctuation">(</span><span class="token function">uv_default_loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>idler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"idle start, num = %ld\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_idle_start</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>idler<span class="token punctuation">,</span> my_idle_cb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_run</span><span class="token punctuation">(</span><span class="token function">uv_default_loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> UV_RUN_DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main函数的处理过程：</p><ul><li>定义idler实例。</li><li>初始化idler实例。</li><li>启动idler实例，并传入对应的回调函数<code>my_idle_cb</code>。</li><li>启动事件循环。</li><li>在结束后退出。</li></ul><p>my_idle_cb回调函数的处理：</p><ul><li>在每次调用回调函数的时候，对全局变量计数。</li><li>在计数值达到<code>10e6</code>后，停止idle handle。</li></ul><h1 id="uv-idle-init"><a href="#uv-idle-init" class="headerlink" title="uv_idle_init()"></a>uv_idle_init()</h1><p>其实你如果直接全局搜索uv_idle_init这个函数的话，是找不到它的，因为libuv做了很骚的操作，将idle、prepare以及check相关的函数都通过C语言的<code>##</code>连接符统一用宏定义了，并且在编译器预处理的时候产生对应的函数代码，具体源码如下：</p><p><code>src\unix\loop-watcher.c文件内容</code></p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"uv.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"internal.h"</span></span><span class="token macro property">#<span class="token directive keyword">define</span> UV_LOOP_WATCHER_DEFINE(name, type)                                    \  int uv_##name##_init(uv_loop_t* loop, uv_##name##_t* handle) {              \    uv__handle_init(loop, (uv_handle_t*)handle, UV_##type);                   \    handle->name##_cb = NULL;                                                 \    return 0;                                                                 \  }                                                                           \                                                                              \  int uv_##name##_start(uv_##name##_t* handle, uv_##name##_cb cb) {           \    if (uv__is_active(handle)) return 0;                                      \    if (cb == NULL) return UV_EINVAL;                                         \    QUEUE_INSERT_HEAD(&amp;handle->loop->name##_handles, &amp;handle->queue);         \    handle->name##_cb = cb;                                                   \    uv__handle_start(handle);                                                 \    return 0;                                                                 \  }                                                                           \                                                                              \  int uv_##name##_stop(uv_##name##_t* handle) {                               \    if (!uv__is_active(handle)) return 0;                                     \    QUEUE_REMOVE(&amp;handle->queue);                                             \    uv__handle_stop(handle);                                                  \    return 0;                                                                 \  }                                                                           \                                                                              \  void uv__run_##name(uv_loop_t* loop) {                                      \    uv_##name##_t* h;                                                         \    QUEUE queue;                                                              \    QUEUE* q;                                                                 \    QUEUE_MOVE(&amp;loop->name##_handles, &amp;queue);                                \    while (!QUEUE_EMPTY(&amp;queue)) {                                            \      q = QUEUE_HEAD(&amp;queue);                                                 \      h = QUEUE_DATA(q, uv_##name##_t, queue);                                \      QUEUE_REMOVE(q);                                                        \      QUEUE_INSERT_TAIL(&amp;loop->name##_handles, q);                            \      h->name##_cb(h);                                                        \    }                                                                         \  }                                                                           \                                                                              \  void uv__##name##_close(uv_##name##_t* handle) {                            \    uv_##name##_stop(handle);                                                 \  }</span><span class="token function">UV_LOOP_WATCHER_DEFINE</span><span class="token punctuation">(</span>prepare<span class="token punctuation">,</span> PREPARE<span class="token punctuation">)</span><span class="token function">UV_LOOP_WATCHER_DEFINE</span><span class="token punctuation">(</span>check<span class="token punctuation">,</span> CHECK<span class="token punctuation">)</span><span class="token function">UV_LOOP_WATCHER_DEFINE</span><span class="token punctuation">(</span>idle<span class="token punctuation">,</span> IDLE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它利用宏定义，在预处理阶段拓展成三个不同类型，但是处理逻辑一样的代码。有三种类型，分别是prepare，check，idle。</p><p>如果你将代码中的<code>##name</code>或者<code>name##</code>或者<code>##name##</code>替换为<code>idle</code>，<code>##type</code>替换为<code>IDLE</code>，就可以得到以下的代码：</p><ul><li>这就是编译器预处理生成的idle handle相关的代码：</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uv_idle_init</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">,</span> uv_idle_t<span class="token operator">*</span> handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 初始化handle的类型，所属loop，设置UV_HANDLE_REF标志，并且把handle插入loop->handle_queue队列的队尾 */</span>    <span class="token function">uv__handle_init</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span> <span class="token punctuation">(</span>uv_handle_t<span class="token operator">*</span><span class="token punctuation">)</span>handle<span class="token punctuation">,</span> UV_IDLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    handle<span class="token operator">-></span>idle_cb <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">uv_idle_start</span><span class="token punctuation">(</span>uv_idle_t<span class="token operator">*</span> handle<span class="token punctuation">,</span> uv_idle_cb cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">/* 如果已经执行过start函数则直接返回 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">uv__is_active</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 回调函数不允许为空 */</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>cb <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> UV_EINVAL<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 把handle插入loop中idle_handles队列，loop有prepare，idle和check三个队列 */</span>    <span class="token function">QUEUE_INSERT_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>handle<span class="token operator">-></span>loop<span class="token operator">-></span>idle_handles<span class="token punctuation">,</span> <span class="token operator">&amp;</span>handle<span class="token operator">-></span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 指定回调函数，在事件循环迭代的时候被执行 */</span>    handle<span class="token operator">-></span>idle_cb <span class="token operator">=</span> cb<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 启动idle handle，设置UV_HANDLE_ACTIVE标记并且将loop中的handle的active计数加一，       init的时候只是把handle挂载到loop，start的时候handle才处于激活态 */</span>    <span class="token function">uv__handle_start</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">uv_idle_stop</span><span class="token punctuation">(</span>uv_idle_t<span class="token operator">*</span> handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">/* 如果idle handle没有被启动则直接返回 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">uv__is_active</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 把handle从loop中相应的队列移除，但是还挂载到handle_queue中 */</span>    <span class="token function">QUEUE_REMOVE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>handle<span class="token operator">-></span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 清除UV_HANDLE_ACTIVE标记并且减去loop中handle的active计数 */</span>    <span class="token function">uv__handle_stop</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 在每一轮循环中执行该函数，具体见uv_run */</span><span class="token keyword">void</span> <span class="token function">uv__run_idle</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">)</span> <span class="token punctuation">{</span>     uv_idle_t<span class="token operator">*</span> h<span class="token punctuation">;</span>    QUEUE queue<span class="token punctuation">;</span>    QUEUE<span class="token operator">*</span> q<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 把loop的idle_handles队列中所有节点摘下来挂载到queue变量 */</span>    <span class="token function">QUEUE_MOVE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-></span>idle_handles<span class="token punctuation">,</span> <span class="token operator">&amp;</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* while循环遍历队列，执行每个节点里面的函数 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">QUEUE_EMPTY</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 取下当前待处理的节点 */</span>        q <span class="token operator">=</span> <span class="token function">QUEUE_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 取得该节点对应的整个结构体的基地址 */</span>        h <span class="token operator">=</span> <span class="token function">QUEUE_DATA</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> uv_idle_t<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 把该节点移出当前队列 */</span>        <span class="token function">QUEUE_REMOVE</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* 重新插入loop->idle_handles队列 */</span>        <span class="token function">QUEUE_INSERT_TAIL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-></span>idle_handles<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* 执行对应的回调函数 */</span>        h<span class="token operator">-></span><span class="token function">idle_cb</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 关闭这个idle handle */</span><span class="token keyword">void</span> <span class="token function">uv__idle_close</span><span class="token punctuation">(</span>uv_idle_t<span class="token operator">*</span> handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">uv_idle_stop</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://docs.libuv.org/en/v1.x/idle.html" target="_blank" rel="noopener">libuv官方文档</a></p><h1 id="例程代码获取"><a href="#例程代码获取" class="headerlink" title="例程代码获取"></a>例程代码获取</h1><p><a href="https://github.com/jiejieTop/libuv-learning-code" target="_blank" rel="noopener">libuv-learning-code</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> libuv </tag>
            
            <tag> 网络 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【libuv高效编程】libuv学习超详细教程3——libuv事件循环</title>
      <link href="/libuv-3/"/>
      <url>/libuv-3/</url>
      
        <content type="html"><![CDATA[<h1 id="libuv系列文章"><a href="#libuv系列文章" class="headerlink" title="libuv系列文章"></a>libuv系列文章</h1><ul><li><p><a href="https://jiedev.com/libuv-1/">【libuv高效编程】libuv学习超详细教程1——libuv的编译与安装</a></p></li><li><p><a href="https://jiedev.com/libuv-2/">【libuv高效编程】libuv学习超详细教程2——libuv框架初窥</a></p></li><li><p><a href="https://jiedev.com/libuv-3/">【libuv高效编程】libuv学习超详细教程3——libuv事件循环</a></p></li><li><p><a href="https://jiedev.com/libuv-4/">【libuv高效编程】libuv学习超详细教程4——libuv idle 空闲句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-5/">【libuv高效编程】libuv学习超详细教程5——libuv prepare 准备句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-6/">【libuv高效编程】libuv学习超详细教程6——libuv check 检查句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-7/">【libuv高效编程】libuv学习超详细教程7——libuv thread 线程句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-8/">【libuv高效编程】libuv学习超详细教程8——libuv signal 信号句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-9/">【libuv高效编程】libuv学习超详细教程9——libuv async异步句柄解读</a></p></li></ul><h1 id="libuv事件循环"><a href="#libuv事件循环" class="headerlink" title="libuv事件循环"></a>libuv事件循环</h1><p>事件循环是 libuv 功能的核心部分。它的主要职责是对 I/O 进行轮询然后基于不同的事件源执行它们的回调函数。</p><p>在上一篇文章我们也讲解了它的整个运作框架，虽然代码还未讲解，但是还是要看看怎么去写代码的。</p><h1 id="uv-loop-t"><a href="#uv-loop-t" class="headerlink" title="uv_loop_t"></a>uv_loop_t</h1><p>在libuv中，事件循环的声明是这样子的：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> uv_loop_s uv_loop_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它是一个句柄<code>handle</code>类型，它管理了同一事件循环的所有资源，并且在整个事件循环的生命周期内都是可用的。</p><p>其实到后面你就会发现，实际上它是事件循环所有资源的统一入口，所有在事件循环上运行的各类 <code>Handle/Request</code> 实例都被注册到 <code>uv_loop_t</code> 内部定义的结构中，反正知道它是可以管理事件循环的所有资源就行了。</p><p>这里再补充一个知识点的说明吧：</p><ul><li>IO 观察者（io_watcher）：在 libuv 内部，对所有 I/O 操作进行了统一的抽象，在底层的操作系统 I/O 操作基础上，结合事件循环机制，实现了 IO 观察者，对应结构体 uv__io_s，通过它可以知道 I/O 相关的信息，比如可读、可写等，handle 通过内嵌 IO 观察者的方式获得 IO 的监测能力。</li></ul><p><strong>其实大家可以直接理解为，我要监测一个TCP连接，那么TCP handle就算是一个 IO 观察者，其实它是一个句柄的同时又是一个 IO 观察者。</strong></p><p>可以看它的成员变量有非常多的东西（此处是对linux平台的讲解，Windows的不在讨论范围内，不过都差不多）：</p><pre class="line-numbers language-js"><code class="language-js">struct uv_loop_s <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/* 用户数据-可以用于任何用途，libuv是不会触碰这个字段的数据的。 */</span>  <span class="token keyword">void</span><span class="token operator">*</span> data<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 事件循环中要判断是否有活跃状态的句柄，其实这就是活跃状态句柄计数器。 */</span>  unsigned int active_handles<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* handle队列是一个双向链表，而数组中这两个元素则分别指向next和prev。 */</span>  <span class="token keyword">void</span><span class="token operator">*</span> handle_queue<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  union <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 这是未使用的东西，主要是防止uv_loop_s结构体大小被改变了 */</span>    <span class="token keyword">void</span><span class="token operator">*</span> unused<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 这才是真正使用的东西，用来对在线程池中调用的异步I/O进行计数 */</span>    unsigned int count<span class="token punctuation">;</span>   <span class="token punctuation">}</span> active_reqs<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 内部标志，用于信号循环停止。*/</span>  unsigned int stop_flag<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 这个宏定义在不同的平台有不一样的处理，具体看下面的定义 */</span>  UV_LOOP_PRIVATE_FIELDS    <span class="token punctuation">}</span><span class="token punctuation">;</span>#define UV_LOOP_PRIVATE_FIELDS                                                \  unsigned long flags<span class="token punctuation">;</span>                                                        \  int backend_fd<span class="token punctuation">;</span>                                                             \  <span class="token keyword">void</span><span class="token operator">*</span> pending_queue<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                                                     \  <span class="token keyword">void</span><span class="token operator">*</span> watcher_queue<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                                                     \  uv__io_t<span class="token operator">**</span> watchers<span class="token punctuation">;</span>                                                        \  unsigned int nwatchers<span class="token punctuation">;</span>                                                     \  unsigned int nfds<span class="token punctuation">;</span>                                                          \  <span class="token keyword">void</span><span class="token operator">*</span> wq<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                                                                \  uv_mutex_t wq_mutex<span class="token punctuation">;</span>                                                        \  uv_async_t wq_async<span class="token punctuation">;</span>                                                        \  uv_rwlock_t cloexec_lock<span class="token punctuation">;</span>                                                   \  uv_handle_t<span class="token operator">*</span> closing_handles<span class="token punctuation">;</span>                                               \  <span class="token keyword">void</span><span class="token operator">*</span> process_handles<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                                                   \  <span class="token keyword">void</span><span class="token operator">*</span> prepare_handles<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                                                   \  <span class="token keyword">void</span><span class="token operator">*</span> check_handles<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                                                     \  <span class="token keyword">void</span><span class="token operator">*</span> idle_handles<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                                                      \  <span class="token keyword">void</span><span class="token operator">*</span> async_handles<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                                                     \  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>async_unused<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* TODO(bnoordhuis) Remove in libuv v2. */</span>     \  uv__io_t async_io_watcher<span class="token punctuation">;</span>                                                  \  int async_wfd<span class="token punctuation">;</span>                                                              \  struct <span class="token punctuation">{</span>                                                                    \    <span class="token keyword">void</span><span class="token operator">*</span> min<span class="token punctuation">;</span>                                                                \    unsigned int nelts<span class="token punctuation">;</span>                                                       \  <span class="token punctuation">}</span> timer_heap<span class="token punctuation">;</span>                                                               \  uint64_t timer_counter<span class="token punctuation">;</span>                                                     \  uint64_t time<span class="token punctuation">;</span>                                                              \  int signal_pipefd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                                                       \  uv__io_t signal_io_watcher<span class="token punctuation">;</span>                                                 \  uv_signal_t child_watcher<span class="token punctuation">;</span>                                                  \  int emfile_fd<span class="token punctuation">;</span>                                                              \  UV_PLATFORM_LOOP_FIELDS                                                     \<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个UV_LOOP_PRIVATE_FIELDS宏跟平台相关，在这里不做过多介绍，就简单说几点：</p><ul><li><code>watcher_queue</code> 是 <code>uv__io_t</code> 的观察者队列，其中保存的是 <code>uv__io_t</code> 的结构体</li><li><code>void* wq[2];</code> 表述的是work queue，是工作队列；</li><li><code>timer_heap</code> 是 <code>timer</code> 的二叉堆，它还使用了二叉树来提高遍历的效率。</li></ul><h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><p>写个demo来讲解整个循环事件的过程吧:</p><pre class="line-numbers language-js"><code class="language-js">#include <span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token operator">></span>#include <span class="token operator">&lt;</span>stdlib<span class="token punctuation">.</span>h<span class="token operator">></span>#include <span class="token operator">&lt;</span>uv<span class="token punctuation">.</span>h<span class="token operator">></span>int <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    uv_loop_t <span class="token operator">*</span>loop <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">sizeof</span><span class="token punctuation">(</span>uv_loop_t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_loop_init</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_run</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span> UV_RUN_DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"quit...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv_loop_close</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个demo是非常简单的，一般来说一个句柄都会经历 <strong>初始化、运行、停止、关闭</strong> 等过程。</p><h1 id="uv-loop-init"><a href="#uv-loop-init" class="headerlink" title="uv_loop_init()"></a>uv_loop_init()</h1><p>这个函数就是将<code>uv_loop_t</code>初始化，给这个loop对象初始化一些默认的成员变量，比如初始化定时器、工作队列、观察者队列等。</p><pre class="line-numbers language-js"><code class="language-js">int <span class="token function">uv_loop_init</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">void</span><span class="token operator">*</span> saved_data<span class="token punctuation">;</span>  int err<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 清空数据 */</span>  saved_data <span class="token operator">=</span> loop<span class="token operator">-</span><span class="token operator">></span>data<span class="token punctuation">;</span>  <span class="token function">memset</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>loop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  loop<span class="token operator">-</span><span class="token operator">></span>data <span class="token operator">=</span> saved_data<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 初始化定时器堆，初始化工作队列、空闲队列、各种队列 */</span>  <span class="token function">heap_init</span><span class="token punctuation">(</span><span class="token punctuation">(</span>struct heap<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>timer_heap<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">QUEUE_INIT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>wq<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">QUEUE_INIT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>idle_handles<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">QUEUE_INIT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>async_handles<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">QUEUE_INIT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>check_handles<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">QUEUE_INIT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>prepare_handles<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 这个队列很重要，对于libuv中其他的 handle 在初始化后都会被放到此队列中 */</span>  <span class="token function">QUEUE_INIT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>handle_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 初始化I/O观察者相关的内容，初始化处于活跃状态的观察者句柄计数、请求计数、文件描述符等为0 */</span>  loop<span class="token operator">-</span><span class="token operator">></span>active_handles <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  loop<span class="token operator">-</span><span class="token operator">></span>active_reqs<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  loop<span class="token operator">-</span><span class="token operator">></span>nfds <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  loop<span class="token operator">-</span><span class="token operator">></span>watchers <span class="token operator">=</span> NULL<span class="token punctuation">;</span>  loop<span class="token operator">-</span><span class="token operator">></span>nwatchers <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 初始化挂起的I/O观察者队列，挂起的I/O观察者会被插入此队列延迟处理 */</span>  <span class="token function">QUEUE_INIT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>pending_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 初始化 I/O观察者队列，所有初始化后的I/O观察者都会被插入此队列 */</span>  <span class="token function">QUEUE_INIT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>watcher_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>  loop<span class="token operator">-</span><span class="token operator">></span>closing_handles <span class="token operator">=</span> NULL<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 初始化时间，获取系统当前的时间 */</span>  <span class="token function">uv__update_time</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>  loop<span class="token operator">-</span><span class="token operator">></span>async_io_watcher<span class="token punctuation">.</span>fd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  loop<span class="token operator">-</span><span class="token operator">></span>async_wfd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  loop<span class="token operator">-</span><span class="token operator">></span>signal_pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  loop<span class="token operator">-</span><span class="token operator">></span>signal_pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  loop<span class="token operator">-</span><span class="token operator">></span>backend_fd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  loop<span class="token operator">-</span><span class="token operator">></span>emfile_fd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  loop<span class="token operator">-</span><span class="token operator">></span>timer_counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  loop<span class="token operator">-</span><span class="token operator">></span>stop_flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 初始化平台、linux Windows等 */</span>  err <span class="token operator">=</span> <span class="token function">uv__platform_loop_init</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token keyword">return</span> err<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 初始化信号 */</span>  <span class="token function">uv__signal_global_once_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  err <span class="token operator">=</span> <span class="token function">uv_signal_init</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span> <span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>child_watcher<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>    goto fail_signal_init<span class="token punctuation">;</span>  <span class="token function">uv__handle_unref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>child_watcher<span class="token punctuation">)</span><span class="token punctuation">;</span>  loop<span class="token operator">-</span><span class="token operator">></span>child_watcher<span class="token punctuation">.</span>flags <span class="token operator">|</span><span class="token operator">=</span> UV_HANDLE_INTERNAL<span class="token punctuation">;</span>  <span class="token function">QUEUE_INIT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>process_handles<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 初始化线程读写锁 */</span>  err <span class="token operator">=</span> <span class="token function">uv_rwlock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>cloexec_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>    goto fail_rwlock_init<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 初始化线程互斥锁 */</span>  err <span class="token operator">=</span> <span class="token function">uv_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>wq_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>    goto fail_mutex_init<span class="token punctuation">;</span>  err <span class="token operator">=</span> <span class="token function">uv_async_init</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span> <span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>wq_async<span class="token punctuation">,</span> uv__work_done<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>    goto fail_async_init<span class="token punctuation">;</span>  <span class="token function">uv__handle_unref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>wq_async<span class="token punctuation">)</span><span class="token punctuation">;</span>  loop<span class="token operator">-</span><span class="token operator">></span>wq_async<span class="token punctuation">.</span>flags <span class="token operator">|</span><span class="token operator">=</span> UV_HANDLE_INTERNAL<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 各种出错的处理 */</span>fail_async_init<span class="token punctuation">:</span>  <span class="token function">uv_mutex_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>wq_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>fail_mutex_init<span class="token punctuation">:</span>  <span class="token function">uv_rwlock_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>cloexec_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>fail_rwlock_init<span class="token punctuation">:</span>  <span class="token function">uv__signal_loop_cleanup</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>fail_signal_init<span class="token punctuation">:</span>  <span class="token function">uv__platform_loop_delete</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> err<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实在libuv有一个全局的、静态的<code>uv_loop_t</code>实例<code>default_loop_struct</code>，与他对应的指针<code>default_loop_ptr</code>，这个东西在后续的使用是经常会被用到，它在<code>uv_default_loop()</code>函数<strong>第一次</strong>被调用的时候就会通过<code>uv_loop_init()</code>函数进行初始化操作，这就保证了无论使用什么样的<code>handle</code>，它都有一个统一的事件循环入口。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> uv_loop_t default_loop_struct<span class="token punctuation">;</span><span class="token keyword">static</span> uv_loop_t<span class="token operator">*</span> default_loop_ptr<span class="token punctuation">;</span>uv_loop_t<span class="token operator">*</span> <span class="token function">uv_default_loop</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>default_loop_ptr <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> default_loop_ptr<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 初始化default_loop_struct实例 */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">uv_loop_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>default_loop_struct<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  default_loop_ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>default_loop_struct<span class="token punctuation">;</span>  <span class="token keyword">return</span> default_loop_ptr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="uv-run"><a href="#uv-run" class="headerlink" title="uv_run()"></a>uv_run()</h1><p>首先讲解一下他的API吧，传入<code>uv_loop_t</code>事假循环的句柄，还有一个运行的模式，它的模式有3种，分别为默认模式、单次模式、不等待模式。</p><ul><li><p>默认模式UV_RUN_DEFAULT：运行事件循环，直到不再有活动的和引用的句柄或请求为止。</p></li><li><p>单次模式UV_RUN_ONCE：轮询一次I/O，如果没有待处理的回调，则进入阻塞状态，完成处理后返回零，不继续运行事件循环。</p></li><li><p>不等待模式UV_RUN_NOWAIT：对I/O进行一次轮询，但如果没有待处理的回调，则不会阻塞。</p></li></ul><p><strong>注意，这个函数不是线程安全的。</strong></p><pre class="line-numbers language-js"><code class="language-js">typedef <span class="token keyword">enum</span> <span class="token punctuation">{</span>  UV_RUN_DEFAULT <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>  UV_RUN_ONCE<span class="token punctuation">,</span>  UV_RUN_NOWAIT<span class="token punctuation">}</span> uv_run_mode<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从代码看<code>uv_run()</code>函数做了什么事情，可以参考上一篇文章中的图，并结合源码来学习：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/libuv005.png" alt="libuv005"></p><pre class="line-numbers language-js"><code class="language-js">int <span class="token function">uv_run</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">,</span> uv_run_mode mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>  int timeout<span class="token punctuation">;</span>  int r<span class="token punctuation">;</span>  int ran_pending<span class="token punctuation">;</span>  r <span class="token operator">=</span> <span class="token function">uv__loop_alive</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>r<span class="token punctuation">)</span>    <span class="token function">uv__update_time</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 这是一个while循环 */</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> loop<span class="token operator">-</span><span class="token operator">></span>stop_flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 更新时间并开始倒计时 */</span>    <span class="token function">uv__update_time</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uv__run_timers</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 处理挂起的handle */</span>    ran_pending <span class="token operator">=</span> <span class="token function">uv__run_pending</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 运行idle handle */</span>    <span class="token function">uv__run_idle</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 运行prepare handle */</span>    <span class="token function">uv__run_prepare</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>    timeout <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mode <span class="token operator">==</span> UV_RUN_ONCE <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>ran_pending<span class="token punctuation">)</span> <span class="token operator">||</span> mode <span class="token operator">==</span> UV_RUN_DEFAULT<span class="token punctuation">)</span>      timeout <span class="token operator">=</span> <span class="token function">uv_backend_timeout</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 计算要阻塞的时间，开始阻塞 */</span>    <span class="token function">uv__io_poll</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 程序执行到这里表示被唤醒了，被唤醒的原因可能是I/O可读可写、或者超时了，检查handle是否可以操作 */</span>    <span class="token function">uv__run_check</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 看看是否有close的handle */</span>    <span class="token function">uv__run_closing_handles</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 单次模式 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mode <span class="token operator">==</span> UV_RUN_ONCE<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/* UV_RUN_ONCE implies forward progress: at least one callback must have       * been invoked when it returns. uv__io_poll() can return without doing       * I/O (meaning: no callbacks) when its timeout expires - which means we       * have pending timers that satisfy the forward progress constraint.       *       * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from       * the check.       */</span>      <span class="token function">uv__update_time</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">uv__run_timers</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* handle保活处理 */</span>    r <span class="token operator">=</span> <span class="token function">uv__loop_alive</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mode <span class="token operator">==</span> UV_RUN_ONCE <span class="token operator">||</span> mode <span class="token operator">==</span> UV_RUN_NOWAIT<span class="token punctuation">)</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/* The if statement lets gcc compile it to a conditional store. Avoids   * dirtying a cache line.   */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>loop<span class="token operator">-</span><span class="token operator">></span>stop_flag <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>    loop<span class="token operator">-</span><span class="token operator">></span>stop_flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大家可以看看相关的函数是这样子调用的（大家只看左下角部分即可）：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/libuv006.png" alt="libuv006"></p><h1 id="uv-loop-close"><a href="#uv-loop-close" class="headerlink" title="uv_loop_close()"></a>uv_loop_close()</h1><p>释放所有内部循环资源。仅当循环完成执行并且所有打开的句柄和请求已关闭时才调用此函数，否则它将返回<code>UV_EBUSY</code>。此函数返回后，用户可以释放为循环分配的内存。</p><p><strong>注意，这个函数也不是线程安全的。</strong></p><pre class="line-numbers language-js"><code class="language-js">int <span class="token function">uv_loop_close</span><span class="token punctuation">(</span>uv_loop_t<span class="token operator">*</span> loop<span class="token punctuation">)</span> <span class="token punctuation">{</span>  QUEUE<span class="token operator">*</span> q<span class="token punctuation">;</span>  uv_handle_t<span class="token operator">*</span> h<span class="token punctuation">;</span>#ifndef NDEBUG  <span class="token keyword">void</span><span class="token operator">*</span> saved_data<span class="token punctuation">;</span>#endif  <span class="token comment" spellcheck="true">/* 如果存在处于活跃状态的请求，则返回UV_EBUSY */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">uv__has_active_reqs</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> UV_EBUSY<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 如果存在处于活跃状态的handle，则返回UV_EBUSY */</span>  <span class="token function">QUEUE_FOREACH</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> <span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>handle_queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    h <span class="token operator">=</span> <span class="token function">QUEUE_DATA</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> uv_handle_t<span class="token punctuation">,</span> handle_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>h<span class="token operator">-</span><span class="token operator">></span>flags <span class="token operator">&amp;</span> UV_HANDLE_INTERNAL<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> UV_EBUSY<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/* 关闭事件循环 */</span>  <span class="token function">uv__loop_close</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>#ifndef NDEBUG  saved_data <span class="token operator">=</span> loop<span class="token operator">-</span><span class="token operator">></span>data<span class="token punctuation">;</span>  <span class="token function">memset</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>loop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  loop<span class="token operator">-</span><span class="token operator">></span>data <span class="token operator">=</span> saved_data<span class="token punctuation">;</span>#endif  <span class="token keyword">if</span> <span class="token punctuation">(</span>loop <span class="token operator">==</span> default_loop_ptr<span class="token punctuation">)</span>    default_loop_ptr <span class="token operator">=</span> NULL<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://docs.libuv.org/en/v1.x/loop.html" target="_blank" rel="noopener">libuv官方文档</a></p><h1 id="例程代码获取"><a href="#例程代码获取" class="headerlink" title="例程代码获取"></a>例程代码获取</h1><p><a href="https://github.com/jiejieTop/libuv-learning-code" target="_blank" rel="noopener">libuv-learning-code</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> libuv </tag>
            
            <tag> 网络 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【libuv高效编程】libuv学习超详细教程2——libuv框架初窥</title>
      <link href="/libuv-2/"/>
      <url>/libuv-2/</url>
      
        <content type="html"><![CDATA[<h1 id="libuv系列文章"><a href="#libuv系列文章" class="headerlink" title="libuv系列文章"></a>libuv系列文章</h1><ul><li><p><a href="https://jiedev.com/libuv-1/">【libuv高效编程】libuv学习超详细教程1——libuv的编译与安装</a></p></li><li><p><a href="https://jiedev.com/libuv-2/">【libuv高效编程】libuv学习超详细教程2——libuv框架初窥</a></p></li><li><p><a href="https://jiedev.com/libuv-3/">【libuv高效编程】libuv学习超详细教程3——libuv事件循环</a></p></li><li><p><a href="https://jiedev.com/libuv-4/">【libuv高效编程】libuv学习超详细教程4——libuv idle 空闲句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-5/">【libuv高效编程】libuv学习超详细教程5——libuv prepare 准备句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-6/">【libuv高效编程】libuv学习超详细教程6——libuv check 检查句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-7/">【libuv高效编程】libuv学习超详细教程7——libuv thread 线程句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-8/">【libuv高效编程】libuv学习超详细教程8——libuv signal 信号句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-9/">【libuv高效编程】libuv学习超详细教程9——libuv async异步句柄解读</a></p></li></ul><h1 id="libuv框架"><a href="#libuv框架" class="headerlink" title="libuv框架"></a>libuv框架</h1><p>从官方的文档可以找到一个设计框架的图片：<code>libuv/docs/src/static/architecture.png</code></p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/libuv004.png" alt="libuv004"></p><p>从这张图片可以看出libuv的设计框架（从上往下看，从左往右分成网络IO与文件IO等操作），从网络I/O看，在linux（unix）平台它可以通过网络的底层epoll作为异步的I/O处理，在OSX上可以使用kqueue等，它的中间有一层抽象层uv__io_t；而在Windows平台可以通过IOCP作为异步的处理；对应文件I/O操作，它不像网络I/O，libuv没有特定平台的异步IO原语（primitives）可以依赖，所以libuv是在线程池中执行阻塞（同步）IO来实现异步的操作。</p><h1 id="同步I-O"><a href="#同步I-O" class="headerlink" title="同步I/O"></a>同步I/O</h1><p>在操作系统中，程序运行的空间分为内核空间和用户空间，用户空间所有对io操作的代码（如文件的读写、socket的收发等）都会通过系统调用进入内核空间完成实际的操作。</p><p>而且我们都知道CPU的速度远远快于硬盘、网络等I/O。在一个线程中，CPU执行代码的速度极快，然而，一旦遇到I/O操作，如读写文件、发送网络数据时，就需要等待 I/O 操作完成，才能继续进行下一步操作，这种情况称为同步 I/O。</p><p>在某个应用程序运行时，假设需要读写某个文件，此时就发生了 I/O 操作，在I/O操作的过程中，系统会将当前线程挂起，而其他需要CPU执行的代码就无法被当前线程执行了，这就是同步I/O操作，因为一个IO操作就阻塞了当前线程，导致其他代码无法执行，所以我们可以使用<strong>多线程或者多进程</strong>来并发执行代码，当某个线程/进程被挂起后，不会影响其他线程或进程。</p><p>多线程和多进程虽然解决了这种并发的问题，但是系统不能无上限地增加线程/进程。由于系统切换线程/进程的开销也很大，所以，一旦线程/进程数量过多，CPU的时间就花在线程/进程切换上了，真正运行代码的时间就少了，这样子的结果也导致系统性能严重下降。</p><p>多线程和多进程只是解决这一问题的一种方法，另一种解决I/O问题的方法是异步I/O。</p><h1 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h1><p>当程序需要对I/O进行操作时，它只发出I/O操作的指令，并不等待I/O操作的结果，然后就去执行其他代码了。一段时间后，当I/O返回结果时，再通知CPU进行处理。这样子用户空间中的程序不需要等待内核空间中的 I/O 完成实际操作，就可执行其他任务，提高CPU的利用率。</p><p><strong>简单来说就是，用户不需要等待内核完成实际对io的读写操作就直接返回了。</strong></p><p>大家可以思考一下，如何去实现异步I/O模型，思考明白了，就表示对libuv框架有一定了解了，或者说看完这篇文章后，你能知道为什么libuv是这样子设计的，那就可以了。</p><h1 id="Handles-和-Requests"><a href="#Handles-和-Requests" class="headerlink" title="Handles 和 Requests"></a>Handles 和 Requests</h1><p>Handles就是句柄，Requests是请求，句柄代表着一个可用的资源（或者说是一个对象），比如一个TCP连接，在整个TCP连接的生命周期中，句柄都是可用的，当断开连接后，句柄也应该随之释放。而请求则表示一个操作的开始，比如TCP请求建立连接、TCP请求读取数据、发送数据等，这个请求是期望得到应答的，当产生应答的时候，请求就完成了。还有很重要的一点是：这些请求是可以在句柄上操作的，比如在某个TCP连接中请求发送数据、读取数据；当然也有不在句柄上的请求。</p><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p>事件循环是libuv的核心部分，它的主要职责是对 I/O 进行轮询，然后基于不同的事件源调度它们的回调，它是libuv中建立所有I/O操作的内容，所有网络I/O工作在<strong>非阻塞</strong>套接字上，这些循环<strong>依赖平台</strong>上的最佳机制进行轮询，比如<strong>在linux平台上使用epoll，在OSX上使用kqueue，在Windows上使用IOCP等机制</strong>，当这些网络I/O有数据到达的时候，libuv将通过回调函数去执行相应的操作，比如读取数据、写入数据等。</p><p>对于文件I/O的操作，由于平台并未对文件I/O提供轮询机制，libuv通过线程池的方式阻塞他们，每个I/O将对应产生一个线程，并在线程中进行阻塞，当有数据可操作的时候解除阻塞，进而进行回调处理，因此libuv将维护一个线程池，线程池中可能创建了多个线程并阻塞它们。</p><p>接下来放一张官方的图片吧，它在<code>libuv/docs/src/static/loop_iteration.png</code>路径下:</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/libuv005.png" alt="libuv005"></p><p>这张图很明确的表示了libuv中<strong>所有I/O</strong>的事件循环处理的过程，其实就是<code>uv_run()</code>函数执行的过程，它内部是一个while循环。</p><ol><li><p>首先判断循环是否是处于活动状态，它主要是通过当前是否存在处于alive活动状态的句柄，如果句柄都没有了，那循环也就没有意义了，如果不存在则直接退出。</p></li><li><p>开始倒计时，主要是维护所有句柄中的定时器，当某个句柄超时了，就会告知应用层已经超时了，就退出去或者重新加入循环中。</p></li><li><p>调用待处理的回调函数，如果有待处理的回调函数，则去处理它，如果没有就接着往下运行。</p></li><li><p>运行空闲句柄，反正它这个线程都默认会有空闲句柄的，这个空闲句柄会在每次循环中被执行。</p></li><li><p>运行准备句柄回调处理，这个名字有点奇怪，我是跟着官方手册来学习的，也不知道怎么去翻译它，简单来说就是在某个I/O要阻塞前，有需要的话就去运行一下他的回调函数，举个例子吧，比如我要从某个文件读取数据，如果我在读取数据进入阻塞状态之前想打印一个信息，那么就可以通过这个准备句柄的回调函数去处理这个打印信息。</p></li><li><p>计算轮询超时，在阻塞I/O之前，循环会计算阻塞的时间，并将这个I/O进入阻塞状态（如果可以的话，阻塞超时为0则表示不阻塞），这些是计算超时的规则：</p></li></ol><ul><li><p>如果使用该<code>UV_RUN_NOWAIT</code>模式运行循环，则超时为0。</p></li><li><p>如果要停止循环（uv_stop()被调用），则超时为0。</p></li><li><p>如果没有活动的句柄或请求，则超时为0。</p></li><li><p>如果有任何空闲的句柄处于活动状态，则超时为0。</p></li><li><p>如果有任何要关闭的句柄，则超时为0。</p></li><li><p>如果以上情况均不匹配，则采用最接近的定时器超时，或者如果没有活动的定时器，则为无穷大。</p></li></ul><blockquote><p>重要知识点说明： I/O 循环作为事件循环迭代的一部分，事件循环将会被阻塞在 I/O 循环上（例如：linux 上的 <code>epoll_pwait()</code> 调用），直到该套接字有 I/O 事件发生时唤醒这个线程，调用关联的回调函数，然后便可以在 handles 上进行读、写或其他想要进行的操作 requests。这也直接避免了时间循环一直工作导致占用 CPU 的问题。</p></blockquote><ol start="7"><li><p>检查句柄的回调，其实当程序能执行到这一步，就表明I/O已经退出阻塞状态了，那么有可能是可读/写数据，也有可能超时了，此时libuv将在这里检查句柄的回调，如果有可读可写的操作就调用他们对应的回调，当超时了就调用超时的处理。</p></li><li><p>如果通过调用uv_close()函数关闭了句柄，则会调用close将这个I/O关闭。</p></li><li><p>在超时后更新下一次的循环时间，前提是通过<code>UV_RUN_DEFAULT</code>模式去运行这个循环，关于运行的模式在后续会讲解到，目前有3中模式，<code>UV_RUN_NOWAIT、UV_RUN_ONCE、UV_RUN_DEFAULT</code>。</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://docs.libuv.org/en/v1.x/design.html#handles-and-requests" target="_blank" rel="noopener">libuv官方文档</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> libuv </tag>
            
            <tag> 网络 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【libuv高效编程】libuv学习超详细教程1——libuv的编译与安装</title>
      <link href="/libuv-1/"/>
      <url>/libuv-1/</url>
      
        <content type="html"><![CDATA[<h1 id="libuv系列文章"><a href="#libuv系列文章" class="headerlink" title="libuv系列文章"></a>libuv系列文章</h1><ul><li><p><a href="https://jiedev.com/libuv-1/">【libuv高效编程】libuv学习超详细教程1——libuv的编译与安装</a></p></li><li><p><a href="https://jiedev.com/libuv-2/">【libuv高效编程】libuv学习超详细教程2——libuv框架初窥</a></p></li><li><p><a href="https://jiedev.com/libuv-3/">【libuv高效编程】libuv学习超详细教程3——libuv事件循环</a></p></li><li><p><a href="https://jiedev.com/libuv-4/">【libuv高效编程】libuv学习超详细教程4——libuv idle 空闲句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-5/">【libuv高效编程】libuv学习超详细教程5——libuv prepare 准备句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-6/">【libuv高效编程】libuv学习超详细教程6——libuv check 检查句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-7/">【libuv高效编程】libuv学习超详细教程7——libuv thread 线程句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-8/">【libuv高效编程】libuv学习超详细教程8——libuv signal 信号句柄解读</a></p></li><li><p><a href="https://jiedev.com/libuv-9/">【libuv高效编程】libuv学习超详细教程9——libuv async异步句柄解读</a></p></li></ul><h1 id="libuv简介"><a href="#libuv简介" class="headerlink" title="libuv简介"></a>libuv简介</h1><p><a href="https://github.com/libuv/libuv" target="_blank" rel="noopener">libuv</a> 是一个高性能的，事件驱动的I/O，并且支持多平台的网络库，比如Node.js、Luvit、Julia、pyuv等大型的软件都有使用它进行开发，这足以看出它的性能优越性。</p><p>其实高性能的网络库在github有非常多，比如libevent、libev、libhv等库，libevent、libev、libuv都是c语言实现的异步事件库、libhv是国内开发者使用C++实现的异步事件库，但是我还是选择了libuv，因为它足够强大，并且支持多平台，编程还非常方便简洁。</p><p>也可以看看下图的简单对比，主要是对比github上的star与fork（当前时间是 2020-4-17 星期五）：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/libuv001.png" alt="libuv001"></p><h1 id="下载libuv"><a href="#下载libuv" class="headerlink" title="下载libuv"></a>下载libuv</h1><p>在linux系统下，可以通过git去拉取libuv的源码并且使用。</p><h2 id="安装必要的依赖"><a href="#安装必要的依赖" class="headerlink" title="安装必要的依赖"></a>安装必要的依赖</h2><blockquote><p>ps:如果你系统中有就不用去安装了。</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> <span class="token function">git</span> automake libtool<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="拉取libuv源码"><a href="#拉取libuv源码" class="headerlink" title="拉取libuv源码"></a>拉取libuv源码</h2><p>打开libuv的github仓库：<a href="https://github.com/libuv/libuv" target="_blank" rel="noopener">https://github.com/libuv/libuv</a> ，了解一下相关的说明信息，然后可以拉取下来：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/libuv002.png" alt="libuv002"></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/libuv/libuv.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果觉得太慢，可以从gitee下载：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> clone https://gitee.com/jiejieTop/libuv.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>切换到<code>v1.36.0</code>版本分支，目前这个版本的分支是最新的。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> checkout v1.36.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然你要是留意看的话，里面还有<strong>227</strong>个 <a href="https://github.com/libuv/libuv/releases" target="_blank" rel="noopener">release</a> 版本，你也可以通过wget或者浏览器去下载它们，它们的格式有zip、tar.gz等压缩格式，目前最新发布的release版本是<code>v1.36.0</code>。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/libuv003.png" alt="libuv003"></p><h1 id="编译使用"><a href="#编译使用" class="headerlink" title="编译使用"></a>编译使用</h1><p>其实如果单纯使用libuv的话，是非常简单的，直接在系统安装即可，但是我想编译一些其他的功能，比如libuv的一些说明文档、man手册等，那么就自己下载源码编译，首先进入libuv目录下，可以看到当前的分支是默认的分支——<code>v1.x</code>，这其实是开发版本，最近这两天都有开发的，反正我们用就对了：</p><pre class="line-numbers language-bash"><code class="language-bash">➜  libuv git:<span class="token punctuation">(</span>v1.x<span class="token punctuation">)</span> <span class="token function">ls</span>                                   AUTHORS         configure.ac     include       m4              srcautogen.sh      CONTRIBUTING.md  libuv.pc.in   MAINTAINERS.md  SUPPORTED_PLATFORMS.mdChangeLog       docs             LICENSE       Makefile.am     <span class="token function">test</span>CMakeLists.txt  img              LICENSE-docs  README.md       tools<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用autotools工具自动配置：</p><pre class="line-numbers language-bash"><code class="language-bash">./autogen.sh ./configure<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后编译并安装：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">make</span><span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>ps:还有个检查的命令：make check，不过我在运行的过程中报错了，测试不通过，暂时别管他吧。。。</p></blockquote><h1 id="验证编译安装是否完成"><a href="#验证编译安装是否完成" class="headerlink" title="验证编译安装是否完成"></a>验证编译安装是否完成</h1><p>在安装完成后，你可以看到在<code>/usr/local/lib/</code>目录下有libuv的静态库、动态库等内容：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">ls</span> /usr/local/lib/libuv.a  libuv.la  libuv.so  libuv.so.1  libuv.so.1.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在<code>/usr/local/include/</code>目录下也有一个uv文件夹、还有一个uv.h头文件。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">ls</span> /usr/local/include/          uv  uv.h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="简单实用"><a href="#简单实用" class="headerlink" title="简单实用"></a>简单实用</h1><p>随便写个代码，打印一下安装的libuv库的版本：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;uv.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>version<span class="token punctuation">;</span>    version <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">uv_version_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"libuv version is %s\n"</span><span class="token punctuation">,</span> version<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写Makefile，指定编译的规则并且编译它，需要注意的是需要指定链接libuv库<code>-luv</code>，这是动态链接的方式：</p><pre class="line-numbers language-Makefile"><code class="language-Makefile">CC=gccSRC = $(wildcard *.c */*.c)OBJS = $(patsubst %.c, %.o, $(SRC))DEP_FILES := $(patsubst %, .%.d,$(OBJS))DEP_FILES := $(wildcard $(DEP_FILES))FLAG = -g -Werror -I. -Iinclude -lpthread -luvTARGET = targets$(TARGET):$(OBJS)    $(CC) -o $@ $^ $(FLAG)ifneq ($(DEP_FILES),)include $(DEP_FILES)endif%.o:%.c    $(CC) -o $@ -c $(FLAG) $< -g -MD -MF .$@.dclean:    rm -rf $(TARGET) $(OBJS)distclean:    rm -rf $(DEP_FILES).PHONY:clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当编译完成后，可以看到产生的可执行文件，可以使用ldd命令去查看它的依赖，可以看到它依赖系统的<code>/usr/local/lib/libuv.so.1</code>：</p><pre class="line-numbers language-bash"><code class="language-bash">➜  001 <span class="token function">make</span>gcc -o demo.o -c -g -Werror -I. -Iinclude -lpthread -luv demo.c -g -MD -MF .demo.o.dgcc -o targets demo.o -g -Werror -I. -Iinclude -lpthread -luv➜  001 <span class="token function">ls</span>demo.c  demo.o  Makefile  targets➜  001 ldd targets         linux-vdso.so.1 <span class="token punctuation">(</span>0x00007fffa5bc6000<span class="token punctuation">)</span>        libuv.so.1 <span class="token operator">=</span><span class="token operator">></span> /usr/local/lib/libuv.so.1 <span class="token punctuation">(</span>0x00007f8346e7b000<span class="token punctuation">)</span>        libc.so.6 <span class="token operator">=</span><span class="token operator">></span> /lib/x86_64-linux-gnu/libc.so.6 <span class="token punctuation">(</span>0x00007f8346a8a000<span class="token punctuation">)</span>        librt.so.1 <span class="token operator">=</span><span class="token operator">></span> /lib/x86_64-linux-gnu/librt.so.1 <span class="token punctuation">(</span>0x00007f8346882000<span class="token punctuation">)</span>        libpthread.so.0 <span class="token operator">=</span><span class="token operator">></span> /lib/x86_64-linux-gnu/libpthread.so.0 <span class="token punctuation">(</span>0x00007f8346663000<span class="token punctuation">)</span>        libdl.so.2 <span class="token operator">=</span><span class="token operator">></span> /lib/x86_64-linux-gnu/libdl.so.2 <span class="token punctuation">(</span>0x00007f834645f000<span class="token punctuation">)</span>        /lib64/ld-linux-x86-64.so.2 <span class="token punctuation">(</span>0x00007f83472ac000<span class="token punctuation">)</span>➜  001 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行：</p><pre class="line-numbers language-bash"><code class="language-bash">./targets libuv version is 1.36.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> libuv </tag>
            
            <tag> 网络 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS入门-7】ROS自定义消息</title>
      <link href="/ros-7/"/>
      <url>/ros-7/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>这篇文章讲解我们自己按需定义消息。</p><h1 id="ROS系列文章"><a href="#ROS系列文章" class="headerlink" title="ROS系列文章"></a>ROS系列文章</h1><ul><li><p><a href="https://jiedev.com/ros-1/">【ROS入门-1】手把手教你在Ubuntu18.04安装ROS Melodic</a></p></li><li><p><a href="https://jiedev.com/ros-2/">【ROS入门-2】带你看ROS文件系统及其工具</a></p></li><li><p><a href="https://jiedev.com/ros-3/">【ROS入门-3】嘴对嘴讲解ROS的核心概念——节点与节点管理器</a></p></li><li><p><a href="https://jiedev.com/ros-4/">【ROS入门-4】嘴对嘴讲解ROS的核心概念——ROS话题通信机制</a></p></li><li><p><a href="https://jiedev.com/ros-5/">【ROS入门-5】深入了解ROS话题通信机制的过程</a></p></li><li><p><a href="https://jiedev.com/ros-6/">【ROS入门-6】ROS工作空间、package 及 catkin 编译系统</a></p></li></ul><h1 id="ROS-消息文件"><a href="#ROS-消息文件" class="headerlink" title="ROS 消息文件"></a>ROS 消息文件</h1><p>消息文件的扩展名是<code>.msg</code>，我们可以在这个消息文件中自定义需要的消息格式。</p><p>这其实是很好理解的，就绪C语言一样有各种结构体，各种类型的数据，消息也是一样的，ROS自带了一系列的消息, 如<code>std_msgs</code>（标准数据类型） 、 <code>geometry_msgs</code>（几何学数据类型） 、<code>sensor_msgs</code>（传感器数据类型） 等，这么多的数据类型可以满足绝大多数场景下的应用，不过ROS也可以用户自定义消息，消息的类型是与语言无关的，无论你是用<code>C++</code>也好还是<code>Python</code>也好，都一样可以使用消息文件。msg文件一般放置在功能包目录下的<code>msg文件夹</code>中。 在编译的时候ROS会根据编译规则生成不同的代码文件，当然，这会依赖于其他功能包，比如<code>message_generation</code>、<code>message_runtime</code>。</p><ul><li><p><code>message_generation</code>功能包是用于生成C++或Python能使用的代码。</p></li><li><p><code>message_runtime</code>则是提供运行时的支持。</p></li></ul><p>消息类型与<code>C++</code>或者<code>Python</code>的数据类型对应关系如下表：</p><table><thead><tr><th>消息类型</th><th>C++数据类型</th><th>Python数据类型</th></tr></thead><tbody><tr><td>bool</td><td>uint8_t</td><td>bool</td></tr><tr><td>int8</td><td>int8_t</td><td>int</td></tr><tr><td>uint8</td><td>uint8_t</td><td>int</td></tr><tr><td>int16</td><td>int16_t</td><td>int</td></tr><tr><td>uint16</td><td>uint16_t</td><td>int</td></tr><tr><td>int32</td><td>int32_t</td><td>int</td></tr><tr><td>uint32</td><td>uint32_t</td><td>int</td></tr><tr><td>int64</td><td>int64_t</td><td>long</td></tr><tr><td>uint64</td><td>uint64_t</td><td>long</td></tr><tr><td>float32</td><td>float</td><td>float</td></tr><tr><td>float64</td><td>double</td><td>double</td></tr><tr><td>string</td><td>std::string</td><td>string</td></tr><tr><td>time</td><td>ros::Time</td><td>rospy.Time</td></tr><tr><td>duration</td><td>ros::Duration</td><td>rospy.Duration</td></tr></tbody></table><h1 id="自定义消息"><a href="#自定义消息" class="headerlink" title="自定义消息"></a>自定义消息</h1><ol><li><p>在功能包中新建一个文件夹，<strong>名字为msg</strong>，这很重要，若非特别想要，尽量不要修改这个文件夹的名字。</p></li><li><p>在msg文件夹其中新建一个名为<code>topic_msg.msg</code>消息类型文件。</p></li><li><p>然后在这个消息文件写入以下测试内容:</p></li></ol><pre class="line-numbers language-js"><code class="language-js">bool bool_msgint8 int8_msguint8 uint8_msgint16 int16_msguint16 uint16_msgint32 int32_msguint32 uint32_msgint64 int64_msguint64 uint64_msgfloat32 float32_msgfloat64 float64_msgstring string_msgtime time_msgduration duration_msg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>ps：消息是可以嵌套的，比如你可以使用ROS中的消息类型，具体的可以参考官方wiki。</p></blockquote><ul><li><p><a href="http://wiki.ros.org/std_msgs" target="_blank" rel="noopener">http://wiki.ros.org/std_msgs</a></p></li><li><p><a href="http://wiki.ros.org/common_msgs" target="_blank" rel="noopener">http://wiki.ros.org/common_msgs</a></p></li></ul><h1 id="添加源码文件"><a href="#添加源码文件" class="headerlink" title="添加源码文件"></a>添加源码文件</h1><p>在功能包的src文件夹下随便建立两个文件，主要是为了能编译通过，名字分别为<code>publisher_topic002.cpp</code>、<code>subscriber_topic002.cpp</code>，先在里面随便写个main函数就行了。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"ros/ros.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h1><blockquote><p>关于创建功能包与工作空间这些，就看我上一篇文章即可。</p></blockquote><p>如果你是新建的功能包，最好通过<code>catkin_create_pkg</code>命令依赖<code>message_generation</code>、<code>message_runtime</code>这两个功能包，具体命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash">catkin_create_pkg my_topic002 roscpp rospy std_msgs message_generation message_runtime<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你是在已有的功能包中想要自定义消息，则在<code>package.xml</code>文件中添加功能包依赖：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token operator">&lt;</span>build_depend<span class="token operator">></span>message_generation<span class="token operator">&lt;</span>/build_depend<span class="token operator">></span><span class="token operator">&lt;</span>run_depend<span class="token operator">></span>message_runtime<span class="token operator">&lt;</span>/run_depend<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="修改编译规则"><a href="#修改编译规则" class="headerlink" title="修改编译规则"></a>修改编译规则</h1><p>CMakeLists.txt是配置编译规则的文件，具体的CMake语法参考我以前的博客文章。</p><p><code>CMakeLists.txt</code>要修改4-5个地方，根据实际场景修改即可：</p><ol><li>首先调用<code>find_package</code>查找依赖的功能包，必须要有的是roscpp、rospy、message_generation、message_runtime，而在消息文件中嵌套了其他的消息，则需要依赖其他的功能包。</li></ol><pre class="line-numbers language-js"><code class="language-js"><span class="token function">find_package</span><span class="token punctuation">(</span>catkin REQUIRED COMPONENTS  message_generation  message_runtime  roscpp  rospy  std_msgs<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>添加消息文件，指定.msg文件。</li></ol><pre class="line-numbers language-js"><code class="language-js"><span class="token function">add_message_files</span><span class="token punctuation">(</span>  FILES  topic_msg<span class="token punctuation">.</span>msg<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>指定生成消息文件时的依赖项，其实如果消息文件中有依赖的话，就需要在这里设置，此处假设我依赖了std_msgs（当然我是没有依赖的），就要配置如下：</li></ol><pre class="line-numbers language-js"><code class="language-js"><span class="token function">generate_messages</span><span class="token punctuation">(</span>  DEPENDENCIES  std_msgs<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li><code>catkin_package</code>声明相关的依赖，一般来通过<code>catkin_create_pkg</code>命令选择了依赖的话，这里是不需要设置的，不过我也给出来我的配置：</li></ol><pre class="line-numbers language-js"><code class="language-js"><span class="token function">catkin_package</span><span class="token punctuation">(</span>#  INCLUDE_DIRS include#  LIBRARIES my_topic002#  CATKIN_DEPENDS message_generation message_runtime roscpp rospy std_msgs#  DEPENDS system_lib<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>编写编译规则，生成的可执行文件名字、源码、链接库、依赖等内容。</li></ol><pre class="line-numbers language-bash"><code class="language-bash">add_executable<span class="token punctuation">(</span>publisher_topic002 src/publisher_topic002.cpp<span class="token punctuation">)</span>target_link_libraries<span class="token punctuation">(</span>publisher_topic002 <span class="token variable">${catkin_LIBRARIES}</span><span class="token punctuation">)</span>add_dependencies<span class="token punctuation">(</span>publisher_topic002 <span class="token variable">${PROJECT_NAME}</span>_generate_messages_cpp<span class="token punctuation">)</span> add_executable<span class="token punctuation">(</span>subscriber_topic002 src/subscriber_topic002.cpp<span class="token punctuation">)</span>target_link_libraries<span class="token punctuation">(</span>subscriber_topic002 <span class="token variable">${catkin_LIBRARIES}</span><span class="token punctuation">)</span>add_dependencies<span class="token punctuation">(</span>subscriber_topic002 <span class="token variable">${PROJECT_NAME}</span>_generate_messages_cpp<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="尝试编译"><a href="#尝试编译" class="headerlink" title="尝试编译"></a>尝试编译</h1><p>回到工作空间的根目录下，运行<code>catkin_make</code>命令就可以编译了，此时如果不出意外就会出现类似以下的信息表上编译成功：</p><pre class="line-numbers language-bash"><code class="language-bash">···<span class="token punctuation">[</span> 69%<span class="token punctuation">]</span> Built target my_topic002_generate_messages_py<span class="token punctuation">[</span> 76%<span class="token punctuation">]</span> Built target my_topic002_generate_messages_eus<span class="token punctuation">[</span> 80%<span class="token punctuation">]</span> Built target my_topic002_generate_messages_nodejs<span class="token punctuation">[</span> 84%<span class="token punctuation">]</span> Built target my_topic002_generate_messages_lisp<span class="token punctuation">[</span> 92%<span class="token punctuation">]</span> Built target my_topic002_generate_messages<span class="token punctuation">[</span> 92%<span class="token punctuation">]</span> Built target subscriber_topic002<span class="token punctuation">[</span>100%<span class="token punctuation">]</span> Built target publisher_topic002<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="查看生成的消息源码文件"><a href="#查看生成的消息源码文件" class="headerlink" title="查看生成的消息源码文件"></a>查看生成的消息源码文件</h1><p>在devel的include文件夹中生成一个my_topic002文件夹（具体是叫啥子得根据你自定义的功能包名字生产），里面有topic_msg.h文件（具体是啥名字也是你自定义的消息文件名）。</p><p>它里面有一大串消息的类型，都是我们自定义的，我随意列举一下：</p><pre class="line-numbers language-c"><code class="language-c">namespace my_topic002<span class="token punctuation">{</span>template <span class="token operator">&lt;</span>class ContainerAllocator<span class="token operator">></span><span class="token keyword">struct</span> topic_msg_<span class="token punctuation">{</span>  <span class="token keyword">typedef</span> topic_msg_<span class="token operator">&lt;</span>ContainerAllocator<span class="token operator">></span> Type<span class="token punctuation">;</span>  <span class="token function">topic_msg_</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">:</span> <span class="token function">bool_msg</span><span class="token punctuation">(</span>false<span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">int8_msg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">uint8_msg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">int16_msg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">uint16_msg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">int32_msg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">uint32_msg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">int64_msg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">uint64_msg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">float32_msg</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">float64_msg</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">string_msg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">time_msg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">duration_msg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token punctuation">}</span>  <span class="token function">topic_msg_</span><span class="token punctuation">(</span><span class="token keyword">const</span> ContainerAllocator<span class="token operator">&amp;</span> _alloc<span class="token punctuation">)</span>    <span class="token punctuation">:</span> <span class="token function">bool_msg</span><span class="token punctuation">(</span>false<span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">int8_msg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">uint8_msg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">int16_msg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">uint16_msg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">int32_msg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">uint32_msg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">int64_msg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">uint64_msg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">float32_msg</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">float64_msg</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">string_msg</span><span class="token punctuation">(</span>_alloc<span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">time_msg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">duration_msg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    ···<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="使用自定义的消息"><a href="#使用自定义的消息" class="headerlink" title="使用自定义的消息"></a>使用自定义的消息</h1><p>那么使用消息也是非常简单的，我们可以像使用ROS标准消息一样，包含头文件，然后使用即可，比如：</p><ul><li>包含头文件</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"my_topic002/topic_msg.h"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>创建一个Publisher，发布名为my_topic_msg，消息类型为my_topic002::topic_msg，队列长度100：</li></ul><pre class="line-numbers language-c"><code class="language-c">ros<span class="token punctuation">:</span><span class="token punctuation">:</span>Publisher pub_topic <span class="token operator">=</span> n<span class="token punctuation">.</span>advertise<span class="token operator">&lt;</span>my_topic002<span class="token punctuation">:</span><span class="token punctuation">:</span>topic_msg<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"my_topic_msg"</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>初始化std_msgs::String类型的消息</li></ul><pre class="line-numbers language-c"><code class="language-c">    my_topic002<span class="token punctuation">:</span><span class="token punctuation">:</span>topic_msg msg<span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>bool_msg <span class="token operator">=</span> true<span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>string_msg <span class="token operator">=</span> <span class="token string">"hello world!"</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>float32_msg <span class="token operator">=</span> <span class="token number">6.66</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>float64_msg <span class="token operator">=</span> <span class="token number">666.666</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>int8_msg <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">66</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>int16_msg <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">666</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>int32_msg <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">6666</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>int64_msg <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">66666</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>uint8_msg <span class="token operator">=</span> <span class="token number">66</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>uint16_msg <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>uint32_msg <span class="token operator">=</span> <span class="token number">6666</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>uint64_msg <span class="token operator">=</span> <span class="token number">66666</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>time_msg <span class="token operator">=</span> ros<span class="token punctuation">:</span><span class="token punctuation">:</span>Time<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="关于ros-Time"><a href="#关于ros-Time" class="headerlink" title="关于ros::Time"></a>关于ros::Time</h1><p>如果有人注意的话，自定义消息类型中有一个叫time和duration的类型消息，它使用到的是ros本身的一些数据类型，就是时间，关于这个类型的描述可以参考官网wiki：<a href="http://wiki.ros.org/roscpp/Overview/Time" target="_blank" rel="noopener">http://wiki.ros.org/roscpp/Overview/Time</a>，它的内部其实是两个变量，与我们linux下的时间是很像的，一个表示秒，一个表示纳秒：</p><pre class="line-numbers language-c"><code class="language-c">int32 secint32 nsec<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同时<code>ros::Time</code>中也包含了很多方法，也重载了很多运算符，大家有兴趣可以自行去研究研究。</p><h1 id="例程源码"><a href="#例程源码" class="headerlink" title="例程源码"></a>例程源码</h1><p>直接将以下源码放到一开始随意添加的两个源码文件<code>publisher_topic002.cpp</code>、<code>subscriber_topic002.cpp</code>中</p><ul><li>publisher_topic002.cpp：</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* * @Author: jiejie * @Github: https://github.com/jiejieTop * @Date: 2020-04-11 23:16:46 * @LastEditTime: 2020-04-12 12:17:00 * @Description: the code belongs to jiejie, please keep the author information and source code according to the license. */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;ros/ros.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"my_topic002/topic_msg.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"std_msgs/String.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ROS节点初始化</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">init</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"publisher_topic002"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建节点句柄</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span>NodeHandle n<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建一个Publisher，发布名为my_topic_msg，消息类型为my_topic002::topic_msg，队列长度100</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span>Publisher pub_topic <span class="token operator">=</span> n<span class="token punctuation">.</span>advertise<span class="token operator">&lt;</span>my_topic002<span class="token punctuation">:</span><span class="token punctuation">:</span>topic_msg<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"my_topic_msg"</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置循环的频率</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span>Rate <span class="token function">loop_rate</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>ros<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 初始化std_msgs::String类型的消息</span>        my_topic002<span class="token punctuation">:</span><span class="token punctuation">:</span>topic_msg msg<span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>bool_msg <span class="token operator">=</span> true<span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>string_msg <span class="token operator">=</span> <span class="token string">"hello world!"</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>float32_msg <span class="token operator">=</span> <span class="token number">6.66</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>float64_msg <span class="token operator">=</span> <span class="token number">666.666</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>int8_msg <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">66</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>int16_msg <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">666</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>int32_msg <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">6666</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>int64_msg <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">66666</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>uint8_msg <span class="token operator">=</span> <span class="token number">66</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>uint16_msg <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>uint32_msg <span class="token operator">=</span> <span class="token number">6666</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>uint64_msg <span class="token operator">=</span> <span class="token number">66666</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>time_msg <span class="token operator">=</span> ros<span class="token punctuation">:</span><span class="token punctuation">:</span>Time<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 发布消息</span>        pub_topic<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 按照循环频率延时</span>        loop_rate<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>subscriber_topic002.cpp：</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;ros/ros.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"my_topic002/topic_msg.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;std_msgs/String.h></span></span><span class="token comment" spellcheck="true">// 接收到订阅的消息后，会进入消息回调函数</span><span class="token keyword">void</span> <span class="token function">test_topic_cb</span><span class="token punctuation">(</span><span class="token keyword">const</span> my_topic002<span class="token punctuation">:</span><span class="token punctuation">:</span>topic_msg<span class="token punctuation">:</span><span class="token punctuation">:</span>ConstPtr <span class="token operator">&amp;</span> msg<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 将接收到的消息打印出来</span>    <span class="token function">ROS_INFO</span><span class="token punctuation">(</span><span class="token string">"------------------ msg ---------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ROS_INFO</span><span class="token punctuation">(</span><span class="token string">"bool_msg:    [%d]"</span><span class="token punctuation">,</span> msg<span class="token operator">-></span>bool_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ROS_INFO</span><span class="token punctuation">(</span><span class="token string">"string_msg:  [%s]"</span><span class="token punctuation">,</span> msg<span class="token operator">-></span>string_msg<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ROS_INFO</span><span class="token punctuation">(</span><span class="token string">"float32_msg: [%f]"</span><span class="token punctuation">,</span> msg<span class="token operator">-></span>float32_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ROS_INFO</span><span class="token punctuation">(</span><span class="token string">"float64_msg: [%f]"</span><span class="token punctuation">,</span> msg<span class="token operator">-></span>float64_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ROS_INFO</span><span class="token punctuation">(</span><span class="token string">"int8_msg:    [%d]"</span><span class="token punctuation">,</span> msg<span class="token operator">-></span>int8_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ROS_INFO</span><span class="token punctuation">(</span><span class="token string">"int16_msg:   [%d]"</span><span class="token punctuation">,</span> msg<span class="token operator">-></span>int16_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ROS_INFO</span><span class="token punctuation">(</span><span class="token string">"int32_msg:   [%d]"</span><span class="token punctuation">,</span> msg<span class="token operator">-></span>int32_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ROS_INFO</span><span class="token punctuation">(</span><span class="token string">"int64_msg:   [%ld]"</span><span class="token punctuation">,</span> msg<span class="token operator">-></span>int64_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ROS_INFO</span><span class="token punctuation">(</span><span class="token string">"uint8_msg:   [%d]"</span><span class="token punctuation">,</span> msg<span class="token operator">-></span>uint8_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ROS_INFO</span><span class="token punctuation">(</span><span class="token string">"uint16_msg:  [%d]"</span><span class="token punctuation">,</span> msg<span class="token operator">-></span>uint16_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ROS_INFO</span><span class="token punctuation">(</span><span class="token string">"uint32_msg:  [%d]"</span><span class="token punctuation">,</span> msg<span class="token operator">-></span>uint32_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ROS_INFO</span><span class="token punctuation">(</span><span class="token string">"uint64_msg:  [%ld]"</span><span class="token punctuation">,</span> msg<span class="token operator">-></span>uint64_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ROS_INFO</span><span class="token punctuation">(</span><span class="token string">"time_msg:    [%d.%d]"</span><span class="token punctuation">,</span> msg<span class="token operator">-></span>time_msg<span class="token punctuation">.</span>sec<span class="token punctuation">,</span> msg<span class="token operator">-></span>time_msg<span class="token punctuation">.</span>nsec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化ROS节点</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">init</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"subscriber_topic002"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建节点句柄</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span>NodeHandle n<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建一个Subscriber，订阅名为my_topic_msg的消息，注册回调函数test_topic_cb</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span>Subscriber sub_topic <span class="token operator">=</span> n<span class="token punctuation">.</span>subscribe<span class="token operator">&lt;</span>my_topic002<span class="token punctuation">:</span><span class="token punctuation">:</span>topic_msg<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"my_topic_msg"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> test_topic_cb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 循环等待回调函数</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">spin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h1><p>使用<code>catkin_make</code>重新编译后，运行，效果如下：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros023.png" alt="ros023"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://item.jd.com/12377412.html" target="_blank" rel="noopener">《ROS机器人开发实践》 胡春旭 著</a></p><p><a href="https://blog.csdn.net/MSNH2012/article/details/100732590" target="_blank" rel="noopener">vscode开发ROS(7)-自定义消息</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 机器人操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS入门-6】ROS工作空间、package 及 catkin 编译系统</title>
      <link href="/ros-6/"/>
      <url>/ros-6/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>其实从前几篇文章中我也有提及过<strong>ROS 工作空间</strong>，而且代码也是在工作空间中编译、运行的。</p><p>其实在 ROS 中，我们创建的软件代码，都会被组织成功能包的形式，所以在我们开始代码之前，第一步是创建一个容纳我们的工作空间。</p><p>因此本文将介绍<strong>ROS工作空间、package 及 catkin 编译系统</strong>。</p><h1 id="ROS系列文章"><a href="#ROS系列文章" class="headerlink" title="ROS系列文章"></a>ROS系列文章</h1><ul><li><p><a href="https://jiedev.com/ros-1/">【ROS入门-1】手把手教你在Ubuntu18.04安装ROS Melodic</a></p></li><li><p><a href="https://jiedev.com/ros-2/">【ROS入门-2】带你看ROS文件系统及其工具</a></p></li><li><p><a href="https://jiedev.com/ros-3/">【ROS入门-3】嘴对嘴讲解ROS的核心概念——节点与节点管理器</a></p></li><li><p><a href="https://jiedev.com/ros-4/">【ROS入门-4】嘴对嘴讲解ROS的核心概念——ROS话题通信机制</a></p></li><li><p><a href="https://jiedev.com/ros-5/">【ROS入门-5】深入了解ROS话题通信机制的过程</a></p></li><li><p><a href="https://jiedev.com/ros-6/">【ROS入门-6】ROS工作空间、package 及 catkin 编译系统</a></p></li></ul><h1 id="ROS-工作空间"><a href="#ROS-工作空间" class="headerlink" title="ROS 工作空间"></a>ROS 工作空间</h1><p>简单地说，ROS 工作空间（ROS workspace）就是统一存放 ROS 文件的地方，这里的文件包括源码、功能包、编译产生的中间文件等，一个项目的所有 ROS 文件最好都放在一个 workspace 中，便于统一管理、编译和调用。</p><p>一般来说，对于初学者，ROS的工作空间不需要经常建立，因为很多代码只是demo，一般只建立一个就好了，但是如果你的工作涉及大量的功能包，或者涉及几个相互独立的的项目，还是建立多个工作空间比较好，这东西看情况使用就好了。</p><p>我们可以在任意位置创建工作目录，一般来说工作空间都有4个文件夹：</p><ul><li><p>src：代码空间，是用来放置我们的功能包的，包括功能包的代码、功能包的配置文件配置等，这个功能包可以是自己写的，也可以是别人的功能包，总之都放在这。</p></li><li><p>build：编译空间，里面会有编译时产生的一些中间的文件，这个文件夹大家基本上是不用去关心的。</p></li><li><p>devel：开发空间，里面会放置我们编译生成的一些可执行文件，还包括一些库、一些脚本等等都放在这里。</p></li><li><p>install： 安装空间，在编译成功后，可以使用<code>make install</code>命令将可执行文件安装到该空间中，这个文件夹并不一定需要，实际上很多工作空间都不需要这个文件夹。</p></li></ul><h1 id="创建工作空间"><a href="#创建工作空间" class="headerlink" title="创建工作空间"></a>创建工作空间</h1><p>在任意目录下创建一个文件夹，名字你随意起，我就起ros_ws，然后在这个文件夹下创建src文件夹：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros017.png" alt="ros017"></p><p>然后在这个src文件夹下运行以下命令去初始化工作空间：</p><pre class="line-numbers language-bash"><code class="language-bash">catkin_init_workspace<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后你就会发现在src目录下生成了一个<code>CMakeLists.txt</code>文件，这其实是CMake的构建规则的文件，这个文件包含了一系列的编译指令，包括应该生成哪种可执行文件，需要哪些源文件，以及在哪里可以找到所需的头文件和链接库。当然，这个文件表明 catkin 在内部使用了 CMake。有兴趣的可以去看看我以前的博文，就是讲解CMake的。</p><h1 id="编译工作空间"><a href="#编译工作空间" class="headerlink" title="编译工作空间"></a>编译工作空间</h1><p>工作空间里面虽然没有任何代码，<strong>但是你依然可以去编译啊</strong>，只不过是一个空的工程，那在这里我们一样可以针对ROS的空的空间做编译，大家可以来熟悉一下这个编译的方式，我们要回到你的这个工作空间的根目录ros_ws，在这个目录下进行编译。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> <span class="token punctuation">..</span><span class="token comment" spellcheck="true"># 编译</span>catkin_make<span class="token comment" spellcheck="true"># 输出内容</span>······-- Using Python nosetests: /usr/bin/nosetests-2.7-- catkin 0.7.23-- BUILD_SHARED_LIBS is on-- BUILD_SHARED_LIBS is on-- Configuring <span class="token keyword">done</span>-- Generating <span class="token keyword">done</span>-- Build files have been written to: /home/jie/ros_ws/build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到有对应的内容输出了，就表示编译成功，然后你的ros_ws目录下回多了两个文件夹，分别为build、devel，这两个文件夹的作用就是前面讲解的了。</p><h1 id="导出环境变量"><a href="#导出环境变量" class="headerlink" title="导出环境变量"></a>导出环境变量</h1><p>devel目录就是我们的环境变量，假设我们当前的工作空间有代码，那么编译成功后会产生可执行文件，那么ROS如何去找到这个可执行文件呢，它不是全能的，需要我们去指定这个可执行文件在哪里，它才能找到，因此我们需要将编译产生的可执行文件、脚本等内容都要告诉系统，我称之为<strong>导出环境变量</strong>。</p><p>如果你查看一下在<code>devel</code>文件夹里面你可以看到几个setup.sh文件。source这些文件中的任何一个都可以将当前工作空间设置在ROS工作环境的最顶层。</p><p>如果你的终端是bash（Ubuntu默认终端），那么就运行：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">source</span> devel/setup.bash <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我个人用的终端是zsh，我是修改过了的，我运行以下命令：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">source</span> devel/setup.zsh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后用<code>echo $ROS_PACKAGE_PATH</code>命令去检查环境变量是否导出，当输出包含了你工作空间的目录就表示环境变量已经导出成功了：</p><pre class="line-numbers language-bash"><code class="language-bash">➜  ros_ws <span class="token keyword">echo</span> <span class="token variable">$ROS_PACKAGE_PATH</span> /home/jie/ros_ws/src:/opt/ros/melodic/share<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="创建功能包"><a href="#创建功能包" class="headerlink" title="创建功能包"></a>创建功能包</h1><p>写代码就要创建一个功能包，放着源码文件，在工作空间的src目录下可以直接运行<code>catkin_create_pkg</code>命令去创建功能包，这个命令有非常多的功能，你可以通过<code>catkin_create_pkg -h</code>去细看它的功能，而我就简单讲解一下：</p><p>简单的命令用法：</p><pre class="line-numbers language-bash"><code class="language-bash">catkin_create_pkg <span class="token punctuation">[</span>功能包名称<span class="token punctuation">]</span> <span class="token punctuation">[</span>依赖功能包1<span class="token punctuation">]</span> <span class="token punctuation">[</span>依赖功能包2<span class="token punctuation">]</span> <span class="token punctuation">[</span>依赖功能包n<span class="token punctuation">]</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建mytopic001功能包，依赖roscpp、rospy、std_msgs这几个功能包，其实rospy不是必须的，我们目前写的是c++的代码，不过放进去都无所谓。</p><pre class="line-numbers language-bash"><code class="language-bash">catkin_create_pkg mytopic001 roscpp rospy std_msgs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>catkin_create_pkg</code>命令在创建用户功能包时会生成catkin构建系统所需的CMakeLists.txt和package.xml文件，还有存放代码的src文件夹，和include文件夹，注意这里的src并不是工作目录下的src，而是功能包的src文件夹。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros018.png" alt="ros018"></p><p>你可以手动去修改功能包的依赖关系，比如编辑<code>package.xml</code>文件：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros019.png" alt="ros019"></p><h1 id="添加源代码"><a href="#添加源代码" class="headerlink" title="添加源代码"></a>添加源代码</h1><p>我们将上一篇文章<a href="https://jiedev.com/ros-4/">【ROS入门-4】嘴对嘴讲解ROS的核心概念——ROS话题通信机制</a>的源代码添加到这个工作空间中，存放的位置是：<code>ros_ws/src/mytopic001/src</code>，</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros020.png" alt="ros020"></p><h1 id="修改构建规则"><a href="#修改构建规则" class="headerlink" title="修改构建规则"></a>修改构建规则</h1><p>修改<code>ros_ws/src/mytopic001</code>目录下的<code>CMakeLists.txt</code>文件就是修改对应的构建规则，可以在这个文件中设置可执行文件的创建规则、依赖关系、连接关系等等。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">add_executable</span><span class="token punctuation">(</span>publisher_topic src<span class="token operator">/</span>publisher_topic<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span><span class="token function">target_link_libraries</span><span class="token punctuation">(</span>publisher_topic $<span class="token punctuation">{</span>catkin_LIBRARIES<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">add_executable</span><span class="token punctuation">(</span>subscriber_topic src<span class="token operator">/</span>subscriber_topic<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span><span class="token function">target_link_libraries</span><span class="token punctuation">(</span>subscriber_topic $<span class="token punctuation">{</span>catkin_LIBRARIES<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros021.png" alt="ros021"></p><p>其实如果你会了CMake后，这东西是非常简单的。。。上面的操作起始就是编译两个可执行文件<code>publisher_topic</code>和<code>subscriber_topic</code>，分别执行发布与订阅的操作。</p><h1 id="编译功能包"><a href="#编译功能包" class="headerlink" title="编译功能包"></a>编译功能包</h1><p>回到工作空间的根目录下<code>ros_ws</code>，运行<code>catkin_make</code>命令编译，当输出以下内容时，表示编译成功：</p><pre class="line-numbers language-bash"><code class="language-bash">catkin_make<span class="token comment" spellcheck="true"># 输出内容</span>······Scanning dependencies of target subscriber_topicScanning dependencies of target publisher_topic<span class="token punctuation">[</span> 50%<span class="token punctuation">]</span> Building CXX object mytopic001/CMakeFiles/publisher_topic.dir/src/publisher_topic.cpp.o<span class="token punctuation">[</span> 50%<span class="token punctuation">]</span> Building CXX object mytopic001/CMakeFiles/subscriber_topic.dir/src/subscriber_topic.cpp.o<span class="token punctuation">[</span> 75%<span class="token punctuation">]</span> Linking CXX executable /home/jie/ros_ws/devel/lib/mytopic001/publisher_topic<span class="token punctuation">[</span>100%<span class="token punctuation">]</span> Linking CXX executable /home/jie/ros_ws/devel/lib/mytopic001/subscriber_topic<span class="token punctuation">[</span>100%<span class="token punctuation">]</span> Built target publisher_topic<span class="token punctuation">[</span>100%<span class="token punctuation">]</span> Built target subscriber_topic<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>步骤如下：</p><ol><li>首先导出环境变量（注意根据你的终端配置运行命令）</li></ol><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">source</span> devel/setup.zsh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>运行节点管理器</li></ol><pre class="line-numbers language-bash"><code class="language-bash">roscore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>在新终端运行发布者节点，也是需要导出环境变量的，不然ROS找不到你的可执行程序位置</li></ol><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">source</span> ros_ws/devel/setup.zshrosrun mytopic001 publisher_topic <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="4"><li>在新终端运行订阅者者节点</li></ol><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">source</span> ros_ws/devel/setup.zshrosrun mytopic001 subscriber_topic <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最终效果：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros022.png" alt="ros022"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/ZhangRelay/article/details/79302460" target="_blank" rel="noopener">张老师的书籍《ROS_Robot_Programming》</a></p><p><a href="https://blog.csdn.net/jiejiemcu/category_9558411.html" target="_blank" rel="noopener">CMake实战教程</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 机器人操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS入门-5】深入了解ROS话题通信机制的过程</title>
      <link href="/ros-5/"/>
      <url>/ros-5/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇文章中简单了解了ROS话题通信机制，但是它内部的通信过程，很多人都是不知道的，今天我看了 <a href="https://item.jd.com/12377412.html" target="_blank" rel="noopener"> 胡春旭的书籍——《ROS机器人开发实践》</a>，又加深了对ROS话题通信的理解，打算接着讲解一下其过程是怎么样的。</p><h1 id="ROS系列文章"><a href="#ROS系列文章" class="headerlink" title="ROS系列文章"></a>ROS系列文章</h1><ul><li><p><a href="https://jiedev.com/ros-1/">【ROS入门-1】手把手教你在Ubuntu18.04安装ROS Melodic</a></p></li><li><p><a href="https://jiedev.com/ros-2/">【ROS入门-2】带你看ROS文件系统及其工具</a></p></li><li><p><a href="https://jiedev.com/ros-3/">【ROS入门-3】嘴对嘴讲解ROS的核心概念——节点与节点管理器</a></p></li><li><p><a href="https://jiedev.com/ros-4/">【ROS入门-4】嘴对嘴讲解ROS的核心概念——ROS话题通信机制</a></p></li><li><p><a href="https://jiedev.com/ros-5/">【ROS入门-5】深入了解ROS话题通信机制的过程</a></p></li></ul><h1 id="节点的连接"><a href="#节点的连接" class="headerlink" title="节点的连接"></a>节点的连接</h1><p>一个节点需要与系统中其他节点进行通信才有意义，系统中任何单独的一个节点其实都是没有意义的。下图是一个话题通讯的过程示意图，一个节点通过节点管理器连接到另一个节点，最终请求话题数据流。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros016.png" alt="ros016"></p><blockquote><p>ps：在ROS中有两个节点：一个是发布者<code>Talker</code>，另一个是订阅者<code>Listener</code>，两个节点分别发布、订阅同一个话题<code>bar</code>。</p></blockquote><h1 id="①发布者Talker注册"><a href="#①发布者Talker注册" class="headerlink" title="①发布者Talker注册"></a>①发布者<code>Talker</code>注册</h1><p>在系统中，节点与节点是没有任何关系的，都靠节点管理器来处理相关的请求与服务，首先第一步，发布者<code>Talker</code>需要向节点管理器<code>ROS Master</code>注册相关信息，包括节点的信息、需要发布的话题名等，然后节点管理器<code>ROS Master</code>会记录下来<code>Talker</code>节点的信息。</p><h1 id="②订阅者Listener注册"><a href="#②订阅者Listener注册" class="headerlink" title="②订阅者Listener注册"></a>②订阅者<code>Listener</code>注册</h1><p>同理订阅者<code>Listener</code>也需要向节点管理器<code>ROS Master</code>注册相关信息，这其实是启动两个节点时候就已经做了的事情。</p><h1 id="③节点管理器ROS-Master进行话题匹配"><a href="#③节点管理器ROS-Master进行话题匹配" class="headerlink" title="③节点管理器ROS Master进行话题匹配"></a>③节点管理器<code>ROS Master</code>进行话题匹配</h1><p>因为发布者<code>Talker</code>与订阅者<code>Listener</code>节点都在节点管理器<code>ROS Master</code>注册了信息，那么节点管理器<code>ROS Master</code>就会发现有相同的话题信息，此时它就需要将订阅与发布话题的两个节点匹配在一起，会通过RPC向订阅者<code>Listener</code>发送<code>Talker</code>节点的RPC地址信息。</p><h1 id="④订阅者Listener向Talker发送连接请求"><a href="#④订阅者Listener向Talker发送连接请求" class="headerlink" title="④订阅者Listener向Talker发送连接请求"></a>④订阅者<code>Listener</code>向<code>Talker</code>发送连接请求</h1><p>订阅者<code>Listener</code>知道发布者<code>Talker</code>后，就会主动找到它，并且通过RPC向T<code>Talker</code><br>发送连接请求，传输订阅的话题名、消息类型以及通信协议。</p><h1 id="⑤发布者Talker确认连接请求"><a href="#⑤发布者Talker确认连接请求" class="headerlink" title="⑤发布者Talker确认连接请求"></a>⑤发布者<code>Talker</code>确认连接请求</h1><p><code>Talker</code>接收到<code>Listener</code>发送的连接请求后，继续通过RPC向<code>Listener</code>确认连接信息，同时发送自身相关的信息。</p><h1 id="⑥Listener尝试与Talker建立网络连接"><a href="#⑥Listener尝试与Talker建立网络连接" class="headerlink" title="⑥Listener尝试与Talker建立网络连接"></a>⑥<code>Listener</code>尝试与<code>Talker</code>建立网络连接</h1><p>Listener接收到确认信息后，使用TCP尝试与<code>Talker</code>建立网络连接。</p><h1 id="⑦Talker向Listener发布消息"><a href="#⑦Talker向Listener发布消息" class="headerlink" title="⑦Talker向Listener发布消息"></a>⑦<code>Talker</code>向<code>Listener</code>发布消息</h1><p>成功建立连接后，<code>Talker</code>开始向<code>Listener</code>发送话题消息数据。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在节点与节点建立连接前，他们的通信协议都是RPC，而这主要都是依赖于节点管理器的，在节点与节点建立连接后，就直接是使用TCP协议进行数据传输，而不需要依赖节点管理器，此时节点管理器允许被关闭，但在关闭后，其他节点就不能订阅、发布这个话题消息了。</p><p>总之节点管理器<code>ROS Master</code>在节点建立连接的过程中起到了重要作用，<strong>但是并不参与节点之间最终的数据传输。</strong></p><h1 id="引用说明"><a href="#引用说明" class="headerlink" title="引用说明"></a>引用说明</h1><p>本文的部分截图来自书籍<a href="https://item.jd.com/12377412.html" target="_blank" rel="noopener">《ROS机器人开发实践》 胡春旭 著</a>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingTopics" target="_blank" rel="noopener">ROS官方wiki</a></p><p><a href="https://joveh-h.blog.csdn.net/article/details/90551432" target="_blank" rel="noopener">ROS笔记（7） 话题通信</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 机器人操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS入门-4】嘴对嘴讲解ROS的核心概念——ROS话题通信机制</title>
      <link href="/ros-4/"/>
      <url>/ros-4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我要给大家来介绍一下ROS当中一些核心的概念，帮助大家去在后面的ROS学习当中更快地吸收这些概念，今天讲解的是ROS中的通信机制——话题通信。</p><h1 id="ROS系列文章"><a href="#ROS系列文章" class="headerlink" title="ROS系列文章"></a>ROS系列文章</h1><ul><li><p><a href="https://jiedev.com/ros-1/">【ROS入门-1】手把手教你在Ubuntu18.04安装ROS Melodic</a></p></li><li><p><a href="https://jiedev.com/ros-2/">【ROS入门-2】带你看ROS文件系统及其工具</a></p></li><li><p><a href="https://jiedev.com/ros-3/">【ROS入门-3】嘴对嘴讲解ROS的核心概念——节点与节点管理器</a></p></li><li><p><a href="https://jiedev.com/ros-4/">【ROS入门-4】嘴对嘴讲解ROS的核心概念——ROS话题通信机制</a></p></li><li><p><a href="https://jiedev.com/ros-5/">【ROS入门-5】深入了解ROS话题通信机制的过程</a></p></li></ul><h1 id="ROS的通信机制"><a href="#ROS的通信机制" class="headerlink" title="ROS的通信机制"></a>ROS的通信机制</h1><p>从前面的文章我们知道，ROS的通信机制是一个 <strong><code>松散耦合的分布式软件框架</code></strong> 设计而来的，而节点间的通讯就会必然是有几种通讯方式，那ROS主要给节点之间提供三种核心的通讯方式，一种叫做话题（topic），一种叫做服务（server），以及基于RPC的参数服务器。</p><p><strong>我们接下来讲解ROS的核心概念——ROS话题通信机制。</strong></p><h1 id="话题（topic）"><a href="#话题（topic）" class="headerlink" title="话题（topic）"></a>话题（topic）</h1><p><code>话题</code>就是ROS中一个数据传输的<strong>有名字的通道</strong>。当一个节点想要分享信息时，它就会发布(publish)消息到对应的一个或者多个话题；当一个节点想要接收信息时，它就会订阅(subscribe)它所需要的一个或者多个话题。 ROS节点管理器负责确保发布节点和订阅节点能找到对方；<strong>而且消息是直接地从发布节点传递到订阅节点，中间并不经过节点管理器转交。</strong></p><p>topic这个单词对我来说是非常熟悉的，因为我在物联网领域老是捣鼓网络协议栈，在MQTT协议里面经常看到topic，巧合的是ROS中的topic跟MQTT协议中的topic是非常像的，基本可以说是同样的模型，但MQTT协议里面需要服务器转发数据。</p><p>比如我们看下面这张图：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros012.png" alt="ros012"></p><p>话题通讯的模型比较简单，这张图的模型里面会分为<strong>发布者（publisher）</strong>和<strong>订阅者（subscriber）</strong>，话题的这种通讯的方式是单向数据传输。比如说有一个节点它要发布一个数据，这个摄像头驱动节点它来驱动摄像头，并且获取摄像头的数据，然后传出来给处理数据的节点去处理，所以它会不断的往外发送一些图像数据，那它发到哪里呢？这个节点作为发布者，需要向某个<code>话题（topic，也可以称为主题）</code>发布这些数据，那么当系统中可能有多个节点要去处理图像，比如有一个节点是需要显示图像数据的，有一个节点是做图像处理的，它们实现要获取到这些数据后，才能处理对吧，而这些节点就是订阅者，它们从<code>话题（topic）</code>中接收这些数据，然后去处理它。</p><h1 id="发布者"><a href="#发布者" class="headerlink" title="发布者"></a>发布者</h1><p>发布者：发布（publish）是指以将数据发布到某个话题中，为了可以正常执行发布操作。发布者（publisher）必须在节点管理器上注册自己的话题等多种信息。</p><p><strong>发布者</strong>的工作过程如下：</p><ol><li><p>向节点管理器注册节点。</p></li><li><p>告诉管理器要向哪个话题发布数据。</p></li><li><p>节点运行时采集数据，然后发布到这个话题。</p></li></ol><h1 id="订阅者"><a href="#订阅者" class="headerlink" title="订阅者"></a>订阅者</h1><p>订阅是指订阅者节点想要接收来自某个话题的数据。为了可以正常执行订阅的操作，订阅者节点必须在节点管理器上注册自己想要订阅的话题等多种信息，并从节点管理器接收来自发布者的数据信息，同一个话题可以有多个发布者也可以有多个订阅者，但一般情况下发布者只有一个，而订阅者是一个或者多个。</p><p><strong>订阅者</strong>的工作过程如下：</p><ol><li><p>向节点管理器注册节点。</p></li><li><p>订阅话题，告诉管理器要接收哪个话题的数据。</p></li><li><p>节点运行时就接收数据，然后去处理数据（一般来说会注册回调函数，当有数据的时候就在回调函数中处理）。</p></li></ol><p>总的来说，话题就像是一个数据传输的管道。打个比方，你可以在运输牛奶的管道接到牛奶，在运输煤气的管道上接收到煤气，在水管上接到水。。。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros013.png" alt="ros013"></p><p>就拿上面的图来说，<code>Camera Node</code>节点是发布者，它负责采集图像数据并且发布；<code>Image Processing Node</code>节点是订阅者，在接收到图像数据后要去处理数据，<code>Image Display Node</code>节点也是订阅者，在接收到图像数据后要去显示图像的数据。</p><p>话题通讯它是一种<strong>异步通讯</strong>，因为我们没有办法知道发布者跟订阅者之间单向传输的这个时效性啊，我可能发不出去之后，订阅者可能等很长时间啊或者阻塞才会接收，到那很多情况下，我们更希望我的数据发出去之后，对方能给我一个。</p><h1 id="消息（Message）"><a href="#消息（Message）" class="headerlink" title="消息（Message）"></a>消息（Message）</h1><p>大家有没有考虑过，话题之间的数据叫什么呢？没错，就是叫<strong>消息</strong>。</p><p>节点之间通过消息（message）来发送和接收数据。消息是用来描述我们传输话题数据的，消息可以是各种类型的数据，比如整形、浮点型、字符等不定程度的数据，我们还可以在消息中使用一些数据结构来描述这些消息。</p><h1 id="用C-来写话题通信的代码"><a href="#用C-来写话题通信的代码" class="headerlink" title="用C++来写话题通信的代码"></a>用C++来写话题通信的代码</h1><p>因为本系列文章还没介绍到工作空间，那么就先简单看看怎么去写代码吧：</p><ul><li>头文件</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;ros/ros.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;geometry_msgs/Twist.h></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="发布者-1"><a href="#发布者-1" class="headerlink" title="发布者"></a>发布者</h2><ul><li>创建节点句柄，并且告诉节点管理器准备向<code>test_topic</code>话题发布消息。</li></ul><pre class="line-numbers language-c"><code class="language-c">    <span class="token comment" spellcheck="true">// ROS节点初始化</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">init</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"publisher_topic"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建节点句柄</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span>NodeHandle n<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建一个Publisher，发布名为test_topic，消息类型为gstd_msgs::String，队列长度100</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span>Publisher pub_topic <span class="token operator">=</span> n<span class="token punctuation">.</span>advertise<span class="token operator">&lt;</span>std_msgs<span class="token punctuation">:</span><span class="token punctuation">:</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"test_topic"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>填充消息的内容并且向话题发布消息：</li></ul><pre class="line-numbers language-c"><code class="language-c">    <span class="token comment" spellcheck="true">// 初始化std_msgs::String类型的消息</span>    std_msgs<span class="token punctuation">:</span><span class="token punctuation">:</span>String str_msg<span class="token punctuation">;</span>    str_msg<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token string">"this is a test_topic message!"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 发布消息</span>    pub_topic<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span>str_msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="订阅者-1"><a href="#订阅者-1" class="headerlink" title="订阅者"></a>订阅者</h2><ul><li>创建节点句柄，并且告诉节点管理器订阅一个话题<code>test_topic</code></li></ul><pre class="line-numbers language-c"><code class="language-c">    <span class="token comment" spellcheck="true">// 接收到订阅的消息后，会进入消息回调函数</span>    <span class="token keyword">void</span> <span class="token function">test_topic_cb</span><span class="token punctuation">(</span><span class="token keyword">const</span> std_msgs<span class="token punctuation">:</span><span class="token punctuation">:</span>String<span class="token punctuation">:</span><span class="token punctuation">:</span>ConstPtr<span class="token operator">&amp;</span> msg<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将接收到的消息打印出来</span>        <span class="token function">ROS_INFO</span><span class="token punctuation">(</span><span class="token string">"I heard: [%s]"</span><span class="token punctuation">,</span> msg<span class="token operator">-></span>data<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 初始化ROS节点</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">init</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"subscriber_topic"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建节点句柄</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span>NodeHandle n<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建一个Subscriber，订阅名为test_topic的消息，注册回调函数test_topic_cb</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span>Subscriber sub_topic <span class="token operator">=</span> n<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"test_topic"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> test_topic_cb<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>循环等待来自话题<code>test_topic</code>的消息，当收到消息后会进入回调函数<code>test_topic_cb()</code>中处理：</li></ul><pre class="line-numbers language-c"><code class="language-c">    <span class="token comment" spellcheck="true">// 循环等待回调函数</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">spin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此处需要在工作空间进行实验，分别打开新的终端运行节点管理器、发布者节点、订阅者节点，实验效果如下：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros014.png" alt="ros014"></p><h1 id="使用rqt-graph"><a href="#使用rqt-graph" class="headerlink" title="使用rqt_graph"></a>使用rqt_graph</h1><p><code>publisher_topic</code>节点和<code>subscriber_topic</code>节点之间是通过一个<code>test_topic</code>话题来互相通信的，我们可以使用<code>rqt_graph</code>来显示当前运行的节点和话题。</p><p>rqt_graph是rqt程序包中的一部分，如果你没有安装，请通过以下命令来安装：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> ros-<span class="token operator">&lt;</span>distro<span class="token operator">></span>-rqt<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> ros-<span class="token operator">&lt;</span>distro<span class="token operator">></span>-rqt-common-plugins<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将 <code>&lt;distro&gt;</code>替换成你所安装的版本（比如 kinetic、melodic 等）。</p><p>在一个新终端中运行:</p><pre class="line-numbers language-bash"><code class="language-bash">rosrun rqt_graph rqt_graph<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你会看到以下界面：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros015.png" alt="ros015"></p><h1 id="源码附录"><a href="#源码附录" class="headerlink" title="源码附录"></a>源码附录</h1><ul><li>subscriber_topic.cpp:</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;ros/ros.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;std_msgs/String.h></span></span><span class="token comment" spellcheck="true">// 接收到订阅的消息后，会进入消息回调函数</span><span class="token keyword">void</span> <span class="token function">test_topic_cb</span><span class="token punctuation">(</span><span class="token keyword">const</span> std_msgs<span class="token punctuation">:</span><span class="token punctuation">:</span>String<span class="token punctuation">:</span><span class="token punctuation">:</span>ConstPtr<span class="token operator">&amp;</span> msg<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 将接收到的消息打印出来</span>    <span class="token function">ROS_INFO</span><span class="token punctuation">(</span><span class="token string">"I heard: [%s]"</span><span class="token punctuation">,</span> msg<span class="token operator">-></span>data<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化ROS节点</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">init</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"subscriber_topic"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建节点句柄</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span>NodeHandle n<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建一个Subscriber，订阅名为test_topic的消息，注册回调函数test_topic_cb</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span>Subscriber sub_topic <span class="token operator">=</span> n<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"test_topic"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> test_topic_cb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 循环等待回调函数</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">spin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>publisher_topic.cpp:</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;ros/ros.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"std_msgs/String.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ROS节点初始化</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">init</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"publisher_topic"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建节点句柄</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span>NodeHandle n<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建一个Publisher，发布名为test_topic，消息类型为gstd_msgs::String，队列长度100</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span>Publisher pub_topic <span class="token operator">=</span> n<span class="token punctuation">.</span>advertise<span class="token operator">&lt;</span>std_msgs<span class="token punctuation">:</span><span class="token punctuation">:</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"test_topic"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置循环的频率</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span>Rate <span class="token function">loop_rate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>ros<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 初始化std_msgs::String类型的消息</span>        std_msgs<span class="token punctuation">:</span><span class="token punctuation">:</span>String str_msg<span class="token punctuation">;</span>        str_msg<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token string">"this is a test_topic message!"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 发布消息</span>        pub_topic<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span>str_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 按照循环频率延时</span>        loop_rate<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当然你也可以用Python语言来实现话题通信，可以参考我后文中给出的链接~</p></blockquote><h1 id="引用说明"><a href="#引用说明" class="headerlink" title="引用说明"></a>引用说明</h1><p>本文的部分截图来自<a href="https://github.com/huchunxu/ros_21_tutorials" target="_blank" rel="noopener">《古月·ROS入门21讲》</a>的课件。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingTopics" target="_blank" rel="noopener">ROS官方wiki</a></p><p><a href="https://joveh-h.blog.csdn.net/article/details/90551432" target="_blank" rel="noopener">ROS笔记（7） 话题通信</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 机器人操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS入门-3】嘴对嘴讲解ROS的核心概念——节点与节点管理器</title>
      <link href="/ros-3/"/>
      <url>/ros-3/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我要给大家来介绍一下ROS当中一些核心的概念，帮助大家去在后面的ROS学习当中更快地吸收这些概念。</p><h1 id="ROS系列文章"><a href="#ROS系列文章" class="headerlink" title="ROS系列文章"></a>ROS系列文章</h1><ul><li><p><a href="https://jiedev.com/ros-1/">【ROS入门-1】手把手教你在Ubuntu18.04安装ROS Melodic</a></p></li><li><p><a href="https://jiedev.com/ros-2/">【ROS入门-2】带你看ROS文件系统及其工具</a></p></li><li><p><a href="https://jiedev.com/ros-3/">【ROS入门-3】嘴对嘴讲解ROS的核心概念——节点与节点管理器</a></p></li><li><p><a href="https://jiedev.com/ros-4/">【ROS入门-4】嘴对嘴讲解ROS的核心概念——ROS话题通信机制</a></p></li><li><p><a href="https://jiedev.com/ros-5/">【ROS入门-5】深入了解ROS话题通信机制的过程</a></p></li></ul><h1 id="ROS的通信机制"><a href="#ROS的通信机制" class="headerlink" title="ROS的通信机制"></a>ROS的通信机制</h1><p>ROS的通信机制是一个 <strong><code>松散耦合的分布式软件框架</code></strong> 设计而来的，比如下面这张图：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros009.png" alt="ros009"></p><p>在这个图当中看到这里面有很多Node（节点），每个节点是在整个机器人中完成一个具体功能的这样一个一个的进程，比如说一个Node是完成图像的识别，另一个Node就完成图像驱动，然后它们之间会有一系列的图像之间的一个数据的传输，所有节点之间它的位置也不是固定的，比如说我们这有两台电脑，一个A，一个B，一些节点运行在A当中，一些节点运行在B当中，它们可以通过一系列的这个数据的传输方式来完成通讯（后面会讲解这个通信方式）。</p><p>还有每个节点它的编程语言也不是也不是固定的，比如说这个Node是用Python开发，它有很好的便利性，另一个节点是用C++开发，它有很高的效率等等。我们可以分布式完成这件的开发，最终只要有统一的这个通讯的标准，就可以完成我们整个系统这样一个搭建了，那这里面就会有很多的节点，节点之间会有很多的通讯，很多的数据，然后它包括通讯的方式，包括所有节点的一个管理，会涉及到很多核心通信机制。</p><p><strong>我们接下来讲解ROS的核心概念——节点与节点管理器。</strong></p><h1 id="节点（Node）"><a href="#节点（Node）" class="headerlink" title="节点（Node）"></a>节点（Node）</h1><p>首先看一张图片，我们结合图片来讲解：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros010.png" alt="ros010"></p><p>首先最重要的概念就是节点啊，<strong>节点在ROS当中是一个最小处理器单元</strong>，它是一个执行单元。</p><p>比如说它要执行某个任务，它其实相当于我们系统里面的某一个具体的进程，无论是完成图像识别也好，完成摄像头的驱动也好，或者是完成你的思路算法的这个处理也好，它都是一个处理任务的进程。建议为一个目的创建一个节点，建议设计时注重可重用性，将每个程序细分化，但节点在整个系统中的名称必须是唯一的。</p><p>不同节点之间我们可以用不同的编程语言，比如说有的人善于做图像处理，他就可以用Python来做处理，有的人善于做驱动。他可能要用C++或C来完成这个设备的驱动，最终大家可以通过ROS框架完成很快这个功能的拼接，那这个ROS里面也是给我们提供了这样一系列的机制，很快速完成这样一个分布式的工作。</p><p>节点在整个系统当中的名称必须是唯一的啊，比如说你要干一个什么事儿，要做一个命名，而为了方便我们整个的管理，每一个节点的名字都必须是唯一的，否则会重名重名之后你的ROS就找不到具体是哪个节点了。</p><p><strong>总结一下节点的特性：</strong></p><ul><li><p>执行具体任务的进程、独立运行的可执行文件。</p></li><li><p>不同节点可使用不同的编程语言，可分布式运行在不同的主机。</p></li><li><p>节点在系统中的名称必须是唯一的。</p></li><li><p>所有节点之间的消息通信都必须使用节点管理器。</p></li></ul><p>可以使用<code>rosrun</code>命令运行一个包内的节点（不需要知道这个包的路径）。</p><pre class="line-numbers language-bash"><code class="language-bash">rosrun <span class="token punctuation">[</span>包名字<span class="token punctuation">]</span> <span class="token punctuation">[</span>节点名字<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="节点管理器（Master）"><a href="#节点管理器（Master）" class="headerlink" title="节点管理器（Master）"></a>节点管理器（Master）</h1><blockquote><p>在某些书籍资料中，节点管理器也被称作是主节点，都是一个意思的东西。</p></blockquote><p>节点管理器（Master）负责节点到节点的连接和消息通信，类似于服务器（Server）。<code>roscore</code>是它的运行命令，当运行节点管理器时，你可以注册每个节点的名字，并根据需要获取信息。没有节点管理器，就不能在节点之间建立访问和消息交流（如话题和服务），所以我们从上面的途中就看到一个很关键的成员——ROS Master。</p><p>系统中的每个节点都需要去找<code>Master</code>去注册，需要告诉<code>Master</code>，我要启动了，我要干个什么事，我要跟谁去发什么数据，这些的管理的这个注册信息都是由<code>Master</code>一手掌握的，简单来说就是<code>Master</code>里面会有一个小本本，它会把所有的节点的各种信息都记下来，然后帮助它们，比如让节点与节点之间去建立连接等。</p><p>就拿上面的图来说，<code>Image Processing Node</code>节点要去处理数据，<code>Camera Node</code>节点要去发布图像数据，<code>Image Display Node</code>节点要去显示图像的数据，那这里面两个节点之间就会发生一个图像的传输，那<code>Master</code>就是要帮助两者建立起来一个传输数据的渠道啊，不然两个毫无瓜葛的节点怎么知道彼此的存在呢。</p><p>在<code>Master</code>里面还有很重要的功能，就是它提供一个<strong>参数服务器</strong>的功能，这个东西很重要，上面会记录一些全局变量的变量名跟变量值，那这个变量名和变量值就可以由各个节点去访问、去设置或者去读写，然后节点之间就可以通过这些变量的设置来读取一些配置文件的信息，读取一些参数配置啊等等。</p><p><strong>总结一下节点管理器的特性：</strong></p><ul><li><p>为节点提供命名和注册服务。</p></li><li><p>跟踪和记录话题/服务通信，辅助节点相互查找、建立连接。</p></li><li><p>提供参数服务器，节点使用此服务器存储和检索运行时的参数。</p></li></ul><h1 id="简单运行"><a href="#简单运行" class="headerlink" title="简单运行"></a>简单运行</h1><p>大家可以去运行一下节点管理器与节点：</p><ul><li>运行节点管理器：</li></ul><pre class="line-numbers language-bash"><code class="language-bash">roscore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros004.png" alt="节点管理器"></p><ul><li>在新终端运行一个节点：</li></ul><pre class="line-numbers language-bash"><code class="language-bash">rosrun turtlesim turtlesim_node<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在新终端列出当前运行的节点：</li></ul><pre class="line-numbers language-bash"><code class="language-bash">rosnode list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>效果如下：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros011.png" alt="ros011"></p><h1 id="引用说明"><a href="#引用说明" class="headerlink" title="引用说明"></a>引用说明</h1><p>本文的部分截图来自<a href="https://github.com/huchunxu/ros_21_tutorials" target="_blank" rel="noopener">《古月·ROS入门21讲》</a>的课件。</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingNodes" target="_blank" rel="noopener">ROS官方wiki</a></p><p><a href="https://joveh-h.blog.csdn.net/article/details/90477682" target="_blank" rel="noopener">ROS笔记（6） ROS通讯机制</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 机器人操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS入门-2】带你看ROS文件系统及其工具</title>
      <link href="/ros-2/"/>
      <url>/ros-2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ROS的架构经过设计并划分成了三部分， 每一部分都代表一个层级的概念：</p><ul><li>文件系统级（Filesystem level）</li></ul><p>主要有ROS的内部构成、 文件夹结构， 以及工作所需的核心文件。</p><ul><li>计算图级（Computation Graph level）</li></ul><p>主要是进程和系统之间的通信，包括建立系统、 处理各类进程、 与多台计算机通信等。</p><ul><li>社区级（Community level）</li></ul><p>主要是在开发人员之间共享知识、 算法和代码，塑造了ROS强大的开源社区。</p><h1 id="ROS系列文章"><a href="#ROS系列文章" class="headerlink" title="ROS系列文章"></a>ROS系列文章</h1><ul><li><p><a href="https://jiedev.com/ros-1/">【ROS入门-1】手把手教你在Ubuntu18.04安装ROS Melodic</a></p></li><li><p><a href="https://jiedev.com/ros-2/">【ROS入门-2】带你看ROS文件系统及其工具</a></p></li><li><p><a href="https://jiedev.com/ros-3/">【ROS入门-3】嘴对嘴讲解ROS的核心概念——节点与节点管理器</a></p></li><li><p><a href="https://jiedev.com/ros-4/">【ROS入门-4】嘴对嘴讲解ROS的核心概念——ROS话题通信机制</a></p></li><li><p><a href="https://jiedev.com/ros-5/">【ROS入门-5】深入了解ROS话题通信机制的过程</a></p></li></ul><h1 id="本章的准备工作"><a href="#本章的准备工作" class="headerlink" title="本章的准备工作"></a>本章的准备工作</h1><p>本文章中我们将会用到<code>ros-tutorials</code>程序包，要先用apt命令去安装：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y ros-<span class="token operator">&lt;</span>distro<span class="token operator">></span>-ros-tutorials<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 <code>&lt;distro&gt;</code>替换成你所安装的版本（比如 kinetic、melodic 等）。</p><p>从我们上一篇文章安装的是<code>melodic</code>版本，那么命令就是：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y ros-melodic-ros-tutorials<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="ROS文件系统的概念"><a href="#ROS文件系统的概念" class="headerlink" title="ROS文件系统的概念"></a>ROS文件系统的概念</h1><p>ROS文件系统可以将项目构建过程集中化， 同时提供很好的灵活性和工具来分散之间的依赖性。</p><h2 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h2><p>功能包，也可以被称之为软件包，是ROS应用程序代码的组织单元，每个功能包都可以包含程序库、可执行文件、脚本或者其它手动创建的东西。</p><h2 id="Manifest"><a href="#Manifest" class="headerlink" title="Manifest"></a>Manifest</h2><p>清单，它包含了关于<code>Packages</code>的维护者、许可协议、依赖关系以及编译标志等的信息，由一个名为<code>package.xml</code>的文件管理。</p><h2 id="Metapackage"><a href="#Metapackage" class="headerlink" title="Metapackage"></a>Metapackage</h2><p>元功能包：多个具有某些功能的包组织在一起，称为元功能包。</p><h2 id="Metapackage-Manifest"><a href="#Metapackage-Manifest" class="headerlink" title="Metapackage Manifest"></a>Metapackage Manifest</h2><p>元功能包清单：由一个名字为<code>package.xml</code>的文件管理，类似普通功能包但有一个XML格式的导出标记。 </p><h1 id="文件系统工具"><a href="#文件系统工具" class="headerlink" title="文件系统工具"></a>文件系统工具</h1><p>由于ROS中大量代码分散在众多的packages和Metapackage之中，linux本身的命令工具ls和cd已不能满足检索要求，因此ROS提供了一套自己的命令工具来完成与这些命令相似的工作。</p><h2 id="rospack"><a href="#rospack" class="headerlink" title="rospack"></a>rospack</h2><p><code>rospack</code>允许用户获取功能包的有关信息，比如我们找一个<code>roscpp</code>功能包所在的位置，可以通过以下命令：</p><pre class="line-numbers language-bash"><code class="language-bash">➜  ~ rospack <span class="token function">find</span> roscpp/opt/ros/melodic/share/roscpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>rospack</code>的用法是：</p><pre class="line-numbers language-bash"><code class="language-bash">rospack <span class="token function">find</span> <span class="token punctuation">[</span>功能包名称<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros006.png" alt="ros006"></p><h2 id="roscd"><a href="#roscd" class="headerlink" title="roscd"></a>roscd</h2><p><code>roscd</code>是<code>rosbash</code>命令集中的一部分，它允许你直接切换（cd）工作目录到某个软件包或者软件包集当中。</p><p><code>roscd</code>的用法是：</p><pre class="line-numbers language-bash"><code class="language-bash">roscd <span class="token punctuation">[</span>功能包名称<span class="token punctuation">[</span>/子目录<span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比如切换到<code>roscpp</code>目录下：</p><pre class="line-numbers language-bash"><code class="language-bash">roscd roscpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比如切换到<code>roscpp</code>的子目录<code>msg</code>下：</p><pre class="line-numbers language-bash"><code class="language-bash">roscd roscpp/msg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros007.png" alt="ros007"></p><h2 id="rosls"><a href="#rosls" class="headerlink" title="rosls"></a>rosls</h2><p>这个命令更linux下的ls很像，但它允许你在任何位置列出某个功能包的当前目录或者其子目录的内容，而不需要在绝对路径执行ls。</p><p><code>rosls</code>的用法是：</p><pre class="line-numbers language-bash"><code class="language-bash">rosls <span class="token punctuation">[</span>功能包名称<span class="token punctuation">[</span>/子目录<span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比如列出<code>roscpp</code>目录下的内容：</p><pre class="line-numbers language-bash"><code class="language-bash">rosls roscpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比如列出<code>roscpp</code>的子目录<code>msg</code>下的内容：</p><pre class="line-numbers language-bash"><code class="language-bash">rosls roscpp/msg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros008.png" alt="ros008"></p><p><strong>同时它们都支持<code>Tab补全</code>，非常方便</strong></p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="http://wiki.ros.org/cn/ROS/Tutorials/NavigatingTheFilesystem" target="_blank" rel="noopener">ROS官方wiki</a></p><p><a href="https://joveh-h.blog.csdn.net/article/details/90412882" target="_blank" rel="noopener">ROS笔记（5） ROS架构</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 机器人操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS入门-1】手把手教你在Ubuntu18.04安装ROS Melodic</title>
      <link href="/ros-1/"/>
      <url>/ros-1/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>先来一张ROS的美照：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ROS_Lunar_Loggerhead.png" alt="ROS_Lunar_Loggerhead"></p><h1 id="ROS系列文章"><a href="#ROS系列文章" class="headerlink" title="ROS系列文章"></a>ROS系列文章</h1><ul><li><p><a href="https://jiedev.com/ros-1/">【ROS入门-1】手把手教你在Ubuntu18.04安装ROS Melodic</a></p></li><li><p><a href="https://jiedev.com/ros-2/">【ROS入门-2】带你看ROS文件系统及其工具</a></p></li><li><p><a href="https://jiedev.com/ros-3/">【ROS入门-3】嘴对嘴讲解ROS的核心概念——节点与节点管理器</a></p></li><li><p><a href="https://jiedev.com/ros-4/">【ROS入门-4】嘴对嘴讲解ROS的核心概念——ROS话题通信机制</a></p></li><li><p><a href="https://jiedev.com/ros-5/">【ROS入门-5】深入了解ROS话题通信机制的过程</a></p></li></ul><p><strong>参考官方wiki安装：</strong><br><a href="http://wiki.ros.org/melodic/Installation/Ubuntu" target="_blank" rel="noopener">http://wiki.ros.org/melodic/Installation/Ubuntu</a></p><p>在Ubuntu的【软件和更新】配置如下：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros001.png" alt="ros001"></p><h1 id="添加软件源"><a href="#添加软件源" class="headerlink" title="添加软件源"></a>添加软件源</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> sh -c <span class="token string">'echo "deb http://packages.ros.org/ros/ubuntu <span class="token variable"><span class="token variable">$(</span>lsb_release -sc<span class="token variable">)</span></span> main" > /etc/apt/sources.list.d/ros-latest.list'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="配置秘钥"><a href="#配置秘钥" class="headerlink" title="配置秘钥"></a>配置秘钥</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt-key adv --keyserver <span class="token string">'hkp://keyserver.ubuntu.com:80'</span> --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="更新软件源"><a href="#更新软件源" class="headerlink" title="更新软件源"></a>更新软件源</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="安装一些依赖"><a href="#安装一些依赖" class="headerlink" title="安装一些依赖"></a>安装一些依赖</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> -y python-rosdep2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>ROS中有许多不同的库和工具，官方提供了四种默认：</p><ul><li>桌面完整版（推荐）</li></ul><p>其实也是不完整的，只是包含了绝大部分成常用的软件包跟开发工具，后续开发的一些工具还是要手动安装，但相对于官方的其他版本，这已经是最全功能的版本了。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> -y ros-melodic-desktop-full<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>桌面版本（非完整）</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> -y ros-melodic-desktop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>基础版本，只有一些基础的内容。</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> -y ros-melodic-ros-base<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>独立版本</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> ros-melodic-PACKAGE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你还可以安装一个特定的ROS包:<br>比如：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> ros-melodic-slam-gmapping<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们只选择 <strong><code>桌面完整版</code></strong> 进行安装，大约半小时左右就安装好了，时间取决于你的网速。</p><h1 id="初始化rosdep"><a href="#初始化rosdep" class="headerlink" title="初始化rosdep"></a>初始化rosdep</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> rosdep init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后他会提示我们更新软件源的依赖：</p><pre class="line-numbers language-bash"><code class="language-bash">Recommended: please run    rosdep update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="更新软件源的依赖"><a href="#更新软件源的依赖" class="headerlink" title="更新软件源的依赖"></a>更新软件源的依赖</h1><pre class="line-numbers language-bash"><code class="language-bash">rosdep update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当出现以下log时表示更新成功：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros002.png" alt="ros002"></p><p>如果出错请参考文末的 <strong>【错误排查】</strong></p><h1 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h1><p>为了能每次在终端打开时，都能将ROS环境变量自动设置好，我们可以这样做：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"source /opt/ros/melodic/setup.bash"</span> <span class="token operator">>></span> ~/.bashrc<span class="token function">source</span> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="构建软件包的依赖关系"><a href="#构建软件包的依赖关系" class="headerlink" title="构建软件包的依赖关系"></a>构建软件包的依赖关系</h1><p>到目前为止，我们已经安装了运行核心ROS软件包所需的软件。为了创建和管理自己的ROS工作区，有各种工具和要求分别分发，我们可以通过一个 <code>rosinstall</code> 命令轻松下载ROS软件包的许多源代码树。</p><p>安装此工具和其他依赖项以构建ROS软件包，运行：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> -y python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>支持，ROS的核心组件以及一些工具都已经安装完成。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros003.png" alt="ros003"></p><h1 id="验证ROS是否安装成功"><a href="#验证ROS是否安装成功" class="headerlink" title="验证ROS是否安装成功"></a>验证ROS是否安装成功</h1><pre class="line-numbers language-bash"><code class="language-bash">roscore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>出现以下内容表示安装成功：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros004.png" alt="ros004"></p><p>如果没有出现这个命令，则表示安装不太完全，再次运行安装ROS命令：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> -y ros-melodic-desktop-full<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接着再运行一个ROS的指令（需要打开新的终端），启动小海龟的仿真器：</p><pre class="line-numbers language-bash"><code class="language-bash">rosrun turtlesim turtlesim_node<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后打开新的终端运行以下命令：然后通过键盘的上下左右键去控制小海龟的运动：</p><pre class="line-numbers language-bash"><code class="language-bash">rosrun turtlesim turtle_teleop_key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>效果如下：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros005.png" alt="ros005"></p><h1 id="错误排查参考"><a href="#错误排查参考" class="headerlink" title="错误排查参考"></a>错误排查参考</h1><p>出现的错误可以参考以下博文，感谢各位博主的解决方案：</p><ul><li><p><a href="https://blog.csdn.net/mrh1714348719/article/details/103803110" target="_blank" rel="noopener">ubuntu安装ROS进行到rosdep update时出现错误，如ERROR: unable to process source …</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/77483614" target="_blank" rel="noopener">ROS:sudo rosdep init出错常规方法都无效后解决办法记录</a></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 机器人操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个基于socket API之上的跨平台MQTT客户端，支持qos2</title>
      <link href="/mqttclient/"/>
      <url>/mqttclient/</url>
      
        <content type="html"><![CDATA[<h1 id="mqttclient"><a href="#mqttclient" class="headerlink" title="mqttclient"></a>mqttclient</h1><p><strong>一个基于socket API之上的跨平台MQTT客户端</strong></p><p>基于socket API的MQTT客户端，拥有非常简洁的API接口，以极少的资源实现QOS2的服务质量，并且无缝衔接了mbedtls加密库。</p><h2 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h2><ul><li><p><strong>基于标准BSD socket之上开发</strong>，只要是兼容BSD socket的系统均可使用。</p></li><li><p><strong>稳定</strong>：无论是<code>掉线重连</code>，<code>丢包重发</code>，都是严格<code>遵循MQTT协议标准</code>执行，除此之外对<strong>大数据量</strong>的测试无论是收是发，都是非常稳定（一次发送<code>135K</code>数据，3秒一次），高频测试也是非常稳定（7个主题同时收发，每秒一次，也就是1秒14个mqtt报文，服务质量QoS0、QoS1、QoS2都有）。因为作者以极少的资源设计了<code>记录机制</code>，对采用QoS1服务质量的报文必须保证到达一次，当发布的主题（qos1、qos2都适用）没有被服务器收到时会自动重发，而对QoS2服务质量的报文保证有且只有处理一次（如果不相信它稳定性的同学可以自己去修改源码，专门为QoS2服务质量去做测试，故意不回复<code>PUBREC</code>包，让服务器重发QoS2报文，且看看客户端是否有且只有处理一次），而对于掉线重连的稳定性，这种则是<strong>基本操作</strong>了，没啥好说的，在自动重连后还会自动重新订阅主题，保证主题不会丢失，因此在测试中稳定性极好。</p></li><li><p><strong>轻量级</strong>：整个代码工程极其简单，不使用mbedtls情况下，占用资源极少，作者曾使用esp8266模组与云端通信，整个工程代码消耗的RAM不足15k（包括系统占用的开销，对数据的处理开销，而此次还是未优化的情况下，还依旧完美保留了掉线重连的稳定性，但是对应qos1、qos2服务质量的报文则未做测试，因为STM32F103C8T6芯片资源实在是太少了，折腾不起）。</p></li><li><p><strong>无缝衔接mbedtls加密传输</strong>，让网络传输更加安全，而且接口层完全不需要用户理会，无论是否加密，mqttclient对用户提供的API接口是<strong>没有变化</strong>的，这就很好的兼容了一套代应用层的码可以加密传输也可以不加密传输。</p></li><li><p><strong>拥有极简的API接口</strong>，总的来说，mqttclient的配置都有默认值，基本无需配置都能使用的，也可以随意配置，对配置都有健壮性检测，这样子设计的API接口也是非常简单。</p></li><li><p><strong>有非常好的代码风格与思想</strong>：整个代码采用分层式设计，代码实现采用异步处理的思想，降低耦合，提高性能，具体体现在什么地方呢？很简单，目前市面上很多MQTT客户端发布主题都是要阻塞等待ack，这是非常暴力的行为，阻塞当前线程等待服务器的应答，那如果我想要发送数据怎么办，或者我要重复检测数据怎么办，你可能会说，指定阻塞时间等待，那如果网络延迟，ack迟迟不来，我就白等了吗，对于qos1、qos2的服务质量怎么办，所以说这种还是要异步处理的思想，我发布主题，那我发布出去就好了，不需要等待，对于qos1、qos2服务质量的MQTT报文，如果服务器没收到，那我重发就可以，这种重发也是异步的处理，完全不会阻塞当前线程。</p></li><li><p><strong>MQTT协议支持主题通配符<code>“#”、“+”</code>。</strong></p></li><li><p><strong>订阅的主题与消息处理完全分离</strong>，让编程逻辑更加简单易用，用户无需理会错综复杂的逻辑关系。</p></li><li><p><strong>mqttclient内部已实现保活处理机制</strong>，无需用户过多关心理会，用户只需专心处理应用功能即可。</p></li><li><p><strong>无缝衔接salof</strong>：它是一个同步异步日志输出框架，在空闲时候输出对应的日志信息，也可以将信息写入flash中保存，方便调试。</p></li><li><p><strong>不对外产生依赖。</strong></p></li></ul><h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><p>拥有非常明确的分层框架。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/mqttclient.png" alt="整体框架"></p><p><strong>目前已实现了Linux、TencentOS tiny、RT-Thread平台（已做成软件包，名字为<code>kawaii-mqtt</code>），除此之外TencentOS tiny的AT框架亦可以使用（RAM消耗不足15K），并且稳定性极好！</strong></p><table><thead><tr><th>平台</th><th>代码位置</th></tr></thead><tbody><tr><td>Linux</td><td><a href="https://github.com/jiejieTop/mqttclient" target="_blank" rel="noopener">https://github.com/jiejieTop/mqttclient</a></td></tr><tr><td>TencentOS tiny</td><td><a href="https://github.com/Tencent/TencentOS-tiny/tree/master/board/Fire_STM32F429" target="_blank" rel="noopener">https://github.com/Tencent/TencentOS-tiny/tree/master/board/Fire_STM32F429</a></td></tr><tr><td>TencentOS tiny AT 框架</td><td><a href="https://github.com/jiejieTop/gokit3-board-mqttclient" target="_blank" rel="noopener">https://github.com/jiejieTop/gokit3-board-mqttclient</a></td></tr><tr><td>RT-Thread</td><td><a href="https://github.com/jiejieTop/kawaii-mqtt" target="_blank" rel="noopener">https://github.com/jiejieTop/kawaii-mqtt</a></td></tr></tbody></table><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><table><thead><tr><th>发布版本</th><th>描述</th></tr></thead><tbody><tr><td>[v1.0.0]</td><td>初次发布，完成基本概念及其稳定性验证</td></tr><tr><td>[v1.0.1]</td><td>修复主动与服务器断开连接时的逻辑</td></tr></tbody></table><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>欢迎以 <a href="https://github.com/jiejieTop/mqttclient/issues" target="_blank" rel="noopener">GitHub Issues</a> 的形式提交问题和bug报告</p><h2 id="版权和许可"><a href="#版权和许可" class="headerlink" title="版权和许可"></a>版权和许可</h2><p>mqttclient 由 <a href="https://github.com/jiejieTop/mqttclient/blob/master/LICENSE" target="_blank" rel="noopener">Apache License v2.0</a> 许可 提供。</p><p>简单谈谈关于开源协议的描述，<a href="https://github.com/jiejieTop/mqttclient/blob/master/LICENSE" target="_blank" rel="noopener">Apache License v2.0</a> 鼓励代码共享和尊重原作者的著作权，可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布（作为开源或闭源商业软件），<strong>但本源码必须保留作者版权声明</strong>。</p><h2 id="linux平台下测试使用"><a href="#linux平台下测试使用" class="headerlink" title="linux平台下测试使用"></a>linux平台下测试使用</h2><h3 id="安装cmake："><a href="#安装cmake：" class="headerlink" title="安装cmake："></a>安装cmake：</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> cmake<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在<code>mqttclient/test/test.c</code>文件中修改以下内容：</p><pre class="line-numbers language-c"><code class="language-c">    init_params<span class="token punctuation">.</span>connect_params<span class="token punctuation">.</span>network_params<span class="token punctuation">.</span>network_ssl_params<span class="token punctuation">.</span>ca_crt <span class="token operator">=</span> <span class="token function">test_ca_get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* CA证书 */</span>    init_params<span class="token punctuation">.</span>connect_params<span class="token punctuation">.</span>network_params<span class="token punctuation">.</span>addr <span class="token operator">=</span> <span class="token string">"xxxxxxx"</span><span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">/* 服务器域名 */</span>    init_params<span class="token punctuation">.</span>connect_params<span class="token punctuation">.</span>network_params<span class="token punctuation">.</span>port <span class="token operator">=</span> <span class="token string">"8883"</span><span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">/* 服务器端口号 */</span>    init_params<span class="token punctuation">.</span>connect_params<span class="token punctuation">.</span>user_name <span class="token operator">=</span> <span class="token string">"xxxxxxx"</span><span class="token punctuation">;</span>                                       <span class="token comment" spellcheck="true">/* 用户名 */</span>    init_params<span class="token punctuation">.</span>connect_params<span class="token punctuation">.</span>password <span class="token operator">=</span> <span class="token string">"xxxxxxx"</span><span class="token punctuation">;</span>                                        <span class="token comment" spellcheck="true">/* 密码 */</span>    init_params<span class="token punctuation">.</span>connect_params<span class="token punctuation">.</span>client_id <span class="token operator">=</span> <span class="token string">"xxxxxxx"</span><span class="token punctuation">;</span>                                       <span class="token comment" spellcheck="true">/* 客户端id */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="mbedtls"><a href="#mbedtls" class="headerlink" title="mbedtls"></a>mbedtls</h3><p>默认不打开mbedtls。</p><p><a href="https://github.com/jiejieTop/salof" target="_blank" rel="noopener">salof</a> 全称是：<code>Synchronous Asynchronous Log Output Framework</code>（同步异步日志输出框架），它是一个同步异步日志输出框架，在空闲时候输出对应的日志信息，并且该库与mqttclient无缝衔接。</p><p><strong>配置对应的日志输出级别：</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> BASE_LEVEL      (0)</span><span class="token macro property">#<span class="token directive keyword">define</span> ASSERT_LEVEL    (BASE_LEVEL + 1)            </span><span class="token comment" spellcheck="true">/* 日志输出级别：断言级别（非常高优先级） */</span><span class="token macro property">#<span class="token directive keyword">define</span> ERR_LEVEL       (ASSERT_LEVEL + 1)          </span><span class="token comment" spellcheck="true">/* 日志输出级别：错误级别（高优先级） */</span><span class="token macro property">#<span class="token directive keyword">define</span> WARN_LEVEL      (ERR_LEVEL + 1)             </span><span class="token comment" spellcheck="true">/* 日志输出级别：警告级别（中优先级） */</span><span class="token macro property">#<span class="token directive keyword">define</span> INFO_LEVEL      (WARN_LEVEL + 1)            </span><span class="token comment" spellcheck="true">/* 日志输出级别：信息级别（低优先级） */</span><span class="token macro property">#<span class="token directive keyword">define</span> DEBUG_LEVEL     (INFO_LEVEL + 1)            </span><span class="token comment" spellcheck="true">/* 日志输出级别：调试级别（更低优先级） */</span><span class="token macro property">#<span class="token directive keyword">define</span>         LOG_LEVEL                   WARN_LEVEL      </span><span class="token comment" spellcheck="true">/* 日志输出级别 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>日志其他选项：</strong></p><ul><li>终端带颜色</li><li>时间戳</li><li>标签</li></ul><h3 id="mqttclient的配置"><a href="#mqttclient的配置" class="headerlink" title="mqttclient的配置"></a>mqttclient的配置</h3><p>配置mqtt等待应答列表的最大值，对于qos1 qos2服务质量有要求的可以将其设置大一点，当然也必须资源跟得上，它主要是保证qos1 qos2的mqtt报文能准确到达服务器。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_ACK_HANDLER_NUM_MAX            64</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选择MQTT协议的版本，默认为4，表示使用MQTT 3.1.1版本，而3则表示为MQTT 3.1版本。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_VERSION                        4           </span><span class="token comment" spellcheck="true">// 4 is mqtt 3.1.1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置默认的保活时间，它主要是保证MQTT客户端与服务器的保持活性连接，单位为 秒 ，比如MQTT客户端与服务器100S没有发送数据了，有没有接收到数据，此时MQTT客户端会发送一个ping包，确认一下这个会话是否存在，如果收到服务器的应答，那么说明这个会话还是存在的，可以随时收发数据，而如果不存在了，就清除会话。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_KEEP_ALIVE_INTERVAL            100         </span><span class="token comment" spellcheck="true">// unit: second</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>默认的命令超时，它主要是用于socket读写超时，在MQTT初始化时可以指定:</p><pre><code>#define     MQTT_DEFAULT_CMD_TIMEOUT            4000</code></pre><p>默认主题的长度，主题是支持通配符的，如果主题太长则会被截断：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_TOPIC_LEN_MAX                  64</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>默认的算法数据缓冲区的大小，如果要发送大量数据则修改大一些，在MQTT初始化时可以指定：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_DEFAULT_BUF_SIZE               1024</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>线程相关的配置，如线程栈，线程优先级，线程时间片等：<br>在linux环境下可以是不需要理会这些参数的，而在RTOS平台则需要配置，如果不使用mbedtls，线程栈2048字节已足够，而使用mbedtls加密后，需要配置4096字节以上。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_THREAD_STACK_SIZE              2048    </span><span class="token comment" spellcheck="true">// 线程栈</span><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_THREAD_PRIO                    5       </span><span class="token comment" spellcheck="true">// 线程优先级</span><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_THREAD_TICK                    50      </span><span class="token comment" spellcheck="true">// 线程时间片</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>默认的重连时间间隔，当发生掉线时，会以这个时间间隔尝试重连：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_RECONNECT_DEFAULT_DURATION     1000</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其他不需要怎么配置的东西：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_MAX_PACKET_ID                  (0xFFFF - 1)    </span><span class="token comment" spellcheck="true">// mqtt报文id</span><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_MAX_CMD_TIMEOUT                20000           </span><span class="token comment" spellcheck="true">//最大的命令超时参数</span><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_MIN_CMD_TIMEOUT                1000            </span><span class="token comment" spellcheck="true">//最小的命令超时参数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>ps：以上参数基本不需要怎么配置的，直接用即可~</p></blockquote><h3 id="编译-amp-运行"><a href="#编译-amp-运行" class="headerlink" title="编译 &amp; 运行"></a>编译 &amp; 运行</h3><pre class="line-numbers language-bash"><code class="language-bash">./build.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行<code>build.sh</code>脚本后会在 <code>./build/bin/</code>目录下生成可执行文件<code>mqtt-client</code>，直接运行即可。</p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><ul><li>整体采用分层式设计，代码实现采用异步设计方式，降低耦合。</li><li>消息的处理使用回调的方式处理：用户指定<code>[订阅的主题]</code>与指定<code>[消息的处理函数]</code></li><li>不对外产生依赖</li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><code>mqttclient</code>拥有非常简洁的<code>api</code>接口</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">mqtt_keep_alive</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mqtt_init</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">,</span> client_init_params_t<span class="token operator">*</span> init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mqtt_release</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mqtt_connect</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mqtt_disconnect</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mqtt_subscribe</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> topic_filter<span class="token punctuation">,</span> mqtt_qos_t qos<span class="token punctuation">,</span> message_handler_t msg_handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mqtt_unsubscribe</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> topic_filter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mqtt_publish</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> topic_filter<span class="token punctuation">,</span> mqtt_message_t<span class="token operator">*</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mqtt_yield</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout_ms<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p><strong>mqtt_client_t 结构</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> mqtt_client <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span>              packet_id<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span>               ping_outstanding<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span>               ack_handler_number<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span>               <span class="token operator">*</span>read_buf<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span>               <span class="token operator">*</span>write_buf<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>                cmd_timeout<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>                read_buf_size<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>                write_buf_size<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>                reconnect_try_duration<span class="token punctuation">;</span>    <span class="token keyword">void</span>                        <span class="token operator">*</span>reconnect_date<span class="token punctuation">;</span>    reconnect_handler_t         reconnect_handler<span class="token punctuation">;</span>    client_state_t              client_state<span class="token punctuation">;</span>    platform_mutex_t            write_lock<span class="token punctuation">;</span>    platform_mutex_t            global_lock<span class="token punctuation">;</span>    list_t                      msg_handler_list<span class="token punctuation">;</span>    list_t                      ack_handler_list<span class="token punctuation">;</span>    network_t                   <span class="token operator">*</span>network<span class="token punctuation">;</span>    platform_thread_t           <span class="token operator">*</span>thread<span class="token punctuation">;</span>    platform_timer_t            reconnect_timer<span class="token punctuation">;</span>    platform_timer_t            last_sent<span class="token punctuation">;</span>    platform_timer_t            last_received<span class="token punctuation">;</span>    connect_params_t            <span class="token operator">*</span>connect_params<span class="token punctuation">;</span><span class="token punctuation">}</span> mqtt_client_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该结构主要维护以下内容：</p><ol><li>读写数据缓冲区<code>read_buf、write_buf</code></li><li>命令超时时间<code>cmd_timeout</code>（主要是读写阻塞时间、等待响应的时间、重连等待时间）</li><li>维护<code>ack</code>链表<code>ack_handler_list</code>，这是异步实现的核心，所有等待响应的报文都会被挂载到这个链表上</li><li>维护消息处理列表<code>msg_handler_list</code>，这是<code>mqtt</code>协议必须实现的内容，所有来自服务器的<code>publish</code>报文都会被处理（前提是订阅了对应的消息）</li><li>维护一个网卡接口<code>network</code></li><li>维护一个内部线程<code>thread</code>，所有来自服务器的mqtt包都会在这里被处理！</li><li>两个定时器，分别是掉线重连定时器与保活定时器<code>reconnect_timer、last_sent、last_received</code></li><li>一些连接的参数<code>connect_params</code></li></ol><h2 id="mqttclient实现"><a href="#mqttclient实现" class="headerlink" title="mqttclient实现"></a>mqttclient实现</h2><p>以下是整个框架的实现方式，方便大家更容易理解mqttclient的代码与设计思想，让大家能够修改源码与使用，还可以提交pr或者issues，开源的世界期待各位大神的参与，感谢！</p><p>除此之外以下代码的<code>记录机制</code>与其<code>超时处理机制</code>是非常好的编程思想，大家有兴趣一定要看源代码！</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">mqtt_init</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">,</span> client_init_params_t<span class="token operator">*</span> init<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>主要是配置<code>mqtt_client_t</code>结构的相关信息，如果没有指定初始化参数，则系统会提供默认的参数。<br>但连接部分的参数则必须指定：</p><pre class="line-numbers language-c"><code class="language-c">    init_params<span class="token punctuation">.</span>connect_params<span class="token punctuation">.</span>network_params<span class="token punctuation">.</span>addr <span class="token operator">=</span> <span class="token string">"[你的mqtt服务器IP地址或者是域名]"</span><span class="token punctuation">;</span>    init_params<span class="token punctuation">.</span>connect_params<span class="token punctuation">.</span>network_params<span class="token punctuation">.</span>port <span class="token operator">=</span> <span class="token number">1883</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//端口号</span>    init_params<span class="token punctuation">.</span>connect_params<span class="token punctuation">.</span>user_name <span class="token operator">=</span> <span class="token string">"jiejietop"</span><span class="token punctuation">;</span>    init_params<span class="token punctuation">.</span>connect_params<span class="token punctuation">.</span>password <span class="token operator">=</span> <span class="token string">"123456"</span><span class="token punctuation">;</span>    init_params<span class="token punctuation">.</span>connect_params<span class="token punctuation">.</span>client_id <span class="token operator">=</span> <span class="token string">"clientid"</span><span class="token punctuation">;</span>    <span class="token function">mqtt_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>client<span class="token punctuation">,</span> <span class="token operator">&amp;</span>init_params<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">mqtt_connect</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数只有 <code>mqtt_client_t</code> 类型的指针，字符串类型的<code>主题</code>（支持通配符”#” “+”），主题的<code>服务质量</code>，以及收到报文的<code>处理函数</code>，如不指定则有默认处理函数。连接服务器则是使用非异步的方式设计，因为必须等待连接上服务器才能进行下一步操作。</p><p>过程如下：</p><ol><li>调用底层的连接函数连接上服务器：</li></ol><pre class="line-numbers language-c"><code class="language-c">c<span class="token operator">-></span>network<span class="token operator">-></span><span class="token function">connect</span><span class="token punctuation">(</span>c<span class="token operator">-></span>network<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>序列化<code>mqtt</code>的<code>CONNECT</code>报文并且发送</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTSerialize_connect</span><span class="token punctuation">(</span>c<span class="token operator">-></span>write_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>write_buf_size<span class="token punctuation">,</span> <span class="token operator">&amp;</span>connect_data<span class="token punctuation">)</span><span class="token function">mqtt_send_packet</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>connect_timer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li>等待来自服务器的<code>CONNACK</code>报文</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_wait_packet</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> CONNACK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>connect_timer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>连接成功后创建一个内部线程<code>mqtt_yield_thread</code>，并在合适的时候启动它：</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">platform_thread_init</span><span class="token punctuation">(</span><span class="token string">"mqtt_yield_thread"</span><span class="token punctuation">,</span> mqtt_yield_thread<span class="token punctuation">,</span> c<span class="token punctuation">,</span> MQTT_THREAD_STACK_SIZE<span class="token punctuation">,</span> MQTT_THREAD_PRIO<span class="token punctuation">,</span> MQTT_THREAD_TICK<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> c<span class="token operator">-></span>thread<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">mqtt_set_client_state</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> CLIENT_STATE_CONNECTED<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">platform_thread_startup</span><span class="token punctuation">(</span>c<span class="token operator">-></span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">platform_thread_start</span><span class="token punctuation">(</span>c<span class="token operator">-></span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/* start run mqtt thread */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>而对于重连来说则不会重新创建线程，直接改变客户端状态为连接状态即可:</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_set_client_state</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> CLIENT_STATE_CONNECTED<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="订阅报文"><a href="#订阅报文" class="headerlink" title="订阅报文"></a>订阅报文</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">mqtt_subscribe</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> topic_filter<span class="token punctuation">,</span> mqtt_qos_t qos<span class="token punctuation">,</span> message_handler_t handler<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>订阅报文使用异步设计来实现的：<br>过程如下：</p><ol><li>序列化订阅报文并且发送给服务器</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTSerialize_subscribe</span><span class="token punctuation">(</span>c<span class="token operator">-></span>write_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>write_buf_size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">mqtt_get_next_packet_id</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>topic<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>qos<span class="token punctuation">)</span><span class="token function">mqtt_send_packet</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>timer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>创建对应的消息处理节点，这个消息节点在收到服务器的<code>SUBACK</code>订阅应答报文后会挂载到消息处理列表<code>msg_handler_list</code>上</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_msg_handler_create</span><span class="token punctuation">(</span>topic_filter<span class="token punctuation">,</span> qos<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>在发送了报文给服务器那就要等待服务器的响应了，先记录这个等待<code>SUBACK</code></li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_ack_list_record</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> SUBACK<span class="token punctuation">,</span> <span class="token function">mqtt_get_next_packet_id</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> msg_handler<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h3><p>与订阅报文的逻辑基本差不多的~</p><ol><li>序列化订阅报文并且发送给服务器</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTSerialize_unsubscribe</span><span class="token punctuation">(</span>c<span class="token operator">-></span>write_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>write_buf_size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> packet_id<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>topic<span class="token punctuation">)</span><span class="token function">mqtt_send_packet</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>timer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>创建对应的消息处理节点，这个消息节点在收到服务器的<code>UNSUBACK</code>取消订阅应答报文后将消息处理列表<code>msg_handler_list</code>上的已经订阅的主题消息节点销毁</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_msg_handler_create</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>topic_filter<span class="token punctuation">,</span> QOS0<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>在发送了报文给服务器那就要等待服务器的响应了，先记录这个等待<code>UNSUBACK</code></li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_ack_list_record</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> UNSUBACK<span class="token punctuation">,</span> packet_id<span class="token punctuation">,</span> len<span class="token punctuation">,</span> msg_handler<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="发布报文"><a href="#发布报文" class="headerlink" title="发布报文"></a>发布报文</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">mqtt_publish</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> topic_filter<span class="token punctuation">,</span> mqtt_message_t<span class="token operator">*</span> msg<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数只有 <code>mqtt_client_t</code> 类型的指针，字符串类型的<code>主题</code>（支持通配符），要发布的消息（包括<code>服务质量</code>、<code>消息主体</code>）。</p><pre class="line-numbers language-c"><code class="language-c">    mqtt_message_t msg<span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>qos <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>payload <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> buf<span class="token punctuation">;</span>    <span class="token function">mqtt_publish</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>client<span class="token punctuation">,</span> <span class="token string">"testtopic1"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>核心思想都差不多，过程如下：</p><ol><li>先序列化发布报文，然后发送到服务器</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTSerialize_publish</span><span class="token punctuation">(</span>c<span class="token operator">-></span>write_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>write_buf_size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> msg<span class="token operator">-></span>qos<span class="token punctuation">,</span> msg<span class="token operator">-></span>retained<span class="token punctuation">,</span> msg<span class="token operator">-></span>id<span class="token punctuation">,</span>              topic<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>msg<span class="token operator">-></span>payload<span class="token punctuation">,</span> msg<span class="token operator">-></span>payloadlen<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">mqtt_send_packet</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>timer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>对于QOS0的逻辑，不做任何处理，对于QOS1和QOS2的报文则需要记录下来，在没收到服务器应答的时候进行重发</li></ol><pre class="line-numbers language-c"><code class="language-c">    <span class="token keyword">if</span> <span class="token punctuation">(</span>QOS1 <span class="token operator">==</span> msg<span class="token operator">-></span>qos<span class="token punctuation">)</span> <span class="token punctuation">{</span>        rc <span class="token operator">=</span> <span class="token function">mqtt_ack_list_record</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> PUBACK<span class="token punctuation">,</span> <span class="token function">mqtt_get_next_packet_id</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>QOS2 <span class="token operator">==</span> msg<span class="token operator">-></span>qos<span class="token punctuation">)</span> <span class="token punctuation">{</span>        rc <span class="token operator">=</span> <span class="token function">mqtt_ack_list_record</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> PUBREC<span class="token punctuation">,</span> <span class="token function">mqtt_get_next_packet_id</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>还有非常重要的一点，重发报文的MQTT报文头部需要设置DUP标志位，这是MQTT协议的标准，因此，在重发的时候作者直接操作了报文的DUP标志位，因为修改DUP标志位的函数我没有从MQTT库中找到，所以我封装了一个函数，这与LwIP中的交叉存取思想是一个道理，它假设我知道MQTT报文的所有操作，所以我可以操作它，这样子可以提高很多效率：</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_set_publish_dup</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* may resend this data, set the udp flag in advance */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="内部线程"><a href="#内部线程" class="headerlink" title="内部线程"></a>内部线程</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">mqtt_yield_thread</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>主要是对<code>mqtt_yield</code>函数的返回值做处理，比如在<code>disconnect</code>的时候销毁这个线程。</p><h3 id="核心的处理函数"><a href="#核心的处理函数" class="headerlink" title="核心的处理函数"></a>核心的处理函数</h3><ol><li>数据包的处理<code>mqtt_packet_handle</code></li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">mqtt_packet_handle</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">,</span> platform_timer_t<span class="token operator">*</span> timer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对不同的包使用不一样的处理：</p><pre class="line-numbers language-c"><code class="language-c">    <span class="token keyword">switch</span> <span class="token punctuation">(</span>packet_type<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">/* timed out reading packet */</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> CONNACK<span class="token punctuation">:</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> PUBACK<span class="token punctuation">:</span>        <span class="token keyword">case</span> PUBCOMP<span class="token punctuation">:</span>            rc <span class="token operator">=</span> <span class="token function">mqtt_puback_and_pubcomp_packet_handle</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> timer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> SUBACK<span class="token punctuation">:</span>            rc <span class="token operator">=</span> <span class="token function">mqtt_suback_packet_handle</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> timer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> UNSUBACK<span class="token punctuation">:</span>            rc <span class="token operator">=</span> <span class="token function">mqtt_unsuback_packet_handle</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> timer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> PUBLISH<span class="token punctuation">:</span>            rc <span class="token operator">=</span> <span class="token function">mqtt_publish_packet_handle</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> timer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> PUBREC<span class="token punctuation">:</span>        <span class="token keyword">case</span> PUBREL<span class="token punctuation">:</span>            rc <span class="token operator">=</span> <span class="token function">mqtt_pubrec_and_pubrel_packet_handle</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> timer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> PINGRESP<span class="token punctuation">:</span>            c<span class="token operator">-></span>ping_outstanding <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>            <span class="token keyword">goto</span> exit<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>并且做保活的处理：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_keep_alive</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当发生超时后</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">platform_timer_is_expired</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token operator">-></span>last_sent<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">platform_timer_is_expired</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token operator">-></span>last_received<span class="token punctuation">)</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>序列号一个心跳包并且发送给服务器</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTSerialize_pingreq</span><span class="token punctuation">(</span>c<span class="token operator">-></span>write_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>write_buf_size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">mqtt_send_packet</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当再次发生超时后，表示与服务器的连接已断开，需要重连的操作，设置客户端状态为断开连接</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_set_client_state</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> CLIENT_STATE_DISCONNECTED<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li><code>ack</code>链表的扫描，当收到服务器的报文时，对ack列表进行扫描操作</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_ack_list_scan</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当超时后就销毁ack链表节点：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_ack_handler_destroy</span><span class="token punctuation">(</span>ack_handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然下面这几种报文则需要重发操作：（<code>PUBACK 、PUBREC、 PUBREL 、PUBCOMP</code>，保证QOS1 QOS2的服务质量）</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ack_handler<span class="token operator">-></span>type <span class="token operator">==</span>  PUBACK<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>ack_handler<span class="token operator">-></span>type <span class="token operator">==</span>  PUBREC<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>ack_handler<span class="token operator">-></span>type <span class="token operator">==</span>  PUBREL<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>ack_handler<span class="token operator">-></span>type <span class="token operator">==</span>  PUBCOMP<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">mqtt_ack_handler_resend</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> ack_handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li>保持活性的时间过去了，可能掉线了，需要重连操作</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_try_reconnect</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重连成功后尝试重新订阅报文，保证恢复原始状态~</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_try_resubscribe</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="发布应答与发布完成报文的处理"><a href="#发布应答与发布完成报文的处理" class="headerlink" title="发布应答与发布完成报文的处理"></a>发布应答与发布完成报文的处理</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">mqtt_puback_and_pubcomp_packet_handle</span><span class="token punctuation">(</span>mqtt_client_t <span class="token operator">*</span>c<span class="token punctuation">,</span> platform_timer_t <span class="token operator">*</span>timer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>反序列化报文</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTDeserialize_ack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>packet_type<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dup<span class="token punctuation">,</span> <span class="token operator">&amp;</span>packet_id<span class="token punctuation">,</span> c<span class="token operator">-></span>read_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>read_buf_size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>取消对应的ack记录</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_ack_list_unrecord</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> packet_type<span class="token punctuation">,</span> packet_id<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="订阅应答报文的处理"><a href="#订阅应答报文的处理" class="headerlink" title="订阅应答报文的处理"></a>订阅应答报文的处理</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">mqtt_suback_packet_handle</span><span class="token punctuation">(</span>mqtt_client_t <span class="token operator">*</span>c<span class="token punctuation">,</span> platform_timer_t <span class="token operator">*</span>timer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>反序列化报文</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTDeserialize_suback</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>packet_id<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>count<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>granted_qos<span class="token punctuation">,</span> c<span class="token operator">-></span>read_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>read_buf_size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>取消对应的ack记录</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_ack_list_unrecord</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> packet_type<span class="token punctuation">,</span> packet_id<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>安装对应的订阅消息处理函数，如果是已存在的则不会安装</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_msg_handlers_install</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> msg_handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="取消订阅应答报文的处理"><a href="#取消订阅应答报文的处理" class="headerlink" title="取消订阅应答报文的处理"></a>取消订阅应答报文的处理</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">mqtt_unsuback_packet_handle</span><span class="token punctuation">(</span>mqtt_client_t <span class="token operator">*</span>c<span class="token punctuation">,</span> platform_timer_t <span class="token operator">*</span>timer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>反序列化报文</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTDeserialize_unsuback</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>packet_id<span class="token punctuation">,</span> c<span class="token operator">-></span>read_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>read_buf_size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>取消对应的ack记录，并且获取到已经订阅的消息处理节点</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_ack_list_unrecord</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> UNSUBACK<span class="token punctuation">,</span> packet_id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg_handler<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>销毁对应的订阅消息处理函数</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_msg_handler_destory</span><span class="token punctuation">(</span>msg_handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="来自服务器的发布报文的处理"><a href="#来自服务器的发布报文的处理" class="headerlink" title="来自服务器的发布报文的处理"></a>来自服务器的发布报文的处理</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">mqtt_publish_packet_handle</span><span class="token punctuation">(</span>mqtt_client_t <span class="token operator">*</span>c<span class="token punctuation">,</span> platform_timer_t <span class="token operator">*</span>timer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>反序列化报文</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTDeserialize_publish</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg<span class="token punctuation">.</span>dup<span class="token punctuation">,</span> <span class="token operator">&amp;</span>qos<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">.</span>retained<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">.</span>id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>topic_name<span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>msg<span class="token punctuation">.</span>payload<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>msg<span class="token punctuation">.</span>payloadlen<span class="token punctuation">,</span> c<span class="token operator">-></span>read_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>read_buf_size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>对于QOS0、QOS1的报文，直接去处理消息</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_deliver_message</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token operator">&amp;</span>topic_name<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>对于QOS1的报文，还需要发送一个<code>PUBACK</code>应答报文给服务器</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTSerialize_ack</span><span class="token punctuation">(</span>c<span class="token operator">-></span>write_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>write_buf_size<span class="token punctuation">,</span> PUBACK<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> msg<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>而对于QOS2的报文则需要发送<code>PUBREC</code>报文给服务器，除此之外还需要记录<code>PUBREL</code>到ack链表上，等待服务器的发布释放报文，最后再去处理这个消息</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTSerialize_ack</span><span class="token punctuation">(</span>c<span class="token operator">-></span>write_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>write_buf_size<span class="token punctuation">,</span> PUBREC<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> msg<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">mqtt_ack_list_record</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> PUBREL<span class="token punctuation">,</span> msg<span class="token punctuation">.</span>id <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token function">mqtt_deliver_message</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token operator">&amp;</span>topic_name<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>说明：一旦注册到ack列表上的报文，当具有重复的报文是不会重新被注册的，它会通过<code>mqtt_ack_list_node_is_exist</code>函数判断这个节点是否存在，主要是依赖等待响应的消息类型与msgid。</p></blockquote><h3 id="发布收到与发布释放报文的处理"><a href="#发布收到与发布释放报文的处理" class="headerlink" title="发布收到与发布释放报文的处理"></a>发布收到与发布释放报文的处理</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">mqtt_pubrec_and_pubrel_packet_handle</span><span class="token punctuation">(</span>mqtt_client_t <span class="token operator">*</span>c<span class="token punctuation">,</span> platform_timer_t <span class="token operator">*</span>timer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>反序列化报文</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTDeserialize_ack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>packet_type<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dup<span class="token punctuation">,</span> <span class="token operator">&amp;</span>packet_id<span class="token punctuation">,</span> c<span class="token operator">-></span>read_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>read_buf_size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>产生一个对应的应答报文</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_publish_ack_packet</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> packet_id<span class="token punctuation">,</span> packet_type<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>取消对应的ack记录</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_ack_list_unrecord</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> UNSUBACK<span class="token punctuation">,</span> packet_id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg_handler<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> mqtt </tag>
            
            <tag> mqttclient </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake实战教程（三）</title>
      <link href="/cmake-3/"/>
      <url>/cmake-3/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从本小节开始，后面所有的构建我们都将采用 <code>out-of-source build</code> 外部构建的方式去编写构建工程代码，构建目录是工程目录下的 <code>build</code> 目录。</p><p>从上一篇文章我们就知道，通过<code>aux_source_directory</code>命令可以扫描某个目录下的所有源码，但是更深一层的目录源码就找不到了，因此不满足我们真正工程项目的需要，毕竟真的工程会有很多个目录的，这些目录在的地方还不一样，现在就来解决这个问题…</p><h1 id="定个小目标"><a href="#定个小目标" class="headerlink" title="定个小目标"></a>定个小目标</h1><ul><li><strong>CMake自动构建多个源码目录下的工程</strong></li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>首先，起码工程中得有多个目录对吧，按照编程习惯，我喜欢把源码放到 <code>src</code> 目录下，把头文件放到 <code>inc</code> 目录下，那么把上一篇文章的代码分离放开，具体如下：</p><pre class="line-numbers language-js"><code class="language-js">jie@pc<span class="token punctuation">:</span><span class="token operator">~</span><span class="token operator">/</span>github<span class="token operator">/</span>cmake<span class="token operator">/</span>section4$ tree<span class="token punctuation">.</span>├── build<span class="token punctuation">.</span>sh├── CMakeLists<span class="token punctuation">.</span>txt├── inc│   └── power<span class="token punctuation">.</span>h├── main<span class="token punctuation">.</span>c└── power    ├── CMakeLists<span class="token punctuation">.</span>txt    └── power<span class="token punctuation">.</span>c<span class="token number">2</span> directories<span class="token punctuation">,</span> <span class="token number">6</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很显然，从上面的目录结构中可以看出，有两个<code>CMakeLists.txt</code>文件，一个是在根目录下，一个是在src目录下：</p><pre class="line-numbers language-bash"><code class="language-bash">./CMakeLists.txt./src/CMakeLists.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其实无论在何处，<code>CMakeLists.txt</code>文件都可以被 <code>CMake</code> 命令识别并且自动构建，但是，我们自动构建的时候，都会有一个顶层目录<code>CMakeLists.txt</code>文件，它就是cmake的入口文件，而在顶层目录下，如果某些子目录中存在<code>CMakeLists.txt</code>文件，那么 <code>CMake</code> 可以将顶层的环境变量传递到子目录下，就好比，你在某个文件中定义了个全局变量，你在那个文件中的子函数都可以使用这个全局变量，有点类似的道理，说白了就是作用域。。。</p><h2 id="添加子目录"><a href="#添加子目录" class="headerlink" title="添加子目录"></a>添加子目录</h2><p>那么为了能人 <code>CMake</code> 去识别到<code>src</code>目录下的<code>./src/CMakeLists.txt</code>文件，我们可以在顶层<code>./CMakeLists.txt</code>文件添加一个子目录，用以下这个命令：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">add_subdirectory</span><span class="token punctuation">(</span>source_dir <span class="token punctuation">[</span>binary_dir<span class="token punctuation">]</span>                <span class="token punctuation">[</span>EXCLUDE_FROM_ALL<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>add_subdirectory</code> 这条命令的作用是为构建添加一个子路径。</p><ul><li><code>source_dir</code> 选项指定了 <code>CMakeLists.txt</code> 源文件和代码文件的位置。如果 <code>source_dir</code> 是一个相对路径，那么 <code>source_dir</code> 选项会被解释为相对于当前的目录，不过它也可以是一个绝对路径。在 <code>source_dir</code> 指定路径下的 <code>CMakeLists.txt</code> 将会在当前输入文件的处理过程执行到该命令之前，立即被 <code>CMake</code> 处理。</li><li><code>binary_dir</code> 选项指定了输出文件的路径，同样的， <code>binary_dir</code> 可以相对路径，也可以是一个绝对路径。不过杰杰目前暂未使用到<code>binary_dir</code>，感兴趣的兄弟姐妹可以自己去了解它。</li><li>如果指定了 <code>EXCLUDE_FROM_ALL</code> 选项，在子路径下的目标默认不会被包含到父路径的 ALL 目标里，并且也会被排除在工程文件之外，用户必须显式构建在子路径下的目标。</li></ul><h2 id="添加路径"><a href="#添加路径" class="headerlink" title="添加路径"></a>添加路径</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token function">include_directories</span><span class="token punctuation">(</span><span class="token punctuation">[</span>AFTER<span class="token operator">|</span>BEFORE<span class="token punctuation">]</span> <span class="token punctuation">[</span>SYSTEM<span class="token punctuation">]</span> dir1 dir2 <span class="token operator">...</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同理可以使用<code>include_directories</code>命令将给定的路径添加到编译器搜索包含文件（.h 文件）的路径列表中，这是为了让编译器找到合适的头文件。如果指定了 <code>SYSTEM</code> 选项，编译器将会认为该路径是某种平台上的系统包含路径。</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>在cmake中，很多变量都是以列表的形式存在，比如上面的两个命令，添加头文件与添加子目录，我们可以用列表的形式添加进去，比如<code>include_directories(dir1 dir2 dir3)</code>，那么这些dir，那么<code>CMake</code>也提供了遍历这些列表的方法，这与C语言中的for循环都差不多，可以使用以下命令去遍历它：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">foreach</span><span class="token punctuation">(</span>loop_var arg1 arg2 <span class="token operator">...</span><span class="token punctuation">)</span><span class="token function">COMMAND1</span><span class="token punctuation">(</span>ARGS <span class="token operator">...</span><span class="token punctuation">)</span><span class="token function">COMMAND2</span><span class="token punctuation">(</span>ARGS <span class="token operator">...</span><span class="token punctuation">)</span><span class="token operator">...</span><span class="token function">endforeach</span><span class="token punctuation">(</span>loop_var<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意，这个命令需要配合 endforeach 命令使用，endforeach 表示结束遍历</strong><br>所有的 <code>foreach</code> 和与之匹配的 <code>endforeach</code> 命令之间的命令，会根据list的每个变量都执行一遍，在每次迭代中，循环变量${loop_var}将会被设置为 list 中的当前变量值。</p><p>为了演示，我就将<code>foreach</code>命令去变量指定的<code>INCDIRS</code>（虽然只有一个变量，不过不影响演示），把<code>INCDIRS</code>列表的内容一个个添加到路径中：</p><pre class="line-numbers language-js"><code class="language-js"># 头文件<span class="token keyword">set</span><span class="token punctuation">(</span>INCDIRS <span class="token string">"inc"</span><span class="token punctuation">)</span># 添加头文件目录<span class="token function">foreach</span><span class="token punctuation">(</span>incdir $<span class="token punctuation">{</span>INCDIRS<span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token function">include_directories</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span>incdir<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">endforeach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，我在这提到遍历并不是因为必须要使用这个命令，而是为后续的文章做铺垫。</p><h2 id="构建库"><a href="#构建库" class="headerlink" title="构建库"></a>构建库</h2><p>如果一个工程中有非常多的源码，那么总不能将所有的源码都使用<code>add_executable</code>命令去生成可执行文件是不是，我们可以让这个可执行文件去依赖库，静态库，动态库都可以，那么在这里就简单说说<code>add_executable</code>命令依赖静态库生成可执行文件，那么问题来了，静态库从哪来？</p><p>很显然，静态库是我们的一些源码文件生成的，在生成静态库后，再通过静态库去构建可执行文件，那么就用到了CMake中的<code>add_library</code>命令：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">add_library</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>name<span class="token operator">></span> <span class="token punctuation">[</span>STATIC <span class="token operator">|</span> SHARED <span class="token operator">|</span> MODULE<span class="token punctuation">]</span>            <span class="token punctuation">[</span>EXCLUDE_FROM_ALL<span class="token punctuation">]</span>            source1 source2 <span class="token operator">...</span> sourceN<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>它的作用就是使用指定的源文件向工程中添加一个库。添加一个名为<code>&lt;name&gt;</code>的库文件，<code>&lt;name&gt;</code>在一个工程的全局域内必须是唯一的，这个库文件将会根据命令里列出的源文件（<code>source1 source2 ... sourceN</code>）来创建。待构建的库文件的实际文件名根据对应平台的命名约定来构造（比如 可以是<code>lib&lt;name&gt;.a</code> 或者<code>&lt;name&gt;.lib</code>）。通过指定<code>STATIC</code>，<code>SHARED</code>，或者 <code>MODULE</code> 参数用来指定要创建的库的类型。</p><ul><li><code>STATIC</code> 库是目标文件的归档文件，在链接其它目标的时候使用。</li><li><code>SHARED</code> 库会被动态链接，在运行时被加载。</li><li><code>MODULE</code> 库是不会被链接到其它目标中的插件，但是可能会在运行时使用 dlopen-系列的函数动态链接。如果没有类型被显式指定，这个选项将会根据变量 <code>BUILD_SHARED_LIBS</code> 的当前值是否为真决定是 <code>STATIC</code> 还是 <code>SHARED</code>。</li></ul><pre class="line-numbers language-js"><code class="language-js"># 查找当前目录下的所有源文件# 并将名称保存到 DIR_LIB_SRCS 变量<span class="token function">file</span><span class="token punctuation">(</span>GLOB_RECURSE DIR_LIB_SRCS <span class="token operator">*</span><span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token function">file</span><span class="token punctuation">(</span>GLOB_RECURSE DIR_LIB_HDRS <span class="token operator">*</span><span class="token punctuation">.</span>h<span class="token punctuation">)</span># 生成链接库<span class="token function">add_library</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span>LIB_NAME<span class="token punctuation">}</span> $<span class="token punctuation">{</span>DIR_LIB_SRCS<span class="token punctuation">}</span> $<span class="token punctuation">{</span>DIR_LIB_HDRS<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，为了我们的<code>CMakeLists.txt</code>文件有更好的兼容性，也不必每次都去写对应的库文件名字<code>&lt;name&gt;</code>，杰杰自己会使用正则表达式去解析当前目录的名字，并以这个目录名字去作为库的命名，正则表达式如下：</p><pre class="line-numbers language-js"><code class="language-js"># 正则表达式得到当前目录名字作为提供给上一层的库名字<span class="token function">string</span><span class="token punctuation">(</span>REGEX REPLACE <span class="token string">".*/(.*)"</span> <span class="token string">"\\1"</span> LIB_NAME $<span class="token punctuation">{</span>CMAKE_CURRENT_SOURCE_DIR<span class="token punctuation">}</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="工程demo"><a href="#工程demo" class="headerlink" title="工程demo"></a>工程demo</h1><p>顶层<code>./CMakeLists.txt</code>文件内容：</p><pre class="line-numbers language-js"><code class="language-js"># CMake 最低版本号要求<span class="token function">cmake_minimum_required</span><span class="token punctuation">(</span>VERSION <span class="token number">2.8</span><span class="token punctuation">)</span># 项目信息<span class="token function">project</span><span class="token punctuation">(</span>targets<span class="token punctuation">)</span># 设置可执行文件目标<span class="token keyword">set</span><span class="token punctuation">(</span>TARGETS <span class="token string">"targets"</span><span class="token punctuation">)</span># 子目录<span class="token keyword">set</span><span class="token punctuation">(</span>SUBDIRS <span class="token string">"power"</span><span class="token punctuation">)</span># 头文件<span class="token keyword">set</span><span class="token punctuation">(</span>INCDIRS <span class="token string">"inc"</span><span class="token punctuation">)</span># 指定编译器<span class="token keyword">set</span><span class="token punctuation">(</span>CMAKE_C_COMPILER <span class="token string">"gcc"</span><span class="token punctuation">)</span>#判断编译器类型<span class="token punctuation">,</span>如果是gcc编译器<span class="token punctuation">,</span>则在编译选项中加入c<span class="token operator">++</span><span class="token number">11</span>支持<span class="token keyword">if</span><span class="token punctuation">(</span>CMAKE_COMPILER_IS_GNUCXX<span class="token punctuation">)</span>    <span class="token keyword">set</span><span class="token punctuation">(</span>CMAKE_CXX_FLAGS <span class="token string">"-std=c++11 ${CMAKE_CXX_FLAGS}"</span><span class="token punctuation">)</span><span class="token function">endif</span><span class="token punctuation">(</span>CMAKE_COMPILER_IS_GNUCXX<span class="token punctuation">)</span>#指定编译类型<span class="token function">SET</span><span class="token punctuation">(</span>CMAKE_BUILE_TYPE <span class="token string">"RELEASE"</span><span class="token punctuation">)</span># 查找当前目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量<span class="token function">aux_source_directory</span><span class="token punctuation">(</span><span class="token punctuation">.</span> DIR_SRCS<span class="token punctuation">)</span># 指定生成目标<span class="token function">add_executable</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span>TARGETS<span class="token punctuation">}</span> $<span class="token punctuation">{</span>DIR_SRCS<span class="token punctuation">}</span><span class="token punctuation">)</span># 添加头文件目录<span class="token function">foreach</span><span class="token punctuation">(</span>incdir $<span class="token punctuation">{</span>INCDIRS<span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token function">include_directories</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span>incdir<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">endforeach</span><span class="token punctuation">(</span><span class="token punctuation">)</span># 添加子目录<span class="token function">foreach</span><span class="token punctuation">(</span>subdir $<span class="token punctuation">{</span>SUBDIRS<span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token function">add_subdirectory</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span>subdir<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">endforeach</span><span class="token punctuation">(</span><span class="token punctuation">)</span># 添加链接库<span class="token function">target_link_libraries</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span>TARGETS<span class="token punctuation">}</span> $<span class="token punctuation">{</span>SUBDIRS<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>src</code>目录下的<code>./src/CMakeLists.txt</code>文件内容：</p><pre class="line-numbers language-js"><code class="language-js"># 查找当前目录下的所有源文件# 并将名称保存到 DIR_LIB_SRCS 变量<span class="token function">file</span><span class="token punctuation">(</span>GLOB_RECURSE DIR_LIB_SRCS <span class="token operator">*</span><span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token function">file</span><span class="token punctuation">(</span>GLOB_RECURSE DIR_LIB_HDRS <span class="token operator">*</span><span class="token punctuation">.</span>h<span class="token punctuation">)</span># 正则表达式得到当前目录名字作为提供给上一层的库名字<span class="token function">string</span><span class="token punctuation">(</span>REGEX REPLACE <span class="token string">".*/(.*)"</span> <span class="token string">"\\1"</span> LIB_NAME $<span class="token punctuation">{</span>CMAKE_CURRENT_SOURCE_DIR<span class="token punctuation">}</span><span class="token punctuation">)</span> # 生成链接库<span class="token function">add_library</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span>LIB_NAME<span class="token punctuation">}</span> $<span class="token punctuation">{</span>DIR_LIB_SRCS<span class="token punctuation">}</span> $<span class="token punctuation">{</span>DIR_LIB_HDRS<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后直接运行<code>./build</code>去构建工程与编译工程即可</p><h1 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h1><p><a href="https://github.com/jiejieTop/cmake" target="_blank" rel="noopener">https://github.com/jiejieTop/cmake</a></p><p>未完待续….</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> cmake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake实战教程（二）</title>
      <link href="/cmake-2/"/>
      <url>/cmake-2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从上一篇的文章中，相信大家也了解了<code>CMake</code>这个东西，但是呢它不是只是看一下就能会的，这种东西还是要实践才能学会，那么如果你已经实践过了，就会体会到上一篇文章在实际中使用到底是多么的难搞，比如：</p><ul><li>生成很多垃圾文件，这是我的第一个体会….</li><li>需要手动去指定编译的文件</li><li>无法指定编译器，编译选项等等很多东西….</li><li>如果有子目录也不能完全适用….</li><li>以及一些其他的问题….</li></ul><p>总的来说就是在真正项目中压根就没法适用的工程，那为什么我要写呢，因为那是我学习的过程，总不能一口吞下一个大胖子是不是，接下来的一系列文章我就会让<code>CMake</code>变得能在实际中使用，越来越自动化，更方便构建。。。</p><h1 id="外部构建"><a href="#外部构建" class="headerlink" title="外部构建"></a>外部构建</h1><p>第一个问题，在运行<code>cmake .</code>后会产生很多垃圾文件，那么我们可以让它在一个build目录下去编译，生成的垃圾文件放在这个目录下就好了，不需要的时候直接清除即可。</p><p>可能有人会问，它不能像Makefile一样直接<code>make clean</code> 或者<code>make distclean</code>清除编译的垃圾文件吗，我当时学的时候也谷歌过，但是，很遗憾没有，使用我才让它产生的垃圾文件放在build目录下，其实不能说是垃圾文件，只不过是一些中间文件，记录某些东西的，我用不上它，所以认为是垃圾…仅此而已。</p><p>对此官方的解释是：</p><blockquote><p>CMakeLists.txt 可以执行脚本并通过脚本生成一些临时文件，但是却没有办法来跟踪这些临时文件到底是哪些，因此，没有办法提供一个可靠的 clean 方案。</p></blockquote><p>那怎么办呢？很简单，从<code>CMake</code>的语法我们就知道，它在构建的时候指定了<code>PATH</code>，也就是顶层<code>CMakeLists.txt</code> 入口的路径。</p><pre class="line-numbers language-js"><code class="language-js">cmake PATH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么很显然，它可以是相对路径而不是绝对路径，毕竟<strong>点<code>‘.’</code></strong>  表示当前路径， <strong>点点<code>‘..’</code></strong> 表示上一级路径，那么我们可以新建一个build目录，然后在build目录下去运行：</p><pre class="line-numbers language-bash"><code class="language-bash">cmake <span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这在<code>CMake</code>中称之为外部构建（out-of-source build），而 <code>CMake</code> 强烈推荐的就是外部构建！</p><p>我自己也写了个build的脚本，内容非常简单，主要做两件事：</p><ol><li>创建一个build目录（存在就不会重新创建的）</li><li>进入build目录</li><li>然后外部构建cmake</li><li>生成Makefile文件后运行make命令编译</li></ol><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token function">mkdir</span> -p build<span class="token function">cd</span> buildcmake <span class="token punctuation">..</span><span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此在编译的时候直接运行这个脚本即可，生成的内容全部都在build目录下。</p><ul><li>这是原始目录</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">.</span>├── build.sh├── CMakeLists.txt└── main.c0 directories, 3 files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译后在build目录下生成很多文件，包括 <code>Makefile、section2(可执行程序)</code>等</p><pre class="line-numbers language-bash"><code class="language-bash">CMakeCache.txt  CMakeFiles  cmake_install.cmake  Makefile  section2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>补充一点，如果你想看到cmake生成的垃圾文件比你源码还多的时候，你就会爱死外部构建这种骚操作了~</strong></p><h1 id="自动查找源码"><a href="#自动查找源码" class="headerlink" title="自动查找源码"></a>自动查找源码</h1><p>不得不说，cmake是个很好的自动化构建工具，既然是自动化，那么很的东西都是自动的，比如查找源码，cmake就提供查找源码的命令：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">aux_source_directory</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>dir<span class="token operator">></span> <span class="token operator">&lt;</span>variable<span class="token operator">></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它的主要作用就是：<strong>查找在某个路径下的所有源文件</strong>，注意，是所有源码文件，当你的目录下有很多个源码文件的时候，他就主动去查找了，哦，当然，它也只会查找源码文件，比如<code>*.c 、 *.cpp 、*.cc</code>啦，反正只要是源码就可以了，但是什么<code>txt  、 *.h</code>文件这些它是不会记录下来的。</p><ul><li><code>dir</code> ： 指定的目录（可以是绝对路径也可以是相对路径）</li><li><code>variable</code>：将输出结果列表储存在指定的<code>&lt;variable&gt;</code>变量中。</li></ul><p>反正这个命令就很方便，我在某个目录下有啥源码文件，我都会被记录到<code>&lt;variable&gt;</code>变量，然后在<code>CMake</code>直接使用即可。当然后续也有其他的命令去找源码文件，一口吃不了一个大胖子，先了解这个先，后续慢慢学习~</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>在<code>CMake</code>中，变量是十分常见的，我正在就简单讲解下基本的语法吧：</p><p>定义变量常用的函数是：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">set</span><span class="token punctuation">(</span>VARIABLE_NAME VARIABLE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>取消定义变量是</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">unset</span><span class="token punctuation">(</span>VARIABLE_NAME <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>VARIABLE_NAME</code> ： 变量名字</li><li><code>VARIABLE</code>：变量的值</li></ul><p>变量的的值始终是<code>string（字符串）</code>类型，变量名字是区分大小写的，一般变量命名还是正常点比较好，别搞太多乱七八糟的特殊符号，只要数字、字母，下划线<code>"_"</code> 、横线<code>"-"</code>就差不多了，变量的作用域也是有全局与局部之分，与C语言、Java都差不多，我也不多说了。我的例程中<code>全局变量是全部大写，局部变量是全小写</code>的，也是比较好区分。</p><p>变量引用的形式为<code>${variable_name}</code>，变量引用被变量的值替换，或者如果变量没有被设置，则由空字符串替换。变量引用可以嵌套，例如<code>${outer_${inner_variable}veriable}</code>；环境变量引用的形式为<code>$ENV{VARIABLE}</code>，并在相同的上下文中作为正常变量引用。</p><h1 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h1><p>在<code>CMake</code>构建的时候，你可能不知道某些变量是啥内容，那么就在终端打印出来看看就好了，这根我们写代码中的printf函数差不多，给直接打一串字符串出来瞧瞧….</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">message</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&lt;</span>mode<span class="token operator">></span><span class="token punctuation">]</span> <span class="token string">"message to display"</span> <span class="token operator">...</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首先呢，<code>&lt;mode&gt;</code>是指定消息的类型：</p><ul><li><code>(无)</code> = 重要消息；</li><li><code>STATUS</code> = 非重要消息；</li><li><code>WARNING</code> = CMake 警告, 会继续执行；</li><li><code>AUTHOR_WARNING</code> = CMake 警告 (dev), 会继续执行；</li><li><code>SEND_ERROR</code> = CMake 错误, 继续执行，但是会跳过生成的步骤；</li><li><code>FATAL_ERROR</code> = CMake 错误, 终止所有处理过程；</li></ul><p>正常情况下我都是输出一些状态信息——<code>STATUS</code>，打印个变量啦，打印下代码的执行顺序啦等等….</p><p>后面就是有些字符串信息了，变量在这里直接引用就好，毕竟变量本身就是字符串….</p><h1 id="section3"><a href="#section3" class="headerlink" title="section3"></a>section3</h1><p>给出个实例代码：<br>当前目录存在2个c文件，分别是<code>main.c</code>、<code>power.c</code>就是简单计算x的y次方，纯粹是个demo，我自己也懒得写，并不是因为代码有多高深，所以这代码我是从网上找的，来自<a href="https://github.com/wzpan" target="_blank" rel="noopener">潘伟洲</a>大神的cmake测试代码：<a href="https://github.com/wzpan/cmake-demo" target="_blank" rel="noopener">https://github.com/wzpan/cmake-demo</a>。</p><ul><li>main.c</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"power.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Usage: %s base exponent \n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">double</span> base <span class="token operator">=</span> <span class="token function">atof</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> exponent <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> result <span class="token operator">=</span> <span class="token function">power</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> exponent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%g ^ %d is %g\n"</span><span class="token punctuation">,</span> base<span class="token punctuation">,</span> exponent<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>power.c</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">double</span> <span class="token function">power</span><span class="token punctuation">(</span><span class="token keyword">double</span> base<span class="token punctuation">,</span> <span class="token keyword">int</span> exponent<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> base<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>exponent <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> exponent<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        result <span class="token operator">=</span> result <span class="token operator">*</span> base<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就是<code>CMakeLists.txt</code>文件：</p><pre class="line-numbers language-js"><code class="language-js"># CMake 最低版本号要求cmake_minimum_required <span class="token punctuation">(</span>VERSION <span class="token number">2.8</span><span class="token punctuation">)</span># 项目信息project <span class="token punctuation">(</span>section3<span class="token punctuation">)</span># 查找当前目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量<span class="token function">aux_source_directory</span><span class="token punctuation">(</span><span class="token punctuation">.</span> DIR_SRCS<span class="token punctuation">)</span># 指定生成目标<span class="token function">add_executable</span><span class="token punctuation">(</span>section3 $<span class="token punctuation">{</span>DIR_SRCS<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相比于上一篇文章，我这个<code>CMakeLists.txt</code>文件只是添加了<code>aux_source_directory</code>命令去自动扫描当前目录下的源码文件，并且保存到<code>DIR_SRCS</code> 变量中，仅此而已！！</p><p>然后在<code>add_executable</code>命令中，用<code>${DIR_SRCS}</code>变量代替指定的源码文件<code>source1 source2 ... sourceN</code>，当然你也可以打印一下<code>${DIR_SRCS}</code>变量到底保存了什么，如果不出意外的话，它保存的就是<code>./main.c;   ./power.c</code>，表示的是当前目录下的<code>main.c</code>、<code>power.c</code>这两个文件，而分号代表它是一个list，后续会讲解怎么去提取list的内容….</p><pre class="line-numbers language-bash"><code class="language-bash">message<span class="token punctuation">(</span>STATUS <span class="token string">"<span class="token variable">${DIR_SRCS}</span>"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后用外部构建的方式去编译代码：</p><pre class="line-numbers language-bash"><code class="language-bash">jie@pc:~/github/cmake/section3$ ./build.sh -- The C compiler identification is GNU 7.4.0-- The CXX compiler identification is GNU 7.4.0-- Check <span class="token keyword">for</span> working C compiler: /usr/bin/cc-- Check <span class="token keyword">for</span> working C compiler: /usr/bin/cc -- works-- Detecting C compiler ABI info-- Detecting C compiler ABI info - <span class="token keyword">done</span>-- Detecting C compile features-- Detecting C compile features - <span class="token keyword">done</span>-- Check <span class="token keyword">for</span> working CXX compiler: /usr/bin/c++-- Check <span class="token keyword">for</span> working CXX compiler: /usr/bin/c++ -- works-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - <span class="token keyword">done</span>-- Detecting CXX compile features-- Detecting CXX compile features - <span class="token keyword">done</span>-- Configuring <span class="token keyword">done</span>-- Generating <span class="token keyword">done</span>-- Build files have been written to: /home/jie/github/cmake/section3/buildScanning dependencies of target section3<span class="token punctuation">[</span> 33%<span class="token punctuation">]</span> Building C object CMakeFiles/section3.dir/main.c.o<span class="token punctuation">[</span> 66%<span class="token punctuation">]</span> Building C object CMakeFiles/section3.dir/power.c.o<span class="token punctuation">[</span>100%<span class="token punctuation">]</span> Linking C executable section3<span class="token punctuation">[</span>100%<span class="token punctuation">]</span> Built target section3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显生成了正确可执行文件~</p><h1 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h1><p><a href="https://github.com/jiejieTop/cmake" target="_blank" rel="noopener">https://github.com/jiejieTop/cmake</a></p><p>未完待续….</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> cmake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake实战教程（一）</title>
      <link href="/cmake-1/"/>
      <url>/cmake-1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在学习<code>CMake</code>之前，一直都是自己在手敲<code>Makefile</code>文件，当项目的文件一旦多了起来，自己手动写<code>Makefile</code>就不是那么好玩了，也曾经了解了一下<code>autotools</code>，但是seeed的柱哥说有<code>CMake</code>这个东西，所以我就去学习了，也在网上搜过对比，下面的一句话让我放弃了<code>autotools</code>：</p><blockquote><p>CMake产生的晚，解决了很多autotools工具的问题</p></blockquote><p>其实吧，简单来说<code>CMake</code>就是生产Makefile的自动化构建工具，引用一句官方的描述就是：</p><blockquote><p>CMake 是一个跨平台的构建系统生成工具。它使用平台无关的 CMake 清单文件CMakeLists.txt，指定工程的构建过程；源码树的每个路径下都有这个文件。CMake 产生一个适用于具体平台的构建系统，用户使用这个系统构建自己的工程。</p></blockquote><h1 id="安装CMake"><a href="#安装CMake" class="headerlink" title="安装CMake"></a>安装CMake</h1><ul><li>开发环境：<code>Ubuntu</code></li></ul><p>一句代码的事安装<code>CMake</code>：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> cmake<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检测安装是否成功：</p><pre class="line-numbers language-js"><code class="language-js">cmake <span class="token operator">--</span>version # 输出cmake version <span class="token number">3.10</span><span class="token punctuation">.</span><span class="token number">2</span>CMake suite maintained and supported by Kitware <span class="token punctuation">(</span>kitware<span class="token punctuation">.</span>com<span class="token operator">/</span>cmake<span class="token punctuation">)</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你用的是<code>vscode</code>写代码的话，最好还是装一个<code>CMake</code>插件，更加方便：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/cmake-1.png" alt="cmake插件"></p><p>关于其他的一些注意事项，你需要编译c代码，起码Ubuntu得有个gcc编译器啥的吧~如果没有就直接安装得了….</p><h1 id="初步了解CMake"><a href="#初步了解CMake" class="headerlink" title="初步了解CMake"></a>初步了解CMake</h1><p>其实呢，<code>CMake</code>是非常简单易用的，我们写代码无非就是将写好的代码进行编译生成可执行文件，那么就可以用<code>CMake</code> 生成 Makefile 文件并编译源代码！</p><p>它的流程基本如下：</p><ol><li>编写 <code>CMake</code>配置文件 <code>CMakeLists.txt</code> 。</li><li>执行<code>cmake PATH</code>命令生成 <code>Makefile</code>。其中， <code>PATH</code> 是 <code>CMakeLists.txt</code> 所在的目录。</li><li>使用 <code>make</code> 命令进行编译。（既然步骤2的时候就生成<code>Makefile</code>文件了，那么肯定是可以直接<code>make</code>编译啦）</li></ol><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p>一个最基本的<code>CmakeLists.txt</code>文件最少需要包含以下3行代码：</p><pre class="line-numbers language-js"><code class="language-js"># CMake 最低版本号要求cmake_minimum_required <span class="token punctuation">(</span>VERSION <span class="token number">2.8</span><span class="token punctuation">)</span># 项目信息project <span class="token punctuation">(</span>section1<span class="token punctuation">)</span># 指定生成目标<span class="token function">add_executable</span><span class="token punctuation">(</span>section1 main<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：<code>CMake</code>的语法支持大写、小写甚至是大小写混合的，实在是太变态了，不过呢，在杰杰的例程中使用的<code>CMake</code>语法是小写的，全局变量是大写的，局部变量是小写！</p><h1 id="section1"><a href="#section1" class="headerlink" title="section1"></a>section1</h1><p>废话不多说，直接入门实战吧，写代码这东西还是要亲自动手去写采用意义~</p><ul><li>文件夹目录结构如下：</li></ul><pre class="line-numbers language-bash"><code class="language-bash">jie@pc:~/github/cmake/section1$ tree<span class="token keyword">.</span>├── CMakeLists.txt└── main.c0 directories, 2 files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非常简单，也就是一个<code>main.c</code>文件与一个<code>CMakeLists.txt</code>文件，内容更是简单，<code>main.c</code>就只是打印个<code>"Hello World!"</code>：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>CMakeLists.txt</code>就是<code>CMake</code>最基础的3行代码：</p><pre class="line-numbers language-js"><code class="language-js"># CMake 最低版本号要求cmake_minimum_required <span class="token punctuation">(</span>VERSION <span class="token number">2.8</span><span class="token punctuation">)</span># 项目信息project <span class="token punctuation">(</span>section1<span class="token punctuation">)</span># 指定生成目标<span class="token function">add_executable</span><span class="token punctuation">(</span>section1 main<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样子可以在该目录下直接运行以下命令去编译（注意有一个 <strong>点<code>.</code></strong>，表示<code>CMakeLists.txt</code> 所在的目录）：</p><pre class="line-numbers language-bash"><code class="language-bash">cmake <span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编译输出信息如下：</p><pre class="line-numbers language-bash"><code class="language-bash">jie@pc:~/github/cmake/section1$ cmake <span class="token keyword">.</span>-- The C compiler identification is GNU 7.4.0-- The CXX compiler identification is GNU 7.4.0-- Check <span class="token keyword">for</span> working C compiler: /usr/bin/cc-- Check <span class="token keyword">for</span> working C compiler: /usr/bin/cc -- works-- Detecting C compiler ABI info-- Detecting C compiler ABI info - <span class="token keyword">done</span>-- Detecting C compile features-- Detecting C compile features - <span class="token keyword">done</span>-- Check <span class="token keyword">for</span> working CXX compiler: /usr/bin/c++-- Check <span class="token keyword">for</span> working CXX compiler: /usr/bin/c++ -- works-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - <span class="token keyword">done</span>-- Detecting CXX compile features-- Detecting CXX compile features - <span class="token keyword">done</span>-- Configuring <span class="token keyword">done</span>-- Generating <span class="token keyword">done</span>-- Build files have been written to: /home/jie/github/cmake/section1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后你就会看到生成了一些其他文件文件以及一个<code>Makefile</code>文件：</p><pre class="line-numbers language-bash"><code class="language-bash">jie@pc:~/github/cmake/section1$ <span class="token function">ls</span>CMakeCache.txt  CMakeFiles  cmake_install.cmake  CMakeLists.txt  main.c  Makefile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>既然有<code>Makefile</code>文件那么就可以直接运行<code>make</code>命令去编译源码文件了，最后输出<code>“Built target section1”</code>表示编译成功！最终目录下会多出一个<code>section1</code>可执行文件，然后你运行它就能看到代码的执行效果了，直接打印输出<code>"Hello World!"</code>。</p><pre class="line-numbers language-bash"><code class="language-bash">jie@pc:~/github/cmake/section1$ <span class="token function">make</span>Scanning dependencies of target section1<span class="token punctuation">[</span> 50%<span class="token punctuation">]</span> Building C object CMakeFiles/section1.dir/main.c.o<span class="token punctuation">[</span>100%<span class="token punctuation">]</span> Linking C executable section1<span class="token punctuation">[</span>100%<span class="token punctuation">]</span> Built target section1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="CMakeLists-txt分析"><a href="#CMakeLists-txt分析" class="headerlink" title="CMakeLists.txt分析"></a>CMakeLists.txt分析</h1><pre class="line-numbers language-js"><code class="language-js"># CMake 最低版本号要求cmake_minimum_required <span class="token punctuation">(</span>VERSION <span class="token number">2.8</span><span class="token punctuation">)</span># 项目信息project <span class="token punctuation">(</span>section1<span class="token punctuation">)</span># 指定生成目标<span class="token function">add_executable</span><span class="token punctuation">(</span>section1 main<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实上面的三句代码看起来像是函数，但并不是函数而是命令，它跟我们的在<code>linux</code>的命令差不多，反正就是指定<code>CMake</code>要怎么做的一系列命令。比如：</p><ul><li><code>cmake_minimum_required</code>：设置一个工程所需要的最低 <code>CMake</code>版本，如果 <code>CMake</code>的当前版本低于指定的版本，它会停止处理工程文件，并报告错误。</li><li><code>project</code>：为整个工程设置一个工程名。</li><li><code>add_executable</code>：使用给定的源文件，为工程引入一个可执行文件。<pre class="line-numbers language-js"><code class="language-js"><span class="token function">add_executable</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>name<span class="token operator">></span> <span class="token punctuation">[</span>WIN32<span class="token punctuation">]</span> <span class="token punctuation">[</span>MACOSX_BUNDLE<span class="token punctuation">]</span>              <span class="token punctuation">[</span>EXCLUDE_FROM_ALL<span class="token punctuation">]</span>              source1 <span class="token punctuation">[</span>source2 <span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>引入一个名字为<code>&lt;name&gt;</code>的可执行目标，这个可执行目标会由调用该命令时在源文件列表中指定的源文件来构建，比如<code>main.c</code>就是一个源码文件。<code>&lt;name&gt;</code>在工程范围内必须是全局唯一的，它实际上就是make编译后生成的可执行文件。</li></ul><p>顺便再提一下语法，上面的代码呢，<code>&lt;name&gt;</code>是必须填写的，然后也必须有一个源码文件<code>source1</code>，当然有可以有多个源码文件<code>[source2 ...]</code>。<br>| 格式     | 注释 |<br>|–|–|<br>| &lt; command &gt; | 必须填写的 |<br>| [ command ] | 可写也可不写的 |<br>| a|b | a或者b都可以 |</p><p>对了，<code>#</code> 后面的是注释，这根C语言中<code>//</code>表示注释是一样的！</p><h1 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h1><p><a href="https://github.com/jiejieTop/cmake" target="_blank" rel="noopener">https://github.com/jiejieTop/cmake</a></p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>暂且到这吧，未完待续….</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> cmake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络底层知识</title>
      <link href="/tcpip-2/"/>
      <url>/tcpip-2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从前一篇文章，我们也知道大概的网络相关知识，网络这个系列文章就从底层往顶层讲解，本篇文章就来接触一下<code>网络底层的相关知识</code>。</p><h1 id="概述网络中的数据递交"><a href="#概述网络中的数据递交" class="headerlink" title="概述网络中的数据递交"></a>概述网络中的数据递交</h1><p>当用户发送数据时，将数据向下交给传输层，这是处于应用层的操作，<code>应用层</code>可以通过调用传输层的接口来编写特定的应用程序，并且<code>TCP/IP</code>协议栈一般也会包含一些简单的应用协议如 <code>Telnet</code> 远程登录、<code>FTP</code>文件传输、<code>SMTP</code> 邮件传输协议等，这些协议有自己的首部——<code>APP首部</code>。<code>传输层</code>会在接收到上层协议的数据前面加上<code>传输层</code>首部（此处以<code>TCP</code>协议为例，图的<code>传输层</code>首部为<code>TCP首部</code>。当然<code>传输层</code>协议还有<code>UDP</code>协议），传输层会向下交给<code>网络层</code>。同样地，<code>网络层</code>会在数据前面加上网络层首部（如<code>IP</code>首部），然后<code>网络层</code>再将数据向下交给<code>链路层</code>，<code>数据链路层</code>会对数据进行最后一次封装，即在数据前面加上<code>数据链路层</code>首部（此处使用以太网接口为例），然后将数据交给<code>网卡</code>。最后，<code>网卡</code>将数据转换成物理链路上的电平信号，数据就这样被发送到了网络中。数据的发送过程，可以概括为TCP/IP的各层协议对数据进行封装的过程;<br>当设备的网卡接收到某个数据包后，它会将其放置在网卡的接收缓存中，并告知<code>TCP/IP</code>协议栈内核。然后<code>TCP/IP</code>协议栈内核就开始工作了，它会将数据包从接收缓存中取出，并逐层解析数据包中的协议首部信息，并最终将<code>数据</code>交给某个应用程序。数据的接收过程与发送过程正好相反，可以概括为TCP/IP的各层协议对数据进行解析的过程。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-5.png" alt="tcpip-5"></p><h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>关于以太网的理论我就不介绍了，因为这些理论太多了，有兴趣可以自己去网上查看。</p><h2 id="链路与数据链路"><a href="#链路与数据链路" class="headerlink" title="链路与数据链路"></a>链路与数据链路</h2><p>我们在这里要明确一下， “链路”和“数据链路”并不是一回事。<br>所谓<code>链路</code>就是从一个结点到相邻结点的一段物理线路（有线或无线）这是实实在在看得见的，比如我们的网线，而中间没有任何其他的交换结点。 在进行数据通信时， 两台计算机之间的通信路径往往要经过许多段这样的链路。 </p><p><code>数据链路</code>则是另一个概念。 这是因为当需要在一条线路上传送数据时， 除了<code>必须</code>有一条物理线路外，还必须有一些必要的协议来控制这些数据的传输，这就是我们<code>TCP/IP</code>协议栈要做的事情。 把这些<code>TCP/IP</code>协议栈加到链路上，就构成了数据链路。<br>一般我们所说的<code>链路层</code>指的都是<code>数据链路</code>。下文均采用<code>链路层</code>表示。</p><h2 id="LwIP中的“链路层”"><a href="#LwIP中的“链路层”" class="headerlink" title="LwIP中的“链路层”"></a>LwIP中的“链路层”</h2><p>我们知道，网络接口（如以太网接口）是硬件接口，（提示：网络接口又可以称之为网卡，为了统一，下文均采用网卡表示网络接口），LwIP是软件，<code>那么怎么让硬件与软件无缝连接起来呢？</code>而且，网卡又有多种多样，怎么能让<code>LwIP</code>使用同样的软件程序能兼容不同的硬件呢？</p><p>因此<code>LwIP</code>使用一个数据结构——<code>netif</code>来描述一个网卡，由于网卡是直接与硬件打交道的，硬件不同则处理基本是不同的，比如网卡的有各种各样的芯片，所以必须由<code>我们自己</code>提供最底层接口函数，<code>LwIP</code>提供统一的接口，比如网卡的初始化，网卡的收发数据，当<code>LwIP</code>底层得到了网络的数据之后，才会经过层层传入内核中去处理；同理，当应用层需要发送一个数据包的时候，也是讲数据包层层往下递交，然后也需要调用网卡的<code>发送函数</code>，将数据发送到网络中，这样子才能把数据从硬件接口到软件内核无缝连接起来。因此LwIP移植的关键是底层的移植，而很多人就卡在这里，如果底层的处理不好，那么就会导致各种各样的问题，比如网卡无缝接收太多数据，导致网速过慢，出现挂掉的现象，时常丢包，或者运行一段时间就导致内存泄漏等等等等乱七八糟的问题。</p><p>简单来说，<code>netif</code>是<code>LwIP</code>抽象出来的网卡描述符，它拥有描述设备中的不同网卡，一个设备至少与一个网卡，才能与网络进行通讯，<code>LwIP</code>协议栈可以使用多个不同的接口，而源码中的<code>ethernetif.c</code>文件则提供了<code>netif</code>访问各种不同的网卡，每个网卡有不同的实现方式，我们呢一般只需要修改<code>ethernetif.c</code>文件就行了，但是本篇文章不讲移植。（此处用LwIP协议栈讲解，本系列教程均基于<code>LwIP</code>）</p><p>举个例子：我们可以理解将整个网络的数据传输理解为物流，那么网卡就是不同的运输工具，我们可以选择汽车、飞机、轮船等运输工具，不同的运输工具速度是不一样的，但是对于一个物流公司而言，可能同时存在很多种运输的工具，这就需要物流公司去记录这些运输工具，当有一个包裹需要通过飞机运输出去，那么物流公司就会将这个包裹通过飞机发送出去，这就好比我们的网卡，需要哪个网卡发送或者接收网络数据的时候，就会让对应的网卡去工作。（可能不太贴切）</p><h2 id="MAC地址简介"><a href="#MAC地址简介" class="headerlink" title="MAC地址简介"></a>MAC地址简介</h2><blockquote><p>MAC地址（英语：Media Access Control Address），直译为媒体访问控制地址，也称为局域网地址（LAN Address），以太网地址（Ethernet Address）或物理地址（Physical Address），它是一个用来确认网络设备位置的地址。在OSI模型中，第三层网络层负责IP地址，第二层数据链接层则负责MAC地址。MAC地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址。（引用来自维基百科）</p></blockquote><p>可能我们做计算机相关专业的人，多多少少都会知道<code>IP地址</code>、<code>MAC地址</code>（也称之为链路层地址）。在前一篇文章说了，想要不同主机之间进行通讯，那么就必须有IP地址，<code>那现在为什么我们在链路层都需要地址呢？</code>事实上，并不是主机或路由器具有链路层地址，而是它们的<code>网卡</code>具有链路层地址。因此，一个主机拥有多少个网卡，那么它就有多少个<code>MAC地址</code>。MAC地址实际上就是网卡地址或网卡标识符。当某台计算机使用某块网卡后，网卡上的标识符就成为该计算机的MAC地址。MAC地址长度为<code>6</code>字节（<code>48bit</code>），其前<code>3</code>个字节表示组织唯一标志符（Organizationally Unique Identifier，即<code>OUI</code>），由<code>IEEE</code>的注册管理机构给不同厂家分配的代码，以区分不同的厂家，后3个字节由厂家自行分配，称为扩展标识符。同一个厂家生产的网卡中MAC地址后<code>24</code>位是不同的。</p><h2 id="IP地址与MAC地址的关系"><a href="#IP地址与MAC地址的关系" class="headerlink" title="IP地址与MAC地址的关系"></a>IP地址与MAC地址的关系</h2><p><code>TCP/IP</code>协议有自己的IP地址，IP地址（IPv4）是一个<code>32</code>位的IP地址，网络层发送数据包只需要知道目标主机IP地址即可，而以网卡发送数据则必须知道对方的硬件<code>MAC</code>地址，同时<code>IP</code>地址的分配与硬件<code>MAC</code>地址是没有关系的，为了让网络层只需要知道<code>IP地址</code>就可以完成通信工作，那就需要有一个协议将<code>IP</code>地址映射成为对应的<code>MAC</code>地址，此外还需要考虑<code>IP</code>地址可能是动态的，非常灵活，使用静态的映射方法是行不通的，所以<code>ARP</code>协议就提供优质的地址动态解析服务，让<code>32</code>位的<code>IP</code>地址能<code>映射</code>成为48位的<code>MAC地址</code>，让上层应用与底层完全分离开，这样子在上层应用就能灵活使用<code>IP</code>地址作为标识，进行通信。</p><p>简单来说，就是计算机中会维护一个ARP缓存表，这个表记录着IP地址与MAC地址的映射关系，我们可以通过在电脑的控制台通过arp -a指令查看一下我们自己计算机的ARP缓存表：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-6.png" alt="tcpip-6"></p><p>我给大家举个例子，IP地址就相当于你家的地址，MAC就是你的身份证，你的身份证是全国唯一的，这没疑问吧，但你的地址是可以跟别人重叠的（你家人也是住在你家）。当你寄快递的时候，快递员要确认这个快递是从你家寄出去的，是你本人亲自寄出去的，同样的，当你收快递的时候，快递员也是先电话找到你，然后必须是你本人才能拿到快递，再拿回家。（可能也不贴切，将就理解一下）</p><h2 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h2><p>链路层的主体部分是网卡中实现的，在发送的数据帧的时候，协议栈取得由高层传递过来的数据报（注意，数据帧与数据报不是一个东西，数据报是形容网络层及其以上的报文，而数据帧一般形容链路层的数据，是一帧一帧的，也是链路层的服务——数据成帧），在链路层中封装该数据报，也就是填写数据帧的各个字段，然后遵循链路接入协议将该帧数据进行传输；在接收端，控制器接收了整个数据帧，抽取出网络层的数据报，往上层传递。<br>下面来看看以太网帧：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-7.png" alt="tcpip-7"></p><p>一看这个以太网帧结构，就觉得它有7个字段，但是事实上，前同步码与帧开始符字段不能算是真正的以太网帧数据结构，他们是在网卡发送的时候自动添加进去的，为了数据的准确传输。</p><p>以太网帧以一个7字节的前同步码开始。该前同步码的值都是规定为<code>10101010</code>；而后紧接着一个字节的帧开始符，其值是<code>10101011</code>。前同步码字段的作用是实现物理层帧输入输出的同步，而帧开始符表示着以太网数据帧的开始，剩下的5个字段才是真正的以太网数据帧结构。 </p><p><strong>目标MAC地址（6字节）</strong>：这个字段包含目标网卡的MAC地址，当一个网卡收到一个以太网数据帧，如果该数据帧的目标地址是网卡自身的MAC地址或者是MAC广播地址，它都将该帧的数据字段的内容传递给网络层；如果它收到了具有任何其他MAC地址的帧，则将该数据帧丢弃。<br><strong>源MAC地址（6字节）</strong>：自身的MAC地址。<br><strong>类型字段（2字节）</strong>：类型字段允许以太网复用多种网络层协议。我们只需要记住主机能够使用除了<code>IP协议</code>以外的其他网络层协议。事实上，一台给定的主机可以支持多种网络层协议，以对不同的应用采用不同的协议。因此，当以太网帧到达网卡中，网卡需要知道它应该将数据字段的内容传递给哪个网络层协议。比如如有<code>IP</code>协议、<code>ARP</code>协议等。</p><p><code>注意了：当这个字段的值小于1518时，它表示后面数据字段的数据长度，当大于1518的时候才表示递交给哪个协议。</code></p><p><strong>数据字段（46~1500字节）</strong>：这个字段承载了IP数据报。以太网的最大传输单元（MTU）是1500字节。这意味着如果IP数据报超过了<code>1500</code>字节，则主机必须将该数据报分片（<code>IPv4</code>支持数据报分片，而<code>IPv6</code>不支持）。数据字段的最小长度是46字节，这意味着如果IP数据报小于<code>46</code>字节，数据报必须被填充到<code>46</code>字节。当采用填充时，传递到网络层的数据包括IP数据报和填充部分，网络层使用<code>IP</code>数据报首部中的长度字段来去除填充部分。<br><strong>CRC（4字节）</strong>：CRC字段包含了以太网的差错校验信息。<br><strong>补充</strong>：所有的以太网都向网络层提供不可靠的无连接服务，在接收到不对的以太网帧时，或者<code>CRC</code>校验不通过时，主机将直接丢弃以太网帧，并不会告知发送的一方。</p><p>未完待续…..<br>下一篇进入<code>协议篇</code></p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> TCP/IP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> TCP/IP </tag>
            
            <tag> LwIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARP协议原理</title>
      <link href="/tcpip-3/"/>
      <url>/tcpip-3/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>从前一篇文章中，我们知道计算机中会维护一个ARP缓存表，这个表记录着IP地址与MAC地址的映射关系，我们可以通过在电脑的控制台通过arp -a指令查看一下我们自己计算机的ARP缓存表：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-6.png" alt="tcpip-6"></p><p>那么什么是<code>ARP</code>协议呢？</p><h1 id="初识ARP"><a href="#初识ARP" class="headerlink" title="初识ARP"></a>初识ARP</h1><p>ARP协议是地址解析协议（<code>Address Resolution Protocol</code>）是通过解析<code>IP地址</code>得到<code>MAC地址</code>的，是一个在网络协议包中极其重要的网络传输协议，它与网卡有着极其密切的关系，在<code>TCP/IP</code>分层结构中，把<code>ARP</code>划分为<code>网络层</code>，为什么呢，因为在<code>网络层</code>看来，源主机与目标主机是通过<code>IP地址</code>进行识别的，而所有的数据传输又依赖网卡底层硬件，即<code>链路层</code>，那么就需要将这些<code>IP地址</code>转换为链路层可以识别的东西，在所有的链路中都有着自己的一套寻址机制，如在以太网中使用<code>MAC地址</code>进行寻址，以标识不同的主机，那么就需要有一个协议将<code>IP地址转换为MAC地址</code>，由此就出现了<code>ARP协议</code>，所有<code>ARP协议</code>在网络层被应用，它是网络层与链路层连接的重要枢纽，每当有一个数据要发送的时候都需要在通过<code>ARP协议</code>将<code>IP地址转换成MAC地址</code>，在IP层及其以上的层次看来，他们只标识IP地址，从不跟硬件打交道，就像我一样，我做应用层的工作，而不会去写底层驱动，得专门有个同事将驱动写完给我，我只需要知道他提供的API接口就行了，而我就专心处理我的工作，我相信他能把驱动写好，我只需要直接调用即可。</p><h1 id="ARP缓存表"><a href="#ARP缓存表" class="headerlink" title="ARP缓存表"></a>ARP缓存表</h1><p>既然已经解释了<code>ARP协议</code>的用途及重要性，那么它是如何工作的？为了实现<code>IP地址</code>与<code>MAC地址</code>的<code>查询与转换</code>，<code>ARP协议</code>引入了<code>ARP缓存表</code>的概念，每台主机或路由器在<code>维护</code>着一个<code>ARP缓存表（ARP table）</code>，这个表包含<code>IP地址到MAC地址的映射关系</code>，表中记录了<code>&lt;IP地址，MAC地址&gt;</code>对，我称之为<code>ARP表项</code>，如我们前面那张<code>图</code>所展示的一样，他们是主机<code>最近</code>运行时获得关于其他主机的<code>IP地址</code>到<code>MAC地址</code>的映射，当需要发送数据的时候，主机就会根据数据报中的<code>目标IP地址</code>信息，然后在ARP缓存表中进行查找对应的<code>MAC地址</code>，最后通过网卡将数据发送出去。<code>ARP缓存表</code>包含一个<code>寿命值（TTL，也称作生存时间）</code>，它将记录每个<code>ARP表项</code>的生存时间，生存时间到了就会从缓存表中删除。从一个表项放置到<code>ARP缓存表</code>中开始，一个表项通常的生存时间一般是<code>10</code>分钟吗，当然，这些生存时间是可以任意设置的，我们一般使用默认即可。</p><h1 id="一句话总结ARP协议的工作"><a href="#一句话总结ARP协议的工作" class="headerlink" title="一句话总结ARP协议的工作"></a>一句话总结ARP协议的工作</h1><p><strong>ARP协议的主要工作就是建立、查询、更新、删除ARP表项。</strong></p><h1 id="ARP表项的建立"><a href="#ARP表项的建立" class="headerlink" title="ARP表项的建立"></a>ARP表项的建立</h1><p>当主机开机的时候，<code>ARP缓存</code>表肯定是空的，那么怎么一步步<code>建立 ARP表项</code>呢？如果此时想发送数据怎么办呢？因为没有<code>ARP表项</code>，说明就找不到<code>IP地址</code>到<code>MAC地址</code>的<code>映射关系</code>，这样子也就无法发送数据了。<br>其实协议栈的实现还是很强大的，如果没有<code>ARP表项</code>，那么主机就会去建立<code>ARP表项</code>。<br>以我们的电脑为例，在开机的时候，我们的电脑肯定是没有<code>ARP表项</code>的（或者应该说只有路由器的<code>ARP表项</code>，因为可能是动态获取IP地址）：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-8.png" alt="tcpip-8"></p><h2 id="对于局域网"><a href="#对于局域网" class="headerlink" title="对于局域网"></a>对于局域网</h2><p>如果我想向局域网中的某个电脑发送一个数据，那么我的电脑就会从已有的<code>ARP缓存表</code>中寻找这个IP地址对应的物理地址的<code>ARP表项</code>，然后直接将数据写入以太网数据帧中让网卡进行发送即可，而如果没有找到这个<code>IP地址</code>，那么这个数据就没法立即发送，电脑会先在局域网上广播一个<code>ARP请求</code>（目标MAC地址为<code>FF-FF-FF-FF-FF-FF</code>），广播的ARP请求发出后，处于同一局域网内的所有主机都会接收到这个请求，如果<code>目标IP地址</code>与接收到ARP请求的主机<code>自身IP地址</code>吻合就会<code>返回</code>一个<code>ARP应答</code>，告诉请求者（即我的电脑）自身的<code>MAC地址</code>，当我的电脑收到这个<code>ARP应答</code>后，就去建立一个<code>ARP表项</code>，并且重新将数据发送出去。<br>ARP协议的核心就是对缓存表的操作，发送数据包的时候，查找<code>ARP缓存表</code>以得到对应的<code>MAC地址</code>，在ARP缓存表中的<code>TTL</code>即将过期的时候<code>更新</code>缓存表以保证<code>ARP表项</code>有效，此外ARP协议还需要不断处理来自局域网中其他主机的<code>ARP请求</code>。</p><h2 id="对于公网"><a href="#对于公网" class="headerlink" title="对于公网"></a>对于公网</h2><p>比如我的电脑向访问我的博客：<a href="https://jiejietop.cn" target="_blank" rel="noopener">https://jiejietop.cn</a><br>因为我的博客主机是处于外网的，那么我的电脑在访问的时候，也是找不到缓存表的，那它只能通过网关，让网关将数据转发到我的博客主机上，即：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-9.png" alt="tcpip-9"></p><p>因为我的电脑与博客主机不在一个网段，电脑查询自己的<code>路由表</code>，知道如果想和<code>博客主机</code>通信则必须通过<code>网关（gateway）</code>来中转，所以会在与<code>网关</code>直连的网卡上请求网关的<code>MAC地址</code>，因为电脑要把发给博客主机的数据先发给网关，当合法以太帧到达网关并且顺利接收，网关会将数据递交给<code>IP层</code>，IP层查询路由表，找到与博客主机直连的接口（假设是直连的，实际上肯定不是直连的），网关会发一个<code>ARP请求</code>到博客主机上，请求它的<code>MAC地址</code>，网关收到应答后将建立新的<code>ARP表项</code>并将开始维护<code>ARP缓存表</code>，然后完成最终的通信。</p><h1 id="ARP缓存表的超时处理"><a href="#ARP缓存表的超时处理" class="headerlink" title="ARP缓存表的超时处理"></a>ARP缓存表的超时处理</h1><p>ARP是<code>动态</code>处理的，现在总结一下：<code>ARP表项</code>的生存时间是一般为<code>5-10</code>分钟（<code>LwIP</code>中默认是<code>5</code>分钟），而<code>ARP请求</code>的等待时间是<code>5秒钟</code>，当这些时间到达后，就会<code>更新ARP表项</code>，如果在物理链路层无法连通则会删除表项。<br>因此每个协议栈的实现都必须维护着一个<code>定时器（超时机制）</code>来管理<code>ARP缓存表</code>，在必要的时候更新及删除<code>ARP表项</code>，关于怎么处理的我们就不多追究，有兴趣的可以看LwIP的<code>etharp_tmr()</code>源码。</p><blockquote><p>说点题外话：因为<code>ARP协议</code>是一个动态的协议，很多网络攻击都是利用<code>ARP协议</code>进行的，如<code>ARP欺骗，ARP洪水攻击</code>等等，而且这种攻击是很难防御的，当然也有办法，直接将动态的<code>ARP缓存表</code>设置为静态就行了，但是这就违背了<code>ARP协议</code>的<code>动态地址解析</code>特性。</p></blockquote><h1 id="ARP报文"><a href="#ARP报文" class="headerlink" title="ARP报文"></a>ARP报文</h1><p>ARP的请求与应答都是依赖<code>ARP报文</code>结构进行的，<code>ARP报文</code>是放在以太网数据帧中进行发送的，下面是<code>ARP报文</code>的格式：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-10.png" alt="tcpip-10"></p><p>当它封装在以太网帧中的格式：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-11.png" alt="tcpip-11"></p><p>在ARP表建立前，主机并不知道目标<code>MAC地址</code>，所以在一开始的时候只能通过广播的方式将<code>ARP请求包</code>发送出去，处于同一局域网的主机都能接收到广播的数据包。所以一开始目标<code>MAC地址</code>是<code>FF-FF-FF-FF-FF-FF</code>，而以太网首部的帧类型是有多种，对于<code>ARP数据包</code>来说，其值为<code>0x0806</code>，对于<code>IP数据报</code>来说，其值为<code>0x0800</code>。<br>在ARP首部一开始的2个字节存储的是硬件类型，表示要知道目标网卡的硬件类型，其中，值为<code>1</code>表示以太网地址；接下来还有<code>2</code>字节的协议类型，其中，<code>0x0800</code>表示<code>IP协议</code>，其他还可能是<code>ICMP/IGMP协议</code>等；接下来有1个字节表示硬件地址长度，指出该报文中硬件地址的长度，对于以太网硬件类型，它的值为<code>6</code>；还有1字节的协议地址长度，如果是<code>ARP协议、IP协议</code>等，该值为<code>4</code>；ARP首部最后的<code>op</code>字段用于记录ARP操作的类型，分别是：</p><ul><li>ARP请求，其值为1。</li><li>ARP应答，其值为2。</li><li>RARP请求，其值为3。</li><li>RARP应答，其值为4。</li></ul><p>我们只关心ARP的请求与应答即可，RARP是逆地址解析协议，在这里我们就不用去了解，它在网络中基本已经被淘汰，用于主机在启动的时候获得自己的IP地址。<br>对于ARP首部后面的四个字段分别是源MAC地址、源IP地址、目标MAC地址、目标IP地址，这些就是比较简单的了。<br>为了加深理解，我们使用<code>wireshark</code>网络抓包工具形象地讲解报文格式与内容，关于<code>wireshark</code>网络抓包工具的使用方式我就不做过多讲解，网上教程一大把，打开工具，然后抓取电脑网络中的数据包。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-12.png" alt="tcpip-12"></p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-13.png" alt="tcpip-13"></p><p>未完待续…<br>下一篇<code>LwIP中ARP协议的实现</code></p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> TCP/IP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> TCP/IP </tag>
            
            <tag> LwIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP协议栈扫盲班</title>
      <link href="/tcpip-1/"/>
      <url>/tcpip-1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文的东西是基础理论知识，因此不必记住，前面的操作系统的文章我不想更新了，现在想写一写网络相关的文章，本篇文章是第一篇，仅传递网络相关知识的概念，不必牢记~</p><h1 id="什么是TCP-IP协议"><a href="#什么是TCP-IP协议" class="headerlink" title="什么是TCP/IP协议"></a>什么是TCP/IP协议</h1><p>简单来说TCP/IP协议是网络中所有相关协议簇的简称，它是众多网络协议的集合，这一类协议簇是有非常多的协议，如常见的:<code>ARP/TCP/UDP/IP/ICMP/IGMP/HTTP/DNS/DHCP/TFP/MQTT</code>等等</p><h1 id="分层思想"><a href="#分层思想" class="headerlink" title="分层思想"></a>分层思想</h1><p><code>TCP/IP</code>模型是一个抽象的分层模型，这个模型中，所有的<code>TCP/IP</code>系列网络协议都被归类到4个抽象的”层”中。每一抽象层创建在低一层提供的服务上，并且为高一层提供服务。 完成一些特定的任务需要众多的协议协同工作，这些协议分布在参考模型的不同层中的，因此有时称它们为一个协议栈。<br>网络协议通常分不同层次进行开发，每一层分别负责不同的通信功能。一个协议族，比如<code>TCP/IP</code>，是一组不同层次上的多个协议的组合。<code>TCP/IP</code>通常被认为是一个四层协议系统，其分层模型如下：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-1.png" alt="tcpip-1"></p><p>每一层都负责不同的功能。</p><h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><p>也称作数据链路层或网络接口层，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>有时也称作互联网层，处理数据报在网络中的活动，例如数据报路由。其中网络层协议包括<code>IP</code>协议（网际协议）， <code>ICMP</code>协议（互联网控制报文协议），以及<code>IGMP</code>协议（英特网组管理协议）。</p><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>运输层主要为两台主机上的应用程序提供端到端的通信。在<code>TCP/IP</code>协议族中，有两个传输层协议： TCP（传输控制协议）和UDP（用户数据报协议）。TCP为两台主机提供<code>高可靠性</code>的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的<code>网络层</code>，同时还要确认接收到的数据是正确的，并且将其组装成有序的数据递交到应用层，同时还要处理超时重传、流量控制等。由于运输层提供了高可靠性的端到端的通信，因此应用层可以更加方便来处理数据。<br>而另一方面，<code>UDP</code>则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端，因此数据的可靠性必须由应用层来提供，这就导致应用层处理程序的困难，但是对于数据要求不可靠的传输通常使用UDP协议，如视频的播放等。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层就是用户程序，不同的应用会有不一样的操作</p><h3 id="运行在TCP协议上的应用程序协议："><a href="#运行在TCP协议上的应用程序协议：" class="headerlink" title="运行在TCP协议上的应用程序协议："></a>运行在TCP协议上的应用程序协议：</h3><p><strong>HTTP</strong>（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。<br><strong>HTTPS</strong>（Hypertext Transfer Protocol over Secure Socket Layer, or HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。<br><strong>FTP</strong>（File Transfer Protocol，文件传输协议），由名知义，用于文件传输。<br><strong>POP3</strong>（Post Office Protocol, version 3，邮局协议），收邮件用。<br><strong>SMTP</strong>（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。<br><strong>SSH</strong>（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。</p><h3 id="运行在UDP协议上的应用程序协议："><a href="#运行在UDP协议上的应用程序协议：" class="headerlink" title="运行在UDP协议上的应用程序协议："></a>运行在UDP协议上的应用程序协议：</h3><p><strong>BOOTP</strong>（Boot Protocol，启动协议），应用于无盘设备。<br><strong>NTP</strong>（Network Time Protocol，网络时间协议），用于网络同步。<br><strong>DHCP</strong>（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。</p><h3 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h3><p><strong>DNS</strong>（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作（运行在TCP和UDP协议上）。<br><strong>ECHO</strong>（Echo Protocol，回绕协议），用于查错及测量应答时间（运行在TCP和UDP协议上）。<br><strong>SNMP</strong>（Simple Network Management Protocol，简单网络管理协议），用于网络信息的收集和网络管理。<br><strong>ARP</strong>（Address Resolution Protocol，地址解析协议），用于动态解析以太网硬件的地址。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-2.png" alt="tcpip-2"></p><p>提示：图中的RARP是基本不怎么使用的协议</p><h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><p>为了标识互联网中的每台主机的身份，设计人员为每个接入网络中的主机都分配一个<code>IP</code>地址（<code>Internet Protocol Address</code>），是一个<code>32</code>位的整数地址，只有合法的<code>IP</code>地址才能接入互联网中并且与其他主机进行通信。注意了：<code>IP</code>地址是软件地址，是协议栈中识别主机身份的唯一标识。如果IP地址是不合法的，那么无法连接上公网（或者称为广域网）。</p><h2 id="IP分类编址"><a href="#IP分类编址" class="headerlink" title="IP分类编址"></a>IP分类编址</h2><p>互联网上的每个接口必须有一个唯一的IP地址, IP地址长 32bit,IP地址并不采用平面形式的地址空间，如 1、2、3等。 IP地址具有一定的结构，有五类不同的互联网地址格式:</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-3.png" alt="tcpip-3"></p><p><strong>A</strong> 类网络地址的第一个字节的第一位必须为0 ，因此， A 类网络地址第一个字节的取值范围<code>为0~127</code>（注意：但0 和127 不是有效的A 类网络地址号）<br><strong>B</strong> 类网络地址的第一个字节的第一位必须为1 ，且第二位必须为0，因此， B 类网络地址第一个字节的取值范围为<code>128~191</code><br><strong>C</strong> 类网络地址的第一个字节的第一位必须为1，第二位必须为1，第三位必须为0，因此C类网络第一个字节的取值范围为<code>192~223</code><br><strong>D</strong> 类IP地址的第一个字节前四位为<code>1110</code>，那么它第一个字节的取值范围为<code>224~239</code>，约占据了所有IP地址的十六分之一，它是一个专门保留的地址，它并不指向特定的网络，目前这一类地址被用于多播。<br><strong>E</strong> 类IP地址的第一个字节前四位必须为<code>1111</code>，那么它第一个字节的取值范围为<code>240~255</code>，约占据了所有IP地址的十六分之一，是为将来使用而保留的，其中32bit全为1的IP地址（255.255.255.255）用作广播地址。</p><p>IP地址特点<br>|类别|第一字节(二进制)|第一字节取值范围|网络号个数|主机号个数|适用范围|<br>|—|—|—|—|—|—|<br>|A类 |0XXX XXXX    |0<del>127     |125      |16777214    |大型网络|<br>|B类    |10XX XXXX    |128</del>191 |16368      |65534    |中型网络|<br>|C类    |110X XXXX    |192<del>223 |2097152 |254        |小型网络|<br>|D类    |1110 XXXX    |224</del>239 |—          |—        |多播|<br>|E类    |1111 XXXX    |240~255 |—          |—        |保留|</p><h2 id="局域网的概念"><a href="#局域网的概念" class="headerlink" title="局域网的概念"></a>局域网的概念</h2><p>局域网（<code>Local Area Network</code>，缩写为<code>LAN</code>），又称内网，指覆盖局部区域（如办公室或楼层）的计算机网络，局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能，是在一定区域内由多个计算机连接组成的网络，比如腾讯、阿里的内网，在内部的计算机上的数据可以互联互通、数据共享等。简单来说，当我们使用的开发板接入路由器的时候，电脑的网络也接入路由器，那么开发板与电脑就组成局域网，数据在链路层上是互联互通的。当然，板子也能通过网线直连电脑，这样子也是组成一个局域网络，数据可以在两个主机之间进行通信。</p><h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><p>广域网（<code>Wide Area Network</code>，缩写为<code>WAN</code>），又称广域网、外网（与翻墙的外网是不一样的概念）、公网。是连接不同地区计算机以进行通信的网络，这种网络通常会跨越很大的范围，覆盖的范围从几十公里到几千公里，它能连接多个地区、城市并能提供远距离通信服务，但是注意的是我们说的广域网并不等同于互联网。<br>简单来说（我使用比喻的方式表达），如果局域网是小溪，不同区域有很多的小溪，这些小溪汇聚成江河，那么这些江河就是广域网，然后这些江河再流入大海，这个大海就是互联网。互联网就是由无数个局域网，通过广域网线路汇聚互联起来，就形成了互联网。互联网的特点是开放、互联，如果一个公司的局域网没有连接到互联网，那这个局域网就不属于互联网，仅仅属于内部通信的网络。<br>举个例子，如果你家在某网络运营商办理了网络服务，可能他们将送你一个光猫，然后你拿着这个光猫就能上网了，你可能觉得需要多人使用网络，所以你又去买了一个无线路由器，让家人也能连接到网络上，那么这个家就是一个局域网，然后局域网的通信是通过运营商连接到广域网上的。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-4.png" alt="tcpip-4"></p><p>这个示意图虽然简单，却把<code>LAN、WAN、Internet</code>三者全包含了。无线路由器把电脑、手机等设备连接到局域网<code>LAN</code>上，并分配IP地址，即局域网<code>IP</code>，我们可以称之为<code>LAN-IP</code>，<code>LAN-IP</code>所到之处，就是局域网的范围，像我们电脑的IP地址<code>（192.168.1.xxx）</code>就是一个局域网<code>IP</code>，而路由器的地址就是运营商给我们的一个<code>IP</code>地址，这个IP地址是绝对合法的，可以看做是<code>WAN-IP</code>（实际上这个<code>IP</code>地址也是运营商的局域网IP地址（相对运营商来说），这个地址在运营商中转换成一个真正的广域网<code>IP</code>地址，因为真正的IP地址是不够的，只能再细分下去，但是这些事情我们暂时<code>无需理会</code>，只要把路由器的IP地址看做是<code>WAN-IP</code>即可）。<br>而运营商是一个边界，国家与国家之间有边界，网络之间也有边界，运营商就是局域网<code>LAN</code>与广域网<code>WAN</code>的边界。局域网<code>LAN-IP</code>可以在局域网内部有效，但是无法跨越边界进入广域网中，LAN-IP是路由器分配给我们的IP，那么我们想要跨越边界进入广域网中，就需要将LAN-IP变成有效的的IP地址，也就是<code>WAN-IP</code>，那么在路由器中就需要将IP地址进行转换，完成<code>LAN-IP&lt;—&gt;WAN-IP</code>地址转换（<code>NAT</code>）。<br>当持有<code>WAN-IP</code>的IP包顺利到达下一个边界<code>Internet Gateway</code>，这是通往互联网<code>Internet</code>的最后一道关卡，即边界。左边是广域网，右边是互联网，也需要做<code>WAN-IP 与 Global-IP</code>（互联网公共IP）的转换才能进入互联网中，我们知道这种概念即可，无需过多深入。</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> TCP/IP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> TCP/IP </tag>
            
            <tag> LwIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TencentOS  tiny】深度源码分析（8）——软件定时器</title>
      <link href="/tencentos-tiny-10/"/>
      <url>/tencentos-tiny-10/</url>
      
        <content type="html"><![CDATA[<h1 id="软件定时器的基本概念"><a href="#软件定时器的基本概念" class="headerlink" title="软件定时器的基本概念"></a>软件定时器的基本概念</h1><p>TencentOS tiny 的软件定时器是由操作系统提供的一类<code>系统接口</code>，它构建在硬件定时器基础之上，使系统能够提供不受硬件定时器资源限制的定时器服务，本质上软件定时器的使用相当于扩展了定时器的数量，允许创建更多的定时业务，它实现的功能与硬件定时器也是类似的。</p><blockquote><p>硬件定时器是芯片本身提供的定时功能。一般是由外部晶振提供给芯片输入时钟，芯片向软件模块提供一组配置寄存器，接受控制输入，到达设定时间值后芯片中断控制器产生时钟中断。硬件定时器的精度一般很高，可以达到纳秒级别，并且是中断触发方式。</p></blockquote><p>软件定时器的超时处理是指：在定时时间到达之后就会自动触发一个超时，然后系统跳转到对应的函数去处理这个超时，此时，调用的函数也被称<code>回调函数</code>。</p><p>回调函数的执行环境可以是<code>中断</code>，也可以是<code>任务</code>，这就需要你自己在<code>tos_config.h</code>通过<code>TOS_CFG_TIMER_AS_PROC</code>宏定义选择回调函数的执行环境了。</p><ul><li><code>TOS_CFG_TIMER_AS_PROC  为 1</code> ：回调函数的执行环境是<code>中断</code></li><li><code>TOS_CFG_TIMER_AS_PROC  为 0</code> ：回调函数的执行环境是<code>任务</code></li></ul><p>这与硬件定时器的中断服务函数很类似，无论是在中断中还是在任务中，回调函数的处理尽可能<code>简短，快进快出</code>。</p><p>软件定时器在被创建之后，当经过设定的超时时间后会触发回调函数，定时精度与系统时钟的周期有关，一般可以采用SysTick作为软件定时器的时基（在<code>m核</code>单片机中几乎都是采用SysTick作为系统时基，而软件定时器又是基于系统时基之上）。</p><p><code>TencentOS tiny</code>提供的软件定时器支持单次模式和周期模式，单次模式和周期模式的定时时间到之后都会调用软件定时器的回调函数。</p><ul><li><p><code>单次模式</code>：当用户创建了定时器并启动了定时器后，指定超时时间到达，只执行<code>一次</code>回调函数之后就将该定时器停止，不再重新执行。</p></li><li><p><code>周期模式</code>：这个定时器会按照指定的定时时间循环执行回调函数，直到将定时器删除。</p></li></ul><blockquote><p>在很多应用中，可能需要一些定时器任务，硬件定时器受硬件的限制，数量上不足以满足用户的实际需求，无法提供更多的定时器，可以采用软件定时器，由软件定时器代替硬件定时器任务。但需要注意的是软件定时器的精度是无法和硬件定时器相比的，因为在软件定时器的定时过程中是极有可能被其他中断打断，因此软件定时器更适用于对时间精度要求不高的任务。</p></blockquote><p>软件定时器以<code>tick</code>为基本计时单位，当用户创建并<code>启动</code>一个软件定时器时， <code>TencentOS tiny</code>会根据当前系统<code>tick</code>与用户指定的超时时间计算出该定时器超时的时间expires，并将该定时器插入软件定时器列表。</p><h1 id="软件定时器的数据结构"><a href="#软件定时器的数据结构" class="headerlink" title="软件定时器的数据结构"></a>软件定时器的数据结构</h1><blockquote><p>以下软件定时器的相关数据结构都在<code>tos_global.c</code>中定义</p></blockquote><h2 id="软件定时器列表"><a href="#软件定时器列表" class="headerlink" title="软件定时器列表"></a>软件定时器列表</h2><p>软件定时器列表用于记录系统中所有的软件定时器，这些软件定时器将按照唤醒时间升序插入软件定时器列表<code>k_timer_ctl.list</code> 中，它的数据类型是<code>timer_ctl_t</code>。</p><pre class="line-numbers language-js"><code class="language-js">timer_ctl_t         k_timer_ctl <span class="token operator">=</span> <span class="token punctuation">{</span> TOS_TIME_FOREVER<span class="token punctuation">,</span> <span class="token function">TOS_LIST_NODE</span><span class="token punctuation">(</span>k_timer_ctl<span class="token punctuation">.</span>list<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>typedef struct timer_control_st <span class="token punctuation">{</span>    k_tick_t    next_expires<span class="token punctuation">;</span>    k_list_t    list<span class="token punctuation">;</span><span class="token punctuation">}</span> timer_ctl_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>next_expires</code>：记录下一个到期的软件定时器时间。</li><li><code>list</code>：软件定时器列表，所有的软件定时器都会被挂载到这个列表中。</li></ul><h2 id="软件定时器任务相关的数据结构"><a href="#软件定时器任务相关的数据结构" class="headerlink" title="软件定时器任务相关的数据结构"></a>软件定时器任务相关的数据结构</h2><p>如果 <code>TOS_CFG_TIMER_AS_PROC</code> 宏定义为0，则表示使用软件定时器任务处理软件定时器的回调函数，那么此时软件定时器的回调函数执行环境为任务；反之软件定时器回调函数的处理将在中断上下文环境中。</p><pre class="line-numbers language-js"><code class="language-js">k_task_t            k_timer_task<span class="token punctuation">;</span>k_stack_t           k_timer_task_stk<span class="token punctuation">[</span>TOS_CFG_TIMER_TASK_STK_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>k_prio_t            <span class="token keyword">const</span> k_timer_task_prio         <span class="token operator">=</span> TOS_CFG_TIMER_TASK_PRIO<span class="token punctuation">;</span>k_stack_t          <span class="token operator">*</span><span class="token keyword">const</span> k_timer_task_stk_addr     <span class="token operator">=</span> <span class="token operator">&amp;</span>k_timer_task_stk<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>size_t              <span class="token keyword">const</span> k_timer_task_stk_size     <span class="token operator">=</span> TOS_CFG_TIMER_TASK_STK_SIZE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>k_timer_task</code>：软件定时器任务控制块</li><li><code>k_timer_task_stk</code>：软件定时器任务栈，其大小为<code>TOS_CFG_TIMER_TASK_STK_SIZE</code></li><li><code>k_timer_task_prio</code>：软件定时器任务优先级，值为<code>TOS_CFG_TIMER_TASK_PRIO</code>，默认值是 <code>(k_prio_t)(K_TASK_PRIO_IDLE - (k_prio_t)1u)</code>，比空闲任务高<code>1</code>个数值优先级，杰杰认为这也是很低的优先级了，这样一来软件定时器的精度将更低，不过好在这个值是可以被用户自定义的，想让精度高一点就将这个软件定时器任务优先级设置得高一点就好。</li><li>k_timer_task_stk_addr：软件定时器任务栈起始地址。</li><li>k_timer_task_stk_size：软件定时器任务栈大小。</li></ul><blockquote><p>以下软件定时器的相关数据结构都在<code>tos_timer.h</code>中定义</p></blockquote><h2 id="软件定时器的回调函数"><a href="#软件定时器的回调函数" class="headerlink" title="软件定时器的回调函数"></a>软件定时器的回调函数</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 软件定时器的回调函数类型</span>typedef <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>k_timer_callback_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>软件定时器的回调函数是一个函数指针的形式，它支持传入一个<code>void指针</code>类型的数据。</p><h2 id="软件定时器控制块"><a href="#软件定时器控制块" class="headerlink" title="软件定时器控制块"></a>软件定时器控制块</h2><p>每个软件定时器都有对应的软件定时器控制块，每个软件定时器控制块都包含了软件定时器的基本信息，如软件定时器的状态、软件定时器工作模式、软件定时器的周期，剩余时间，以及软件定时器回调函数等信息。</p><pre class="line-numbers language-js"><code class="language-js">typedef struct k_timer_st <span class="token punctuation">{</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    knl_obj_t               knl_obj<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**&lt; 仅为了验证,测试当前内核对象是否真的是一个软件定时器 */</span>#endif    k_timer_callback_t      cb<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/**&lt; 时间到时回调函数 */</span>    <span class="token keyword">void</span>                   <span class="token operator">*</span>cb_arg<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/**&lt; 回调函数中传入的参数 */</span>    k_list_t                list<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/**&lt; 挂载到软件定时器列表的节点 */</span>    k_tick_t                expires<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**&lt; 距离软件定时器的到期时间到期还剩多少时间（单位为tick） */</span>    k_tick_t                delay<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/**&lt; 还剩多少时间运行第一个到期的软件定时器（的回调函数） */</span>    k_tick_t                period<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/**&lt; 软件定时器的周期 */</span>    k_opt_t                 opt<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**&lt; 软件定时器的工作模式选项，可以是单次模式TOS_OPT_TIMER_ONESHOT，也可以是周期模式TOS_OPT_TIMER_PERIODIC */</span>    timer_state_t           state<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/**&lt; 软件定时器的状态 */</span><span class="token punctuation">}</span> k_timer_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="软件定时器的工作模式"><a href="#软件定时器的工作模式" class="headerlink" title="软件定时器的工作模式"></a>软件定时器的工作模式</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// if we just want the timer to run only once, this option should be passed to tos_timer_create.</span>#define TOS_OPT_TIMER_ONESHOT                   <span class="token punctuation">(</span>k_opt_t<span class="token punctuation">)</span><span class="token punctuation">(</span>0x0001u<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// if we want the timer run periodically, this option should be passed to tos_timer_create.</span>#define TOS_OPT_TIMER_PERIODIC                  <span class="token punctuation">(</span>k_opt_t<span class="token punctuation">)</span><span class="token punctuation">(</span>0x0002u<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>TOS_OPT_TIMER_ONESHOT</code>：<strong>单次</strong>模式，软件定时器在超时后，只会执行一次回调函数，它的状态将被设置为<code>TIMER_STATE_COMPLETED</code>，不再重新执行它的回调函数，当然，用户还是可以重新启动这个单次模式的软件定时器，它并未被删除。</p><blockquote><p>如果只希望计时器运行一次，则应将此选项传递给<code>tos_timer_create()</code>。</p></blockquote></li><li><p>TOS_OPT_TIMER_PERIODIC ：<strong>周期</strong>模式 ，软件定时器在超时后，会执行对应的回调函数，同时根据软件定时器控制块中的<code>period</code>成员变量的值再重新插入软件定时器列表中，这个定时器会按照指定的定时时间循环执行（周期性执行）回调函数，直到用户将定时器删除。</p><blockquote><p>如果我们希望计时器周期运行，则应将此选项传递给<code>tos_timer_create()</code>。</p></blockquote></li></ul><h2 id="软件定时器的状态"><a href="#软件定时器的状态" class="headerlink" title="软件定时器的状态"></a>软件定时器的状态</h2><p>定时器状态有以下几种：</p><pre class="line-numbers language-js"><code class="language-js">typedef <span class="token keyword">enum</span> timer_state_en <span class="token punctuation">{</span>    TIMER_STATE_UNUSED<span class="token punctuation">,</span>     <span class="token comment" spellcheck="true">/**&lt; the timer has been destroyed */</span>    TIMER_STATE_STOPPED<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/**&lt; the timer has been created but not been started, or just be stopped(tos_timer_stop) */</span>    TIMER_STATE_RUNNING<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/**&lt; the timer has been created and been started */</span>    TIMER_STATE_COMPLETED   <span class="token comment" spellcheck="true">/**&lt; the timer has finished its expires, it can only happen when the timer's opt is TOS_OPT_TIMER_ONESHOT */</span><span class="token punctuation">}</span> timer_state_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>TIMER_STATE_UNUSED</code>：未使用状态。</p></li><li><p><code>TIMER_STATE_STOPPED</code>：<code>创建</code>了软件定时器，但此时软件定时器<code>未启动</code>或者处于<code>停止</code>状态，调用<code>tos_timer_create()</code>函数接口或者在软件定时器启动后调用<code>tos_timer_stop()</code>函数接口后，定时器将变成该状态。</p></li><li><p><code>TIMER_STATE_RUNNING</code>：软件定时器处于运行状态，在定时器被<code>创建</code>后调用<code>tos_timer_start()</code>函数接口，定时器将变成该状态，表示定时器运行时的状态。</p></li><li><p><code>TIMER_STATE_COMPLETED</code>：软件定时器已到期，只有在软件定时器的模式选择为<code>TOS_OPT_TIMER_ONESHOT</code>时才可能发生，表示软件定时器已经完成了。</p></li></ul><h1 id="创建软件定时器"><a href="#创建软件定时器" class="headerlink" title="创建软件定时器"></a>创建软件定时器</h1><p><strong>函数</strong></p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_timer_create</span><span class="token punctuation">(</span>k_timer_t <span class="token operator">*</span>tmr<span class="token punctuation">,</span>                                 k_tick_t delay<span class="token punctuation">,</span>                                 k_tick_t period<span class="token punctuation">,</span>                                 k_timer_callback_t callback<span class="token punctuation">,</span>                                 <span class="token keyword">void</span> <span class="token operator">*</span>cb_arg<span class="token punctuation">,</span>                                 k_opt_t opt<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参数</strong></p><table><thead><tr><th>参数</th><th>说明（杰杰）</th></tr></thead><tbody><tr><td>tmr</td><td>软件定时器控制块指针</td></tr><tr><td>delay</td><td>软件定时器第一次运行的延迟时间间隔</td></tr><tr><td>period</td><td>软件定时器的周期</td></tr><tr><td>callback</td><td>软件定时器的回调函数，在超时时调用（由用户自己定义）</td></tr><tr><td>cb_arg</td><td>用于回调函数传入的形参（void指针类型）</td></tr><tr><td>opt</td><td>软件定时器的工作模式（单次 / 周期）</td></tr></tbody></table><blockquote><p>杰杰觉得 <code>delay</code>与 <code>period</code> 比较有意思，就简单提一下 <code>delay</code> 参数与 <code>period</code> 参数的意义与区别：</p><ul><li><code>delay</code>参数其实是第一次运行的延迟时间间隔（即第一次调用回调函数的时间），如果软件定时器是单次模式，那么只用 <code>delay</code> 参数作为软件定时器的回调时间，因为软件定时器是单次工作模式的话，只会运行一次回调函数，那么就没有周期一说（<code>period</code> 参数将不起作用），只能是以第一次运行的延迟时间间隔作为它的回调时间。</li><li><code>period</code> 参数则是作为软件定时器的周期性回调的时间间隔，就好比你的闹钟，每天 7 点叫你起床，但是<code>delay</code>参数在周期工作模式下的软件定时器也是有作用的，它是对第一次回调函数的延迟时间，举个例子：今天晚上<code>9</code>点的时候，你设置了一个闹钟，闹钟时间是每天早上<code>7</code>点的，那么在<code>10</code>个小时后，闹钟将叫你起床，那么这10个小时就相当于<code>delay</code>参数的值，因为闹钟第一次叫你起床并不是在<code>24</code>小时后，而在明天7点后，闹钟响了，此时闹钟将在一天后才会再响，这24小时则相当于 <code>period</code> 参数的值。</li></ul></blockquote><p>系统中每个软件定时器都有对应的软件定时器控制块，软件定时器控制块中包含了软件定时器的所有信息，那么可以想象一下，创建软件定时器的本质是不是就是对软件定时器控制块进行初始化呢？很显然就是这样子的。因为在后续对软件定时器的操作都是通过软件定时器控制块来操作的，如果控制块没有信息，那怎么能操作嘛~</p><p>步骤如下：</p><ol><li><p>判断传入的参数是否正确：软件定时器控制块不为<code>null</code>，回调函数不为<code>null</code>，如果是创建周期模式的软件定时器，那么 <code>period</code> 参数则不可以为<code>0</code>，而如果是单次模式的软件定时器，参数<code>delay</code>则不可以为<code>0</code>，无论是何种模式的软件定时器，<code>delay</code> 参数与 <code>period</code> 参数都不可以为<code>K_ERR_TIMER_PERIOD_FOREVER</code>，因为这代表着软件定时器不需要运行，那还创建个锤子啊。</p></li><li><p>根据传入的参数将软件定时器控制块的成员变量赋初值，软件定时器状态<code>state</code>被设置为<code>TIMER_STATE_STOPPED</code>，<code>expires</code> 则被设置为<code>0</code>，因为还尚未启动软件定时器。</p></li><li><p>调用<code>tos_list_init()</code>函数将软件定时器控制块中可挂载到<code>k_tick_list</code>列表的节点初始化。</p></li></ol><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_timer_create</span><span class="token punctuation">(</span>k_timer_t <span class="token operator">*</span>tmr<span class="token punctuation">,</span>                                 k_tick_t delay<span class="token punctuation">,</span>                                 k_tick_t period<span class="token punctuation">,</span>                                 k_timer_callback_t callback<span class="token punctuation">,</span>                                 <span class="token keyword">void</span> <span class="token operator">*</span>cb_arg<span class="token punctuation">,</span>                                 k_opt_t opt<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>opt <span class="token operator">==</span> TOS_OPT_TIMER_PERIODIC <span class="token operator">&amp;&amp;</span> period <span class="token operator">==</span> <span class="token punctuation">(</span>k_tick_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TIMER_INVALID_PERIOD<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>opt <span class="token operator">==</span> TOS_OPT_TIMER_ONESHOT <span class="token operator">&amp;&amp;</span> delay <span class="token operator">==</span> <span class="token punctuation">(</span>k_tick_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TIMER_INVALID_DELAY<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>opt <span class="token operator">!=</span> TOS_OPT_TIMER_ONESHOT <span class="token operator">&amp;&amp;</span> opt <span class="token operator">!=</span> TOS_OPT_TIMER_PERIODIC<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TIMER_INVALID_OPT<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>delay <span class="token operator">==</span> TOS_TIME_FOREVER<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TIMER_DELAY_FOREVER<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>period <span class="token operator">==</span> TOS_TIME_FOREVER<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TIMER_PERIOD_FOREVER<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token function">knl_object_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tmr<span class="token operator">-</span><span class="token operator">></span>knl_obj<span class="token punctuation">,</span> KNL_OBJ_TYPE_TIMER<span class="token punctuation">)</span><span class="token punctuation">;</span>#endif    tmr<span class="token operator">-</span><span class="token operator">></span>state          <span class="token operator">=</span> TIMER_STATE_STOPPED<span class="token punctuation">;</span>    tmr<span class="token operator">-</span><span class="token operator">></span>delay          <span class="token operator">=</span> delay<span class="token punctuation">;</span>    tmr<span class="token operator">-</span><span class="token operator">></span>expires        <span class="token operator">=</span> <span class="token punctuation">(</span>k_tick_t<span class="token punctuation">)</span>0u<span class="token punctuation">;</span>    tmr<span class="token operator">-</span><span class="token operator">></span>period         <span class="token operator">=</span> period<span class="token punctuation">;</span>    tmr<span class="token operator">-</span><span class="token operator">></span>opt            <span class="token operator">=</span> opt<span class="token punctuation">;</span>    tmr<span class="token operator">-</span><span class="token operator">></span>cb             <span class="token operator">=</span> callback<span class="token punctuation">;</span>    tmr<span class="token operator">-</span><span class="token operator">></span>cb_arg         <span class="token operator">=</span> cb_arg<span class="token punctuation">;</span>    <span class="token function">tos_list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tmr<span class="token operator">-</span><span class="token operator">></span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="销毁软件定时器"><a href="#销毁软件定时器" class="headerlink" title="销毁软件定时器"></a>销毁软件定时器</h1><p>软件定时器销毁函数是根据软件定时器控制块直接销毁的，销毁之后软件定时器的所有信息都会被清除，而且不能再次使用这个软件定时器，如果软件定时器处于运行状态，那么就需要将被销毁的软件定时器停止，然后再进行销毁操作。<br>其过程如下：</p><ol><li><p>判断软件定时器是否有效，然后根据软件定时器状态判断软件定时器是否创建，如果是未使用状态<code>TIMER_STATE_UNUSED</code>，则直接返回错误代码<code>K_ERR_TIMER_INACTIVE</code>。</p></li><li><p>如果软件定时器状态是 <code>运行</code>状态 <code>TIMER_STATE_RUNNING</code>，那么调用<code>timer_takeoff()</code>函数将软件定时器停止。</p></li><li><p>最后调用<code>timer_reset()</code>函数将软件定时器控制块的内容重置，主要是将软件定时器的状态设置为未使用状态<code>TIMER_STATE_UNUSED</code>，将对应的回调函数设置为<code>null</code>。</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_timer_destroy</span><span class="token punctuation">(</span>k_timer_t <span class="token operator">*</span>tmr<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><p>#if TOS_CFG_OBJECT_VERIFY_EN &gt; 0u<br>    if (!knl_object_verify(&amp;tmr-&gt;knl_obj, KNL_OBJ_TYPE_TIMER)) {<br>        return K_ERR_OBJ_INVALID;<br>    }<br>#endif</p><pre><code>if (tmr-&gt;state == TIMER_STATE_UNUSED) {    return K_ERR_TIMER_INACTIVE;}if (tmr-&gt;state == TIMER_STATE_RUNNING) {    timer_takeoff(tmr);}timer_reset(tmr);return K_ERR_NONE;</code></pre><p>}</p><pre><code># 停止软件定时器（内部函数）在销毁软件定时器的时候提到了`timer_takeoff()`函数，那么就来看看这个函数具体是怎么样停止软件定时器的，其实本质上就是将软件定时器从软件定时器列表中移除。&gt; 注意，这个函数是内部静态函数，不是给用户使用的，它与`tos_timer_stop()`不同。 1. 首先通过`TOS_LIST_FIRST_ENTRY`宏定义将软件定时器列表`k_timer_ctl.list`中的第一个软件定时器取出，因为防止软件定时器列表中的第一个软件定时器被移除了，而没有重置软件定时器列表中的相关的信息，因此此时要记录一下第一个软件定时器。 2. 调用`tos_list_del()`将软件定时器从软件定时器列表中移除，表示中国软件定时器就被停止了，因为不知软件定时器列表中，中国软件定时器也就不会被处理。 3. 判断一下移除的软件定时器是不是第一个软件定时器，如果是，则重置相关信息。如果软件定时器列表中不存在其他软件定时器，则将软件定时器列表的下一个到期时间设置为`TOS_TIME_FOREVER`，反正则让软件定时器列表的下一个到期时间为第二个软件定时器。```js__STATIC__ void timer_takeoff(k_timer_t *tmr){    TOS_CPU_CPSR_ALLOC();    k_timer_t *first, *next;    TOS_CPU_INT_DISABLE();    first = TOS_LIST_FIRST_ENTRY(&amp;k_timer_ctl.list, k_timer_t, list);    tos_list_del(&amp;tmr-&gt;list);    if (first == tmr) {        // if the first guy removed, we need to refresh k_timer_ctl.next_expires        next = TOS_LIST_FIRST_ENTRY_OR_NULL(&amp;tmr-&gt;list, k_timer_t, list);        if (!next) {            // the only guy removed            k_timer_ctl.next_expires = TOS_TIME_FOREVER;        } else {            k_timer_ctl.next_expires = next-&gt;expires;        }    }    TOS_CPU_INT_ENABLE();}</code></pre><h1 id="启动软件定时器"><a href="#启动软件定时器" class="headerlink" title="启动软件定时器"></a>启动软件定时器</h1><p>在创建成功软件定时器的时候，软件定时器的状态从<code>TIMER_STATE_UNUSED</code>（未使用状态）变成<code>TIMER_STATE_STOPPED</code>（创建但未启动 / 停止状态），创建完成的软件定时器是未运行的，用户在需要的时候可以启动它，TencentOS tiny提供了软件定时器启动函数<code>tos_timer_start()</code>。启动软件定时器的本质就是将软件定时器插入软件定时器列表<code>k_timer_ctl.list</code> 中，既然是这样子，那么很显然需要根据软件定时器的不同状态进行不同的处理。</p><p><strong>其实现过程如下</strong>：判断软件定时器控制块是否为<code>null</code>，然后判断软件定时器状态，如果为未使用状态<code>TIMER_STATE_UNUSED</code>则直接返回错误代码<code>K_ERR_TIMER_INACTIVE</code>；如果为已经运行状态<code>TIMER_STATE_RUNNING</code>，那么将软件定时器停止，然重新插入软件定时器列表<code>k_timer_ctl.list</code>中；如果是<code>TIMER_STATE_STOPPED</code>或者<code>TIMER_STATE_COMPLETED</code>状态，则将软件定时器的状态重新设置为运行状态<code>TIMER_STATE_RUNNING</code>，并且插入软件定时器列表<code>k_timer_ctl.list</code>中。</p><blockquote><p>注意：插入软件定时器列表的函数是<code>timer_place()</code>。</p></blockquote><blockquote><p><code>tos_timer_start()</code>函数将软件定时器控制块的<code>period</code>或者<code>delay</code>成员变量的值赋值给<code>expires</code>，但这个值是相对的到期时间，而不是绝对值，因此在<code>timer_place()</code>函数中将重新计算得出绝对的到期时间。</p></blockquote><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_timer_start</span><span class="token punctuation">(</span>k_timer_t <span class="token operator">*</span>tmr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">knl_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tmr<span class="token operator">-</span><span class="token operator">></span>knl_obj<span class="token punctuation">,</span> KNL_OBJ_TYPE_TIMER<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">==</span> TIMER_STATE_UNUSED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TIMER_INACTIVE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">==</span> TIMER_STATE_RUNNING<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">timer_takeoff</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span>        tmr<span class="token operator">-</span><span class="token operator">></span>expires <span class="token operator">=</span> tmr<span class="token operator">-</span><span class="token operator">></span>delay<span class="token punctuation">;</span>        <span class="token function">timer_place</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">==</span> TIMER_STATE_STOPPED <span class="token operator">||</span>        tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">==</span> TIMER_STATE_COMPLETED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">=</span> TIMER_STATE_RUNNING<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>delay <span class="token operator">==</span> <span class="token punctuation">(</span>k_tick_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>            tmr<span class="token operator">-</span><span class="token operator">></span>expires <span class="token operator">=</span> tmr<span class="token operator">-</span><span class="token operator">></span>period<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            tmr<span class="token operator">-</span><span class="token operator">></span>expires <span class="token operator">=</span> tmr<span class="token operator">-</span><span class="token operator">></span>delay<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">timer_place</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> K_ERR_TIMER_INVALID_STATE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="插入软件定时器列表"><a href="#插入软件定时器列表" class="headerlink" title="插入软件定时器列表"></a>插入软件定时器列表</h1><p>插入软件定时器列表的函数是<code>timer_place()</code>，这个函数会根据软件定时器的到期时间升序排序，然后再插入。</p><blockquote><p>该函数是一个内部实现的静态函数</p></blockquote><p>实现过程如下：</p><ol><li>根据软件定时器的到期时间<code>expires</code>（相对值） 与系统当前时间<code>k_tick_count</code>计算得出到期时间<code>expires</code>（绝对值）。<blockquote><p>举个例子，闹钟将在10分钟后叫我起床（这是一个<code>相对值</code>）。闹钟将在当前时间（7:00）的10分钟后叫我起床，那么闹钟响的时间是7:10分，此时的时间就是<code>绝对值</code>。</p></blockquote></li></ol><ol start="2"><li><p>通过for循环<code>TOS_LIST_FOR_EACH</code>找到合适的位置插入软件定时器列表，此时插入软件定时器列表安装到期时间升序插入。</p></li><li><p>找到合适的位置后，调用<code>tos_list_add_tail()</code>函数将软件定时器插入软件定时器列表。</p></li><li><p>如果插入的软件定时器是唯一定时器列表中的第一个，那么相应的，下一个到期时间就是这个软件定时器的到期时间，将到期时间更新： <code>k_timer_ctl.next_expires = tmr-&gt;expires</code>。如果<code>TOS_CFG_TIMER_AS_PROC</code> 宏定义为0，则判断一下软件定时器任务是否处于睡眠状态，如果是则调用<code>tos_task_delay_abort()</code>函数恢复软件定时器任务运行，以便于更新它休眠的时间，因为此时是需要更新软件定时器任务睡眠的时间的，毕竟第一个软件定时器到期时间已经改变了。</p></li><li><p>如果软件定时器任务处于挂起状态，表示并没有软件定时器在工作，现在插入了软件定时器，需要调用<code>tos_task_resume()</code>函数将软件定时器任务唤醒。</p></li></ol><blockquote><p>关于唤醒软件定时器任务是为了什么，我们在后续讲解</p></blockquote><pre class="line-numbers language-js"><code class="language-js">__STATIC__ <span class="token keyword">void</span> <span class="token function">timer_place</span><span class="token punctuation">(</span>k_timer_t <span class="token operator">*</span>tmr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_list_t <span class="token operator">*</span>curr<span class="token punctuation">;</span>    k_timer_t <span class="token operator">*</span>iter <span class="token operator">=</span> K_NULL<span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    tmr<span class="token operator">-</span><span class="token operator">></span>expires <span class="token operator">+</span><span class="token operator">=</span> k_tick_count<span class="token punctuation">;</span>    <span class="token function">TOS_LIST_FOR_EACH</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>k_timer_ctl<span class="token punctuation">.</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        iter <span class="token operator">=</span> <span class="token function">TOS_LIST_ENTRY</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> k_timer_t<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>expires <span class="token operator">&lt;</span> iter<span class="token operator">-</span><span class="token operator">></span>expires<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">tos_list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tmr<span class="token operator">-</span><span class="token operator">></span>list<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k_timer_ctl<span class="token punctuation">.</span>list<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token operator">&amp;</span>tmr<span class="token operator">-</span><span class="token operator">></span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// we are the first guy now</span>        k_timer_ctl<span class="token punctuation">.</span>next_expires <span class="token operator">=</span> tmr<span class="token operator">-</span><span class="token operator">></span>expires<span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_TIMER_AS_PROC <span class="token operator">==</span> 0u        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">task_state_is_sleeping</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>k_timer_task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">tos_task_delay_abort</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>k_timer_task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>#endif    <span class="token punctuation">}</span>#<span class="token keyword">if</span> TOS_CFG_TIMER_AS_PROC <span class="token operator">==</span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">task_state_is_suspended</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>k_timer_task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">tos_task_resume</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>k_timer_task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="停止软件定时器（外部函数）"><a href="#停止软件定时器（外部函数）" class="headerlink" title="停止软件定时器（外部函数）"></a>停止软件定时器（外部函数）</h1><blockquote><p>在前文也提及停止软件定时器，但是那个<code>timer_takeoff()</code>函数是内部函数，而<code>tos_timer_stop()</code>函数是外部函数，可以被用户使用。</p></blockquote><p>停止软件定时器的本质也是调用<code>timer_takeoff()</code>函数将软件定时器从软件定时器列表中移除，但是在调用这个函数之前还好做一些相关的判断，这样能保证系统的稳定性。</p><ol><li><p>对软件定时器控制块检测，如果软件定时器控制块为null，则直接返回错误代码。</p></li><li><p>如果软件定时器状态为未使用状态<code>TIMER_STATE_UNUSED</code>，则直接返回错误代码<code>K_ERR_TIMER_INACTIVE</code>。</p></li><li><p>如果软件定时器状态为<code>TIMER_STATE_COMPLETED</code> 或者是<code>TIMER_STATE_STOPPED</code>，则不需要停止软件定时器，因为这个软件定时器是未启动的。则直接返回错误代码<code>K_ERR_TIMER_STOPPED</code>。</p></li><li><p>如果软件定时器状态为<code>TIMER_STATE_RUNNING</code> ，就将软件定时器状态设置为停止状态<code>TIMER_STATE_STOPPED</code>，并且调用<code>timer_takeoff()</code>函数将软件定时器从软件定时器列表中移除。</p></li></ol><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_timer_stop</span><span class="token punctuation">(</span>k_timer_t <span class="token operator">*</span>tmr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">knl_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tmr<span class="token operator">-</span><span class="token operator">></span>knl_obj<span class="token punctuation">,</span> KNL_OBJ_TYPE_TIMER<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">==</span> TIMER_STATE_UNUSED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TIMER_INACTIVE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">==</span> TIMER_STATE_COMPLETED <span class="token operator">||</span>        tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">==</span> TIMER_STATE_STOPPED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TIMER_STOPPED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">==</span> TIMER_STATE_RUNNING<span class="token punctuation">)</span> <span class="token punctuation">{</span>        tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">=</span> TIMER_STATE_STOPPED<span class="token punctuation">;</span>        <span class="token function">timer_takeoff</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="软件定时器的处理（在中断上下文环境）"><a href="#软件定时器的处理（在中断上下文环境）" class="headerlink" title="软件定时器的处理（在中断上下文环境）"></a>软件定时器的处理（在中断上下文环境）</h1><p>我们知道，TencentOS tiny的软件定时器是可以在中断上下文环境来处理回调函数的，因此当软件定时器到期后，会在<code>tos_tick_handler()</code>函数中调用<code>timer_update()</code>来处理软件定时器。这个函数在每次tick中断到来的时候都会判断一下是否有软件定时器到期，如果有则去处理它。<br>过程如下：</p><ol><li><p>判断软件定时器的下一个到期时间<code>k_timer_ctl.next_expires</code>是否小于<code>k_tick_count</code>，如果是小于则表示还未到期，直接退出。</p></li><li><p>反之则表示到期，此时要<code>遍历</code>软件定时器列表，找到<code>所有</code>到期的软件定时器，并处理他们。</p></li></ol><blockquote><p>因为有可能不只是一个软件定时器到期，很可能有多个定时器到期。当然啦，当软件定时器没到期的时候就会退出遍历。</p></blockquote><ol start="3"><li><p>到期后的处理就是：调用<code>timer_takeoff()</code>函数将到期的软件定时器停止，如果是周期工作的定时器就调用<code>timer_place()</code>函数将它重新插入软件定时器列表中（它到期的相对时间就是软件定时器的周期值：<code>tmr-&gt;expires = tmr-&gt;period</code>）；如果是单次工作模式的软件定时器，就仅将软件定时器状态设置为<code>TIMER_STATE_COMPLETED</code>。</p></li><li><p>调用软件定时器的回调函数处理相关的工作：<code>(*tmr-&gt;cb)(tmr-&gt;cb_arg)</code></p></li></ol><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ <span class="token keyword">void</span> <span class="token function">timer_update</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    k_timer_t <span class="token operator">*</span>tmr<span class="token punctuation">;</span>    k_list_t <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k_timer_ctl<span class="token punctuation">.</span>next_expires <span class="token operator">&lt;</span> k_tick_count<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">tos_knl_sched_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_LIST_FOR_EACH_SAFE</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>k_timer_ctl<span class="token punctuation">.</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        tmr <span class="token operator">=</span> <span class="token function">TOS_LIST_ENTRY</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> k_timer_t<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>expires <span class="token operator">></span> k_tick_count<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// time's up</span>        <span class="token function">timer_takeoff</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>opt <span class="token operator">==</span> TOS_OPT_TIMER_PERIODIC<span class="token punctuation">)</span> <span class="token punctuation">{</span>            tmr<span class="token operator">-</span><span class="token operator">></span>expires <span class="token operator">=</span> tmr<span class="token operator">-</span><span class="token operator">></span>period<span class="token punctuation">;</span>            <span class="token function">timer_place</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">=</span> TIMER_STATE_COMPLETED<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">(</span><span class="token operator">*</span>tmr<span class="token operator">-</span><span class="token operator">></span>cb<span class="token punctuation">)</span><span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>cb_arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">tos_knl_sched_unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="软件定时器的处理（在任务上下文环境）"><a href="#软件定时器的处理（在任务上下文环境）" class="headerlink" title="软件定时器的处理（在任务上下文环境）"></a>软件定时器的处理（在任务上下文环境）</h1><blockquote><p>关于使用软件定时器任务处理回调函数（即回调函数执行的上下文环境是<code>任务</code>），则必须打开<code>TOS_CFG_TIMER_AS_PROC</code> 宏定义。</p></blockquote><h2 id="创建软件定时器任务"><a href="#创建软件定时器任务" class="headerlink" title="创建软件定时器任务"></a>创建软件定时器任务</h2><p>既然是软件定时器任务，那么就必须创建软件定时器任务，那么这个任务将在<code>timer_init()</code>函数中被创建，它是一个内核调用的函数，在内核初始化时就被调用（在<code>tos_knl_init()</code>函数中调用）。</p><blockquote><p>创建软件定时器任务也是跟创建其他任务没啥差别，都是通过<code>tos_task_create()</code>函数创建，软件定时器任务控制块、任务主体、优先级、任务栈起始地址与大小等都在<code>前面</code>的数据结构中指定了，任务的名字为”timer”。</p></blockquote><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ k_err_t <span class="token function">timer_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>#<span class="token keyword">if</span> TOS_CFG_TIMER_AS_PROC <span class="token operator">></span> 0u    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>#<span class="token keyword">else</span>    <span class="token keyword">return</span> <span class="token function">tos_task_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>k_timer_task<span class="token punctuation">,</span>                            <span class="token string">"timer"</span><span class="token punctuation">,</span>                            timer_task_entry<span class="token punctuation">,</span>                            K_NULL<span class="token punctuation">,</span>                            k_timer_task_prio<span class="token punctuation">,</span>                            k_timer_task_stk_addr<span class="token punctuation">,</span>                            k_timer_task_stk_size<span class="token punctuation">,</span>                            <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>#endif<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="软件定时器任务主体"><a href="#软件定时器任务主体" class="headerlink" title="软件定时器任务主体"></a>软件定时器任务主体</h2><p>软件定时器任务的主体也是一个<code>while (K_TRUE)</code>循环，在循环中处理对应的事情。</p><ol><li>调用<code>timer_next_expires_get()</code>函数获取软件定时器列表中的下一个到期时间，并且更新<code>next_expires</code> 的值。</li></ol><blockquote><p><code>注意</code>：这里的时间已经在函数内部转换为<code>相对</code>到期时间，比如10分钟后闹钟叫我起床，而不是7:10分闹钟叫我起床）</p></blockquote><ol start="2"><li>根据<code>next_expires</code>的值，判断一下软件定时器任务应该休眠多久，在多久后到期时才唤醒软件定时器任务并且处理回调函数。也就是说，软件定时器任务在软件定时器没有到期的时候是不会被唤醒的，都是处于休眠状态，调用<code>tos_task_delay()</code>函数将任务进入休眠状态，此时任务会被挂载到系统的<code>延时（时基）列表</code>中。</li></ol><blockquote><p><code>注意</code>：如果<code>next_expires</code>的值为<code>TOS_TIME_FOREVER</code>，则不是休眠而是直接挂起，因为挂起状态的任务对调度器而言是不可见的，这样子的处理效率更高~挂起任务的函数是<code>tos_task_suspend()</code>。</p></blockquote><ol start="3"><li><p>任务如果被唤醒了，或者被恢复运行了，则表明软件定时器到期了或者有新的软件定时器插入列表了，那么在唤醒之后就要判断一下是哪种情况，如果是到期了则处理对应的回调函数：首先调用<code>timer_takeoff()</code>函数将到期的软件定时器停止，如果是周期工作的定时器就调用<code>timer_place()</code>函数将它重新插入软件定时器列表中（它到期的相对时间就是软件定时器的周期值：<code>tmr-&gt;expires = tmr-&gt;period</code>）；如果是单次工作模式的软件定时器，就仅将软件定时器状态设置为<code>TIMER_STATE_COMPLETED</code>。（这里也是会<code>遍历</code>软件定时器列表以处理<code>所有</code>到期的软件定时器）</p></li><li><p>最后将调用软件定时器的回调函数处理相关的工作：<code>(*tmr-&gt;cb)(tmr-&gt;cb_arg)</code>。</p></li><li><p>如果定时器还未到期，并且软件定时器任务被唤醒了，那么就表示有新的软件定时器插入列表了，此时要更新一下任务的睡眠时间，因为软件定时器任务主体是一个<code>while</code>循环，还是会回到 <code>timer_next_expires_get()</code>函数中重新获取下一个唤醒任务的时间的。</p></li></ol><blockquote><p>注意：软件定时器的处理都是在锁调度器中处理的，就是为了避免其他任务打扰回调函数的执行。</p></blockquote><pre class="line-numbers language-js"><code class="language-js">__STATIC__ <span class="token keyword">void</span> <span class="token function">timer_task_entry</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">{</span>    k_timer_t <span class="token operator">*</span>tmr<span class="token punctuation">;</span>    k_list_t <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    k_tick_t next_expires<span class="token punctuation">;</span>    arg <span class="token operator">=</span> arg<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// make compiler happy</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>K_TRUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        next_expires <span class="token operator">=</span> <span class="token function">timer_next_expires_get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>next_expires <span class="token operator">==</span> TOS_TIME_FOREVER<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">tos_task_suspend</span><span class="token punctuation">(</span>K_NULL<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>next_expires <span class="token operator">></span> <span class="token punctuation">(</span>k_tick_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">tos_task_delay</span><span class="token punctuation">(</span>next_expires<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">tos_knl_sched_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">TOS_LIST_FOR_EACH_SAFE</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>k_timer_ctl<span class="token punctuation">.</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            tmr <span class="token operator">=</span> <span class="token function">TOS_LIST_ENTRY</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> k_timer_t<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>expires <span class="token operator">></span> k_tick_count<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// not yet</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// time's up</span>            <span class="token function">timer_takeoff</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>opt <span class="token operator">==</span> TOS_OPT_TIMER_PERIODIC<span class="token punctuation">)</span> <span class="token punctuation">{</span>                tmr<span class="token operator">-</span><span class="token operator">></span>expires <span class="token operator">=</span> tmr<span class="token operator">-</span><span class="token operator">></span>period<span class="token punctuation">;</span>                <span class="token function">timer_place</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">=</span> TIMER_STATE_COMPLETED<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token punctuation">(</span><span class="token operator">*</span>tmr<span class="token operator">-</span><span class="token operator">></span>cb<span class="token punctuation">)</span><span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>cb_arg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">tos_knl_sched_unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="获取软件定时器下一个到期时间"><a href="#获取软件定时器下一个到期时间" class="headerlink" title="获取软件定时器下一个到期时间"></a>获取软件定时器下一个到期时间</h1><p><code>timer_next_expires_get()</code>就是用于获取软件定时器下一个到期时间，如果软件定时器到期时间是<code>TOS_TIME_FOREVER</code>，就返回<code>TOS_TIME_FOREVER</code>，如果下一个到期时间小于<code>k_tick_count</code>则直接返回0，表示已经到期了，可以直接处理它，而如果是其他值，则需要减去<code>k_tick_count</code>，将其转变为相对值，因为调用这个函数就是为了知道任务能休眠多少时间。</p><blockquote><p>打个比方，我7点醒来了，而7:10分的闹钟才会响，那么我就能再睡10分钟，就是这个道理。</p></blockquote><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ k_tick_t <span class="token function">timer_next_expires_get</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_tick_t next_expires<span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k_timer_ctl<span class="token punctuation">.</span>next_expires <span class="token operator">==</span> TOS_TIME_FOREVER<span class="token punctuation">)</span> <span class="token punctuation">{</span>        next_expires <span class="token operator">=</span> TOS_TIME_FOREVER<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k_timer_ctl<span class="token punctuation">.</span>next_expires <span class="token operator">&lt;=</span> k_tick_count<span class="token punctuation">)</span> <span class="token punctuation">{</span>        next_expires <span class="token operator">=</span> <span class="token punctuation">(</span>k_tick_t<span class="token punctuation">)</span>0u<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        next_expires <span class="token operator">=</span> k_timer_ctl<span class="token punctuation">.</span>next_expires <span class="token operator">-</span> k_tick_count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> next_expires<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台回复 “ 19 ” 获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> TencentOS tiny </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TencentOS tiny </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TencentOS  tiny】深度源码分析（7）——事件</title>
      <link href="/tencentos-tiny-9/"/>
      <url>/tencentos-tiny-9/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>大家在裸机编程中很可能经常用到<code>flag</code>这种变量，用来标志一下某个事件的发生，然后在循环中判断这些标志是否发生，如果是等待多个事件的话，还可能会<code>if((xxx_flag)&amp;&amp;(xxx_flag))</code>这样子做判断。当然，如果聪明一点的同学就会拿<code>flag</code>的<code>某些位</code>做标志，比如这个变量的第一位表示<code>A</code>事件，第二位表示<code>B</code>事件，当这两个事件都发生的时候，就判断<code>flag&amp;0x03</code>的值是多少，从而判断出哪个事件发生了。</p><p>但在操作系统中又将如何实现呢？</p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p><strong>在操作系统中，<code>事件</code>是一种内核资源，主要用于<code>任务与任务间、中断与任务间</code>的<code>同步</code>，<code>不提供</code>数据传输功能！</strong></p><p>与使用<code>信号量</code>同步有细微的差别：事件它可以实现一对多，多对多的同步。即一个任务可以等待多个事件的发生：可以是任意一个事件发生时唤醒任务进行事件处理；也可以是几个事件都发生后才唤醒任务进行事件处理。同样，也可以是多个任务同步多个事件。</p><p>每一个事件组只需要极少的<code>RAM</code>空间来保存事件旗标，一个<code>事件（控制块）</code>中包含了一个<code>旗标</code>，这个<code>旗标</code>的每一位表示一个“<code>事件</code>”，旗标存储在一个<code>k_event_flag_t</code>类型的变量中（名字叫<code>flag</code>，旗标简单理解就是<code>事件标记变量</code>），该变量在事件控制块中被定义，每一位代表一个事件，任务通过<code>“逻辑与”</code>或<code>“逻辑或”</code>与一个或多个事件建立关联，在事件发生时任务将被唤醒。</p><ul><li><p>事件“逻辑或”是<code>独立型同步</code>，指的是任务所等待的若干事件中任意一个事件发生即可被唤醒；</p><ul><li>事件“逻辑与”则是<code>关联型同步</code>，指的是任务所等待的若干事件中全部<code>都</code>发生时才被唤醒。</li></ul></li></ul><p>事件是一种实现任务间通信的机制，可用于实现任务间的同步，但事件无数据传输。多任务环境下，任务、中断之间往往需要同步操作，一个事件发生会告知等待中的任务，即形成一个任务与任务、中断与任务间的同步。</p><p>事件<code>无排队性</code>，即多次向任务设置同一事件(如果任务还未来得及读走)，等效于只设置一次。</p><p>此外事件可以提供一对多、多对多的同步操作。</p><ul><li><p><code>一对多</code>同步模型：一个任务等待多个事件的触发，这种情况是比较常见的；</p></li><li><p><code>多对多</code>同步模型：多个任务等待多个事件的触发，任务可以通过设置事件位来实现事件的触发和等待操作。</p></li></ul><h1 id="事件数据结构"><a href="#事件数据结构" class="headerlink" title="事件数据结构"></a>事件数据结构</h1><h2 id="事件控制块"><a href="#事件控制块" class="headerlink" title="事件控制块"></a>事件控制块</h2><p><code>TencentOS tiny</code> 通过事件控制块操作事件，其数据类型为<code>k_event_t</code>，事件控制块由多个元素组成。</p><ul><li><code>pend_obj</code>有点类似于面向对象的继承，继承一些属性，里面有描述内核资源的类型（如互斥锁、队列、互斥量等，同时还有一个等待列表<code>list</code>）。</li><li><code>flag</code>是旗标，一个32位的变量，因此每个事件控制块最多只能标识32个事件发生！<pre class="line-numbers language-js"><code class="language-js">typedef struct k_event_st <span class="token punctuation">{</span> pend_obj_t      pend_obj<span class="token punctuation">;</span> k_event_flag_t  flag<span class="token punctuation">;</span><span class="token punctuation">}</span> k_event_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="任务控制块与事件相关的数据结构"><a href="#任务控制块与事件相关的数据结构" class="headerlink" title="任务控制块与事件相关的数据结构"></a>任务控制块与事件相关的数据结构</h2><pre class="line-numbers language-js"><code class="language-js">typedef struct k_task_st <span class="token punctuation">{</span>    ···    k_opt_t             opt_event_pend<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/**&lt; 等待事件的的操作类型：TOS_OPT_EVENT_PEND_ANY 、 TOS_OPT_EVENT_PEND_ALL */</span>    k_event_flag_t      flag_expect<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**&lt; 期待发生的事件 */</span>    k_event_flag_t     <span class="token operator">*</span>flag_match<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/**&lt; 等待到的事件（匹配的事件） */</span>    ···<span class="token punctuation">}</span> k_task_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="与事件相关的宏定义"><a href="#与事件相关的宏定义" class="headerlink" title="与事件相关的宏定义"></a>与事件相关的宏定义</h2><p>在<code>tos_config.h</code>中，配置事件开关的宏定义是<code>TOS_CFG_EVENT_EN</code></p><pre class="line-numbers language-js"><code class="language-js">#define TOS_CFG_EVENT_EN            1u<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在<code>tos_event.h</code>中，存在一些宏定义是用于操作事件的（<code>opt选项</code>）：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// if we are pending an event, for any flag we expect is set is ok, this flag should be passed to tos_event_pend </span>#define TOS_OPT_EVENT_PEND_ANY          <span class="token punctuation">(</span>k_opt_t<span class="token punctuation">)</span><span class="token number">0x0001</span><span class="token comment" spellcheck="true">// if we are pending an event, must all the flag we expect is set is ok, this flag should be passed to tos_event_pend </span>#define TOS_OPT_EVENT_PEND_ALL          <span class="token punctuation">(</span>k_opt_t<span class="token punctuation">)</span><span class="token number">0x0002</span>#define TOS_OPT_EVENT_PEND_CLR          <span class="token punctuation">(</span>k_opt_t<span class="token punctuation">)</span><span class="token number">0x0004</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>TOS_OPT_EVENT_PEND_ANY</code>：任务在等待任意一个事件发生，即“逻辑或”！</li><li><code>TOS_OPT_EVENT_PEND_ALL</code>：任务在等待所有事件发生，即“逻辑与”！</li><li><code>TOS_OPT_EVENT_PEND_CLR</code>：清除等待到的事件旗标，可以与<code>TOS_OPT_EVENT_PEND_ANY</code>、<code>TOS_OPT_EVENT_PEND_ALL</code>混合使用（通过<code>“|”</code>运算符）。</li></ul><p>除此之外还有一个枚举类型的数据结构，用于发送事件时的选项操作，可以在发送事件时清除事件旗标的其他位（即覆盖，影响其他事件），也可以保持原本旗标中的其他位（不覆盖，不影响其他事件）。</p><pre class="line-numbers language-js"><code class="language-js">typedef <span class="token keyword">enum</span> opt_event_post_en <span class="token punctuation">{</span>    OPT_EVENT_POST_KEP<span class="token punctuation">,</span>    OPT_EVENT_POST_CLR<span class="token punctuation">,</span><span class="token punctuation">}</span> opt_event_post_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="创建事件"><a href="#创建事件" class="headerlink" title="创建事件"></a>创建事件</h1><p>系统中每个事件都有对应的事件控制块，事件控制块中包含了事件的所有信息，比如它的等待列表、它的资源类型，以及它的事件旗标值，那么可以想象一下，创建事件的本质是不是就是对事件控制块进行初始化呢？很显然就是这样子的。因为在后续对事件的操作都是通过事件控制块来操作的，如果控制块没有信息，那怎么能操作嘛~</p><p>创建事件函数是<code>tos_event_create()</code>，传入一个事件控制块的指针<code>*event</code>，除此之外还可以指定事件初始值<code>init_flag</code>。</p><p>事件的创建实际上就是调用<code>pend_object_init()</code>函数将事件控制块中的<code>event-&gt;pend_obj</code>成员变量进行初始化，它的资源类型被标识为<code>PEND_TYPE_EVENT</code>。然后将<code>event-&gt;flag</code>成员变量设置为事件旗标初始值<code>init_flag</code>。</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_event_create</span><span class="token punctuation">(</span>k_event_t <span class="token operator">*</span>event<span class="token punctuation">,</span> k_event_flag_t init_flag<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pend_object_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>event<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_EVENT<span class="token punctuation">)</span><span class="token punctuation">;</span>    event<span class="token operator">-</span><span class="token operator">></span>flag <span class="token operator">=</span> init_flag<span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="销毁事件"><a href="#销毁事件" class="headerlink" title="销毁事件"></a>销毁事件</h1><p>事件销毁函数是根据事件控制块直接销毁的，销毁之后事件的所有信息都会被清除，而且不能再次使用这个事件，当事件被销毁时，其等待列表中存在任务，系统有必要将这些等待这些任务唤醒，并告知任务事件已经被销毁了<code>PEND_STATE_DESTROY</code>。然后产生一次任务调度以切换到最高优先级任务执行。</p><p><code>TencentOS tiny</code> 对事件销毁的处理流程如下：</p><ol><li>调用<code>pend_is_nopending()</code>函数判断一下是否有任务在等待事件</li><li>如果有任务在等待事件则调用<code>pend_wakeup_all()</code>函数将这些任务唤醒，并且告知等待任务事件已经被销毁了（即设置任务控制块中的等待状态成员变量<code>pend_state</code>为<code>PEND_STATE_DESTROY</code>）。</li><li>调用<code>pend_object_deinit()</code>函数将事件控制块中的内容清除，最主要的是将控制块中的资源类型设置为<code>PEND_TYPE_NONE</code>，这样子就无法使用这个事件了。</li><li>将<code>event-&gt;flag</code>成员变量恢复为默认值<code>0</code>。</li><li>进行任务调度<code>knl_sched()</code></li></ol><p>注意：如果事件控制块的RAM是由<code>编译器静态分配</code>的，所以即使是销毁了事件，这个内存也是没办法释放的。当然你也可以使用动态内存为事件控制块分配内存，只不过在销毁后要将这个内存释放掉，避免内存泄漏。</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_event_destroy</span><span class="token punctuation">(</span>k_event_t <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>event<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_EVENT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_is_nopending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>event<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">pend_wakeup_all</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>event<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_STATE_DESTROY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pend_object_deinit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>event<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    event<span class="token operator">-</span><span class="token operator">></span>flag <span class="token operator">=</span> <span class="token punctuation">(</span>k_event_flag_t<span class="token punctuation">)</span>0u<span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="等待事件"><a href="#等待事件" class="headerlink" title="等待事件"></a>等待事件</h1><p><code>tos_event_pend()</code>函数用于获取事件，通过这个函数，就可以知道<code>事件旗标</code>中的哪一<code>位</code>被<code>置1</code>，即哪一个事件发生了，然后任务可以对等待的事件指定<code>“逻辑与”、“逻辑或”</code>进行等待操作（<code>opt_pend选项</code>）。</p><p>并且这个函数实现了<code>等待超时</code>机制，且仅当任务等待的事件发生时，任务才能等待到事件。当事件未发生的时候，等待事件的任务会进入阻塞态，阻塞时间<code>timeout</code>由用户指定，在这段时间中，如果事件一直没发生，该任务将保持阻塞状态以等待事件发生。当其它任务或中断服务程序往其等待的事件旗标设置对应的标志位，该任务将自动由阻塞态转为就绪态。当任务等待的时间超过了指定的阻塞时间，即使事件还未发生，任务也会自动从阻塞态转移为就绪态。这样子很有效的体现了操作系统的实时性。</p><p>任务获取了某个事件时，可以选择清除事件操作。</p><p><strong>等待事件的操作不允许在中断上下文环境运行！</strong></p><p>等待事件的过程如下：</p><ol><li>首先检测传入的参数是否正确。，注意<code>opt_pend</code>的选项必须存在<code>TOS_OPT_EVENT_PEND_ALL</code> 或者 <code>TOS_OPT_EVENT_PEND_ANY</code> 之一，且二者不允许同时存在（<code>互斥</code>）。</li><li>调用<code>event_is_match()</code>函数判断等待的事件是否已发生（即任务等待的事件与事件控制块中的旗标是否<code>匹配</code>）。</li><li>在<code>event_is_match()</code>函数中会根据等待选项<code>opt_pend</code>是等待任意一个事件（<code>TOS_OPT_EVENT_PEND_ANY</code>）还是等待所有事件（<code>TOS_OPT_EVENT_PEND_ANY</code>）做出是否匹配的判断，如果是匹配了则返回<code>K_TRUE</code>，反之返回<code>K_FALSE</code>，同时等待到的事件通过<code>flag_match</code>变量返回（已发生匹配）。对于等待所有时间的选项，当且仅当所有事件都发生是才算匹配：<code>(event &amp; flag_expect) == flag_expect)</code>，对于等待任意一个事件的选项，有其中一个事件发生都算匹配：<code>(event &amp; flag_expect)</code>。</li><li>如果事件未发生则可能会阻塞当前获取的任务，看一下用户指定的阻塞时间<code>timeout</code>是否为不阻塞<code>TOS_TIME_NOWAIT</code>，如果不阻塞则直接返回<code>K_ERR_PEND_NOWAIT</code>错误代码。</li><li>如果调度器被锁了<code>knl_is_sched_locked()</code>，则无法进行等待操作，返回错误代码<code>K_ERR_PEND_SCHED_LOCKED</code>，毕竟需要切换任务，调度器被锁则无法切换任务。</li><li>将任务控制块中关于事件的变量设置一下，即设置任务期望等待的事件<code>k_curr_task-&gt;flag_expect</code>，任务匹配的事件<code>k_curr_task-&gt;flag_match</code>，以及任务等待事件的选项<code>k_curr_task-&gt;opt_event_pend</code>。</li><li>调用<code>pend_task_block()</code>函数将任务阻塞，该函数实际上就是将任务从就绪列表中移除<code>k_rdyq.task_list_head[task_prio]</code>，并且插入到等待列表中<code>object-&gt;list</code>，如果等待的时间不是永久等待<code>TOS_TIME_FOREVER</code>，还会将任务插入时间列表中<code>k_tick_list</code>，阻塞时间为<code>timeout</code>，然后进行一次任务调度<code>knl_sched()</code>。</li><li>当程序能继续往下执行时，则表示<code>任务等待到事件</code>，又或者<code>等待发生了超时</code>，任务就不需要等待事件了，此时将任务控制块中的内容清空，即清空任务期望等待的事件<code>k_curr_task-&gt;flag_expect</code>，任务匹配的事件<code>k_curr_task-&gt;flag_match</code>，以及任务等待事件的选项<code>k_curr_task-&gt;opt_event_pend</code>，同时还调用<code>pend_state2errno()</code>函数获取一下任务的等待状态，看一下是哪种情况导致任务恢复运行，并且将结果返回给调用等待事件函数的任务。</li></ol><p>注意：当等待事件的任务能从阻塞中恢复运行，也不一定是等待到事件发生，也有可能是发生了超时，因此在写程序的时候必须要判断一下等待的事件状态，如果是<code>K_ERR_NONE</code>则表示获取成功！</p><p>代码如下：</p><pre class="line-numbers language-js"><code class="language-js">__STATIC__ int <span class="token function">event_is_match</span><span class="token punctuation">(</span>k_event_flag_t event<span class="token punctuation">,</span> k_event_flag_t flag_expect<span class="token punctuation">,</span> k_event_flag_t <span class="token operator">*</span>flag_match<span class="token punctuation">,</span> k_opt_t opt_pend<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>opt_pend <span class="token operator">&amp;</span> TOS_OPT_EVENT_PEND_ALL<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>event <span class="token operator">&amp;</span> flag_expect<span class="token punctuation">)</span> <span class="token operator">==</span> flag_expect<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token operator">*</span>flag_match <span class="token operator">=</span> flag_expect<span class="token punctuation">;</span>            <span class="token keyword">return</span> K_TRUE<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>opt_pend <span class="token operator">&amp;</span> TOS_OPT_EVENT_PEND_ANY<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>event <span class="token operator">&amp;</span> flag_expect<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token operator">*</span>flag_match <span class="token operator">=</span> event <span class="token operator">&amp;</span> flag_expect<span class="token punctuation">;</span>            <span class="token keyword">return</span> K_TRUE<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> K_FALSE<span class="token punctuation">;</span><span class="token punctuation">}</span>__API__ k_err_t <span class="token function">tos_event_pend</span><span class="token punctuation">(</span>k_event_t <span class="token operator">*</span>event<span class="token punctuation">,</span> k_event_flag_t flag_expect<span class="token punctuation">,</span> k_event_flag_t <span class="token operator">*</span>flag_match<span class="token punctuation">,</span> k_tick_t timeout<span class="token punctuation">,</span> k_opt_t opt_pend<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>flag_match<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_IN_IRQ_CHECK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>event<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_EVENT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>opt_pend <span class="token operator">&amp;</span> TOS_OPT_EVENT_PEND_ALL<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>opt_pend <span class="token operator">&amp;</span> TOS_OPT_EVENT_PEND_ANY<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_EVENT_PEND_OPT_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>opt_pend <span class="token operator">&amp;</span> TOS_OPT_EVENT_PEND_ALL<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>opt_pend <span class="token operator">&amp;</span> TOS_OPT_EVENT_PEND_ANY<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_EVENT_PEND_OPT_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">event_is_match</span><span class="token punctuation">(</span>event<span class="token operator">-</span><span class="token operator">></span>flag<span class="token punctuation">,</span> flag_expect<span class="token punctuation">,</span> flag_match<span class="token punctuation">,</span> opt_pend<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>opt_pend <span class="token operator">&amp;</span> TOS_OPT_EVENT_PEND_CLR<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// destroy the bridge after get across the river</span>            event<span class="token operator">-</span><span class="token operator">></span>flag <span class="token operator">=</span> <span class="token punctuation">(</span>k_event_flag_t<span class="token punctuation">)</span>0u<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout <span class="token operator">==</span> TOS_TIME_NOWAIT<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_PEND_NOWAIT<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">knl_is_sched_locked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_PEND_SCHED_LOCKED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    k_curr_task<span class="token operator">-</span><span class="token operator">></span>flag_expect      <span class="token operator">=</span> flag_expect<span class="token punctuation">;</span>    k_curr_task<span class="token operator">-</span><span class="token operator">></span>flag_match       <span class="token operator">=</span> flag_match<span class="token punctuation">;</span>    k_curr_task<span class="token operator">-</span><span class="token operator">></span>opt_event_pend   <span class="token operator">=</span> opt_pend<span class="token punctuation">;</span>    <span class="token function">pend_task_block</span><span class="token punctuation">(</span>k_curr_task<span class="token punctuation">,</span> <span class="token operator">&amp;</span>event<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_curr_task<span class="token operator">-</span><span class="token operator">></span>flag_expect      <span class="token operator">=</span> <span class="token punctuation">(</span>k_event_flag_t<span class="token punctuation">)</span>0u<span class="token punctuation">;</span>    k_curr_task<span class="token operator">-</span><span class="token operator">></span>flag_match       <span class="token operator">=</span> <span class="token punctuation">(</span>k_event_flag_t <span class="token operator">*</span><span class="token punctuation">)</span>K_NULL<span class="token punctuation">;</span>    k_curr_task<span class="token operator">-</span><span class="token operator">></span>opt_event_pend   <span class="token operator">=</span> <span class="token punctuation">(</span>k_opt_t<span class="token punctuation">)</span>0u<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">pend_state2errno</span><span class="token punctuation">(</span>k_curr_task<span class="token operator">-</span><span class="token operator">></span>pend_state<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="发送事件"><a href="#发送事件" class="headerlink" title="发送事件"></a>发送事件</h1><p><code>TencentOS tiny</code> 提供两个函数发送事件，分别是：<code>tos_event_post()</code>与<code>tos_event_post_keep()</code>，两个函数本质上都是调用同一个函数<code>event_do_post()</code>去实现发送事件的操作的，只不过选项是不同而已，使用<code>tos_event_post()</code>函数会覆盖写入指定的事件，可能影响其他已发生的事件，而<code>tos_event_post_keep()</code>函数则可以保持其他事件位不改变的同时发生事件，在实际情况中后者更常用。</p><p>此函数用于将已发生的事件写入事件旗标中指定的位，当对应的位被置1之后，等待事件的任务将可能被恢复，此时需要遍历等待在事件对象上的事件等待列表，判断是否有任务<code>期望的事件</code>与当前<code>事件旗标</code>的值匹配，如果有，则唤醒该任务。</p><p>简单来说，就是设置自己定义的事件标志位为1，并且看看有没有任务在等待这个事件，有的话就唤醒它。</p><p><code>TencentOS tiny</code> 中设计的很好的地方就是简单与低耦合，这两个api接口本质上都是调用<code>event_do_post()</code>函数去发生事件，只是通过<code>opt_post</code>参数不同选择不同的处理方法。</p><p>在<code>event_do_post()</code>函数中的处理也是非常简单明了的，其执行思路如下：</p><ol><li>首先判断一下发生事件的方式<code>opt_post</code>，如果是<code>OPT_EVENT_POST_KEP</code>则采用或运算<code>“|”</code>写入事件旗标，否则直接赋值。</li><li>使用<code>TOS_LIST_FOR_EACH_SAFE</code>遍历等待在事件对象上的事件等待列表，通过<code>event_is_match()</code>函数判断是否有任务<code>期望的事件</code>与当前<code>事件旗标</code>的值匹配，如果有则调用<code>pend_task_wakeup()</code>函数唤醒对应的任务。</li><li>如果唤醒的等待任务指定了清除对应的事件，那么将清除事件的旗标值。</li><li>最后进行一次任务调度<code>knl_sched()</code>。<pre class="line-numbers language-js"><code class="language-js">__STATIC__ k_err_t <span class="token function">event_do_post</span><span class="token punctuation">(</span>k_event_t <span class="token operator">*</span>event<span class="token punctuation">,</span> k_event_flag_t flag<span class="token punctuation">,</span> opt_event_post_t opt_post<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>k_task_t <span class="token operator">*</span>task<span class="token punctuation">;</span>k_list_t <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>#if TOS_CFG_OBJECT_VERIFY_EN &gt; 0u<br>    if (!pend_object_verify(&amp;event-&gt;pend_obj, PEND_TYPE_EVENT)) {<br>        return K_ERR_OBJ_INVALID;<br>    }<br>#endif</p><pre><code>if (opt_post == OPT_EVENT_POST_KEP) {    event-&gt;flag |= flag;} else {    event-&gt;flag = flag;}TOS_CPU_INT_DISABLE();TOS_LIST_FOR_EACH_SAFE(curr, next, &amp;event-&gt;pend_obj.list) {    task = TOS_LIST_ENTRY(curr, k_task_t, pend_list);    if (event_is_match(event-&gt;flag, task-&gt;flag_expect, task-&gt;flag_match, task-&gt;opt_event_pend)) {        pend_task_wakeup(TOS_LIST_ENTRY(curr, k_task_t, pend_list), PEND_STATE_POST);        // if anyone pending the event has set the TOS_OPT_EVENT_PEND_CLR, then no wakeup for the others pendig for the event.        if (task-&gt;opt_event_pend &amp; TOS_OPT_EVENT_PEND_CLR) {            event-&gt;flag = (k_event_flag_t)0u;            break;        }    }}TOS_CPU_INT_ENABLE();knl_sched();return K_ERR_NONE;</code></pre><p>}</p><p><strong>API</strong> k_err_t tos_event_post(k_event_t *event, k_event_flag_t flag)<br>{<br>    TOS_PTR_SANITY_CHECK(event);</p><pre><code>return event_do_post(event, flag, OPT_EVENT_POST_CLR);</code></pre><p>}</p><p><strong>API</strong> k_err_t tos_event_post_keep(k_event_t *event, k_event_flag_t flag)<br>{<br>    TOS_PTR_SANITY_CHECK(event);</p><pre><code>return event_do_post(event, flag, OPT_EVENT_POST_KEP);</code></pre><p>}</p><p>```</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台回复 “ 19 ” 获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> TencentOS tiny </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TencentOS tiny </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TencentOS  tiny】深度源码分析（6）——互斥锁</title>
      <link href="/tencentos-tiny-8/"/>
      <url>/tencentos-tiny-8/</url>
      
        <content type="html"><![CDATA[<h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><p>互斥锁又称互斥互斥锁，是一种特殊的信号量，它和信号量不同的是，它具有<code>互斥锁所有权、递归访问以及优先级继承</code>等特性，在操作系统中常用于对临界资源的<code>独占式</code>处理。在任意时刻互斥锁的状态只有两种，<code>开锁或闭锁</code>，当互斥锁被任务持有时，该互斥锁处于闭锁状态，当该任务释放互斥锁时，该互斥锁处于开锁状态。</p><ul><li>一个任务持有互斥锁就表示它拥有互斥锁的所有权，只有该任务才能释放互斥锁，同时其他任务将不能持有该互斥锁，这就是互斥锁的<code>所有权</code>特性。</li><li>当持有互斥锁的任务再次获取互斥锁时不会被挂起，而是能递归获取，这就是互斥锁的<code>递归访问</code>特性。这个特性与一般的信号量有很大的不同，在信号量中，由于已经不存在可用的信号量，任务递归获取信号量时会发生挂起任务最终形成<code>死锁</code>。</li><li>互斥锁还拥有<code>优先级继承</code>机制，它可以将<code>低</code>优先级任务的优先级<code>临时提升</code>到与获取互斥锁的<code>高</code>优先级任务的优先级<code>相同</code>，尽可能<code>降低</code>优先级翻转的危害。</li></ul><p>在实际应用中，如果想要实现同步功能，可以使用信号量，虽然互斥锁也可以用于任务与任务间的同步，但互斥锁更多的是用于临界资源的互斥访问。</p><p>使用互斥锁对临界资源保护时，任务必须先获取互斥锁以获得访问该资源的所有权，当任务使用资源后，必须释放互斥锁以便其他任务可以访问该资源（而使用信号量保护临界资源时则可能发生优先级翻转，且<code>危害</code>是不可控的）。</p><h1 id="优先级翻转"><a href="#优先级翻转" class="headerlink" title="优先级翻转"></a>优先级翻转</h1><p>简单来说就是高优先级任务在等待低优先级任务执行完毕，这已经违背了操作系统的设计初衷（抢占式调度）。</p><p>为什么会发生优先级翻转？</p><p>当系统中某个临界资源受到一个互斥锁保护时，任务访问该资源时需要获得互斥锁，如果这个资源正在被一个<code>低优先级</code>任务使用，此时互斥锁处于闭锁状态；如果此时一个<code>高优先级</code>任务想要访问该资源，那么高优先级任务会因为获取不到互斥锁而进入阻塞态，此时就形成高优先级任务在等待低优先级任务运行（等待它释放互斥锁）。</p><p>优先级翻转是会产生<code>危害</code>的，在一开始设计系统的时候，就已经指定任务的优先级，越重要的任务优先级越高，但是发生优先级翻转后，高优先级任务在等待低优先级任务，这就有可能让高优先级任务得不到有效的处理，严重时可能导致系统崩溃。</p><p>优先级翻转的危害是不可控的，因为低优先级任务很可能会被系统中其他<code>中间优先级</code>任务（低优先级与高优先级任务之间的优先级任务）抢占，这就有可能导致高优先级任务将等待所有中间优先级任务运行完毕的情况，这种情况对高优先级任务来说是不可接受的，也是违背了操作系统设计的原则。</p><h1 id="优先级继承"><a href="#优先级继承" class="headerlink" title="优先级继承"></a>优先级继承</h1><p>在<code>TencentOS tiny</code> 中为了<code>降低</code>优先级翻转产生的危害使用了<code>优先级继承算法</code>：暂时提高占有某种临界资源的低优先级任务的优先级，使之与在所有等待该资源的任务中，优先级最高的任务优先级相等，而当这个低优先级任务执行完毕释放该资源时，优先级恢复初始设定值（此处可以看作是低优先级任务临时继承了高优先级任务的优先级）。因此，继承优先级的任务避免了系统资源被任何中间优先级任务抢占。互斥锁的优先级继承机制，它确保高优先级任务进入阻塞状态的时间尽可能短，以及将已经出现的“优先级翻转”危害<code>降低到最小</code>，<code>但不能消除</code>优先级翻转带来的危害。</p><p>值得一提的是<code>TencentOS tiny</code> 在持有互斥锁时还允许调用修改任务优先级的API接口。</p><h1 id="互斥锁的数据结构"><a href="#互斥锁的数据结构" class="headerlink" title="互斥锁的数据结构"></a>互斥锁的数据结构</h1><h2 id="互斥锁控制块"><a href="#互斥锁控制块" class="headerlink" title="互斥锁控制块"></a>互斥锁控制块</h2><p><code>TencentOS tiny</code> 通过互斥锁控制块操作互斥锁，其数据类型为<code>k_mutex_t</code>，互斥锁控制块由多个元素组成。</p><ul><li><code>pend_obj</code>有点类似于面向对象的继承，继承一些属性，里面有描述内核资源的类型（如互斥锁、队列、互斥量等，同时还有一个等待列表<code>list</code>）。</li><li><code>pend_nesting</code>实际上是一个<code>uint8_t</code>类型的变量，记录互斥锁被获取的次数，如果<code>pend_nesting</code>为0则表示开锁状态，不为0则表示闭锁状态，且它的值记录了互斥量被获取的次数（拥有递归访问特性）</li><li><code>*owner</code>是任务控制块指针，记录当前互斥锁被哪个任务持有。</li><li><code>owner_orig_prio</code>变量记录了持有互斥锁任务的优先级，因为有可能发生优先级继承机制而临时改变任务的优先级。（拥有优先级继承机制）。</li><li><code>owner_list</code>是一个列表节点，当互斥锁被任务获取时，该节点会被添加到任务控制块的<code>task-&gt;mutex_own_list</code>列表中，表示任务自己获取到的互斥锁有哪些。当互斥锁被<code>完全</code>释放时（<code>pend_nesting等于0</code>），该节点将从任务控制块的<code>task-&gt;mutex_own_list</code>列表中移除。</li><li><code>prio_pending</code>变量比较有意思：在一般的操作系统中，任务在持有互斥锁时不允许修改优先级，但在<code>TencentOS tiny</code> 中是允许的，就是因为这个变量，当一个任务处于互斥锁优先级反转的时候，我假设他因为优先级反转优先级得到了提升，此时有用户企图改变这个任务的优先级，但这个更改后的优先级会使此任务违背其优先级必须比所有等待他所持有的互斥锁的任务还高的原则时，此时需要将用户的这次优先级更改请求记录到<code>prio_pending</code>里，待其释放其所持有的互斥锁后再更改，相当于将任务优先级的更改延后了。<blockquote><p>举个例子：好比一个任务优先级是10，且持有一把锁，此时一个优先级为6的任务尝试获取这把锁，那么此任务优先级会被提升为6，如果此时用户试图更改他的优先级为7，那么不能立刻响应这次请求，必须要等这把锁放掉的时候才能做真正的优先级修改</p></blockquote></li></ul><pre class="line-numbers language-js"><code class="language-js">typedef struct k_mutex_st <span class="token punctuation">{</span>    pend_obj_t      pend_obj<span class="token punctuation">;</span>    k_nesting_t     pend_nesting<span class="token punctuation">;</span>    k_task_t       <span class="token operator">*</span>owner<span class="token punctuation">;</span>    k_prio_t        owner_orig_prio<span class="token punctuation">;</span>    k_list_t        owner_list<span class="token punctuation">;</span><span class="token punctuation">}</span> k_mutex_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">typedef struct k_task_st <span class="token punctuation">{</span>#<span class="token keyword">if</span> TOS_CFG_MUTEX_EN <span class="token operator">></span> 0u    k_list_t            mutex_own_list<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/**&lt; 任务拥有的互斥量 */</span>    k_prio_t            prio_pending<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/*&lt; 在持有互斥锁时修改任务优先级将被记录到这个变量中，在释放持有的互斥锁时再更改 */</span>#endif<span class="token punctuation">}</span> k_task_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="与互斥锁相关的宏定义"><a href="#与互斥锁相关的宏定义" class="headerlink" title="与互斥锁相关的宏定义"></a>与互斥锁相关的宏定义</h2><p>在<code>tos_config.h</code>中，使能互斥锁的宏定义是<code>TOS_CFG_MUTEX_EN</code></p><pre class="line-numbers language-js"><code class="language-js">#define TOS_CFG_MUTEX_EN            1u<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="创建互斥锁"><a href="#创建互斥锁" class="headerlink" title="创建互斥锁"></a>创建互斥锁</h1><p>系统中每个互斥锁都有对应的互斥锁控制块，互斥锁控制块中包含了互斥锁的所有信息，比如它的等待列表、它的资源类型，以及它的互斥锁值，那么可以想象一下，创建互斥锁的本质是不是就是对互斥锁控制块进行初始化呢？很显然就是这样子的。因为在后续对互斥锁的操作都是通过互斥锁控制块来操作的，如果控制块没有信息，那怎么能操作嘛~</p><p>创建互斥锁函数是<code>tos_mutex_create()</code>，传入一个互斥锁控制块的指针<code>*mutex</code>即可。</p><p>互斥锁的创建实际上就是调用<code>pend_object_init()</code>函数将互斥锁控制块中的<code>mutex-&gt;pend_obj</code>成员变量进行初始化，它的资源类型被标识为<code>PEND_TYPE_MUTEX</code>。然后将<code>mutex-&gt;pend_nesting</code>成员变量设置为<code>0</code>，表示互斥锁处于开锁状态；将<code>mutex-&gt;owner</code>成员变量设置为<code>K_NULL</code>，表示此事并无任务持有互斥锁；将<code>mutex-&gt;owner_orig_prio</code>成员变量设置为默认值<code>K_TASK_PRIO_INVALID</code>，毕竟此事没有任务持有互斥锁，也无需记录持有互斥锁任务的优先级。最终调用<code>tos_list_init()</code>函数将互斥锁的持有互斥锁任务的列表节点<code>owner_list</code>。</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_mutex_create</span><span class="token punctuation">(</span>k_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pend_object_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_MUTEX<span class="token punctuation">)</span><span class="token punctuation">;</span>    mutex<span class="token operator">-</span><span class="token operator">></span>pend_nesting     <span class="token operator">=</span> <span class="token punctuation">(</span>k_nesting_t<span class="token punctuation">)</span>0u<span class="token punctuation">;</span>    mutex<span class="token operator">-</span><span class="token operator">></span>owner            <span class="token operator">=</span> K_NULL<span class="token punctuation">;</span>    mutex<span class="token operator">-</span><span class="token operator">></span>owner_orig_prio  <span class="token operator">=</span> K_TASK_PRIO_INVALID<span class="token punctuation">;</span>    <span class="token function">tos_list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>owner_list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="销毁互斥锁"><a href="#销毁互斥锁" class="headerlink" title="销毁互斥锁"></a>销毁互斥锁</h1><p>互斥锁销毁函数是根据互斥锁控制块直接销毁的，销毁之后互斥锁的所有信息都会被清除，而且不能再次使用这个互斥锁，当互斥锁被销毁时，其等待列表中存在任务，系统有必要将这些等待这些任务唤醒，并告知任务互斥锁已经被销毁了<code>PEND_STATE_DESTROY</code>。然后产生一次任务调度以切换到最高优先级任务执行。</p><p><code>TencentOS tiny</code> 对互斥锁销毁的处理流程如下：</p><ol><li>调用<code>pend_is_nopending()</code>函数判断一下是否有任务在等待互斥锁</li><li>如果有则调用<code>pend_wakeup_all()</code>函数将这些任务唤醒，并且告知等待任务互斥锁已经被销毁了（即设置任务控制块中的等待状态成员变量<code>pend_state</code>为<code>PEND_STATE_DESTROY</code>）。</li><li>调用<code>pend_object_deinit()</code>函数将互斥锁控制块中的内容清除，最主要的是将控制块中的资源类型设置为<code>PEND_TYPE_NONE</code>，这样子就无法使用这个互斥锁了。</li><li>将<code>mutex-&gt;pend_nesting</code>成员变量恢复为默认值<code>0</code>。</li><li>如果删除的时候有任务持有互斥锁，那么调用<code>mutex_old_owner_release()</code>函数将互斥锁释放。</li><li>进行任务调度<code>knl_sched()</code></li></ol><p>注意：如果互斥锁控制块的RAM是由<code>编译器静态分配</code>的，所以即使是销毁了互斥锁，这个内存也是没办法释放的。当然你也可以使用动态内存为互斥锁控制块分配内存，只不过在销毁后要将这个内存释放掉，避免内存泄漏。</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_mutex_destroy</span><span class="token punctuation">(</span>k_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_MUTEX<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_is_nopending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">pend_wakeup_all</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_STATE_DESTROY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pend_object_deinit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    mutex<span class="token operator">-</span><span class="token operator">></span>pend_nesting <span class="token operator">=</span> <span class="token punctuation">(</span>k_nesting_t<span class="token punctuation">)</span>0u<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mutex<span class="token operator">-</span><span class="token operator">></span>owner<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">mutex_old_owner_release</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="获取互斥锁"><a href="#获取互斥锁" class="headerlink" title="获取互斥锁"></a>获取互斥锁</h1><p><code>tos_mutex_pend_timed()</code>函数用于获取互斥锁，互斥锁就像是临界资源的令牌，任务只有获取到互斥锁时才能访问临界资源。当且仅当互斥锁处于开锁的状态，任务才能获取互斥锁成功，当任务持有了某个互斥锁的时候，其它任务就无法获取这个互斥锁，需要等到持有互斥锁的任务进行释放后，其他任务才能获取成功，任务通过互斥锁获取函数来获取互斥锁的所有权，任务对互斥锁的所有权是独占的，任意时刻互斥锁只能被一个任务持有，如果互斥锁处于开锁状态，那么获取该互斥锁的任务将成功获得该互斥锁，并拥有互斥锁的使用权；如果互斥锁处于闭锁状态，获取该互斥锁的任务将无法获得互斥锁，任务将可能被阻塞，也可能立即返回，阻塞时间<code>timeout</code>由用户指定，在指定时间还无法获取到互斥锁时，将发送超时，等待任务将自动恢复为就绪态。在任务被阻塞之前，会进行优先级继承，如果当前任务优先级比持有互斥锁的任务优先级高，那么将会临时提升持有互斥锁任务的优先级。</p><p><code>TencentOS tiny</code> 提供两组API接口用于获取互斥锁，分别是<code>tos_mutex_pend_timed()</code>和<code>tos_mutex_pend()</code>，主要的差别是参数不同：可选阻塞与永久阻塞获取互斥锁，实际获取的过程都是一样的。获取互斥锁的过程如下：</p><ol><li>首先检测传入的参数是否正确，此处不仅会检查互斥锁控制块的信息，还会调用<code>TOS_IN_IRQ_CHECK()</code>检查上下文是否处于中断中，因为互斥锁的操作是不允许在中断中进行的。</li><li>判断互斥锁控制块中的<code>mutex-&gt;pend_nesting</code>成员变量是否为<code>0</code>，为0表示互斥锁处于开锁状态，调用<code>mutex_fresh_owner_mark()</code>函数将获取互斥锁任务的相关信息保存到互斥锁控制块中，如<code>mutex-&gt;pend_nesting</code>成员变量的值变为<code>1</code>表示互斥锁处于闭锁状态，其他任务无法获取，<code>mutex-&gt;owner</code>成员变量指向当前获取互斥锁的任务控制块，<code>mutex-&gt;owner_orig_prio</code>成员变量则是记录当前任务的优先级，最终使用<code>tos_list_add()</code>函数将互斥锁控制块的<code>mutex-&gt;owner_list</code>节点挂载到任务控制块的<code>task-&gt;mutex_own_list</code>列表中，任务获取成功后返回<code>K_ERR_NONE</code>。</li><li>如果互斥锁控制块中的<code>mutex-&gt;pend_nesting</code>成员变量不为<code>0</code>，则表示互斥锁处于闭锁状态，那么由于互斥锁具有递归访问特性，那么会判断一下是不是已经持有互斥锁的任务再次获取互斥锁（<code>knl_is_self()</code>），因为这也是允许的，判断一下<code>mutex-&gt;pend_nesting</code>成员变量的值是否为<code>(k_nesting_t)-1</code>，如果是则表示递归访问次数达到最大值，互斥锁已经溢出了，返回错误代码<code>K_ERR_MUTEX_NESTING_OVERFLOW</code>。否则就将<code>mutex-&gt;pend_nesting</code>成员变量的值加1，返回<code>K_ERR_MUTEX_NESTING</code>表示递归获取成功。</li><li>如果互斥锁处于闭锁状态，且当前任务并未持有互斥锁，看一下用户指定的阻塞时间<code>timeout</code>是否为不阻塞<code>TOS_TIME_NOWAIT</code>，如果不阻塞则直接返回<code>K_ERR_PEND_NOWAIT</code>错误代码。</li><li>如果调度器被锁了<code>knl_is_sched_locked()</code>，则无法进行等待操作，返回错误代码<code>K_ERR_PEND_SCHED_LOCKED</code>，毕竟需要切换任务，调度器被锁则无法切换任务。</li><li>最最最最重要的特性来了，在阻塞当前任务之前，需要判断一下当前任务与持有互斥锁的任务优先级大小情况，如果当前任务优先级比持有互斥锁任务优先级大，则需要进行优先级继承，临时将持有互斥锁任务的优先级提升到当前优先级，通过<code>tos_task_prio_change()</code>函数进行改变优先级。</li><li>调用<code>pend_task_block()</code>函数将任务阻塞，该函数实际上就是将任务从就绪列表中移除<code>k_rdyq.task_list_head[task_prio]</code>，并且插入到等待列表中<code>object-&gt;list</code>，如果等待的时间不是永久等待<code>TOS_TIME_FOREVER</code>，还会将任务插入时间列表中<code>k_tick_list</code>，阻塞时间为<code>timeout</code>，然后进行一次任务调度<code>knl_sched()</code>。</li><li>当程序能行到<code>pend_state2errno()</code>时，则表示<code>任务等获取到互斥锁</code>，又或者<code>等待发生了超时</code>，那么就调用<code>pend_state2errno()</code>函数获取一下任务的等待状态，看一下是哪种情况导致任务恢复运行，如果任务已经获取到互斥锁，那么需要调用<code>mutex_new_owner_mark()</code>函数标记一下获取任务的信息，将获取互斥锁任务的相关信息保存到互斥锁控制块中。</li></ol><p>注意：当获取互斥锁的任务能从阻塞中恢复运行，也不一定是获取到互斥锁，也可能是发生了超时，因此在写程序的时候必须要判断一下获取的互斥锁状态，如果返回值是<code>K_ERR_NONE</code>与<code>K_ERR_MUTEX_NESTING</code>则表示获取成功！</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_mutex_pend_timed</span><span class="token punctuation">(</span>k_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">,</span> k_tick_t timeout<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_err_t err<span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_IN_IRQ_CHECK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_MUTEX<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_nesting <span class="token operator">==</span> <span class="token punctuation">(</span>k_nesting_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// first come</span>        <span class="token function">mutex_fresh_owner_mark</span><span class="token punctuation">(</span>mutex<span class="token punctuation">,</span> k_curr_task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">knl_is_self</span><span class="token punctuation">(</span>mutex<span class="token operator">-</span><span class="token operator">></span>owner<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// come again</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_nesting <span class="token operator">==</span> <span class="token punctuation">(</span>k_nesting_t<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> K_ERR_MUTEX_NESTING_OVERFLOW<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token operator">++</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_nesting<span class="token punctuation">;</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_MUTEX_NESTING<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout <span class="token operator">==</span> TOS_TIME_NOWAIT<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// no wait, return immediately</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_PEND_NOWAIT<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">knl_is_sched_locked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_PEND_SCHED_LOCKED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mutex<span class="token operator">-</span><span class="token operator">></span>owner<span class="token operator">-</span><span class="token operator">></span>prio <span class="token operator">></span> k_curr_task<span class="token operator">-</span><span class="token operator">></span>prio<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// PRIORITY INVERSION:</span>        <span class="token comment" spellcheck="true">// we are declaring a mutex, which's owner has a lower(numerically bigger) priority.</span>        <span class="token comment" spellcheck="true">// make owner the same priority with us.</span>        <span class="token function">tos_task_prio_change</span><span class="token punctuation">(</span>mutex<span class="token operator">-</span><span class="token operator">></span>owner<span class="token punctuation">,</span> k_curr_task<span class="token operator">-</span><span class="token operator">></span>prio<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pend_task_block</span><span class="token punctuation">(</span>k_curr_task<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    err <span class="token operator">=</span> <span class="token function">pend_state2errno</span><span class="token punctuation">(</span>k_curr_task<span class="token operator">-</span><span class="token operator">></span>pend_state<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">==</span> K_ERR_NONE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// good, we are the owner now.</span>        <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mutex_new_owner_mark</span><span class="token punctuation">(</span>mutex<span class="token punctuation">,</span> k_curr_task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> err<span class="token punctuation">;</span><span class="token punctuation">}</span>__API__ k_err_t <span class="token function">tos_mutex_pend</span><span class="token punctuation">(</span>k_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">tos_mutex_pend_timed</span><span class="token punctuation">(</span>mutex<span class="token punctuation">,</span> TOS_TIME_FOREVER<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>mutex_fresh_owner_mark</code>与<code>mutex_new_owner_mark()</code>函数的实现：</p><pre class="line-numbers language-js"><code class="language-js">__STATIC_INLINE__ <span class="token keyword">void</span> <span class="token function">mutex_fresh_owner_mark</span><span class="token punctuation">(</span>k_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">,</span> k_task_t <span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">{</span>    mutex<span class="token operator">-</span><span class="token operator">></span>pend_nesting     <span class="token operator">=</span> <span class="token punctuation">(</span>k_nesting_t<span class="token punctuation">)</span>1u<span class="token punctuation">;</span>    mutex<span class="token operator">-</span><span class="token operator">></span>owner            <span class="token operator">=</span> task<span class="token punctuation">;</span>    mutex<span class="token operator">-</span><span class="token operator">></span>owner_orig_prio  <span class="token operator">=</span> task<span class="token operator">-</span><span class="token operator">></span>prio<span class="token punctuation">;</span>    <span class="token function">tos_list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>owner_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>task<span class="token operator">-</span><span class="token operator">></span>mutex_own_list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>__STATIC_INLINE__ <span class="token keyword">void</span> <span class="token function">mutex_new_owner_mark</span><span class="token punctuation">(</span>k_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">,</span> k_task_t <span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">{</span>    k_prio_t highest_pending_prio<span class="token punctuation">;</span>    <span class="token function">mutex_fresh_owner_mark</span><span class="token punctuation">(</span>mutex<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// we own the mutex now, make sure our priority is higher than any one in the pend list.</span>    highest_pending_prio <span class="token operator">=</span> <span class="token function">pend_highest_prio_get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token operator">-</span><span class="token operator">></span>prio <span class="token operator">></span> highest_pending_prio<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">tos_task_prio_change</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> highest_pending_prio<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="释放互斥锁"><a href="#释放互斥锁" class="headerlink" title="释放互斥锁"></a>释放互斥锁</h1><p>互斥锁的释放是不允许在中断中释放的，主要的原因是因为中断中没有上下文的概念，所以中断上下文不能持有，也不能释放互斥锁；互斥锁有<code>所属</code>关系，只有持有互斥锁的任务才能将互斥锁释放，而持有者是任务。</p><p>任务想要访问某个资源的时候，需要先获取互斥锁，然后进行资源访问，在任务使用完该资源的时候，必须要<code>及时</code>释放互斥锁，这样别的任务才能访问临界资源。任务可以调用<code>tos_mutex_post()</code>函数进行释放互斥锁，当互斥锁处于开锁状态时就表示我已经用完了，别人可以获取互斥锁以访问临界资源。</p><p>使用<code>tos_mutex_post()</code>函数接口时，只有已持有互斥锁所有权的任务才能释放它，当任务调用<code>tos_mutex_post()</code>函数时会将互斥锁释放一次，当互斥锁完全释放完毕（<code>mutex-&gt;pend_nesting</code>成员变量的值为<code>0</code>）就变为开锁状态，等待获取该互斥锁的任务将被唤醒。如果任务的优先级被互斥锁的优先级翻转机制临时提升，那么当互斥锁被释放后，任务的优先级将恢复为原本设定的优先级。</p><p><code>TencentOS tiny</code> 中可以只让等待中的一个任务获取到互斥锁（在等待的任务中具有最高优先级）。</p><p>在<code>tos_mutex_post()</code>函数中的处理也是非常简单明了的，其执行思路如下：</p><ol><li>首先进行传入的互斥锁控制块相关的参数检测，然后判断一下是否是持有互斥锁的任务来释放互斥锁，如果是则进行释放操作，如果不是则返回错误代码<code>K_ERR_MUTEX_NOT_OWNER</code>。</li><li>将<code>mutex-&gt;pend_nesting</code>成员变量的值减1，然后判断它的值是否为0，如果不为0则表示当前任务还是持有互斥锁的，也无需进行后续的操作，直接返回<code>K_ERR_MUTEX_NESTING</code>。</li><li>如果<code>mutex-&gt;pend_nesting</code>成员变量的值为0，则表示互斥锁处于开锁状态，则需要调用<code>mutex_old_owner_release()</code>函数完全释放掉互斥锁，在这个函数中会将互斥锁控制块的成员变量（如<code>owner_list、owner、owner_orig_prio</code>等都设置为初始值），此外还有最重要的就是判断一下任务是否发生过优先级继承，如果是则需要将任务恢复为原本的优先级，否则就无效理会。</li><li>调用<code>pend_is_nopending()</code>函数判断一下是否有任务在等待互斥锁，如果没有则返回<code>K_ERR_NONE</code>表示释放互斥锁成功，因为此时没有唤醒任务也就无需任务调度，直接返回即可。</li><li>如果有任务在等待互斥锁，则直接调用<code>pend_wakeup_one()</code>函数唤醒一个等待任务，这个任务在等待任务中是处于最高优先级的，因为<code>TencentOS tiny</code> 的等待任务是按照优先级进行排序。</li><li>进行一次任务调度<code>knl_sched()</code>。</li></ol><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_mutex_post</span><span class="token punctuation">(</span>k_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_MUTEX<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">knl_is_self</span><span class="token punctuation">(</span>mutex<span class="token operator">-</span><span class="token operator">></span>owner<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_MUTEX_NOT_OWNER<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_nesting <span class="token operator">==</span> <span class="token punctuation">(</span>k_nesting_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_MUTEX_NESTING_OVERFLOW<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">--</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_nesting<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_nesting <span class="token operator">></span> <span class="token punctuation">(</span>k_nesting_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_MUTEX_NESTING<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">mutex_old_owner_release</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pend_is_nopending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pend_wakeup_one</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_STATE_POST<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>持有互斥锁的任务释放互斥锁<code>mutex_old_owner_release()</code>。</p><pre class="line-numbers language-js"><code class="language-js">__STATIC_INLINE__ <span class="token keyword">void</span> <span class="token function">mutex_old_owner_release</span><span class="token punctuation">(</span>k_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">{</span>    k_task_t <span class="token operator">*</span>owner<span class="token punctuation">;</span>    owner <span class="token operator">=</span> mutex<span class="token operator">-</span><span class="token operator">></span>owner<span class="token punctuation">;</span>    <span class="token function">tos_list_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>owner_list<span class="token punctuation">)</span><span class="token punctuation">;</span>    mutex<span class="token operator">-</span><span class="token operator">></span>owner <span class="token operator">=</span> K_NULL<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// the right time comes! let's do it!</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>owner<span class="token operator">-</span><span class="token operator">></span>prio_pending <span class="token operator">!=</span> K_TASK_PRIO_INVALID<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">tos_task_prio_change</span><span class="token punctuation">(</span>owner<span class="token punctuation">,</span> owner<span class="token operator">-</span><span class="token operator">></span>prio_pending<span class="token punctuation">)</span><span class="token punctuation">;</span>        owner<span class="token operator">-</span><span class="token operator">></span>prio_pending <span class="token operator">=</span> K_TASK_PRIO_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>owner<span class="token operator">-</span><span class="token operator">></span>prio <span class="token operator">!=</span> mutex<span class="token operator">-</span><span class="token operator">></span>owner_orig_prio<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">tos_task_prio_change</span><span class="token punctuation">(</span>owner<span class="token punctuation">,</span> mutex<span class="token operator">-</span><span class="token operator">></span>owner_orig_prio<span class="token punctuation">)</span><span class="token punctuation">;</span>        mutex<span class="token operator">-</span><span class="token operator">></span>owner_orig_prio <span class="token operator">=</span> K_TASK_PRIO_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台回复 “ 19 ” 获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> TencentOS tiny </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TencentOS tiny </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TencentOS  tiny】深度源码分析（5）——信号量</title>
      <link href="/tencentos-tiny-7/"/>
      <url>/tencentos-tiny-7/</url>
      
        <content type="html"><![CDATA[<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>信号量（<code>sem</code>）在操作系统中是一种实现系统中任务与任务、任务与中断间同步或者临界资源互斥保护的机制。在多任务系统中，各任务之间常需要同步或互斥，信号量就可以为用户提供这方面的支持。</p><p>抽象来说，信号量是一个非负整数，每当信号量被获取（<code>pend</code>）时，该整数会减一，当该整数的值为 <code>0</code> 时，表示信号量处于无效状态，将无法被再次获取，所有试图获取它的任务将进入阻塞态。通常一个信号量是有计数值的，它的计数值可以用于系统资源计数（统计）。</p><p>一般来说信号量的值有两种：</p><ul><li>0：表示没有积累下来的<code>post</code>信号量操作，且可能有任务阻塞在此信号量上。</li><li>正值：表示有一个或多个<code>post</code>信号量操作。</li></ul><p>一般来说信号量多用于同步而非互斥，因为操作系统中会提供另一种互斥机制（互斥锁），互斥量的互斥作用更完善：互斥锁有优先级继承机制，而信号量则没有这个机制，此外互斥量还拥有所有者属性，我们会在后续讲解。</p><p>信号量也如队列一样，拥有<code>阻塞机制</code>。任务需要等待某个中断发生后，再去执行对应的处理，那么任务可以处于阻塞态等待信号量，直到中断发生后释放信号量后，该任务才被唤醒去执行对应的处理。在释放（<code>post</code>）信号量的时候能立即将等待的任务转变为就绪态，如果任务的优先级在就绪任务中是最高的，任务就能立即被运行，这就是操作系统中的“<code>实时响应，实时处理</code>”。在操作系统中使用信号量可以提高处理的效率。</p><h1 id="信号量的数据结构"><a href="#信号量的数据结构" class="headerlink" title="信号量的数据结构"></a>信号量的数据结构</h1><h2 id="信号量控制块"><a href="#信号量控制块" class="headerlink" title="信号量控制块"></a>信号量控制块</h2><p><code>TencentOS tiny</code> 通过信号量控制块操作信号量，其数据类型为<code>k_sem_t</code>，信号量控制块由多个元素组成，主要有 <code>pend_obj_t</code> 类型的<code>pend_obj</code>以及<code>k_sem_cnt_t</code>类型的<code>count</code>。而<code>pend_obj</code>有点类似于面向对象的继承，继承一些属性，里面有描述内核资源的类型（如信号量、队列、互斥量等，同时还有一个等待列表<code>list</code>）。而<code>count</code>则是一个简单的变量（它是16位的无符号整数），表示信号量的值。</p><pre class="line-numbers language-js"><code class="language-js">typedef struct k_sem_st <span class="token punctuation">{</span>    pend_obj_t      pend_obj<span class="token punctuation">;</span>    k_sem_cnt_t     count<span class="token punctuation">;</span><span class="token punctuation">}</span> k_sem_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="与信号量相关的宏定义"><a href="#与信号量相关的宏定义" class="headerlink" title="与信号量相关的宏定义"></a>与信号量相关的宏定义</h2><p>在<code>tos_config.h</code>中，使能信号量的宏定义是<code>TOS_CFG_SEM_EN</code></p><pre class="line-numbers language-js"><code class="language-js">#define TOS_CFG_SEM_EN              1u<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="信号量实现"><a href="#信号量实现" class="headerlink" title="信号量实现"></a>信号量实现</h1><p><code>TencentOS tiny</code> 中实现信号量非常简单，核心代码仅仅只有<code>125</code>行，可以说是非常少了。</p><h1 id="创建信号量"><a href="#创建信号量" class="headerlink" title="创建信号量"></a>创建信号量</h1><p>系统中每个信号量都有对应的信号量控制块，信号量控制块中包含了信号量的所有信息，比如它的等待列表、它的资源类型，以及它的信号量值，那么可以想象一下，创建信号量的本质是不是就是对信号量控制块进行初始化呢？很显然就是这样子的。因为在后续对信号量的操作都是通过信号量控制块来操作的，如果控制块没有信息，那怎么能操作嘛~</p><p>创建信号量函数是<code>tos_sem_create()</code>，传入两个参数，一个是信号量控制块的指针<code>*sem</code>，另一个是信号量的初始值<code>init_count</code>，该值是非负整数即可，但主要不能超过<code>65535</code>。</p><p>实际上就是调用<code>pend_object_init()</code>函数将信号量控制块中的<code>sem-&gt;pend_obj</code>成员变量进行初始化，它的资源类型被标识为<code>PEND_TYPE_SEM</code>。然后将<code>sem-&gt;count</code>成员变量设置为传递进来的信号量的初始值<code>init_count</code>。</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_sem_create</span><span class="token punctuation">(</span>k_sem_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> k_sem_cnt_t init_count<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pend_object_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_SEM<span class="token punctuation">)</span><span class="token punctuation">;</span>    sem<span class="token operator">-</span><span class="token operator">></span>count <span class="token operator">=</span> init_count<span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="销毁信号量"><a href="#销毁信号量" class="headerlink" title="销毁信号量"></a>销毁信号量</h1><p>信号量销毁函数是根据信号量控制块直接销毁的，销毁之后信号量的所有信息都会被清除，而且不能再次使用这个信号量，当信号量被销毁时，其等待列表中存在任务，系统有必要将这些等待这些任务唤醒，并告知任务信号量已经被销毁了<code>PEND_STATE_DESTROY</code>。然后产生一次任务调度以切换到最高优先级任务执行。</p><p><code>TencentOS tiny</code> 对信号量销毁的处理流程如下：</p><ol><li>调用<code>pend_is_nopending()</code>函数判断一下是否有任务在等待信号量</li><li>如果有则调用<code>pend_wakeup_all()</code>函数将这些任务唤醒，并且告知等待任务信号量已经被销毁了（即设置任务控制块中的等待状态成员变量<code>pend_state</code>为<code>PEND_STATE_DESTROY</code>）。</li><li>调用<code>pend_object_deinit()</code>函数将信号量控制块中的内容清除，最主要的是将控制块中的资源类型设置为<code>PEND_TYPE_NONE</code>，这样子就无法使用这个信号量了。</li><li>进行任务调度<code>knl_sched()</code></li></ol><p>注意：如果信号量控制块的RAM是由<code>编译器静态分配</code>的，所以即使是销毁了信号量，这个内存也是没办法释放的。当然你也可以使用动态内存为信号量控制块分配内存，只不过在销毁后要将这个内存释放掉，避免内存泄漏。</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_sem_destroy</span><span class="token punctuation">(</span>k_sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_SEM<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_is_nopending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">pend_wakeup_all</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_STATE_DESTROY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pend_object_deinit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="获取信号量"><a href="#获取信号量" class="headerlink" title="获取信号量"></a>获取信号量</h1><p><code>tos_sem_pend()</code>函数用于获取信号量，当信号量有效的时候，任务才能获取信号量。任务获取了某个信号量时，该信号量的可用个数减一，当它为0的时候，获取信号量的任务会进入阻塞态，阻塞时间<code>timeout</code>由用户指定，在指定时间还无法获取到信号量时，将发送超时，等待任务将自动恢复为就绪态。</p><p>获取信号量的过程如下：</p><ol><li>首先检测传入的参数是否正确。</li><li>判断信号量控制块中的<code>count</code>成员变量是否大于<code>0</code>，大于0表示存在可用信号量，将<code>count</code>成员变量的值<code>减1</code>，任务获取成功后返回<code>K_ERR_NONE</code>。</li><li>如果不存在信号量则可能会阻塞当前获取的任务，看一下用户指定的阻塞时间<code>timeout</code>是否为不阻塞<code>TOS_TIME_NOWAIT</code>，如果不阻塞则直接返回<code>K_ERR_PEND_NOWAIT</code>错误代码。</li><li>如果调度器被锁了<code>knl_is_sched_locked()</code>，则无法进行等待操作，返回错误代码<code>K_ERR_PEND_SCHED_LOCKED</code>，毕竟需要切换任务，调度器被锁则无法切换任务。</li><li>调用<code>pend_task_block()</code>函数将任务阻塞，该函数实际上就是将任务从就绪列表中移除<code>k_rdyq.task_list_head[task_prio]</code>，并且插入到等待列表中<code>object-&gt;list</code>，如果等待的时间不是永久等待<code>TOS_TIME_FOREVER</code>，还会将任务插入时间列表中<code>k_tick_list</code>，阻塞时间为<code>timeout</code>，然后进行一次任务调度<code>knl_sched()</code>。</li><li>当程序能行到<code>pend_state2errno()</code>时，则表示<code>任务等获取到信号量</code>，又或者<code>等待发生了超时</code>，那么就调用<code>pend_state2errno()</code>函数获取一下任务的等待状态，看一下是哪种情况导致任务恢复运行，并且将结果返回给调用获取信号量的任务。</li></ol><p>注意：当获取信号量的任务能从阻塞中恢复运行，也不一定是获取到信号量，也可能是发生了超时，因此在写程序的时候必须要判断一下获取的信号量状态，如果是<code>K_ERR_NONE</code>则表示获取成功！</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_sem_pend</span><span class="token punctuation">(</span>k_sem_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> k_tick_t timeout<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_IN_IRQ_CHECK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_SEM<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sem<span class="token operator">-</span><span class="token operator">></span>count <span class="token operator">></span> <span class="token punctuation">(</span>k_sem_cnt_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">--</span>sem<span class="token operator">-</span><span class="token operator">></span>count<span class="token punctuation">;</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout <span class="token operator">==</span> TOS_TIME_NOWAIT<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// no wait, return immediately</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_PEND_NOWAIT<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">knl_is_sched_locked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_PEND_SCHED_LOCKED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pend_task_block</span><span class="token punctuation">(</span>k_curr_task<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sem<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">pend_state2errno</span><span class="token punctuation">(</span>k_curr_task<span class="token operator">-</span><span class="token operator">></span>pend_state<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="释放信号量"><a href="#释放信号量" class="headerlink" title="释放信号量"></a>释放信号量</h1><p>任务或者中断服务程序都可以释放信号量（post），释放信号量的本质就是将信号量控制块的<code>count</code>成员变量的值<code>加1</code>，表示信号量有效，不过如果有任务在等待这个信号量时，信号量控制块的<code>count</code>成员变量的值是不会改变的，因为要唤醒等待任务，而唤醒等待任务的本质就是等待任务获取到信号量，信号量控制块的<code>count</code>成员变量的值要<code>减1</code>，这一来一回中，信号量控制块的<code>count</code>成员变量的值是不会改变的。</p><p><code>TencentOS tiny</code> 中可以只让等待中的一个任务获取到信号量，也可以让所有等待任务都获取到信号量。分别对应的API是<code>tos_sem_post()</code>与<code>tos_sem_post_all()</code>。顺便提一点，<code>tos_sem_post_all()</code>的设计模式其实是观察者模式，当一个观察的对象改变后，那么所有的观察者都会知道它改变了，具体可以看看《大话设计模式》这本书。</p><p><code>TencentOS tiny</code> 中设计的很好的地方就是简单与低耦合，这两个api接口本质上都是调用<code>sem_do_post()</code>函数去释放信号量，只是通过<code>opt</code>参数不同选择不同的处理方法。</p><p>在<code>sem_do_post()</code>函数中的处理也是非常简单明了的，其执行思路如下：</p><ol><li>首先判断一下信号量是否溢出了，因为一个整数始终都会溢出的，总不能一直释放信号量让<code>count</code>成员变量的值<code>加1</code>吧，因此必须要判断一下是否溢出，如果<code>sem-&gt;count</code>的值为 <code>(k_sem_cnt_t)-1</code>，则表示已经溢出，无法继续释放信号量，返回错误代码K_ERR_SEM_OVERFLOW。</li><li>调用<code>pend_is_nopending()</code>函数判断一下是否有任务在等待信号量，如果没有则将<code>count</code>成员变量的值<code>加1</code>，返回<code>K_ERR_NONE</code>表示释放信号量成功，因为此时没有唤醒任务也就无需任务调度，直接返回即可。</li><li>如果有任务在等待信号量，则<code>count</code>成员变量的值<code>无需加1</code>，直接调用<code>pend_wakeup</code>唤醒对应的任务即可，唤醒任务则是根据<code>opt</code>参数进行唤醒，可以唤醒等待中的一个任务或者是所有任务。</li><li>进行一次任务调度<code>knl_sched()</code>。</li></ol><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_sem_post</span><span class="token punctuation">(</span>k_sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">sem_do_post</span><span class="token punctuation">(</span>sem<span class="token punctuation">,</span> OPT_POST_ONE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>__API__ k_err_t <span class="token function">tos_sem_post_all</span><span class="token punctuation">(</span>k_sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">sem_do_post</span><span class="token punctuation">(</span>sem<span class="token punctuation">,</span> OPT_POST_ALL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>__STATIC__ k_err_t <span class="token function">sem_do_post</span><span class="token punctuation">(</span>k_sem_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> opt_post_t opt<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_SEM<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sem<span class="token operator">-</span><span class="token operator">></span>count <span class="token operator">==</span> <span class="token punctuation">(</span>k_sem_cnt_t<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_SEM_OVERFLOW<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pend_is_nopending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">++</span>sem<span class="token operator">-</span><span class="token operator">></span>count<span class="token punctuation">;</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pend_wakeup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_STATE_POST<span class="token punctuation">,</span> opt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于为什么判断<code>sem-&gt;count</code>是<code>(k_sem_cnt_t)-1</code>就代表溢出呢？我在C语言中举了个简单的例子：</p><pre class="line-numbers language-js"><code class="language-js">#include <span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token operator">></span>int <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    unsigned int a <span class="token operator">=</span> <span class="token operator">~</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token punctuation">(</span>unsigned int<span class="token punctuation">)</span>0XFFFFFFFF<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"OK\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token punctuation">(</span>unsigned int<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"OK\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"unsigned int a = %d \n"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>输出：OKOKunsigned int a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>代码精悍短小，思想清晰，非常建议深入学习~</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台回复 “ 19 ” 获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> TencentOS tiny </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TencentOS tiny </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TencentOS  tiny】深度源码分析（4）——消息队列</title>
      <link href="/tencentos-tiny-6/"/>
      <url>/tencentos-tiny-6/</url>
      
        <content type="html"><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>在前一篇文章中<a href="https://blog.csdn.net/jiejiemcu/article/details/99687678" target="_blank" rel="noopener">【TencentOS tiny学习】源码分析（3）——队列</a><br>我们描述了TencentOS tiny的队列实现，同时也点出了TencentOS tiny的队列是依赖于消息队列的，那么我们今天来看看消息队列的实现。</p><p>其实消息队列是TencentOS tiny的一个<strong>基础组件</strong>，作为队列的底层。<br>所以在<code>tos_config.h</code>中会用以下宏定义：</p><pre class="line-numbers language-js"><code class="language-js">#<span class="token keyword">if</span> <span class="token punctuation">(</span>TOS_CFG_QUEUE_EN <span class="token operator">></span> 0u<span class="token punctuation">)</span>#define TOS_CFG_MSG_EN     1u#<span class="token keyword">else</span>#define TOS_CFG_MSG_EN     0u#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="系统消息池初始化"><a href="#系统消息池初始化" class="headerlink" title="系统消息池初始化"></a>系统消息池初始化</h1><p>在系统初始化（<code>tos_knl_init()</code>）的时候，系统就会将消息池进行初始化，其中， <code>msgpool_init()</code>函数就是用来初始化消息池的，该函数的定义位于 tos_msg.c文件中，函数的实现主要是通过一个<code>for</code>循环，将消息池<code>k_msg_pool[TOS_CFG_MSG_POOL_SIZE]</code>的成员变量进行初始化，初始化对应的列表节点，并且将它挂载到空闲消息列表上<code>k_msg_freelist</code><br>初始化完成示意图：（假设只有3个消息）<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190820005010919.png" alt=""></p><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ <span class="token keyword">void</span> <span class="token function">msgpool_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    uint32_t i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> TOS_CFG_MSG_POOL_SIZE<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">tos_list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>k_msg_pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">tos_list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>k_msg_pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>k_msg_freelist<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_knl_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    ···    #<span class="token keyword">if</span> <span class="token punctuation">(</span>TOS_CFG_MSG_EN<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span>        <span class="token function">msgpool_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    #endif    ···<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="消息队列创建"><a href="#消息队列创建" class="headerlink" title="消息队列创建"></a>消息队列创建</h1><p>这个函数在队列创建中会被调用，当然他也可以自己作为用户API接口提供给用户使用，而非仅仅是内核API接口。<br>这个函数的本质上就是初始化消息队列中的消息列表<code>queue_head</code>。<br>初始化完成示意图：<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190820005606981.png" alt=""></p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_msg_queue_create</span><span class="token punctuation">(</span>k_msg_queue_t <span class="token operator">*</span>msg_queue<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>msg_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token function">knl_object_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg_queue<span class="token operator">-</span><span class="token operator">></span>knl_obj<span class="token punctuation">,</span> KNL_OBJ_TYPE_MSG_QUEUE<span class="token punctuation">)</span><span class="token punctuation">;</span>#endif    <span class="token function">tos_list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg_queue<span class="token operator">-</span><span class="token operator">></span>queue_head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="消息队列销毁"><a href="#消息队列销毁" class="headerlink" title="消息队列销毁"></a>消息队列销毁</h1><p><code>tos_msg_queue_destroy()</code>函数用于销毁一个消息队列，当消息队列不在使用是可以将其销毁，销毁的本质其实是将消息队列控制块的内容进行清除，首先判断一下消息队列控制块的类型是<code>KNL_OBJ_TYPE_MSG_QUEUE</code>，这个函数只能销毁队列类型的控制块。然后调用<code>tos_msg_queue_flush()</code>函数将队列的消息列表的消息全部“<code>清空</code>”，“清空”的意思是将挂载到队列上的消息释放回消息池（如果消息队列的消息列表存在消息，使用<code>msgpool_free()</code>函数释放消息）。并且通过<code>tos_list_init()</code>函数将消息队列的消息列表进行初始化，<code>knl_object_deinit()</code>函数是为了确保消息队列已经被销毁，此时消息队列控制块的<code>pend_obj</code>成员变量中的<code>type</code> 属性标识为<code>KNL_OBJ_TYPE_NONE</code>。</p><blockquote><p>但是有一点要注意，因为队列控制块的RAM是由编译器静态分配的，所以即使是销毁了队列，这个内存也是没办法释放的~</p></blockquote><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_msg_queue_destroy</span><span class="token punctuation">(</span>k_msg_queue_t <span class="token operator">*</span>msg_queue<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>msg_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">knl_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg_queue<span class="token operator">-</span><span class="token operator">></span>knl_obj<span class="token punctuation">,</span> KNL_OBJ_TYPE_MSG_QUEUE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">tos_msg_queue_flush</span><span class="token punctuation">(</span>msg_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg_queue<span class="token operator">-</span><span class="token operator">></span>queue_head<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token function">knl_object_deinit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg_queue<span class="token operator">-</span><span class="token operator">></span>knl_obj<span class="token punctuation">)</span><span class="token punctuation">;</span>#endif    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">__API__ <span class="token keyword">void</span> <span class="token function">tos_msg_queue_flush</span><span class="token punctuation">(</span>k_msg_queue_t <span class="token operator">*</span>msg_queue<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_list_t <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_LIST_FOR_EACH_SAFE</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg_queue<span class="token operator">-</span><span class="token operator">></span>queue_head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">msgpool_free</span><span class="token punctuation">(</span><span class="token function">TOS_LIST_ENTRY</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> k_msg_t<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="从消息队列获取消息"><a href="#从消息队列获取消息" class="headerlink" title="从消息队列获取消息"></a>从消息队列获取消息</h1><p><code>tos_msg_queue_get()</code>函数用于从消息队列中获取消息，获取到的消息通过<code>msg_addr</code>参数返回，获取到消息的大小通过<code>msg_size</code>参数返回给用户，当获取成功是返回<code>K_ERR_NONE</code>，否则返回对应的错误代码。<br>这个从消息队列中获取消息的函数是不会产生阻塞的，如果有消息则获取成功，否则就获取失败，它的实现过程如下：<br><code>TOS_CFG_OBJECT_VERIFY_EN</code> 宏定义使能了，就调用<code>knl_object_verify()</code>函数确保是从消息队列中获取消息，然后通过<code>TOS_LIST_FIRST_ENTRY_OR_NULL</code>判断一下是消息队列的消息列表否存在消息，如果不存在则返回<code>K_ERR_MSG_QUEUE_EMPTY</code>表示消息队列是空的，反正将获取成功，获取成功后需要使用<code>msgpool_free()</code>函数将消息释放回消息池。</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_msg_queue_get</span><span class="token punctuation">(</span>k_msg_queue_t <span class="token operator">*</span>msg_queue<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">**</span>msg_addr<span class="token punctuation">,</span> size_t <span class="token operator">*</span>msg_size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_msg_t <span class="token operator">*</span>msg<span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">knl_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg_queue<span class="token operator">-</span><span class="token operator">></span>knl_obj<span class="token punctuation">,</span> KNL_OBJ_TYPE_MSG_QUEUE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    msg <span class="token operator">=</span> <span class="token function">TOS_LIST_FIRST_ENTRY_OR_NULL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg_queue<span class="token operator">-</span><span class="token operator">></span>queue_head<span class="token punctuation">,</span> k_msg_t<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_MSG_QUEUE_EMPTY<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">*</span>msg_addr <span class="token operator">=</span> msg<span class="token operator">-</span><span class="token operator">></span>msg_addr<span class="token punctuation">;</span>    <span class="token operator">*</span>msg_size <span class="token operator">=</span> msg<span class="token operator">-</span><span class="token operator">></span>msg_size<span class="token punctuation">;</span>    <span class="token function">msgpool_free</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="向消息队列写入消息"><a href="#向消息队列写入消息" class="headerlink" title="向消息队列写入消息"></a>向消息队列写入消息</h1><p>当发送消息时，<code>TencentOS tiny</code>会从消息池（空闲消息列表）中取出一个空闲消息，挂载到消息队列的消息列表中，可以通过<code>opt</code>参数选择挂载到消息列表的末尾或者是头部，因此消息队列的写入是支持<code>FIFO</code>与<code>LIFO</code>方式的，<code>msg_queue</code>是要写入消息的消息队列控制块，<code>msg_addr</code>、<code>msg_size</code>则是要写入消息的地址与大小。</p><p>写入消息的过程非常简单，直接通过<code>msgpool_alloc()</code>函数从消息池取出一个空闲消息，如果系统不存在空闲的消息，则直接返回错误代码<code>K_ERR_MSG_QUEUE_FULL</code>表示系统可用的消息已经被使用完。如果取出空闲消息成功则将要写入的消息地址与大小记录到消息池的<code>msg_addr</code> 与 <code>msg_size</code> 成员变量中，然后通过<code>opt</code>参数选择将消息挂载到消息列表的位置（头部或者是尾部）。</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_msg_queue_put</span><span class="token punctuation">(</span>k_msg_queue_t <span class="token operator">*</span>msg_queue<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>msg_addr<span class="token punctuation">,</span> size_t msg_size<span class="token punctuation">,</span> k_opt_t opt<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_msg_t <span class="token operator">*</span>msg<span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">knl_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg_queue<span class="token operator">-</span><span class="token operator">></span>knl_obj<span class="token punctuation">,</span> KNL_OBJ_TYPE_MSG_QUEUE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    msg <span class="token operator">=</span> <span class="token function">msgpool_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_MSG_QUEUE_FULL<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    msg<span class="token operator">-</span><span class="token operator">></span>msg_addr <span class="token operator">=</span> msg_addr<span class="token punctuation">;</span>    msg<span class="token operator">-</span><span class="token operator">></span>msg_size <span class="token operator">=</span> msg_size<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>opt <span class="token operator">&amp;</span> TOS_OPT_MSG_PUT_LIFO<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">tos_list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg<span class="token operator">-</span><span class="token operator">></span>list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg_queue<span class="token operator">-</span><span class="token operator">></span>queue_head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">tos_list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg<span class="token operator">-</span><span class="token operator">></span>list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg_queue<span class="token operator">-</span><span class="token operator">></span>queue_head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="实验测试代码"><a href="#实验测试代码" class="headerlink" title="实验测试代码"></a>实验测试代码</h1><pre class="line-numbers language-js"><code class="language-js">#include <span class="token string">"stm32f10x.h"</span>#include <span class="token string">"bsp_usart.h"</span>#include <span class="token string">"tos.h"</span>k_msg_queue_t test_msg_queue_00<span class="token punctuation">;</span>k_task_t task1<span class="token punctuation">;</span>k_task_t task2<span class="token punctuation">;</span>k_stack_t task_stack1<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>k_stack_t task_stack2<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test_task1</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>Parameter<span class="token punctuation">)</span><span class="token punctuation">{</span>    k_err_t err<span class="token punctuation">;</span>    int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    int msg_received<span class="token punctuation">;</span>    size_t msg_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"queue pend\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>         <span class="token punctuation">{</span>            err <span class="token operator">=</span> <span class="token function">tos_msg_queue_get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>test_msg_queue_00<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">**</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>msg_received<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg_size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">==</span> K_ERR_NONE<span class="token punctuation">)</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"msg queue get is %d \r\n"</span><span class="token punctuation">,</span>msg_received<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">==</span> K_ERR_PEND_DESTROY<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"queue is destroy\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">tos_task_delay</span><span class="token punctuation">(</span>TOS_TIME_FOREVER <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">tos_task_delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">test_task2</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>Parameter<span class="token punctuation">)</span><span class="token punctuation">{</span>    k_err_t err<span class="token punctuation">;</span>    int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    uint32_t msgs<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"task2 running\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>         <span class="token punctuation">{</span>            err <span class="token operator">=</span> <span class="token function">tos_msg_queue_put</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>test_msg_queue_00<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>msgs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sizeof</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span><span class="token punctuation">,</span> TOS_OPT_MSG_PUT_FIFO<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">!=</span> K_ERR_NONE<span class="token punctuation">)</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"msg queue put fail! code : %d \r\n"</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">tos_task_delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * @brief  主函数  * @param  无  * @retval 无  */</span>int <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    k_err_t err<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*初始化USART 配置模式为 115200 8-N-1，中断接收*/</span>    <span class="token function">USART_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Welcome to TencentOS tiny\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_knl_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// TOS Tiny kernel initialize</span>    <span class="token function">tos_robin_config</span><span class="token punctuation">(</span>TOS_ROBIN_STATE_ENABLED<span class="token punctuation">,</span> <span class="token punctuation">(</span>k_timeslice_t<span class="token punctuation">)</span>500u<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"create test_queue_00\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    err <span class="token operator">=</span> <span class="token function">tos_msg_queue_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>test_msg_queue_00<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> K_ERR_NONE<span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"TencentOS Create test_msg_queue_00 fail! code : %d \r\n"</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"create task1\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    err <span class="token operator">=</span> <span class="token function">tos_task_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>task1<span class="token punctuation">,</span>                           <span class="token string">"task1"</span><span class="token punctuation">,</span>                           test_task1<span class="token punctuation">,</span>                          NULL<span class="token punctuation">,</span>                           <span class="token number">3</span><span class="token punctuation">,</span>                           task_stack1<span class="token punctuation">,</span>                          <span class="token number">1024</span><span class="token punctuation">,</span>                          <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> K_ERR_NONE<span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"TencentOS Create task1 fail! code : %d \r\n"</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"create task2\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    err <span class="token operator">=</span> <span class="token function">tos_task_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>task2<span class="token punctuation">,</span>                           <span class="token string">"task2"</span><span class="token punctuation">,</span>                           test_task2<span class="token punctuation">,</span>                          NULL<span class="token punctuation">,</span>                           <span class="token number">4</span><span class="token punctuation">,</span>                           task_stack2<span class="token punctuation">,</span>                          <span class="token number">1024</span><span class="token punctuation">,</span>                          <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> K_ERR_NONE<span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"TencentOS Create task2 fail! code : %d \r\n"</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_knl_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Start TOS Tiny</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190925193400985.png?" alt="现象"></p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台回复 “ 19 ” 获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> TencentOS tiny </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TencentOS tiny </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TencentOS  tiny】深度源码分析（3）——队列</title>
      <link href="/tencentos-tiny-5/"/>
      <url>/tencentos-tiny-5/</url>
      
        <content type="html"><![CDATA[<h1 id="队列基本概念"><a href="#队列基本概念" class="headerlink" title="队列基本概念"></a>队列基本概念</h1><p>队列是一种常用于任务间通信的数据结构，队列可以在<code>任务与任务间、中断和任务间</code>传递消息，实现了任务接收来自其他任务或中断的不固定长度的消息，任务能够从队列里面读取消息，当队列中的消息是空时，读取消息的任务将被阻塞，用户还可以指定任务等待消息的时间<code>timeout</code>，在这段时间中，如果队列为空，该任务将<code>保持阻塞</code>状态以等待队列数据有效。当队列中有新消息时，被阻塞的任务会被唤醒并处理新消息；当等待的时间超过了指定的阻塞时间，即使队列中尚无有效数据，任务也会自动从阻塞态转为就绪态，消息队列是一种<code>异步</code>的通信方式。</p><p>通过队列服务，任务或中断服务例程可以将一条或多条消息放入队列中。同样，一个或多个任务可以从队列中获得消息。当有多个消息发送到队列时，通常是将先进入队列的消息先传给任务，也就是说，任务先得到的是最先进入队列的消息，即先进先出原则（<code>FIFO</code>），其实<code>TencentOS tiny</code>暂时不支持后进先出原则<code>LIFO</code>操作队列，但是支持后进先出操作<code>消息队列</code>。</p><blockquote><p>提示：<code>TencentOS tiny</code> 的队列不等同于消息队列，虽然<code>队列</code>的底层实现是<strong>依赖</strong><code>消息队列</code>，但在<code>TencentOS tiny</code>中将它们分离开，这是两个概念，毕竟操作是不一样的。</p></blockquote><h1 id="队列的阻塞机制"><a href="#队列的阻塞机制" class="headerlink" title="队列的阻塞机制"></a>队列的阻塞机制</h1><p>举个简单的例子来理解操作系统中的阻塞机制：</p><blockquote><p>假设你某天去餐厅吃饭，但是餐厅没菜了，那么你可能会有3个选择，你扭头就走，既然都没菜了，肯定换一家餐厅啊是吧。或者你会选择等一下，说不定老板去买菜了，一会就有菜了呢，就能吃饭。又或者，你觉得这家餐厅非常好吃，吃不到饭你就不走了，在这死等~</p></blockquote><p>同样的：假设有一个任务A对某个队列进行读操作的时候（<code>出队</code>），发现它此时是没有消息的，那么此时任务A有3个选择：第一个选择，任务A扭头就走，既然队列没有消息，那我也不等了，干其它事情去，这样子任务A<code>不会进入阻塞态</code>；第二个选择，任务A还是在这里等等吧，可能过一会队列就有消息，此时任务A会进入阻塞状态，在等待着消息的到来，而任务A的等待时间就<code>由我们自己指定</code>，当阻塞的这段时间中任务A等到了队列的消息，那么任务A就会从阻塞态变成就绪态；假如等待超时了，队列还没消息，那任务A就不等了，从阻塞态中唤醒；第三个选择，任务A死等，不等到消息就不走了，这样子任务A就会进入阻塞态，直到完成读取队列的消息。</p><h1 id="队列实现的数据结构"><a href="#队列实现的数据结构" class="headerlink" title="队列实现的数据结构"></a>队列实现的数据结构</h1><h2 id="队列控制块"><a href="#队列控制块" class="headerlink" title="队列控制块"></a>队列控制块</h2><p><code>TencentOS tiny</code> 通过队列控制块操作队列，其数据类型为<code>k_queue_t</code>，队列控制块由多个元素组成，主要有 <code>pend_obj_t</code> 类型的<code>pend_obj</code>以及<code>k_msg_queue_t</code>类型的<code>msg_queue</code><strong>消息列表</strong>。其实整个队列的实现非常简单，主要靠<code>msg_queue</code>中的<code>queue_head</code>成员变量（这其实是一个消息列表（消息链表）），所有的消息都会被记录在这个消息列表中，当读取消息的时候，会从消息列表读取消息。</p><blockquote><p><strong>继承自内核对象的数据结构 在 \kernel\core\include\tos_pend.h 的 35 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">typedef struct pend_object_st <span class="token punctuation">{</span>    pend_type_t     type<span class="token punctuation">;</span>    k_list_t        list<span class="token punctuation">;</span><span class="token punctuation">}</span> pend_obj_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>消息列表的数据类型（消息队列控制块），在 \kernel\core\include\tos_msg.h 文件的第 13 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">typedef struct k_msg_queue_st <span class="token punctuation">{</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    knl_obj_t       knl_obj<span class="token punctuation">;</span>#endif    k_list_t        queue_head<span class="token punctuation">;</span><span class="token punctuation">}</span> k_msg_queue_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>队列控制块，在 \kernel\core\include\tos_queue.h 文件的第 6 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">typedef struct k_queue_st <span class="token punctuation">{</span>    pend_obj_t      pend_obj<span class="token punctuation">;</span>    k_msg_queue_t msg_queue<span class="token punctuation">;</span><span class="token punctuation">}</span> k_queue_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>队列控制块示意图如下：</p><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190817012709177.png?" alt=""></p><h2 id="消息控制块"><a href="#消息控制块" class="headerlink" title="消息控制块"></a>消息控制块</h2><p>除了上述的队列控制块外，还有消息队列控制块，这是因为<code>TencentOS tiny</code>中实现队列是依赖消息队列的，既然队列可以传递数据（消息），则必须存在一种可以存储消息的数据结构，我称之为消息控制块，消息控制块中记录了消息的存储地址<code>msg_addr</code>，以及消息的大小<code>msg_size</code>，此外还存在一个<code>list</code>成员变量，可以将消息挂载到队列的消息列表中。</p><blockquote><p><strong>消息控制块数据结构， 在 \kernel\core\include\tos_msg.h 文件的第 7 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">typedef struct k_message_st <span class="token punctuation">{</span>    k_list_t        list<span class="token punctuation">;</span>    <span class="token keyword">void</span>           <span class="token operator">*</span>msg_addr<span class="token punctuation">;</span>    size_t          msg_size<span class="token punctuation">;</span><span class="token punctuation">}</span> k_msg_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190817013938740.png?" alt=""></p><blockquote><p><strong>其实队列的实现依赖于消息队列，他们的关系如下：</strong></p></blockquote><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190923202021286.png?" alt=""></p><h2 id="任务控制块中的消息成员变量"><a href="#任务控制块中的消息成员变量" class="headerlink" title="任务控制块中的消息成员变量"></a>任务控制块中的消息成员变量</h2><p>假设任务A在队列中等待消息，而中断或其他任务往任务A等待的队列写入（发送）一个消息，那么这个消息不会被挂载到队列的消息列表中，而是会直接被记录在任务A的任务控制块中，表示任务A从队列中等待到这个消息，因此任务控制块必须存在一些成员变量用于记录消息相关信息（如消息地址、消息大小等）：</p><blockquote><p><strong>任务控制块数据结构 在\kernel\core\include\tos_task.h文件的第 90 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">typedef struct k_task_st <span class="token punctuation">{</span>···#<span class="token keyword">if</span> TOS_CFG_MSG_EN <span class="token operator">></span> 0u    <span class="token keyword">void</span>               <span class="token operator">*</span>msg_addr<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">/**&lt; 保存接收到的消息地址 */</span>    size_t              msg_size<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/**&lt; 保存接收到的消息大小 */</span>#endif···<span class="token punctuation">}</span> k_task_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="与消息相关的宏定义"><a href="#与消息相关的宏定义" class="headerlink" title="与消息相关的宏定义"></a>与消息相关的宏定义</h2><p>在<code>tos_config.h</code>文件中，使能队列组件的宏定义<code>TOS_CFG_QUEUE_EN</code>，使能消息队列组件宏定义<code>TOS_CFG_MSG_EN</code>，系统支持的消息池中消息个数宏定义<code>TOS_CFG_MSG_POOL_SIZE</code>。</p><pre class="line-numbers language-js"><code class="language-js">#define TOS_CFG_QUEUE_EN                1u#define TOS_CFG_MSG_EN                    1u#define TOS_CFG_MSG_POOL_SIZE           3u<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="消息池"><a href="#消息池" class="headerlink" title="消息池"></a>消息池</h2><p>在<code>TencentOS tiny</code>中定义了一个数组<code>k_msg_pool[TOS_CFG_MSG_POOL_SIZE]</code>作为消息池，它的数据类型是消息控制块类型<code>k_msg_t</code>，因为在使用消息队列的时候存取消息比较频繁，而在系统初始化的时候就将这个大数组的各个元素串初始化，并挂载到空闲消息列表中<code>k_msg_freelist</code>，组成我们说的消息池<code>k_msg_pool</code>，而池中的成员变量就是我们所说的消息。</p><blockquote><p>为什么使用池化的方式处理消息呢，因为高效，复用率高，就像我们在池塘中去一勺水，在使用完毕再将其归还到池塘，这种操作是非常高效的，并且在有限资源的嵌入式中能将资源重复有效地利用起来。</p></blockquote><blockquote><p><strong>消息池相关的定义 在\kernel\core\tos_global.c文件 第 51 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">#<span class="token keyword">if</span> TOS_CFG_MSG_EN <span class="token operator">></span> 0u<span class="token function">TOS_LIST_DEFINE</span><span class="token punctuation">(</span>k_msg_freelist<span class="token punctuation">)</span><span class="token punctuation">;</span>k_msg_t             k_msg_pool<span class="token punctuation">[</span>TOS_CFG_MSG_POOL_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="队列创建"><a href="#队列创建" class="headerlink" title="队列创建"></a>队列创建</h1><p><code>tos_queue_create()</code>函数用于创建一个队列，队列就是一个数据结构，用于任务间的数据的传递。每创建一个新的队列都需要为其分配RAM，在创建的时候我们需要自己定义一个队列控制块，其内存是由编译器自动分配的。在创建的过程中实际上就是将队列控制块的内容进行初始化，将队列控制块的 <code>pend_obj</code>成员变量中的<code>type</code> 属性标识为<code>PEND_TYPE_QUEUE</code>，表示这是一个队列，然后调用消息队列中的API函数<code>tos_msg_queue_create()</code>将队列的消息成员变量<code>msg_queue</code>初始化，实际上就是初始化消息列表。</p><blockquote><p><strong>创建队列函数，在\kernel\core\tos_queue.c 第 5 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_queue_create</span><span class="token punctuation">(</span>k_queue_t <span class="token operator">*</span>queue<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pend_object_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_QUEUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_msg_queue_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>msg_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="销毁队列"><a href="#销毁队列" class="headerlink" title="销毁队列"></a>销毁队列</h1><p><code>tos_queue_destroy()</code>函数用于销毁一个队列，当队列不在使用是可以将其销毁，销毁的本质其实是将队列控制块的内容进行清除，首先判断一下队列控制块的类型是<code>PEND_TYPE_QUEUE</code>，这个函数只能销毁队列类型的控制块。然后判断是否有任务在等待队列中的消息，如果有则调用<code>pend_wakeup_all()</code>函数将这项任务唤醒，然后调用<code>tos_msg_queue_flush()</code>函数将队列的消息列表的消息全部“<code>清空</code>”，“清空”的意思是将挂载到队列上的消息释放回消息池（如果队列的消息列表存在消息，使用<code>msgpool_free()</code>函数释放消息），<code>knl_object_deinit()</code>函数是为了确保队列已经被销毁，此时队列控制块的<code>pend_obj</code>成员变量中的<code>type</code> 属性标识为<code>KNL_OBJ_TYPE_NONE</code>。最后在销毁队列后进行一次任务调度，以切换任务（毕竟刚刚<strong>很可能</strong>唤醒了任务）。</p><blockquote><p>但是有一点要注意，因为队列控制块的RAM是由编译器静态分配的，所以即使是销毁了队列，这个内存也是没办法释放的~</p></blockquote><blockquote><p><strong>销毁队列函数，在\kernel\core\tos_queue.c 第 14 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_queue_destroy</span><span class="token punctuation">(</span>k_queue_t <span class="token operator">*</span>queue<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_QUEUE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_is_nopending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">pend_wakeup_all</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_STATE_DESTROY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pend_object_deinit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_msg_queue_flush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>msg_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="清空队列"><a href="#清空队列" class="headerlink" title="清空队列"></a>清空队列</h1><p>清空队列实际上就是将消息释放回消息池中，本质上还是调用<code>tos_msg_queue_flush()</code>函数。它是依赖于消息队列实现的。</p><blockquote><p><strong>清空队列函数，在\kernel\core\tos_queue.c 第 41 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_queue_flush</span><span class="token punctuation">(</span>k_queue_t <span class="token operator">*</span>queue<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_QUEUE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_msg_queue_flush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>msg_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="等待队列（消息）"><a href="#等待队列（消息）" class="headerlink" title="等待队列（消息）"></a>等待队列（消息）</h1><p>当任务试图从队列中的获取消息时，用户可以指定一个等待时间，当且仅当队列存在消息的时候，任务才能获取到消息。在等待的这段时间中，如果队列为空，该任务将保持阻塞状态以等待队列消息有效。当其他任务或中断服务程序往其等待的队列中写入了数据，该任务将自动由阻塞态转为就绪态。当任务等待发生超时，即使队列中尚无有效消息，任务也会自动从阻塞态转为就绪态。<br>等待队列的过程也是非常简单的，先来看看参数吧（其中<code>msg_addr</code>与<code>msg_size</code>参数是用于保存函数返回的内容，即输出）：<br>| 参数 | 说明 |<br>|–|–|<br>| queue | 队列控制块指针 |<br>| msg_addr| 用于保存获取到的消息（这是输出的） |<br>| msg_size| 用于保存获取到消息的大小（这是输出的） |<br>| timeout| 等待时间（以k_tick_t为单位） |</p><p>等待队列消息的过程如下：</p><ol><li><p>首先检测传入的参数是否正确</p></li><li><p>尝试调用<code>tos_msg_queue_get()</code>函数获取消息，如果队列存在消息则会获取成功（返回<code>K_ERR_NONE</code>），否则获取失败。（关于该函数在下一章讲解）</p></li><li><p>当获取成功则可以直接退出函数，而当获取消息失败的时候，则可以根据指定的等待时间<code>timeout</code>进行阻塞，如果不等待（<code>timeout =TOS_TIME_NOWAIT</code>），则直接返回错误代码<code>K_ERR_PEND_NOWAIT</code>。</p></li><li><p>如果调度器被锁了<code>knl_is_sched_locked()</code>，则无法进行等待操作，返回错误代码<code>K_ERR_PEND_SCHED_LOCKED</code>，毕竟需要切换任务，调度器被锁则无法切换任务。</p></li><li><p>调用<code>pend_task_block()</code>函数将任务阻塞，该函数实际上就是将任务从就绪列表中移除<code>k_rdyq.task_list_head[task_prio]</code>，并且插入到等待列表中<code>object-&gt;list</code>，如果等待的时间不是永久等待<code>TOS_TIME_FOREVER</code>，还会将任务插入时间列表中<code>k_tick_list</code>，阻塞时间为<code>timeout</code>，然后进行一次任务调度<code>knl_sched()</code>。</p></li><li><p>当程序能执行到<code>pend_state2errno()</code>时，则表示<code>任务等待到消息</code>，又或者<code>发生超时</code>，那么就调用<code>pend_state2errno()</code>函数获取一下任务的等待状态，看一下是哪种情况导致任务恢复运行。</p></li><li><p>如果是正常情况（等待获取到消息），则将消息从任务控制块的<code>k_curr_task-&gt;msg_addr</code>读取出来，并且写入<code>msg_addr</code> 中用于返回。同样的消息的大小也是会通过<code>msg_size</code>返回。</p></li></ol><blockquote><p><strong>获取（等待）队列消息函数，在\kernel\core\tos_queue.c 第 60 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_queue_pend</span><span class="token punctuation">(</span>k_queue_t <span class="token operator">*</span>queue<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">**</span>msg_addr<span class="token punctuation">,</span> size_t <span class="token operator">*</span>msg_size<span class="token punctuation">,</span> k_tick_t timeout<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_err_t err<span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>msg_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>msg_size<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_QUEUE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tos_msg_queue_get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>msg_queue<span class="token punctuation">,</span> msg_addr<span class="token punctuation">,</span> msg_size<span class="token punctuation">)</span> <span class="token operator">==</span> K_ERR_NONE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout <span class="token operator">==</span> TOS_TIME_NOWAIT<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>msg_addr <span class="token operator">=</span> K_NULL<span class="token punctuation">;</span>        <span class="token operator">*</span>msg_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_PEND_NOWAIT<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">knl_is_sched_locked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_PEND_SCHED_LOCKED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pend_task_block</span><span class="token punctuation">(</span>k_curr_task<span class="token punctuation">,</span> <span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    err <span class="token operator">=</span> <span class="token function">pend_state2errno</span><span class="token punctuation">(</span>k_curr_task<span class="token operator">-</span><span class="token operator">></span>pend_state<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">==</span> K_ERR_NONE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>msg_addr <span class="token operator">=</span> k_curr_task<span class="token operator">-</span><span class="token operator">></span>msg_addr<span class="token punctuation">;</span>        <span class="token operator">*</span>msg_size <span class="token operator">=</span> k_curr_task<span class="token operator">-</span><span class="token operator">></span>msg_size<span class="token punctuation">;</span>        k_curr_task<span class="token operator">-</span><span class="token operator">></span>msg_addr <span class="token operator">=</span> K_NULL<span class="token punctuation">;</span>        k_curr_task<span class="token operator">-</span><span class="token operator">></span>msg_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> err<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>将等待消息的任务添加到对应等待列表函数，在\kernel\core\tos_pend.c文件的 第 106 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ <span class="token keyword">void</span> <span class="token function">pend_task_block</span><span class="token punctuation">(</span>k_task_t <span class="token operator">*</span>task<span class="token punctuation">,</span> pend_obj_t <span class="token operator">*</span>object<span class="token punctuation">,</span> k_tick_t timeout<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">readyqueue_remove</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pend_list_add</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> object<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout <span class="token operator">!=</span> TOS_TIME_FOREVER<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">tick_list_add</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>获取任务等待状态的函数，在\kernel\core\tos_pend.c文件的 第 72 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ k_err_t <span class="token function">pend_state2errno</span><span class="token punctuation">(</span>pend_state_t state<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> PEND_STATE_POST<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> PEND_STATE_TIMEOUT<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_PEND_TIMEOUT<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> PEND_STATE_DESTROY<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_PEND_DESTROY<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> PEND_STATE_OWNER_DIE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_PEND_OWNER_DIE<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_PEND_ABNORMAL<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="（消息）写入队列"><a href="#（消息）写入队列" class="headerlink" title="（消息）写入队列"></a>（消息）写入队列</h1><p>任务或者中断服务程序都可以给消息队列发送消息，当发送消息时，<code>TencentOS tiny</code>会从消息池中取出一个消息，挂载到队列的消息列表末尾（FIFO发送方式）。<code>tos_queue_post()</code>是唤醒一个等待队列消息任务，<code>tos_queue_post_all()</code>则会唤醒所有等待队列消息的任务，无论何种情况，都是调用<code>queue_do_post</code>将消息写入队列中。<br>消息的写入队列过程：</p><ol><li><p>首先检测传入的参数是否正确</p></li><li><p>判断一下是否有任务在等待消息，如果有则根据<code>opt</code>参数决定唤醒一个任务或者所有等待任务，否则直接将消息写入队列中。</p></li><li><p>当没有任务在等待消息时，调用<code>tos_msg_queue_put()</code>函数将消息写入队列，写入队列的方式遵循<code>FIFO</code>原则（<code>TOS_OPT_MSG_PUT_FIFO</code>），写入成功返回<code>K_ERR_NONE</code>。而如果消息池已经没有消息了（消息最大个数由<code>TOS_CFG_MSG_POOL_SIZE</code>宏定义决定），则写入失败，返回<code>K_ERR_QUEUE_FULL</code>错误代码。（关于该函数将在下一章讲解）</p></li><li><p>如果有任务在等待消息，则调用<code>queue_task_msg_recv()</code>函数将消息内容与大小写入任务控制块的<code>msg_addr</code>与<code>msg_size</code>成员变量中，此外还需要唤醒任务，就通过调用<code>pend_task_wakeup()</code>函数将对应的等待任务唤醒，核心处理思想就是通过<code>TOS_LIST_FIRST_ENTRY</code>获取到等待在队列上的任务，然后唤醒它。</p></li><li><p>对于唤醒所有等待任务的处理其实也是一样的，只不过是多了个循环处理，把等待列表中的所有任务依次唤醒，仅此而已~</p></li></ol><blockquote><p><strong>写入队列消息函数，在\kernel\core\tos_queue.c 第 159 、164 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_queue_post</span><span class="token punctuation">(</span>k_queue_t <span class="token operator">*</span>queue<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>msg_addr<span class="token punctuation">,</span> size_t msg_size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>msg_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">queue_do_post</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> msg_addr<span class="token punctuation">,</span> msg_size<span class="token punctuation">,</span> OPT_POST_ONE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>__API__ k_err_t <span class="token function">tos_queue_post_all</span><span class="token punctuation">(</span>k_queue_t <span class="token operator">*</span>queue<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>msg_addr<span class="token punctuation">,</span> size_t msg_size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>msg_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">queue_do_post</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> msg_addr<span class="token punctuation">,</span> msg_size<span class="token punctuation">,</span> OPT_POST_ALL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>写入队列消息函数实际调用的函数，通过<code>opt</code>参数进行不一样的处理，在\kernel\core\tos_queue.c 第 118 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">__STATIC__ k_err_t <span class="token function">queue_do_post</span><span class="token punctuation">(</span>k_queue_t <span class="token operator">*</span>queue<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>msg_addr<span class="token punctuation">,</span> size_t msg_size<span class="token punctuation">,</span> opt_post_t opt<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_list_t <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_QUEUE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pend_is_nopending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tos_msg_queue_put</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>msg_queue<span class="token punctuation">,</span> msg_addr<span class="token punctuation">,</span> msg_size<span class="token punctuation">,</span> TOS_OPT_MSG_PUT_FIFO<span class="token punctuation">)</span> <span class="token operator">!=</span> K_ERR_NONE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> K_ERR_QUEUE_FULL<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>opt <span class="token operator">==</span> OPT_POST_ONE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">queue_task_msg_recv</span><span class="token punctuation">(</span><span class="token function">TOS_LIST_FIRST_ENTRY</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">.</span>list<span class="token punctuation">,</span> k_task_t<span class="token punctuation">,</span> pend_list<span class="token punctuation">)</span><span class="token punctuation">,</span>                                msg_addr<span class="token punctuation">,</span> msg_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// OPT_QUEUE_POST_ALL</span>        <span class="token function">TOS_LIST_FOR_EACH_SAFE</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">.</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">queue_task_msg_recv</span><span class="token punctuation">(</span><span class="token function">TOS_LIST_ENTRY</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> k_task_t<span class="token punctuation">,</span> pend_list<span class="token punctuation">)</span><span class="token punctuation">,</span>                                msg_addr<span class="token punctuation">,</span> msg_size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>唤醒等待的任务函数，在\kernel\core\tos_pend.c文件 的第 87 行</strong></p></blockquote><p>唤醒等待任务的思想就是将任务从对应的等待列表移除，然后添加到就绪列表中。</p><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ <span class="token keyword">void</span> <span class="token function">pend_task_wakeup</span><span class="token punctuation">(</span>k_task_t <span class="token operator">*</span>task<span class="token punctuation">,</span> pend_state_t state<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">task_state_is_pending</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// mark why we wakeup</span>        task<span class="token operator">-</span><span class="token operator">></span>pend_state <span class="token operator">=</span> state<span class="token punctuation">;</span>        <span class="token function">pend_list_remove</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">task_state_is_sleeping</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">tick_list_remove</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">task_state_is_suspended</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">readyqueue_add</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>代码精悍短小，思想清晰，非常建议深入学习~</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> TencentOS tiny </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TencentOS tiny </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TencentOS  tiny】深度源码分析（2）——调度器</title>
      <link href="/tencentos-tiny-4/"/>
      <url>/tencentos-tiny-4/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>温馨提示：本文不描述与浮点相关的寄存器的内容，如需了解自行查阅（毕竟我自己也不懂）</strong></p></blockquote><h1 id="调度器的基本概念"><a href="#调度器的基本概念" class="headerlink" title="调度器的基本概念"></a>调度器的基本概念</h1><p><code>TencentOS tiny</code>中提供的任务调度器是基于优先级的全抢占式调度，在系统运行过程中，当有比当前任务优先级更高的任务就绪时，当前任务将立刻被<code>切出</code>，高优先级任务<code>抢占</code>处理器运行。</p><p><code>TencentOS tiny</code>内核中也允许创建相同优先级的任务。相同优先级的任务采用时间片轮转方式进行调度（也就是通常说的分时调度器），时间片轮转调度仅在当前系统中<strong>无更高优先级就绪任务</strong>的情况下才有效。</p><p>为了保证系统的实时性，系统尽最大可能地保证高优先级的任务得以运行。任务调度的原则是一旦任务状态发生了改变，并且当前运行的任务优先级小于优先级队列中任务最高优先级时，立刻进行任务切换（除非当前系统处于中断处理程序中或禁止任务切换的状态）。</p><p>调度器是操作系统的<code>核心</code>，其主要功能就是<code>实现任务的切换</code>，即从就绪列表里面<code>找到</code>优先级最高的任务，然后去<code>执行</code>该任务。</p><h1 id="启动调度器"><a href="#启动调度器" class="headerlink" title="启动调度器"></a>启动调度器</h1><p>调度器的启动由<code>cpu_sched_start</code>函数来完成，它会被<code>tos_knl_start</code>函数调用，这个函数中主要做两件事，首先通过<code>readyqueue_highest_ready_task_get</code>函数获取当前系统中处于最高优先级的就绪任务，并且将它赋值给指向当前任务控制块的指针<code>k_curr_task</code>，然后设置一下系统的状态为运行态<code>KNL_STATE_RUNNING</code>。</p><p>当然最重要的是调用汇编代码写的函数<code>cpu_sched_start</code>启动调度器，该函数在源码的<code>arch\arm\arm-v7m</code>目录下的<code>port_s.S</code>汇编文件下，<code>TencentOS tiny</code>支持多种内核的芯片，如<code>M3/M4/M7</code>等，不同的芯片该函数的实现方式不同，<code>port_s.S</code>也是<code>TencentOS tiny</code>作为软件与CPU硬件连接的<code>桥梁</code>。以M4的<code>cpu_sched_start</code>举个例子：</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_knl_start</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tos_knl_is_running</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_KNL_RUNNING<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    k_next_task <span class="token operator">=</span> <span class="token function">readyqueue_highest_ready_task_get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_curr_task <span class="token operator">=</span> k_next_task<span class="token punctuation">;</span>    k_knl_state <span class="token operator">=</span> KNL_STATE_RUNNING<span class="token punctuation">;</span>    <span class="token function">cpu_sched_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">port_sched_start    CPSID   I        <span class="token punctuation">;</span> <span class="token keyword">set</span> pendsv priority lowest    <span class="token punctuation">;</span> otherwise trigger pendsv <span class="token keyword">in</span> port_irq_context_switch will cause a context swich <span class="token keyword">in</span> irq    <span class="token punctuation">;</span> that would be a disaster    MOV32   R0<span class="token punctuation">,</span> NVIC_SYSPRI14    MOV32   R1<span class="token punctuation">,</span> NVIC_PENDSV_PRI    STRB    R1<span class="token punctuation">,</span> <span class="token punctuation">[</span>R0<span class="token punctuation">]</span>    LDR     R0<span class="token punctuation">,</span> <span class="token operator">=</span>SCB_VTOR    LDR     R0<span class="token punctuation">,</span> <span class="token punctuation">[</span>R0<span class="token punctuation">]</span>    LDR     R0<span class="token punctuation">,</span> <span class="token punctuation">[</span>R0<span class="token punctuation">]</span>    MSR     MSP<span class="token punctuation">,</span> R0    <span class="token punctuation">;</span> k_curr_task <span class="token operator">=</span> k_next_task    MOV32   R0<span class="token punctuation">,</span> k_curr_task    MOV32   R1<span class="token punctuation">,</span> k_next_task    LDR     R2<span class="token punctuation">,</span> <span class="token punctuation">[</span>R1<span class="token punctuation">]</span>    STR     R2<span class="token punctuation">,</span> <span class="token punctuation">[</span>R0<span class="token punctuation">]</span>    <span class="token punctuation">;</span> sp <span class="token operator">=</span> k_next_task<span class="token operator">-</span><span class="token operator">></span>sp    LDR     R0<span class="token punctuation">,</span> <span class="token punctuation">[</span>R2<span class="token punctuation">]</span>    <span class="token punctuation">;</span> PSP <span class="token operator">=</span> sp    MSR     PSP<span class="token punctuation">,</span> R0    <span class="token punctuation">;</span> using PSP    MRS     R0<span class="token punctuation">,</span> CONTROL    ORR     R0<span class="token punctuation">,</span> R0<span class="token punctuation">,</span> #<span class="token number">2</span>    MSR     CONTROL<span class="token punctuation">,</span> R0    ISB    <span class="token punctuation">;</span> restore r4<span class="token number">-11</span> <span class="token keyword">from</span> <span class="token keyword">new</span> <span class="token class-name">process</span> stack    LDMFD   SP<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>R4 <span class="token operator">-</span> R11<span class="token punctuation">}</span>    IF <span class="token punctuation">{</span>FPU<span class="token punctuation">}</span> <span class="token operator">!=</span> <span class="token string">"SoftVFP"</span>    <span class="token punctuation">;</span> ignore EXC_RETURN the first <span class="token keyword">switch</span>    LDMFD   SP<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>R0<span class="token punctuation">}</span>    ENDIF    <span class="token punctuation">;</span> restore r0<span class="token punctuation">,</span> r3    LDMFD    SP<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>R0 <span class="token operator">-</span> R3<span class="token punctuation">}</span>    <span class="token punctuation">;</span> load R12 and LR    LDMFD    SP<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>R12<span class="token punctuation">,</span> LR<span class="token punctuation">}</span>    <span class="token punctuation">;</span> load PC and discard xPSR    LDMFD    SP<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>R1<span class="token punctuation">,</span> R2<span class="token punctuation">}</span>    CPSIE    I    BX       R1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Cortex-M内核关中断指令"><a href="#Cortex-M内核关中断指令" class="headerlink" title="Cortex-M内核关中断指令"></a>Cortex-M内核关中断指令</h2><p>从上面的汇编代码，我又想介绍一下<code>Cortex-M</code>内核关中断指令，唉~感觉还是有点麻烦！<br>为了快速地开关中断， Cortex-M内核专门设置了一条 <code>CPS 指令</code>，用于操作<code>PRIMASK</code>寄存器跟<code>FAULTMASK</code>寄存器的，这两个寄存器是与屏蔽中断有关的，除此之外<code>Cortex-M</code>内核还存在<code>BASEPRI</code>寄存器也是与中断有关的，也顺带介绍一下吧。</p><pre class="line-numbers language-js"><code class="language-js">CPSID I     <span class="token punctuation">;</span>PRIMASK<span class="token operator">=</span><span class="token number">1</span>     <span class="token punctuation">;</span>关中断CPSIE I     <span class="token punctuation">;</span>PRIMASK<span class="token operator">=</span><span class="token number">0</span>     <span class="token punctuation">;</span>开中断CPSID F     <span class="token punctuation">;</span>FAULTMASK<span class="token operator">=</span><span class="token number">1</span>   <span class="token punctuation">;</span>关异常CPSIE F     <span class="token punctuation">;</span>FAULTMASK<span class="token operator">=</span><span class="token number">0</span>   <span class="token punctuation">;</span>开异常<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>寄存器</th><th>功能</th></tr></thead><tbody><tr><td>PRIMASK</td><td>它被置 1 后，就关掉所有可屏蔽的异常，只剩下 NMI 和HardFault FAULT可以响应</td></tr><tr><td>FAULTMASK</td><td>当它置 1 时，只有 NMI 才能响应，所有其它的异常都无法响应（包括HardFault FAULT）</td></tr><tr><td>BASEPRI</td><td>这个寄存器最多有 9 位（由表达优先级的位数决定）。它定义了被屏蔽优先级的阈值。当它被设成某个值后，所有优先级号大于等于此值的中断都被关（优先级号越大，优先级越低）。但若被设成 0，则不关闭任何中断</td></tr></tbody></table><p>更多具体的描述看我以前的文章：<a href="https://blog.csdn.net/jiejiemcu/article/details/82534974" target="_blank" rel="noopener">RTOS临界段知识：https://blog.csdn.net/jiejiemcu/article/details/82534974</a></p><h2 id="回归正题"><a href="#回归正题" class="headerlink" title="回归正题"></a>回归正题</h2><p>在启动内核调度器过程中需要配置<code>PendSV</code> 的中断优先级为最低，就是往<code>NVIC_SYSPRI14（0xE000ED22）</code>地址写入<code>NVIC_PENDSV_PRI（0xFF）</code>。因为<code>PendSV</code>都会涉及到系统调度，系统调度的优先级要<code>低于</code>系统的其它硬件中断优先级，即优先响应系统中的外部硬件中断，所以PendSV的中断优先级要配置为最低，不然很可能在中断上下文中产生任务调度。</p><p><code>PendSV</code> 异常会自动延迟上下文切换的请求，直到其它的 <code>ISR</code> 都完成了处理后才放行。为实现这个机制，需要把 <code>PendSV</code> 编程为最低优先级的异常。如果 <code>OS</code> 检测到某 <code>ISR</code> 正在活动，它将悬起一个 <code>PendSV</code> 异常，以便缓期执行上下文切换。也就是说，只要将<code>PendSV</code>的优先级设为最低的，systick即使是打断了IRQ，它也不会马上进行上下文切换，而是等到<code>ISR</code>执行完，<code>PendSV</code> 服务例程才开始执行，并且在里面执行上下文切换。过程如图所示：<br><img src="./images/loading.png" data-original="https://img-blog.csdn.net/20180714005652198?" alt=""><br>然后获取<code>MSP</code>主栈指针的地址，在<code>Cortex-M</code>中，<code>0xE000ED08</code>是<code>SCB_VTOR</code>寄存器的地址，里面存放的是向量表的起始地址。</p><p>加载<code>k_next_task</code>指向的任务控制块到 <code>R2</code>，从上一篇文章可知任务控制块的第一个成员就是栈顶指针，所以此时<code>R2</code>等于栈顶指针。</p><blockquote><p>ps : 在调度器启动时，<code>k_next_task</code>与<code>k_curr_task</code>是一样的（<code>k_curr_task = k_next_task</code>）</p></blockquote><p>加载<code>R2</code>到<code>R0</code>，然后将栈顶指针<code>R0</code>更新到<code>psp</code>，任务执行的时候使用的栈指针是<code>psp</code>。</p><blockquote><p>ps：<code>sp</code>指针有两个，分别为<code>psp</code>和<code>msp</code>。（可以简单理解为：在任务上下文环境中使用<code>psp</code>，在中断上下文环境使用<code>msp</code>，也不一定是正确的，这是我个人的理解）</p></blockquote><p>以<code>R0</code>为基地址，将栈中向上增长的<code>8</code>个字的内容加载到CPU寄存器<code>R4~R11</code>，同时<code>R0</code>也会跟着自增</p><p>接着需要加载<code>R0 ~ R3、R12以及LR、 PC、xPSR</code>到CPU寄存器组，PC指针指向的是即将要运行的线程，而LR寄存器则指向任务的退出。<code>因为这是第一次启动任务，要全部手动把任务栈上的寄存器弹到硬件里，才能进入第一个任务的上下文，因为一开始并没有第一个任务运行的上下文环境，而在进入PendSV的时候需要上文保存，所以需要手动创造任务上下文环境（将这些寄存器加载到CPU寄存器组中）</code>，第一次的时候此汇编入口函数，sp是指向一个选好的任务的栈顶（<code>k_curr_task</code>）。</p><h2 id="看看任务栈的初始化"><a href="#看看任务栈的初始化" class="headerlink" title="看看任务栈的初始化"></a>看看任务栈的初始化</h2><p>从上面的了解，再来看看任务栈的初始化，可能会有更深一点的印象。主要了解以下几点即可：</p><ul><li><p>获取栈顶指针为<code>stk_base[stk_size]</code>高地址，<code>Cortex-M</code>内核的栈是<code>向下增长</code>的。</p></li><li><p><code>R0、R1、R2、R3、R12、R14、R15和xPSR的位24</code>是会被CPU<code>自动</code>加载与保存的。</p></li><li><p>xPSR的<code>bit24必须置1</code>，即0x01000000。</p></li><li><p>entry是任务的入口地址，即<code>PC</code></p></li><li><p>R14 (<code>LR</code>)是任务的退出地址，所以任务一般是死循环而不会<code>return</code></p></li><li><p>R0: arg是任务主体的形参</p></li><li><p>初始化栈时sp指针会自减</p><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ k_stack_t <span class="token operator">*</span><span class="token function">cpu_task_stk_init</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>entry<span class="token punctuation">,</span>                                           <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span>                                           <span class="token keyword">void</span> <span class="token operator">*</span>exit<span class="token punctuation">,</span>                                           k_stack_t <span class="token operator">*</span>stk_base<span class="token punctuation">,</span>                                           size_t stk_size<span class="token punctuation">)</span><span class="token punctuation">{</span> cpu_data_t <span class="token operator">*</span>sp<span class="token punctuation">;</span> sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>stk_base<span class="token punctuation">[</span>stk_size<span class="token punctuation">]</span><span class="token punctuation">;</span> sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cpu_addr_t<span class="token punctuation">)</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFFFFFFF8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* auto-saved on exception(pendSV) by hardware */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x01000000u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* xPSR     */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>entry<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* entry    */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>exit<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">/* R14 (LR) */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x12121212u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R12      */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x03030303u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R3       */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x02020202u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R2       */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x01010101u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R1       */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>arg<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* R0: arg  */</span> <span class="token comment" spellcheck="true">/* Remaining registers saved on process stack */</span> <span class="token comment" spellcheck="true">/* EXC_RETURN = 0xFFFFFFFDL    Initial state: Thread mode +  non-floating-point state + PSP    31 - 28 : EXC_RETURN flag, 0xF    27 -  5 : reserved, 0xFFFFFE    4       : 1, basic stack frame; 0, extended stack frame    3       : 1, return to Thread mode; 0, return to Handler mode    2       : 1, return to PSP; 0, return to MSP    1       : reserved, 0    0       : reserved, 1  */</span>#<span class="token keyword">if</span> defined <span class="token punctuation">(</span>TOS_CFG_CPU_ARM_FPU_EN<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>TOS_CFG_CPU_ARM_FPU_EN <span class="token operator">==</span> 1U<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0xFFFFFFFDL<span class="token punctuation">;</span>#endif <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x11111111u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R11      */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x10101010u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R10      */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x09090909u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R9       */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x08080808u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R8       */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x07070707u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R7       */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x06060606u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R6       */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x05050505u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R5       */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x04040404u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R4       */</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>k_stack_t <span class="token operator">*</span><span class="token punctuation">)</span>sp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="查找最高优先级任务"><a href="#查找最高优先级任务" class="headerlink" title="查找最高优先级任务"></a>查找最高优先级任务</h1><p>一个操作系统如果只是具备了高优先级任务能够<code>立即</code>获得处理器并得到执行的特点，那么它仍然不算是实时操作系统。因为这个查找最高优先级任务的过程决定了调度时间是否具有确定性，可以简单来说可以使用<code>时间复杂度</code>来描述一下吧，如果系统查找最高优先级任务的时间是<code>O(N)</code>，那么这个时间会随着任务个数的增加而增大，这是不可取的，<code>TencentOS tiny</code>的时间复杂度是<code>O(1)</code>，它提供两种方法查找最高优先级任务，通过<code>TOS_CFG_CPU_LEAD_ZEROS_ASM_PRESENT</code>宏定义决定。</p></li></ul><ol><li>第一种是使用普通方法，根据就绪列表中<code>k_rdyq.prio_mask[]</code>的变量判断对应的位是否被置1。</li><li>第二种方法则是特殊方法，利用计算前导零指令<code>CLZ</code>，直接在<code>k_rdyq.prio_mask[]</code>这个<code>32</code>位的变量中直接得出最高优先级所处的位置，这种方法比普通方法更快捷，<code>但受限于平台</code>（需要硬件前导零指令，在STM32中我们就可以使用这种方法）。</li></ol><p>实现过程如下，建议看一看<code>readyqueue_prio_highest_get</code>函数，他的实现还是非常精妙的~</p><pre class="line-numbers language-js"><code class="language-js">__STATIC__ k_prio_t <span class="token function">readyqueue_prio_highest_get</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    uint32_t <span class="token operator">*</span>tbl<span class="token punctuation">;</span>    k_prio_t prio<span class="token punctuation">;</span>    prio    <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    tbl     <span class="token operator">=</span> <span class="token operator">&amp;</span>k_rdyq<span class="token punctuation">.</span>prio_mask<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>tbl <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        prio <span class="token operator">+</span><span class="token operator">=</span> K_PRIO_TBL_SLOT_SIZE<span class="token punctuation">;</span>        <span class="token operator">++</span>tbl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    prio <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">tos_cpu_clz</span><span class="token punctuation">(</span><span class="token operator">*</span>tbl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> prio<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">__API__ uint32_t <span class="token function">tos_cpu_clz</span><span class="token punctuation">(</span>uint32_t val<span class="token punctuation">)</span><span class="token punctuation">{</span>#<span class="token keyword">if</span> <span class="token function">defined</span><span class="token punctuation">(</span>TOS_CFG_CPU_LEAD_ZEROS_ASM_PRESENT<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>TOS_CFG_CPU_LEAD_ZEROS_ASM_PRESENT <span class="token operator">==</span> 0u<span class="token punctuation">)</span>    uint32_t nbr_lead_zeros <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>val <span class="token operator">&amp;</span> 0XFFFF0000<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">&lt;</span><span class="token operator">&lt;=</span> <span class="token number">16</span><span class="token punctuation">;</span>        nbr_lead_zeros <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>val <span class="token operator">&amp;</span> 0XFF000000<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">&lt;</span><span class="token operator">&lt;=</span> <span class="token number">8</span><span class="token punctuation">;</span>        nbr_lead_zeros <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>val <span class="token operator">&amp;</span> 0XF0000000<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">&lt;</span><span class="token operator">&lt;=</span> <span class="token number">4</span><span class="token punctuation">;</span>        nbr_lead_zeros <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>val <span class="token operator">&amp;</span> 0XC0000000<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">&lt;</span><span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">;</span>        nbr_lead_zeros <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>val <span class="token operator">&amp;</span> 0X80000000<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        nbr_lead_zeros <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        nbr_lead_zeros <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>nbr_lead_zeros<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">else</span>    <span class="token keyword">return</span> <span class="token function">port_clz</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>#endif<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="任务切换的实现"><a href="#任务切换的实现" class="headerlink" title="任务切换的实现"></a>任务切换的实现</h1><p>从前面我们也知道，任务切换是在<code>PendSV</code>中断中进行的，这个中断中实现的内容总结成一句精髓的话就是 <strong>上文保存，下文切换</strong>，直接看源代码：</p><pre class="line-numbers language-js"><code class="language-js">PendSV_Handler    CPSID   I    MRS     R0<span class="token punctuation">,</span> PSP_context_save    <span class="token punctuation">;</span> R0<span class="token operator">-</span>R3<span class="token punctuation">,</span> R12<span class="token punctuation">,</span> LR<span class="token punctuation">,</span> PC<span class="token punctuation">,</span> xPSR is saved automatically here    IF <span class="token punctuation">{</span>FPU<span class="token punctuation">}</span> <span class="token operator">!=</span> <span class="token string">"SoftVFP"</span>    <span class="token punctuation">;</span> is it extended frame<span class="token operator">?</span>    TST     LR<span class="token punctuation">,</span> #<span class="token number">0x10</span>    IT      EQ    VSTMDBEQ  R0<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>S16 <span class="token operator">-</span> S31<span class="token punctuation">}</span>    <span class="token punctuation">;</span> S0 <span class="token operator">-</span> S16<span class="token punctuation">,</span> FPSCR saved automatically here    <span class="token punctuation">;</span> save EXC_RETURN    STMFD   R0<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>LR<span class="token punctuation">}</span>    ENDIF    <span class="token punctuation">;</span> save remaining regs r4<span class="token number">-11</span> on process stack    STMFD   R0<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>R4 <span class="token operator">-</span> R11<span class="token punctuation">}</span>    <span class="token punctuation">;</span> k_curr_task<span class="token operator">-</span><span class="token operator">></span>sp <span class="token operator">=</span> PSP    MOV32   R5<span class="token punctuation">,</span> k_curr_task    LDR     R6<span class="token punctuation">,</span> <span class="token punctuation">[</span>R5<span class="token punctuation">]</span>    <span class="token punctuation">;</span> R0 is SP <span class="token keyword">of</span> process being switched out    STR     R0<span class="token punctuation">,</span> <span class="token punctuation">[</span>R6<span class="token punctuation">]</span>_context_restore    <span class="token punctuation">;</span> k_curr_task <span class="token operator">=</span> k_next_task    MOV32   R1<span class="token punctuation">,</span> k_next_task    LDR     R2<span class="token punctuation">,</span> <span class="token punctuation">[</span>R1<span class="token punctuation">]</span>    STR     R2<span class="token punctuation">,</span> <span class="token punctuation">[</span>R5<span class="token punctuation">]</span>    <span class="token punctuation">;</span> R0 <span class="token operator">=</span> k_next_task<span class="token operator">-</span><span class="token operator">></span>sp    LDR     R0<span class="token punctuation">,</span> <span class="token punctuation">[</span>R2<span class="token punctuation">]</span>    <span class="token punctuation">;</span> restore R4 <span class="token operator">-</span> R11    LDMFD   R0<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>R4 <span class="token operator">-</span> R11<span class="token punctuation">}</span>    IF <span class="token punctuation">{</span>FPU<span class="token punctuation">}</span> <span class="token operator">!=</span> <span class="token string">"SoftVFP"</span>    <span class="token punctuation">;</span> restore EXC_RETURN    LDMFD   R0<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>LR<span class="token punctuation">}</span>    <span class="token punctuation">;</span> is it extended frame<span class="token operator">?</span>    TST     LR<span class="token punctuation">,</span> #<span class="token number">0x10</span>    IT      EQ    VLDMIAEQ    R0<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>S16 <span class="token operator">-</span> S31<span class="token punctuation">}</span>    ENDIF    <span class="token punctuation">;</span> Load PSP <span class="token keyword">with</span> <span class="token keyword">new</span> <span class="token class-name">process</span> SP    MSR     PSP<span class="token punctuation">,</span> R0    CPSIE   I    <span class="token punctuation">;</span> R0<span class="token operator">-</span>R3<span class="token punctuation">,</span> R12<span class="token punctuation">,</span> LR<span class="token punctuation">,</span> PC<span class="token punctuation">,</span> xPSR restored automatically here    <span class="token punctuation">;</span> S0 <span class="token operator">-</span> S16<span class="token punctuation">,</span> FPSCR restored automatically here <span class="token keyword">if</span> FPCA <span class="token operator">=</span> <span class="token number">1</span>    BX      LR    ALIGN    END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将<code>PSP</code>的值存储到<code>R0</code>。当进入<code>PendSVC_Handler</code>时，上一个任务运行的环境即： <code>xPSR，PC（任务入口地址），R14，R12，R3，R2，R1，R0</code>这些CPU寄存器的值会<code>自动</code>存储到任务的栈中，此时psp指针已经被自动更新。而剩下的<code>r4~r11</code>需要<code>手动</code>保存，这也是为啥要在<code>PendSVC_Handler</code>中保存上文（<code>_context_save</code>）的原因，主要是加载CPU中不能自动保存的寄存器，将其压入任务栈中。</p><p>接着找到下一个要运行的任务<code>k_next_task</code>，将它的任务栈顶加载到<code>R0</code>，然后手动将新任务栈中的内容（此处是指<code>R4~R11</code>）加载到<code>CPU</code>寄存器组中，这就是下文切换，当然还有一些其他没法自动保存的内容也是需要手动加载到<code>CPU</code>寄存器组的。手动加载完后，此时<code>R0</code>已经被更新了，更新psp的值，在退出<code>PendSVC_Handler</code>中断时，会以<code>psp</code>作为基地址，将任务栈中剩下的内容（<code>xPSR，PC（任务入口地址），R14，R12，R3，R2，R1，R0</code>）自动加载到CPU寄存器。</p><p>其实在异常发生时，R14中保存异常返回标志，包括返回后进入任务模式还是处理器模式、使用PSP堆栈指针还是MSP堆栈指针。此时的r14等于0xfffffffd，最表示异常返回后进入任务模式（毕竟<code>PendSVC_Handler</code>优先级是最低的，会返回到任务中），SP以PSP作为堆栈指针出栈，出栈完毕后<code>PSP</code>指向任务栈的栈顶。当调用 BX R14指令后，系统以<code>PSP</code>作为<code>SP</code>指针出栈，把接下来要运行的新任务的任务栈中剩下的内容加载到CPU寄存器：<code>R0、R1、R2、R3、R12、R14（LR）、R15（PC）和xPSR</code>，从而切换到新的任务。</p><h1 id="SysTick"><a href="#SysTick" class="headerlink" title="SysTick"></a>SysTick</h1><h2 id="SysTick初始化"><a href="#SysTick初始化" class="headerlink" title="SysTick初始化"></a>SysTick初始化</h2><p>systick是系统的时基，而且它是内核时钟，只要是<code>M0/M3/M4/M7</code>内核它都会存在<code>systick</code>时钟，并且它是可以被编程配置的，这就对操作系统的移植提供极大的方便。<br><code>TencentOS tiny</code>会在<code>cpu_init</code>函数中将<code>systick</code>进行初始化，即调用<code>cpu_systick_init</code>函数，这样子就不需要用户自行去编写<code>systick</code>初始化相关的代码。</p><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ <span class="token keyword">void</span> <span class="token function">cpu_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    k_cpu_cycle_per_tick <span class="token operator">=</span> TOS_CFG_CPU_CLOCK <span class="token operator">/</span> k_cpu_tick_per_second<span class="token punctuation">;</span>    <span class="token function">cpu_systick_init</span><span class="token punctuation">(</span>k_cpu_cycle_per_tick<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> <span class="token punctuation">(</span>TOS_CFG_CPU_HRTIMER_EN <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">tos_cpu_hrtimer_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>#endif<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ <span class="token keyword">void</span> <span class="token function">cpu_systick_init</span><span class="token punctuation">(</span>k_cycle_t cycle_per_tick<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">port_systick_priority_set</span><span class="token punctuation">(</span>TOS_CFG_CPU_SYSTICK_PRIO<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">port_systick_config</span><span class="token punctuation">(</span>cycle_per_tick<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="SysTick中断"><a href="#SysTick中断" class="headerlink" title="SysTick中断"></a>SysTick中断</h2><p><code>SysTick</code>中断服务函数是需要我们自己编写的，要在里面调用一下<code>TencentOS tiny</code>相关的函数，更新系统时基以驱动系统的运行，<code>SysTick_Handler</code>函数的移植如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">SysTick_Handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">HAL_IncTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tos_knl_is_running</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">tos_knl_irq_enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_tick_handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_knl_irq_leave</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要是需要调用<code>tos_tick_handler</code>函数将系统时基更新，具体见：</p><pre class="line-numbers language-js"><code class="language-js">__API__ <span class="token keyword">void</span> <span class="token function">tos_tick_handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tos_knl_is_running</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">tick_update</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k_tick_t<span class="token punctuation">)</span>1u<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_TIMER_EN <span class="token operator">></span> 0u <span class="token operator">&amp;&amp;</span> TOS_CFG_TIMER_AS_PROC <span class="token operator">></span> 0u    <span class="token function">timer_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>#endif#<span class="token keyword">if</span> TOS_CFG_ROUND_ROBIN_EN <span class="token operator">></span> 0u    <span class="token function">robin_sched</span><span class="token punctuation">(</span>k_curr_task<span class="token operator">-</span><span class="token operator">></span>prio<span class="token punctuation">)</span><span class="token punctuation">;</span>#endif<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不得不说<code>TencentOS tiny</code>源码的实现非常简单，<code>我非常喜欢</code>，在<code>tos_tick_handler</code>中，首先判断一下系统是否已经开始运行，如果没有运行将直接返回，如果已经运行了，那就调用<code>tick_update</code>函数更新系统时基，如果使能了<code>TOS_CFG_TIMER_EN</code> 宏定义表示使用软件定时器，则需要更新相应的处理，此处暂且不提及。如果使能了<code>TOS_CFG_ROUND_ROBIN_EN</code>宏定义，还需要更新时间片相关变量，稍后讲解。</p><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ <span class="token keyword">void</span> <span class="token function">tick_update</span><span class="token punctuation">(</span>k_tick_t tick<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_task_t <span class="token operator">*</span>first<span class="token punctuation">,</span> <span class="token operator">*</span>task<span class="token punctuation">;</span>    k_list_t <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_tick_count <span class="token operator">+</span><span class="token operator">=</span> tick<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tos_list_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>k_tick_list<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    first <span class="token operator">=</span> <span class="token function">TOS_LIST_FIRST_ENTRY</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>k_tick_list<span class="token punctuation">,</span> k_task_t<span class="token punctuation">,</span> tick_list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token operator">-</span><span class="token operator">></span>tick_expires <span class="token operator">&lt;=</span> tick<span class="token punctuation">)</span> <span class="token punctuation">{</span>        first<span class="token operator">-</span><span class="token operator">></span>tick_expires <span class="token operator">=</span> <span class="token punctuation">(</span>k_tick_t<span class="token punctuation">)</span>0u<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        first<span class="token operator">-</span><span class="token operator">></span>tick_expires <span class="token operator">-</span><span class="token operator">=</span> tick<span class="token punctuation">;</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_LIST_FOR_EACH_SAFE</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>k_tick_list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        task <span class="token operator">=</span> <span class="token function">TOS_LIST_ENTRY</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> k_task_t<span class="token punctuation">,</span> tick_list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token operator">-</span><span class="token operator">></span>tick_expires <span class="token operator">></span> <span class="token punctuation">(</span>k_tick_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// we are pending on something, but tick's up, no longer waitting</span>        <span class="token function">pend_task_wakeup</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> PEND_STATE_TIMEOUT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>tick_update</code>函数的主要功能就是将<code>k_tick_count +1</code>，并且判断一下时基列表<code>k_tick_list</code>（也可以成为延时列表吧）的任务是否超时，如果超时则唤醒该任务，否则就直接退出即可。关于时间片的调度也是非常简单，将任务的剩余时间片变量<code>timeslice</code>减一，然后当变量减到0时，将该变量进行重装载<code>timeslice_reload</code>，然后切换任务<code>knl_sched()</code>，其实现过程如下：</p><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ <span class="token keyword">void</span> <span class="token function">robin_sched</span><span class="token punctuation">(</span>k_prio_t prio<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_task_t <span class="token operator">*</span>task<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k_robin_state <span class="token operator">!=</span> TOS_ROBIN_STATE_ENABLED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    task <span class="token operator">=</span> <span class="token function">readyqueue_first_task_get</span><span class="token punctuation">(</span>prio<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>task <span class="token operator">||</span> <span class="token function">knl_is_idle</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">readyqueue_is_prio_onlyone</span><span class="token punctuation">(</span>prio<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">knl_is_sched_locked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token operator">-</span><span class="token operator">></span>timeslice <span class="token operator">></span> <span class="token punctuation">(</span>k_timeslice_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">--</span>task<span class="token operator">-</span><span class="token operator">></span>timeslice<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token operator">-</span><span class="token operator">></span>timeslice <span class="token operator">></span> <span class="token punctuation">(</span>k_timeslice_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">readyqueue_move_head_to_tail</span><span class="token punctuation">(</span>k_curr_task<span class="token operator">-</span><span class="token operator">></span>prio<span class="token punctuation">)</span><span class="token punctuation">;</span>    task <span class="token operator">=</span> <span class="token function">readyqueue_first_task_get</span><span class="token punctuation">(</span>prio<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token operator">-</span><span class="token operator">></span>timeslice_reload <span class="token operator">==</span> <span class="token punctuation">(</span>k_timeslice_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>        task<span class="token operator">-</span><span class="token operator">></span>timeslice <span class="token operator">=</span> k_robin_default_timeslice<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        task<span class="token operator">-</span><span class="token operator">></span>timeslice <span class="token operator">=</span> task<span class="token operator">-</span><span class="token operator">></span>timeslice_reload<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> TencentOS tiny </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TencentOS tiny </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TencentOS  tiny】深度源码分析（1）——task</title>
      <link href="/tencentos-tiny-3/"/>
      <url>/tencentos-tiny-3/</url>
      
        <content type="html"><![CDATA[<h1 id="任务的基本概念"><a href="#任务的基本概念" class="headerlink" title="任务的基本概念"></a>任务的基本概念</h1><p>从系统的角度看，任务是竞争系统资源的最小运行单元。TencentOS  tiny是一个支持多任务的操作系统，任务可以使用或等待CPU、使用内存空间等系统资源，并独立于其它任务运行，理论上任何数量的任务都可以共享同一个优先级，这样子处于就绪态的多个相同优先级任务将会以时间片切换的方式共享处理器。</p><blockquote><p>不过<strong>要注意</strong>的是：在TencentOS  tiny中，不能创建与空闲任务相同优先级的任务<code>K_TASK_PRIO_IDLE</code>，相同优先级下的任务需要允许使用时间片调度，打开<code>TOS_CFG_ROUND_ROBIN_EN</code>。</p></blockquote><p>简而言之： TencentOS  tiny的任务可认为是一系列独立任务的集合。每个任务在自己的环境中运行。在任何时刻，只有一个任务得到运行，由TencentOS  tiny调度器决定运行哪个任务。从<code>宏观</code>看上去所有的任务都在同时在执行。</p><p>TencentOS中的任务是抢占式调度机制，高优先级的任务可打断低优先级任务，低优先级任务必须在高优先级任务阻塞或结束后才能得到调度。同时TencentOS也支持时间片轮转调度方式。</p><p>系统默认可以支持10个优先级，<code>0～TOS_CFG_TASK_PRIO_MAX</code>，这个宏定义是可以修改的，优先级数值越大的任务优先级越低，<code>(TOS_CFG_TASK_PRIO_MAX - (k_prio_t)1u)</code>为最低优先级，分配给空闲任务使用。</p><pre class="line-numbers language-js"><code class="language-js">#define K_TASK_PRIO_IDLE         <span class="token punctuation">(</span>k_prio_t<span class="token punctuation">)</span><span class="token punctuation">(</span>TOS_CFG_TASK_PRIO_MAX <span class="token operator">-</span> <span class="token punctuation">(</span>k_prio_t<span class="token punctuation">)</span>1u<span class="token punctuation">)</span>#define K_TASK_PRIO_INVALID      <span class="token punctuation">(</span>k_prio_t<span class="token punctuation">)</span><span class="token punctuation">(</span>TOS_CFG_TASK_PRIO_MAX<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h1><p>TencentOS  tiny任务状态有以下几种。</p><ul><li>就绪态（K_TASK_STATE_READY）：该任务在就绪列表中，就绪的任务已经具备执行的能力，只等待调度器进行调度，新创建的任务会初始化为就绪态。</li><li>运行态（K_TASK_STATE_READY）：该状态表明任务正在执行，此时它占用处理器，<strong>其实此时的任务还是处于就绪列表中的</strong>，TencentOS调度器选择运行的永远是处于最高优先级的就绪态任务，当任务被运行的一刻，它的任务状态就变成了运行态。</li><li>睡眠态（K_TASK_STATE_SLEEP）：如果任务当前正在休眠让出CPU使用权，那么就可以说这个任务处于休眠状态，该任务不在就绪列表中，此时任务处于睡眠列表中（或者叫延时列表）。</li><li>等待态（K_TASK_STATE_PEND）：任务正在等待信号量、队列或者等待事件等状态。</li><li>挂起态（K_TASK_STATE_SUSPENDED）：任务被挂起，此时任务对调度器而言是不可见的。</li><li>退出态（K_TASK_STATE_DELETED）：该任务运行结束，并且被删除。</li><li>等待超时状态（K_TASK_STATE_PENDTIMEOUT）：任务正在等待信号量、队列或者等待事件发生超时的状态。</li><li>睡眠挂起态（K_TASK_STATE_SLEEP_SUSPENDED）：任务在睡眠中被挂起时的状态。</li><li>等待挂起态（K_TASK_STATE_PEND_SUSPENDED）：任务正在等待信号量、队列或者等待事件时被挂起的状态。</li><li>等待超时挂起态（K_TASK_STATE_PENDTIMEOUT_SUSPENDED）：任务正在等待信号量、队列或者等待事件发生超时，但此时任务已经被挂起的状态。</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// ready to schedule</span><span class="token comment" spellcheck="true">// a task's pend_list is in readyqueue</span>#define K_TASK_STATE_READY                <span class="token punctuation">(</span>k_task_state_t<span class="token punctuation">)</span><span class="token number">0x0000</span><span class="token comment" spellcheck="true">// delayed, or pend for a timeout</span><span class="token comment" spellcheck="true">// a task's tick_list is in k_tick_list</span>#define K_TASK_STATE_SLEEP                <span class="token punctuation">(</span>k_task_state_t<span class="token punctuation">)</span><span class="token number">0x0001</span><span class="token comment" spellcheck="true">// pend for something</span><span class="token comment" spellcheck="true">// a task's pend_list is in some pend object's list</span>#define K_TASK_STATE_PEND                 <span class="token punctuation">(</span>k_task_state_t<span class="token punctuation">)</span><span class="token number">0x0002</span><span class="token comment" spellcheck="true">// suspended</span>#define K_TASK_STATE_SUSPENDED            <span class="token punctuation">(</span>k_task_state_t<span class="token punctuation">)</span><span class="token number">0x0004</span><span class="token comment" spellcheck="true">// deleted</span>#define K_TASK_STATE_DELETED              <span class="token punctuation">(</span>k_task_state_t<span class="token punctuation">)</span><span class="token number">0x0008</span><span class="token comment" spellcheck="true">// actually we don't really need those TASK_STATE below, if you understand the task state deeply, the code can be much more elegant. </span><span class="token comment" spellcheck="true">// we are pending, also we are waitting for a timeout(eg. tos_sem_pend with a valid timeout, not TOS_TIME_FOREVER)</span><span class="token comment" spellcheck="true">// both a task's tick_list and pend_list is not empty</span>#define K_TASK_STATE_PENDTIMEOUT                      <span class="token punctuation">(</span>k_task_state_t<span class="token punctuation">)</span><span class="token punctuation">(</span>K_TASK_STATE_PEND <span class="token operator">|</span> K_TASK_STATE_SLEEP<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// suspended when sleeping</span>#define K_TASK_STATE_SLEEP_SUSPENDED                  <span class="token punctuation">(</span>k_task_state_t<span class="token punctuation">)</span><span class="token punctuation">(</span>K_TASK_STATE_SLEEP <span class="token operator">|</span> K_TASK_STATE_SUSPENDED<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// suspened when pending</span>#define K_TASK_STATE_PEND_SUSPENDED                   <span class="token punctuation">(</span>k_task_state_t<span class="token punctuation">)</span><span class="token punctuation">(</span>K_TASK_STATE_PEND <span class="token operator">|</span> K_TASK_STATE_SUSPENDED<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// suspended when pendtimeout</span>#define K_TASK_STATE_PENDTIMEOUT_SUSPENDED            <span class="token punctuation">(</span>k_task_state_t<span class="token punctuation">)</span><span class="token punctuation">(</span>K_TASK_STATE_PENDTIMEOUT <span class="token operator">|</span> K_TASK_STATE_SUSPENDED<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="TencentOS中维护任务的数据结构"><a href="#TencentOS中维护任务的数据结构" class="headerlink" title="TencentOS中维护任务的数据结构"></a>TencentOS中维护任务的数据结构</h1><h2 id="就绪列表"><a href="#就绪列表" class="headerlink" title="就绪列表"></a>就绪列表</h2><p>TencentOS  tiny维护一条就绪列表，用于挂载系统中的所有处于就绪态的任务，他是<code>readyqueue_t</code>类型的列表，其成员变量如下：</p><pre class="line-numbers language-js"><code class="language-js">readyqueue_t        k_rdyq<span class="token punctuation">;</span>typedef struct readyqueue_st <span class="token punctuation">{</span>    k_list_t    task_list_head<span class="token punctuation">[</span>TOS_CFG_TASK_PRIO_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>    uint32_t    prio_mask<span class="token punctuation">[</span>K_PRIO_TBL_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    k_prio_t    highest_prio<span class="token punctuation">;</span><span class="token punctuation">}</span> readyqueue_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>task_list_head</code>是列表类型<code>k_list_t</code>的数组，TencentOS  tiny为每个优先级的任务都分配一个列表，系统支持最大优先级为<code>TOS_CFG_TASK_PRIO_MAX</code><br><code>prio_mask</code>则是优先级掩码数组，它是一个类型为32位变量的数组，数组成员个数由<code>TOS_CFG_TASK_PRIO_MAX</code>决定：</p><pre class="line-numbers language-js"><code class="language-js">#define K_PRIO_TBL_SIZE         <span class="token punctuation">(</span><span class="token punctuation">(</span>TOS_CFG_TASK_PRIO_MAX <span class="token operator">+</span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">32</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当<code>TOS_CFG_TASK_PRIO_MAX</code>不超过32时数组成员变量只有一个，就是32位的变量数值，那么该变量的每一位代表一个优先级。比如当<code>TOS_CFG_TASK_PRIO_MAX</code>为64时，<code>prio_mask[0]</code>变量的每一位（bit）代表<code>0-31</code>优先级，而<code>prio_mask[1]</code>变量的每一位代表<code>32-63</code>优先级。</p><p><code>highest_prio</code>则是记录当前优先级列表的最高优先级，方便索引<code>task_list_head</code>。</p><h2 id="延时列表"><a href="#延时列表" class="headerlink" title="延时列表"></a>延时列表</h2><p>与系统时间相关的任务都会被挂载到这个列表中，可能是睡眠、有期限地等待信号量、事件、消息队列等情况~</p><pre><code>k_list_t             k_tick_list;</code></pre><h2 id="任务控制块"><a href="#任务控制块" class="headerlink" title="任务控制块"></a>任务控制块</h2><p>在多任务系统中，任务的执行是由系统调度的。系统为了顺利的调度任务，为每个任务都额外定义了一个任务控制块，这个任务控制块就相当于任务的身份证，里面存有任务的所有信息，比如任务的栈指针，任务名称，任务的形参等。有了这个任务控制块之后，以后系统对任务的全部操作都可以通过这个任务控制块来实现。<br>TencentOS 任务控制块如下：</p><pre class="line-numbers language-js"><code class="language-js">typedef struct k_task_st <span class="token punctuation">{</span>    k_stack_t          <span class="token operator">*</span>sp<span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">/**&lt; 任务栈指针,用于切换上下文*/</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    knl_obj_t           knl_obj<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/**&lt; 只是为了验证，测试当前对象是否真的是一项任务。*/</span>#endif    char               <span class="token operator">*</span>name<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">/**&lt; 任务名称 */</span>    k_task_entry_t      entry<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">/**&lt; 任务主体 */</span>    <span class="token keyword">void</span>               <span class="token operator">*</span>arg<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/**&lt; 任务主体形参 */</span>    k_task_state_t      state<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">/**&lt; 任务状态 */</span>    k_prio_t            prio<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">/**&lt; 任务优先级 */</span>    k_stack_t          <span class="token operator">*</span>stk_base<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">/**&lt; 任务栈基地址 */</span>    size_t              stk_size<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">/**&lt; 任务栈大小 */</span>    k_tick_t            tick_expires<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/**&lt; 任务阻塞的时间 */</span>    k_list_t            tick_list<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/**&lt; 延时列表 */</span>    k_list_t            pend_list<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/**&lt; 就绪、等待列表 */</span>#<span class="token keyword">if</span> TOS_CFG_MUTEX_EN <span class="token operator">></span> 0u    k_list_t            mutex_own_list<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/**&lt; 任务拥有的互斥量 */</span>    k_prio_t            prio_pending<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/*&lt; 用于记录持有互斥量的任务初始优先级，在优先级继承中使用 */</span>#endif    pend_obj_t         <span class="token operator">*</span>pending_obj<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/**&lt; 记录任务此时挂载到的列表 */</span>    pend_state_t        pend_state<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/**&lt; 等待被唤醒的原因（状态） */</span>#<span class="token keyword">if</span> TOS_CFG_ROUND_ROBIN_EN <span class="token operator">></span> 0u    k_timeslice_t       timeslice_reload<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/**&lt; 时间片初始值（重装载值） */</span>    k_timeslice_t       timeslice<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/**&lt; 剩余时间片 */</span>#endif#<span class="token keyword">if</span> TOS_CFG_MSG_EN <span class="token operator">></span> 0u    <span class="token keyword">void</span>               <span class="token operator">*</span>msg_addr<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">/**&lt; 保存接收到的消息 */</span>    size_t              msg_size<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/**&lt; 保存接收到的消息大小 */</span>#endif#<span class="token keyword">if</span> TOS_CFG_EVENT_EN <span class="token operator">></span> 0u    k_opt_t             opt_event_pend<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/**&lt; 等待事件的的操作类型：TOS_OPT_EVENT_PEND_ANY 、 TOS_OPT_EVENT_PEND_ALL */</span>    k_event_flag_t      flag_expect<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**&lt; 期待发生的事件 */</span>    k_event_flag_t     <span class="token operator">*</span>flag_match<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/**&lt; 等待到的事件 */</span>#endif<span class="token punctuation">}</span> k_task_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h1><p>在TencentOS  tiny中，凡是使用<code>__API__</code>修饰的函数都是提供给用户使用的，而使用<code>__KERNEL__</code>修饰的代码则是给内核使用的。<br>TencentOS的创建任务函数有好几个参数：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>entry</td><td>任务主体</td></tr><tr><td>name</td><td>任务名字</td></tr><tr><td>arg</td><td>任务形参</td></tr><tr><td>task</td><td>任务控制块</td></tr><tr><td>stk_base</td><td>任务栈基地址</td></tr><tr><td>stk_size</td><td>任务栈大小</td></tr><tr><td>prio</td><td>优先级</td></tr><tr><td>timeslice</td><td>时间片</td></tr></tbody></table><p>参数详解（来源TencentOS  tiny开发指南）：</p><ul><li><p>task</p><p>这是一个k_task_t类型的指针，k_task_t是内核的任务结构体类型。注意：task指针，应该指向生命周期大于待创建任务体生命周期的k_task_t类型变量，如果该指针指向的变量生命周期比待创建的任务体生命周期短，譬如可能是一个生命周期极端的函数栈上变量，可能会出现任务体还在运行而k_task_t变量已被销毁，会导致系统调度出现不可预知问题。</p></li><li><p>name</p><p>指向任务名字符串的指针。注意：同task，该指针指向的字符串生命周期应该大于待创建的任务体生命周期，一般来说，传入字符串常量指针即可。</p></li><li><p>entry</p><p>任务体运行的函数入口。当任务创建完毕进入运行状态后，entry是任务执行的入口，用户可以在此函数中编写业务逻辑。</p></li><li><p>arg</p><p>传递给任务入口函数的参数。</p></li><li><p>prio</p><p>任务优先级。prio的数值越小，优先级越高。用户可以在tos_config.h中，通过TOS_CFG_TASK_PRIO_MAX来配置任务优先级的最大数值，在内核的实现中，idle任务的优先级会被分配为TOS_CFG_TASK_PRIO_MAX - 1,此优先级只能被idle任务使用。因此对于一个用户创建的任务来说，合理的优先级范围应该为[0, TOS_CFG_TASK_PRIO_MAX - 2]。另外TOS_CFG_TASK_PRIO_MAX的配置值必需大于等于8。</p></li><li><p>stk_base</p><p>任务在运行时使用的栈空间的起始地址。注意：同task，该指针指向的内存空间的生命周期应该大于待创建的任务体生命周期。stk_base是k_stack_t类型的数组起始地址。</p></li><li><p>stk_size</p><p>任务的栈空间大小。注意：因为stk_base是k_stack_t类型的数组指针，因此实际栈空间所占内存大小为stk_size * sizeof(k_stack_t)。</p></li><li><p>timeslice</p><p>时间片轮转机制下当前任务的时间片大小。当timeslice为0时，任务调度时间片会被设置为默认大小（TOS_CFG_CPU_TICK_PER_SECOND / 10），系统时钟滴答（systick）数 / 10。</p></li></ul><p>创建任务的实现如下：首先对参数进行检查，还要再提一下：<strong>在TencentOS中，不能创建与空闲任务相同优先级的任务<code>K_TASK_PRIO_IDLE</code></strong>。然后调用<code>cpu_task_stk_init</code>函数将任务栈进行初始化，并且将传入的参数记录到任务控制块中。如果打开了<code>TOS_CFG_ROUND_ROBIN_EN</code>宏定义，则表示支持时间片调度，则需要配置时间片相关的信息<code>timeslice</code>到任务控制块中。然后调用<code>task_state_set_ready</code>函数将新创建的任务设置为就绪态<code>K_TASK_STATE_READY</code>，再调用<code>readyqueue_add_tail</code>函数将任务插入就绪列表<code>k_rdyq</code>中。如果调度器运行起来了，则进行一次任务调度。</p><blockquote><p>个人感觉吧，没有从堆中动态分配还是有点小小的遗憾，我更喜欢简单的函数接口~！</p></blockquote><p>代码如下：</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_task_create</span><span class="token punctuation">(</span>k_task_t <span class="token operator">*</span>task<span class="token punctuation">,</span>                                char <span class="token operator">*</span>name<span class="token punctuation">,</span>                                k_task_entry_t entry<span class="token punctuation">,</span>                                <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span>                                k_prio_t prio<span class="token punctuation">,</span>                                k_stack_t <span class="token operator">*</span>stk_base<span class="token punctuation">,</span>                                size_t stk_size<span class="token punctuation">,</span>                                k_timeslice_t timeslice<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_IN_IRQ_CHECK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>stk_base<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>stk_size <span class="token operator">&lt;</span> <span class="token function">sizeof</span><span class="token punctuation">(</span>cpu_context_t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TASK_STK_SIZE_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>prio <span class="token operator">==</span> K_TASK_PRIO_IDLE <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">knl_is_idle</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TASK_PRIO_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>prio <span class="token operator">></span> K_TASK_PRIO_IDLE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TASK_PRIO_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">task_reset</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token function">knl_object_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>task<span class="token operator">-</span><span class="token operator">></span>knl_obj<span class="token punctuation">,</span> KNL_OBJ_TYPE_TASK<span class="token punctuation">)</span><span class="token punctuation">;</span>#endif    task<span class="token operator">-</span><span class="token operator">></span>sp        <span class="token operator">=</span> <span class="token function">cpu_task_stk_init</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>entry<span class="token punctuation">,</span> arg<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>task_exit<span class="token punctuation">,</span> stk_base<span class="token punctuation">,</span> stk_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    task<span class="token operator">-</span><span class="token operator">></span>entry     <span class="token operator">=</span> entry<span class="token punctuation">;</span>    task<span class="token operator">-</span><span class="token operator">></span>arg       <span class="token operator">=</span> arg<span class="token punctuation">;</span>    task<span class="token operator">-</span><span class="token operator">></span>name      <span class="token operator">=</span> name<span class="token punctuation">;</span>    task<span class="token operator">-</span><span class="token operator">></span>prio      <span class="token operator">=</span> prio<span class="token punctuation">;</span>    task<span class="token operator">-</span><span class="token operator">></span>stk_base  <span class="token operator">=</span> stk_base<span class="token punctuation">;</span>    task<span class="token operator">-</span><span class="token operator">></span>stk_size  <span class="token operator">=</span> stk_size<span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_ROUND_ROBIN_EN <span class="token operator">></span> 0u    task<span class="token operator">-</span><span class="token operator">></span>timeslice_reload <span class="token operator">=</span> timeslice<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeslice <span class="token operator">==</span> <span class="token punctuation">(</span>k_timeslice_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>        task<span class="token operator">-</span><span class="token operator">></span>timeslice <span class="token operator">=</span> k_robin_default_timeslice<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        task<span class="token operator">-</span><span class="token operator">></span>timeslice <span class="token operator">=</span> timeslice<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">task_state_set_ready</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">readyqueue_add_tail</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tos_knl_is_running</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="任务销毁"><a href="#任务销毁" class="headerlink" title="任务销毁"></a>任务销毁</h1><p>这个函数十分简单，根据传递进来的任务控制块销毁任务，也可以传递进NULL表示销毁当前运行的任务。但是不允许销毁空闲任务<code>k_idle_task</code>，当调度器被锁住时不能销毁自身，会返回<code>K_ERR_SCHED_LOCKED</code>错误代码。如果使用了互斥量，当任务被销毁时会释放掉互斥量，并且根据任务所处的状态进行销毁，比如任务处于就绪态、延时态、等待态，则会从<code>对应的状态列表</code>中移除。<br>代码实现如下：</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_task_destroy</span><span class="token punctuation">(</span>k_task_t <span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_IN_IRQ_CHECK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        task <span class="token operator">=</span> k_curr_task<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">knl_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>task<span class="token operator">-</span><span class="token operator">></span>knl_obj<span class="token punctuation">,</span> KNL_OBJ_TYPE_TASK<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">knl_is_idle</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TASK_DESTROY_IDLE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">knl_is_self</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">knl_is_sched_locked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_SCHED_LOCKED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_MUTEX_EN <span class="token operator">></span> 0u    <span class="token comment" spellcheck="true">// when we die, wakeup all the people in this land.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tos_list_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>task<span class="token operator">-</span><span class="token operator">></span>mutex_own_list<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">task_mutex_release</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">task_state_is_ready</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// that's simple, good kid</span>        <span class="token function">readyqueue_remove</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">task_state_is_sleeping</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">tick_list_remove</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">task_state_is_pending</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">pend_list_remove</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">task_reset</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">task_state_set_deleted</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="任务睡眠"><a href="#任务睡眠" class="headerlink" title="任务睡眠"></a>任务睡眠</h1><p>任务睡眠非常简单，主要的思路就是将任务从就绪列表移除，然后添加到延时列表中<code>k_tick_list</code>，如果调度器被锁，直接返回错误代码<code>K_ERR_SCHED_LOCKED</code>，如果睡眠时间为0，则调用<code>tos_task_yield</code>函数发起一次任务调度；调用<code>tick_list_add</code>函数将任务<code>插入延时列表</code>中，睡眠的时间<code>delay</code>是由用户指定的。不过<strong>需要注意</strong>的是<strong>如果任务睡眠的时间是永久睡眠<code>TOS_TIME_FOREVER</code></strong>，将返回错误代码<code>K_ERR_DELAY_FOREVER</code>，这是因为任务睡眠是<code>主动行为</code>，如果永久睡眠了，将没法主动唤醒，而任务等待事件、信号量、消息队列等行为是被动行为，可以是永久等待，一旦事件发生了、信号量呗释放、消息队列不为空时任务就会被唤醒，这是<code>被动行为</code>，这两点需要区分开来。最后调用<code>readyqueue_remove</code>函数将任务从就绪列表中移除，然后调用<code>knl_sched</code>函数发起一次任务调度，就能切换另一个任务。<br>任务睡眠的代码如下：</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_task_delay</span><span class="token punctuation">(</span>k_tick_t delay<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_IN_IRQ_CHECK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">knl_is_sched_locked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_SCHED_LOCKED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>delay <span class="token operator">==</span> <span class="token punctuation">(</span>k_tick_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">tos_task_yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tick_list_add</span><span class="token punctuation">(</span>k_curr_task<span class="token punctuation">,</span> delay<span class="token punctuation">)</span> <span class="token operator">!=</span> K_ERR_NONE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_DELAY_FOREVER<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">readyqueue_remove</span><span class="token punctuation">(</span>k_curr_task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> TencentOS tiny </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TencentOS tiny </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TencentOS tiny】 移植到STM32F103全教程</title>
      <link href="/tencentos-tiny-2/"/>
      <url>/tencentos-tiny-2/</url>
      
        <content type="html"><![CDATA[<h1 id="移植前的准备工作"><a href="#移植前的准备工作" class="headerlink" title="移植前的准备工作"></a>移植前的准备工作</h1><h2 id="1-获取STM32的裸机工程模板"><a href="#1-获取STM32的裸机工程模板" class="headerlink" title="1. 获取STM32的裸机工程模板"></a>1. 获取STM32的裸机工程模板</h2><p>STM32的裸机工程模板直接使用野火STM32开发板配套的固件库例程即可。可以从我<code>github</code>上获取<a href="https://github.com/jiejieTop/TencentOS-Demo" target="_blank" rel="noopener">https://github.com/jiejieTop/TencentOS-Demo</a></p><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919200430213.png?" alt=""></p><h1 id="下载TencentOS-tiny-源码"><a href="#下载TencentOS-tiny-源码" class="headerlink" title="下载TencentOS tiny 源码"></a>下载TencentOS tiny 源码</h1><p>TencentOS tiny的源码可从<code>TencentOS tiny</code> <strong>GitHub</strong>仓库地址<a href="https://github.com/Tencent/TencentOS-tiny" target="_blank" rel="noopener">https://github.com/Tencent/TencentOS-tiny</a>下载，如果GitHub下载慢，也可以通过腾讯工蜂开源仓下载，地址：<a href="https://git.code.tencent.com/Tencent_Open_Source/TencentOS-tiny" target="_blank" rel="noopener">https://git.code.tencent.com/Tencent_Open_Source/TencentOS-tiny</a> ，大家在移植时并不需要把整个<code>TencentOS tiny</code> 源码放进工程文件中，否则工程的代码量太大。杰杰将在下文讲解如何将<code>TencentOS tiny</code>移植到工程中去，以及如何把<code>TencentOS tiny</code>源码中的核心部分单独提取出来，方便以后在不同的平台上移植。目前使用的是<code>TencentOS tiny</code>最新版本，由于<code>TencentOS tiny</code>在不断更新，如果以后<code>TencentOS tiny</code>更新到更高的版本，则以最新的版本为准。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919200841964.png?" alt="TencentOS tiny源码"></p><h1 id="TencentOS-tiny源码核心文件夹分析"><a href="#TencentOS-tiny源码核心文件夹分析" class="headerlink" title="TencentOS tiny源码核心文件夹分析"></a>TencentOS tiny源码核心文件夹分析</h1><p>打开<code>TencentOS tiny</code>源码文件，可以看见里面有<code>12</code>个文件夹，下面先来了解主要文件夹及其子文件夹的作用，然后将<code>TencentOS tiny</code>源码的核心文件提取出来，添加到工程根目录下的文件夹中，因为工程只需要有用的源码文件，而不是全部的<code>TencentOS tiny</code>源码，所以可以避免工程过于庞大。</p><table><thead><tr><th>一级目录</th><th>二 / 三级目录</th><th>说明（杰杰）</th></tr></thead><tbody><tr><td><strong><code>arch</code></strong></td><td><strong><code>arm</code></strong></td><td><strong><code>TencentOS tiny适配的IP核架构（含M核中断、调度、tick相关代码），对我们的移植很重要</code></strong></td></tr><tr><td>arch</td><td>risc-v</td><td>TencentOS tiny适配的risc-v架构</td></tr><tr><td>board</td><td>TencentOS_tiny_EVB_MX</td><td>TencentOS tiny 定制开发板demo，包含AT适配框架、MQTT协议、安全组件等</td></tr><tr><td>component</td><td>connectivity / loraWAN</td><td>loRaWAN协议栈实现源码及适配层</td></tr><tr><td></td><td>connectivity / Eclipse-Paho-MQTT</td><td>MQTT协议栈实现源码及适配层</td></tr><tr><td></td><td>connectivity / TencentCloud_SDK</td><td>腾讯云C-SDK实现源码及适配层</td></tr><tr><td></td><td>fs</td><td>文件系统实现源码</td></tr><tr><td></td><td>security</td><td>mbedtls 安全协议源码</td></tr><tr><td></td><td>utils</td><td>包含json相关源码</td></tr><tr><td>devices</td><td></td><td>TencentOS tiny适配的一些外设驱动（如串口wifi gprs 驱动等）</td></tr><tr><td>doc</td><td></td><td>TencentOS tiny相关技术文档及开发指南（<code>建议多看这部分</code>）</td></tr><tr><td>examples</td><td></td><td>TencentOS tiny提供的功能示例</td></tr><tr><td><strong><code>kernel</code></strong></td><td><strong><code>core</code></strong></td><td><strong><code>TencentOS tiny内核源码（这部分是最重要的）</code></strong></td></tr><tr><td></td><td><strong><code>hal</code></strong></td><td><strong><code>TencentOS tiny驱动抽象层</code></strong></td></tr><tr><td></td><td><strong>pm</strong></td><td><strong>TencentOS tiny低功耗模块源码</strong></td></tr><tr><td>net</td><td>at</td><td>TencentOS tiny为串口类通信模组提供的AT框架实现层</td></tr><tr><td></td><td>lora_module_wrapper</td><td>TencentOS tiny为串口类LoraWAN模块提供的移植框架</td></tr><tr><td></td><td>lwip</td><td>Lwip协议实现源码及适配层</td></tr><tr><td></td><td>sal_module_wrapper</td><td>TencentOS tiny为串口类网络模块（wifi gprs）提供的socket移植框架</td></tr><tr><td></td><td>tencent_firmware_module_wrapper</td><td>TencentOS tiny提供的腾讯定制模组移植框架</td></tr><tr><td>osal</td><td>cmsis_os</td><td>TencentOS tiny提供的cmsis os 适配</td></tr><tr><td>platform</td><td>hal</td><td>TencentOS tiny适配的部分芯片的驱动实现源码</td></tr><tr><td></td><td>vendor_bsp</td><td>芯片厂家提供的原厂bsp固件库，如STM32的HAL库</td></tr><tr><td>test</td><td></td><td>存放TencentOS tiny提供的一些测试代码，含内核及上层模块示例及测试代码</td></tr><tr><td>tools</td><td></td><td>存放TencentOS tiny提供的工具，小程序，配置工具等</td></tr></tbody></table><p>简单提一下我们的重点文件夹：</p><ul><li><p><strong>arch</strong>: <code>TencentOS tiny</code>是软件，单片机是硬件，为了使<code>TencentOS tiny</code>运行在单片机上面，<code>TencentOS tiny</code>和单片机必须关联在一起，那么如何关联呢？还是要通过代码来关联，这部分关联的文件叫接口文件，通常由汇编语言和C语言联合编写。这些接口文件都是跟硬件密切相关的，不同的硬件接口文件是不一样的，但都大同小异。<code>TencentOS tiny</code>在<code>arch\arm\arm-v6m</code>目录中存放了<code>cortex m0</code>内核的单片机的接口文件，在<code>arch\arm\arm-v7m</code>目录中存放了<code>cortex m3、m4</code>和<code>m7</code>内核的单片机的接口文件，以及一些通用的接口文件，基于这些内核的mcu都可以使用里面的接口文件。</p></li><li><p><strong>kernel</strong>：<code>kernel</code>是<code>TencentOS tiny</code>内核核心源码，它的重要性我也不用多说，毕竟整个内核就是由这里面的文件组成，而其他文件夹都是基于内核的组件。</p></li></ul><h1 id="提取TencentOS-tiny内核源码"><a href="#提取TencentOS-tiny内核源码" class="headerlink" title="提取TencentOS tiny内核源码"></a>提取TencentOS tiny内核源码</h1><p>将裸机工程源码重命名为hello-world，然后在裸机工程中新建一个<code>TencentOS</code>文件夹，接着将<code>kernel</code>文件夹、<code>arch</code>文件夹、添加到<code>TencentOS</code>文件夹下：</p><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919203814911.png?" alt=""></p><p>除了<code>TencentOS tiny</code>的核心文件外，还需要移植一下其他文件，如关于<code>TencentOS tiny</code>系统的配置文件。这是一些可以被用户修改的文件，所以会放在具体的工程文件中。<code>board</code>就是<code>TencentOS tiny</code>为一些常用开发板开发的<code>demo</code>文件夹，其内有各个工程的配置文件，选一个与移植芯片最相机的开发板，找到它的配置文件<code>tos_config.h</code>，比如我们可以选择：<code>TencentOS-tiny\board\STM32F103_SIM800A\TOS-CONFIG</code>路径下的配置文件，把它拷贝到我们工程中的<code>TencentOS</code>文件夹下，当然你也可以把整个<code>TOS-CONFIG</code>目录拷贝过去，把其他无关的配置删掉就好了。</p><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919204033306.png" alt=""></p><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919204358500.png" alt=""></p><p>这个配置文件<strong>很重要</strong>，后续在移植工程时，我们需要对这个配置文件进行修改，这样子可以裁剪<code>TencentOS tiny</code>的功能，得到最适合的工程配置。</p><h1 id="开始移植"><a href="#开始移植" class="headerlink" title="开始移植"></a>开始移植</h1><p>打开<code>TencentOS-Demo\hello-world\Project\RVMDK（uv5）</code>路径下的<code>TencentOS.uvprojx</code>文件。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919205248405.png?" alt=""></p><ol><li>根据下图的提示，新建<code>3</code>个工程分组，分别为<code>tos/kernel、tos/arch、tos/config</code>，这样可以<strong>见其名知其意</strong>，这些工程分组分别保存<code>TencentOS tiny</code>的<strong>内核源码、接口文件、以及配置文件</strong>。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919205631749.png?" alt=""></li><li>根据下图将<code>TencentOS-Demo\hello-world\TencentOS\kernel\core</code>路径下的所有<code>.c文件</code>添加到<code>tos/kernel</code>工程分组中，也将<code>\TencentOS-Demo\hello-world\TencentOS\kernel\pm</code>目录下的所有<code>.c文件</code>添加到<code>tos/kernel</code>工程分组中:<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919211038774.png?" alt=""></li><li>同理将<code>TencentOS-Demo\hello-world\TencentOS\arch\arm\arm-v7m\common</code>路径下的 <code>tos_cpu.c、tos_fault.c</code>添加到<code>tos/arch</code>工程分组下，也将<code>TencentOS-Demo\hello-world\TencentOS\arch\arm\arm-v7m\cortex-m3\armcc</code>路径下的 <code>port_s.S、port_c.c</code>文件添加到<code>tos/arch</code>工程分组下<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919210818240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppZWppZW1jdQ==,size_16,color_FFFFFF,t_70" alt=""></li><li>最后再将<code>TencentOS-Demo\hello-world\TencentOS\TOS-CONFIG</code>路径下的<code>tos_config.h</code>文件添加到<code>tos/config</code>工程分组中。</li></ol><p><strong>需要注意的是</strong>，在<code>tos/arch</code>分组中添加的<code>port_s.S</code>文件，需要在添加时选择文件类型为<code>“All files (*.*)”</code>，添加(<em>.h)文件类型的时候也需要选择文件类型为`“All files (</em>.*)”`</p><p>添加完成后的文件：<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919211133584.png" alt=""></p><h1 id="指定头文件路径"><a href="#指定头文件路径" class="headerlink" title="指定头文件路径"></a>指定头文件路径</h1><p>编译时需要为这些源文件指定头文件的路径，否则编译会报错。<code>TencentOS tiny</code>的源码中有很多头文件，必须将对应的路径添加到开发环境里。在添加<code>TencentOS tiny</code>源码时，一些其他的头文件夹也被复制到了工程目录中，所以这些文件夹的路径也要加到开发环境中。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919211444152.png?" alt=""><br>这些头文件的路径分别是：</p><pre><code>..\..\TencentOS\arch\arm\arm-v7m\common\include..\..\TencentOS\arch\arm\arm-v7m\cortex-m3\armcc..\..\TencentOS\kernel\core\include..\..\TencentOS\kernel\pm\include..\..\TencentOS\TOS-CONFIG</code></pre><p>同时还要在配置中勾选支持<code>C99</code>模式：<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919213556464.png?" alt=""></p><h1 id="尝试编译"><a href="#尝试编译" class="headerlink" title="尝试编译"></a>尝试编译</h1><p>如果你走到这一步，那么可以尝试编译一下，不过我测试时编译是没通过的，原因是缺少了部分头文件：<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919213852458.png?" alt=""><br>不过这不影响，我们在配置文件<code>tos_config.h</code>中修改一下就好，添加两句话</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span> </span><span class="token comment" spellcheck="true">// 或者 #include &lt;stddef.h></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如下图：<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919214203165.png?" alt=""></p><h1 id="修改中断函数"><a href="#修改中断函数" class="headerlink" title="修改中断函数"></a>修改中断函数</h1><h2 id="注释PendSV-Handler-函数"><a href="#注释PendSV-Handler-函数" class="headerlink" title="注释PendSV_Handler()函数"></a>注释PendSV_Handler()函数</h2><p>鉴于<code>TencentOS tiny</code>已经处理好<code>PendSV与SysTick</code>中断了，就不需要用户自己去处理，所以要在中断相关的源文件（<code>stm32f10x_it.c文件</code>）中<strong>注释</strong>（或者<strong>删除</strong>）<code>PendSV_Handler()</code>函数。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919214321770.png?" alt=""></p><h2 id="编写SysTick-Handler-函数"><a href="#编写SysTick-Handler-函数" class="headerlink" title="编写SysTick_Handler()函数"></a>编写SysTick_Handler()函数</h2><p><code>SysTick</code>中断服务函数是一个非常重要的函数，<code>TencentOS tiny</code>所有跟时间相关的事情都在里面处理，<code>SysTick</code>就是<code>TencentOS tiny</code>的一个心跳时钟，驱动着<code>TencentOS tiny</code>的运行，就像人的心跳一样，假如没有心跳，我们就相当于<code>“挂掉”</code>，同样的，<code>TencentOS tiny</code>没有了心跳，那么它就会卡死在某个地方，不能进行任务调度，不能运行任何的东西，因此我们需要实现一个<code>TencentOS tiny</code>的心跳时钟。代码如下：</p><p><strong>注意</strong>：<code>SysTick_Handler()</code>中调用的都是<code>TencentOS tiny</code>中的函数，所以需要在<code>stm32f10x_it.c</code>文件中包含<code>tos.h</code>头文件。</p><pre class="line-numbers language-js"><code class="language-js">#include <span class="token string">"tos.h"</span><span class="token comment" spellcheck="true">// SysTick_Handler()函数</span><span class="token keyword">void</span> <span class="token function">SysTick_Handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tos_knl_is_running</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">tos_knl_irq_enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_tick_handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_knl_irq_leave</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="编写main函数"><a href="#编写main函数" class="headerlink" title="编写main函数"></a>编写main函数</h1><p>当你走到这一步，编译是不会出错了，此时我们已经完全移植好操作系统了，那么可以编写代码了，现在编写一个测试代码，在<code>main.c</code>文件中：</p><pre class="line-numbers language-js"><code class="language-js">#include <span class="token string">"stm32f10x.h"</span>#include <span class="token string">"bsp_usart.h"</span>#include <span class="token string">"tos.h"</span>k_task_t task<span class="token punctuation">;</span>k_stack_t task_stack<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test_task</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>Parameter<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world!\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">tos_task_delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * @brief  主函数  * @author 杰杰  * @retval 无  */</span>int <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    k_err_t err<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*初始化USART 配置模式为 115200 8-N-1，中断接收*/</span>    <span class="token function">USART_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Welcome to TencentOS tiny\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_knl_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// TOS Tiny kernel initialize</span>    err <span class="token operator">=</span> <span class="token function">tos_task_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>task<span class="token punctuation">,</span>                           <span class="token string">"task1"</span><span class="token punctuation">,</span>                           test_task<span class="token punctuation">,</span>                          NULL<span class="token punctuation">,</span>                           <span class="token number">2</span><span class="token punctuation">,</span>                           task_stack<span class="token punctuation">,</span>                          <span class="token number">1024</span><span class="token punctuation">,</span>                          <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> K_ERR_NONE<span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"TencentOS Create task fail! code : %d \r\n"</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_knl_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Start TOS Tiny</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>然后编译，下载到开发板上，就通过串口可以看到程序已经跑起来了：<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919215529345.png?" alt=""></p><h1 id="end"><a href="#end" class="headerlink" title="end"></a>end</h1><p>至此，<code>TencentOS tiny</code>移植到<code>stm32f1</code>的过程全部完成！</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> TencentOS tiny </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TencentOS tiny </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TencentOS tiny】又有一个操作系统开源</title>
      <link href="/tencentos-tiny-1/"/>
      <url>/tencentos-tiny-1/</url>
      
        <content type="html"><![CDATA[<h1 id="新闻"><a href="#新闻" class="headerlink" title="新闻"></a>新闻</h1><p>2019年9月18日，腾讯宣布将<code>开源</code> <code>自主研发</code>的<code>轻量级</code>物联网实时操作系统<strong>TencentOS tiny</strong>。相比市场上其它系统，腾讯TencentOS tiny在资源占用、设备成本、功耗管理以及安全稳定等层面极具竞争力。该系统的开源可大幅降低物联网应用开发成本，提升开发效率，同时支持一键上云，对接云端海量资源。</p><p><strong>源码已在github上开源：<a href="https://github.com/Tencent/TencentOS-tiny" target="_blank" rel="noopener">https://github.com/Tencent/TencentOS-tiny</a></strong></p><h1 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h1><p>很荣幸，能亲眼见证TencentOS tiny的开源，也很荣幸能在一个多月前内测使用过它~</p><p>不得不说，TencentOS tiny的内核确实是非常非常小巧，最少资源占用为RAM <strong><code>0.6KB</code></strong>，ROM <strong><code>1.8 KB</code></strong>。这是他们团队自主研发的RTOS，源码非常简单易懂，源码作者以非常清晰的逻辑实现了整个内核（还是非常佩服戴大神的，膜拜一下）。</p><p><strong>了解一下TencentOS tiny的框架</strong><br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190918190421629.png?" alt="TencentOS tiny的主体架构图"><br>TencentOS tiny主要由<strong>一个轻量级RTOS内核<code>+</code>多个物联网组件</strong>构成，，从下到上主要包括：</p><p> <strong>CPU库</strong> ：TencentOS tiny支持的CPU IP核架构，当前主要支持<code>ARM Cortex M0/3/4/7</code>，还有现在很火的<code>RISC-V</code>，当然，腾讯物联网团队肯定也会支持更多种类更多IP核与开发板。</p><p> <strong>驱动管理层</strong> ：包括<code>BSP</code>板级支持包，这些东西主要由MCU芯片厂家开发与维护，、<code>HAL</code>硬件抽象、Drivers设备驱动，这部分对于纯粹嵌入式开发者来说还是很重要的，肯定会越来越完善的！</p><p> <strong>内核</strong> ：<code>TencentOS tiny</code>实时内核包括任务管理、实时调度、时间管理、中断管理、内存管理、异常处理、软件定时器、链表、消息队列、信号量、互斥锁、事件标志等模块，接下来我也将写一系列<code>TencentOS tiny</code>内核<code>源码分析</code>的文章，敬请期待吧！</p><p> <strong>IoT协议栈</strong> ：<code>TencentOS tiny</code>提供<code>lwip、AT Adapter、SAL层</code>，支持不同的网络硬件，如<code>以太网、串口WIFI、GPRS、NB-IoT、4G</code>等通信模块。在<code>TCP/IP</code>网络协议栈上提供常用的物联网协议栈应用层，如<code>COAP、MQTT</code>，支撑终端业务快速接入腾讯云；</p><p> <strong>安全框架</strong> ：<code>TencentOS tiny</code>为了确保物联网终端数据传输安全以及设备认证安全，提供了比较完整的安全解决方案。安全框架提供的<code>DTLS</code>和<code>TLS</code>安全协议加固了<code>COAP</code>及<code>MQTT</code>的传输层，可确保物联网终端在对接腾讯云时实现安全认证和数据加密；另外针对低资源的终端硬件，安全框架还提供与<code>腾讯云IoTHub</code>配套的密钥认证方案，确保资源受限设备也能在一定程度上实现设备安全认证；物联网安全是非常重要的，这些框架也是必须存在的。</p><p> <strong>组件框架</strong> ：<code>TencentOS tiny</code>提供<code>文件系统、KV存储、自组网、JS引擎、低功耗框架、设备框架、OTA、调试工具</code>链等一系列组件，这部分我觉得还是很不错的，期待ing；</p><p> <strong>开放API</strong> (规划开发中)：<code>TencentOS tiny</code>将在协议中间件和框架层上提供开放<code>API</code>函数，这样子就能很方便使用中间组件的功能，我是最喜欢这种开发的，不造轮子，能直接使用。简单来说这个API能快速对接腾讯云，实现终端业务上云的需求，最大程度减少终端物联网产品开发周期，节省开发成本；</p><p> <strong>示例应用</strong> ：<code>TencentOS tiny</code>提供的示例代码，模块测试代码等，方便用户参考使用。</p><p>  <strong>腾讯云物联网平台</strong>（图中最上层的部分）：严格来说这部分不算<code>TencentOS tiny</code>的框架内容，这是接入平台层了，腾讯云的物联网平台都是提供多种语言的<code>SDK</code>包，当然在嵌入式设备上肯定使用<code>C SDK</code>的，不过总的来说都是很不错的。</p><p>总的来说<code>TencentOS tiny</code>还是非常不错的，该有的功能都有，可以考虑使用一下这个操作系统~</p><p>对于杰杰来说，作为嵌入式开发者，我是很看好物联网的，也一直在往这条路上缓缓前行，在万物互联的时代，说不定真的能在<code>赚钱</code>的同时还能<code>为世界做出一丢丢贡献</code>（如果没有那就算了）。</p><p>据我所知，<code>TencentOS tiny</code>后续也将推出基于事件驱动模型的调度，用于某些单片机上不支持基于上下文调度的多任务。</p><p>顺便再透露一下，我将接下来会写一系列<code>TencentOS tiny</code>内核分析的文章，全网首发哦！ps：<strong>得到源码作者的亲自指点，绝对干货！！！</strong></p><h1 id="图文教程："><a href="#图文教程：" class="headerlink" title="图文教程："></a>图文教程：</h1><h2 id="简单上手："><a href="#简单上手：" class="headerlink" title="简单上手："></a>简单上手：</h2><ul><li><a href="https://blog.csdn.net/jiejiemcu/article/details/101034426" target="_blank" rel="noopener">超详细的 TencentOS tiny 移植到STM32F103全教程</a></li></ul><h2 id="深度源码分析："><a href="#深度源码分析：" class="headerlink" title="深度源码分析："></a>深度源码分析：</h2><ul><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/99618912" target="_blank" rel="noopener">【TencentOS tiny学习】源码分析（1）——task</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/99665883" target="_blank" rel="noopener">【TencentOS tiny学习】源码分析（2）——调度器</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/99687678" target="_blank" rel="noopener">【TencentOS tiny学习】源码分析（3）——队列</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/99781093" target="_blank" rel="noopener">【TencentOS tiny学习】源码分析（4）——消息队列</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/100052643" target="_blank" rel="noopener">【TencentOS tiny学习】源码分析（5）——信号量</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/100056641" target="_blank" rel="noopener">【TencentOS tiny学习】源码分析（6）——互斥锁</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/100492219" target="_blank" rel="noopener">【TencentOS tiny学习】源码分析（7）——事件</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/101846089" target="_blank" rel="noopener">【TencentOS tiny学习】源码分析（8）——软件定时器</a></p></li></ul><h2 id="配套例程："><a href="#配套例程：" class="headerlink" title="配套例程："></a>配套例程：</h2><ul><li><p><a href="https://github.com/jiejieTop/TencentOS-Demo/tree/master/hello-world" target="_blank" rel="noopener">【TencentOS tiny学习】例程（0）——hello world</a></p></li><li><p><a href="https://github.com/jiejieTop/TencentOS-Demo/tree/master/01-task" target="_blank" rel="noopener">【TencentOS tiny学习】例程（1）——task</a></p></li><li><p><a href="https://github.com/jiejieTop/TencentOS-Demo/tree/master/02-queue" target="_blank" rel="noopener">【TencentOS tiny学习】例程（2）——队列</a></p></li><li><p><a href="https://github.com/jiejieTop/TencentOS-Demo/tree/master/03-msg_queue" target="_blank" rel="noopener">【TencentOS tiny学习】例程（3）——消息队列</a></p></li><li><p><a href="https://github.com/jiejieTop/TencentOS-Demo/tree/master/04-sem" target="_blank" rel="noopener">【TencentOS tiny学习】例程（4）——信号量</a></p></li><li><p><a href="https://github.com/jiejieTop/TencentOS-Demo/tree/master/05-mutex" target="_blank" rel="noopener">【TencentOS tiny学习】例程（5）——互斥锁</a></p></li><li><p><a href="https://github.com/jiejieTop/TencentOS-Demo/tree/master/07-event" target="_blank" rel="noopener">【TencentOS tiny学习】例程（6）——事件</a></p></li><li><p><a href="https://github.com/jiejieTop/TencentOS-Demo/tree/master/07-timer" target="_blank" rel="noopener">【TencentOS tiny学习】例程（7）——软件定时器</a></p></li><li><p><a href="https://github.com/jiejieTop/TencentOS-Demo/tree/master/08-mmblk" target="_blank" rel="noopener">【TencentOS tiny学习】例程（8）——内存池</a></p></li><li><p><a href="https://github.com/jiejieTop/TencentOS-Demo/tree/master/09-mmheap" target="_blank" rel="noopener">【TencentOS tiny学习】例程（9）——内存堆</a></p></li></ul><h2 id="视频教程："><a href="#视频教程：" class="headerlink" title="视频教程："></a>视频教程：</h2><ul><li><p><a href="https://www.bilibili.com/video/av70478596" target="_blank" rel="noopener">【TencentOS tiny学习】视频汇总</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=1" target="_blank" rel="noopener">【视频】01-初识TencentOS tiny</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=2" target="_blank" rel="noopener">【视频】02-TencentOS tiny基础知识</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=3" target="_blank" rel="noopener">【视频】03-TencentOS tiny移植</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=4" target="_blank" rel="noopener">【视频】04-TencentOS tiny任务-1</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=5" target="_blank" rel="noopener">【视频】05-TencentOS tiny任务-2</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=6" target="_blank" rel="noopener">【视频】06-TencentOS tiny队列-1</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=7" target="_blank" rel="noopener">【视频】07-TencentOS tiny队列-2</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=8" target="_blank" rel="noopener">【视频】08-TencentOS tiny消息队列</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=9" target="_blank" rel="noopener">【视频】09-TencentOS tiny信号量-1</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=10" target="_blank" rel="noopener">【视频】10-TencentOS tiny信号量-2</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=11" target="_blank" rel="noopener">【视频】11-TencentOS tiny互斥锁-1</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=12" target="_blank" rel="noopener">【视频】12-TencentOS tiny互斥锁-2</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=13" target="_blank" rel="noopener">【视频】13-TencentOS tiny互斥锁-3</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=14" target="_blank" rel="noopener">【视频】14-TencentOS tiny事件-1</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=15" target="_blank" rel="noopener">【视频】15-TencentOS tiny事件-2</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=16" target="_blank" rel="noopener">【视频】16-TencentOS tiny软件定时器-1</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=17" target="_blank" rel="noopener">【视频】17-TencentOS tiny软件定时器-2</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=18" target="_blank" rel="noopener">【视频】18-TencentOS tiny软件定时器-3</a></p></li></ul><div style="position: relative; width: 100%; height: 100%; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=70478596&amp;cid=122092611&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;">    </iframe></div><h2 id="相关PPT资料："><a href="#相关PPT资料：" class="headerlink" title="相关PPT资料："></a>相关PPT资料：</h2><ul><li><a href="https://github.com/jiejieTop/TencentOS-Demo/tree/master/PPT" target="_blank" rel="noopener">【TencentOS tiny学习】视频PPT</a></li></ul><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> TencentOS tiny </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TencentOS tiny </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一种Cortex-M内核中的精确延时方法</title>
      <link href="/dwt/"/>
      <url>/dwt/</url>
      
        <content type="html"><![CDATA[<h3 id="本文介绍一种Cortex-M内核中的精确延时方法"><a href="#本文介绍一种Cortex-M内核中的精确延时方法" class="headerlink" title="本文介绍一种Cortex-M内核中的精确延时方法"></a>本文介绍一种Cortex-M内核中的精确延时方法</h3><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为什么要学习这种延时的方法？</p><ol><li>很多时候我们跑操作系统，就一般会占用一个硬件定时器——SysTick，而我们一般操作系统的时钟节拍一般是设置100-1000HZ，也就是1ms——10ms产生一次中断。很多裸机教程使用延时函数又是基于SysTick的，这样一来又难免产生冲突。</li><li>很多人会说，不是还有定时器吗，定时器的计时是超级精确的。这点我不否认，但是假设，如果一个系统，总是进入定时器中断（10us一次/1us一次/0.5us一次），那整个系统就会经常被打断，线程的进行就没办法很好运行啊。此外还消耗一个硬件定时器资源，一个硬件定时器可能做其他事情呢！</li><li>对应ST HAL库的修改，其实杰杰个人觉得吧，ST的东西什么都好，就是出的HAL库太恶心了，没办法，而HAL库中有一个HAL_Delay()，他也是采用SysTick延时的，在移植操作系统的时候，会有诸多不便，不过好在，HAL_Delay()是一个弱定义的，我们可以重写这个函数的实现，那么，采用内核延时当然是最好的办法啦（个人是这么觉得的）当然你有能力完全用for循环写个简单的延时还是可以的。</li><li>可能我说的话没啥权威，那我就引用Cortex-M3权威指南中的一句话——“DWT 中有剩余的计数器，它们典型地用于程序代码的“性能速写”（profiling）。通过编程它们，就可以让它们在计数器溢出时发出事件（以跟踪数据包的形式）。最典型地，就是使用 CYCCNT寄存器来测量执行某个任务所花的周期数，这也可以用作时间基准相关的目的（操作系统中统计 CPU使用率可以用到它）。”<h2 id="Cortex-M中的DWT"><a href="#Cortex-M中的DWT" class="headerlink" title="Cortex-M中的DWT"></a>Cortex-M中的DWT</h2>在Cortex-M里面有一个外设叫DWT(Data Watchpoint and Trace)，是用于系统调试及跟踪，<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181110191659860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppZWppZW1jdQ==,size_16,color_FFFFFF,t_70" alt="">它有一个32位的寄存器叫CYCCNT，它是一个向上的计数器，记录的是内核时钟运行的个数，内核时钟跳动一次，该计数器就加1，精度非常高，决定内核的频率是多少，如果是F103系列，内核时钟是72M，那精度就是1/72M = 14ns，而程序的运行时间都是微秒级别的，所以14ns的精度是远远够的。最长能记录的时间为：60s=2的32次方/72000000(假设内核频率为72M，内核跳一次的时间大概为1/72M=14ns)，而如果是H7这种400M主频的芯片，那它的计时精度高达2.5ns（1/400000000 = 2.5），而如果是 i.MX RT1052这种比较牛逼的处理器，最长能记录的时间为： 8.13s=2的32次方/528000000 (假设内核频率为528M，内核跳一次的时间大概为1/528M=1.9ns) 。当CYCCNT溢出之后，会清0重新开始向上计数。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181110193428964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppZWppZW1jdQ==,size_16,color_FFFFFF,t_70" alt=""></li></ol><blockquote><p>m3、m4、m7杰杰实测可用（m0不可用）。<br>精度：1/内核频率(s)。</p></blockquote><p>要实现延时的功能，总共涉及到三个寄存器：DEMCR 、DWT_CTRL、DWT_CYCCNT，分别用于开启DWT功能、开启CYCCNT及获得系统时钟计数值。</p><h4 id="DEMCR"><a href="#DEMCR" class="headerlink" title="DEMCR"></a>DEMCR</h4><p> 想要使能DWT外设，需要由另外的内核调试寄存器DEMCR的位24控制，写1使能（划重点啦，要考试！！）。<br> DEMCR的地址是<strong>0xE000 EDFC</strong><br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181110192323371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppZWppZW1jdQ==,size_16,color_FFFFFF,t_70" alt=""><br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181110201757887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppZWppZW1jdQ==,size_16,color_FFFFFF,t_70" alt=""></p><h4 id="关于DWT-CYCCNT"><a href="#关于DWT-CYCCNT" class="headerlink" title="关于DWT_CYCCNT"></a>关于DWT_CYCCNT</h4><p>使能DWT_CYCCNT寄存器之前，先清0。<br>让我们看看DWT_CYCCNT的基地址，从ARM-Cortex-M手册中可以看到其基地址是<strong>0xE000 1004</strong>，复位默认值是0，而且它的类型是可读可写的，我们往<strong>0xE000 1004</strong>这个地址写0就将DWT_CYCCNT清0了。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181110195939728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppZWppZW1jdQ==,size_16,color_FFFFFF,t_70" alt=""></p><h4 id="关于CYCCNTENA"><a href="#关于CYCCNTENA" class="headerlink" title="关于CYCCNTENA"></a>关于CYCCNTENA</h4><p>CYCCNTENA Enable the CYCCNT counter. If not enabled, the counter does not count and no event is<br>generated for PS sampling or CYCCNTENA. In normal use, the debugger must initialize<br>the CYCCNT counter to 0.<br>它是DWT控制寄存器的第一位，写1使能，则启用CYCCNT计数器，否则CYCCNT计数器将不会工作。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181110200343311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppZWppZW1jdQ==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="综上所述"><a href="#综上所述" class="headerlink" title="综上所述"></a>综上所述</h3><p><strong>想要使用DWT的CYCCNT步骤：</strong></p><blockquote><ol><li>先使能DWT外设，这个由另外内核调试寄存器DEMCR的位24控制，写1使能</li><li>使能CYCCNT寄存器之前，先清0。</li><li>使能CYCCNT寄存器，这个由DWT的CYCCNTENA 控制，也就是DWT控制寄存器的位0控制，写1使能</li></ol></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**  ******************************************************************  * @file    core_delay.c  * @author  fire  * @version V1.0  * @date    2018-xx-xx  * @brief   使用内核寄存器精确延时  ******************************************************************  * @attention  *  * 实验平台:野火 STM32开发板    * 论坛    :http://www.firebbs.cn  * 淘宝    :https://fire-stm32.taobao.com  *  ******************************************************************  */</span>#include <span class="token string">"./delay/core_delay.h"</span>   <span class="token comment" spellcheck="true">/************************************************************************         时间戳相关寄存器定义***********************************************************************/</span><span class="token comment" spellcheck="true">/* 在Cortex-M里面有一个外设叫DWT(Data Watchpoint and Trace)， 该外设有一个32位的寄存器叫CYCCNT，它是一个向上的计数器， 记录的是内核时钟运行的个数，最长能记录的时间为： 10.74s=2的32次方/400000000 (假设内核频率为400M，内核跳一次的时间大概为1/400M=2.5ns) 当CYCCNT溢出之后，会清0重新开始向上计数。 使能CYCCNT计数的操作步骤： 1、先使能DWT外设，这个由另外内核调试寄存器DEMCR的位24控制，写1使能 2、使能CYCCNT寄存器之前，先清0 3、使能CYCCNT寄存器，这个由DWT_CTRL(代码上宏定义为DWT_CR)的位0控制，写1使能 */</span>#define  DWT_CR      <span class="token operator">*</span><span class="token punctuation">(</span>__IO uint32_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0xE0001000</span>#define  DWT_CYCCNT  <span class="token operator">*</span><span class="token punctuation">(</span>__IO uint32_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0xE0001004</span>#define  DEM_CR      <span class="token operator">*</span><span class="token punctuation">(</span>__IO uint32_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0xE000EDFC</span>#define  DEM_CR_TRCENA                   <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">24</span><span class="token punctuation">)</span>#define  DWT_CR_CYCCNTENA                <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span>  <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">/**  * @brief  初始化时间戳  * @param  无  * @retval 无  * @note   使用延时函数前，必须调用本函数  */</span>HAL_StatusTypeDef <span class="token function">HAL_InitTick</span><span class="token punctuation">(</span>uint32_t TickPriority<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 使能DWT外设 */</span>    DEM_CR <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span>DEM_CR_TRCENA<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">/* DWT CYCCNT寄存器计数清0 */</span>    DWT_CYCCNT <span class="token operator">=</span> <span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span>0u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 使能Cortex-M DWT CYCCNT寄存器 */</span>    DWT_CR <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span>DWT_CR_CYCCNTENA<span class="token punctuation">;</span>    <span class="token keyword">return</span> HAL_OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * @brief  读取当前时间戳  * @param  无  * @retval 当前时间戳，即DWT_CYCCNT寄存器的值  */</span>uint32_t <span class="token function">CPU_TS_TmrRd</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span>DWT_CYCCNT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * @brief  读取当前时间戳  * @param  无  * @retval 当前时间戳，即DWT_CYCCNT寄存器的值  */</span>uint32_t <span class="token function">HAL_GetTick</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span>DWT_CYCCNT<span class="token operator">/</span>SysClockFreq<span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * @brief  采用CPU的内部计数实现精确延时，32位计数器  * @param  us : 延迟长度，单位1 us  * @retval 无  * @note   使用本函数前必须先调用CPU_TS_TmrInit函数使能计数器，            或使能宏CPU_TS_INIT_IN_DELAY_FUNCTION            最大延时值为8秒，即8*1000*1000  */</span><span class="token keyword">void</span> <span class="token function">CPU_TS_Tmr_Delay_US</span><span class="token punctuation">(</span>uint32_t us<span class="token punctuation">)</span><span class="token punctuation">{</span>  uint32_t ticks<span class="token punctuation">;</span>  uint32_t told<span class="token punctuation">,</span>tnow<span class="token punctuation">,</span>tcnt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 在函数内部初始化时间戳寄存器， */</span>  #<span class="token keyword">if</span> <span class="token punctuation">(</span>CPU_TS_INIT_IN_DELAY_FUNCTION<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">/* 初始化时间戳并清零 */</span>  <span class="token function">HAL_InitTick</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>#endif  ticks <span class="token operator">=</span> us <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token function">GET_CPU_ClkFreq</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 需要的节拍数 */</span>        tcnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  told <span class="token operator">=</span> <span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span><span class="token function">CPU_TS_TmrRd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* 刚进入时的计数器值 */</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    tnow <span class="token operator">=</span> <span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span><span class="token function">CPU_TS_TmrRd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>tnow <span class="token operator">!=</span> told<span class="token punctuation">)</span>    <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">/* 32位计数器是递增计数器 */</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>tnow <span class="token operator">></span> told<span class="token punctuation">)</span>      <span class="token punctuation">{</span>        tcnt <span class="token operator">+</span><span class="token operator">=</span> tnow <span class="token operator">-</span> told<span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">/* 重新装载 */</span>      <span class="token keyword">else</span>       <span class="token punctuation">{</span>        tcnt <span class="token operator">+</span><span class="token operator">=</span> UINT32_MAX <span class="token operator">-</span> told <span class="token operator">+</span> tnow<span class="token punctuation">;</span>       <span class="token punctuation">}</span>       told <span class="token operator">=</span> tnow<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*时间超过/等于要延迟的时间,则退出 */</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>tcnt <span class="token operator">>=</span> ticks<span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*********************************************END OF FILE**********************/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">#ifndef __CORE_DELAY_H#define __CORE_DELAY_H#include <span class="token string">"stm32h7xx.h"</span><span class="token comment" spellcheck="true">/* 获取内核时钟频率 */</span>#define <span class="token function">GET_CPU_ClkFreq</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token function">HAL_RCC_GetSysClockFreq</span><span class="token punctuation">(</span><span class="token punctuation">)</span>#define SysClockFreq            <span class="token punctuation">(</span><span class="token number">218000000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">/* 为方便使用，在延时函数内部调用CPU_TS_TmrInit函数初始化时间戳寄存器，   这样每次调用函数都会初始化一遍。   把本宏值设置为0，然后在main函数刚运行时调用CPU_TS_TmrInit可避免每次都初始化 */</span>  #define CPU_TS_INIT_IN_DELAY_FUNCTION   <span class="token number">0</span>  <span class="token comment" spellcheck="true">/******************************************************************************* * 函数声明 ******************************************************************************/</span>uint32_t <span class="token function">CPU_TS_TmrRd</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>HAL_StatusTypeDef <span class="token function">HAL_InitTick</span><span class="token punctuation">(</span>uint32_t TickPriority<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用以下函数前必须先调用CPU_TS_TmrInit函数使能计数器，或使能宏CPU_TS_INIT_IN_DELAY_FUNCTION</span><span class="token comment" spellcheck="true">//最大延时值为8秒</span><span class="token keyword">void</span> <span class="token function">CPU_TS_Tmr_Delay_US</span><span class="token punctuation">(</span>uint32_t us<span class="token punctuation">)</span><span class="token punctuation">;</span>#define <span class="token function">HAL_Delay</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span>     <span class="token function">CPU_TS_Tmr_Delay_US</span><span class="token punctuation">(</span>ms<span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span>#define <span class="token function">CPU_TS_Tmr_Delay_S</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>       <span class="token function">CPU_TS_Tmr_Delay_MS</span><span class="token punctuation">(</span>s<span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span>#endif <span class="token comment" spellcheck="true">/* __CORE_DELAY_H */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><p>使用者如果不是在HAL库中使用，注释掉：</p><pre class="line-numbers language-js"><code class="language-js">uint32_t <span class="token function">HAL_GetTick</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span>DWT_CYCCNT<span class="token operator">/</span>SysClockFreq<span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同时建议重新命名<code>HAL_InitTick()</code>函数。</p><p>按照自己的平台重写以下宏定义：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* 获取内核时钟频率 */</span>#define <span class="token function">GET_CPU_ClkFreq</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token function">HAL_RCC_GetSysClockFreq</span><span class="token punctuation">(</span><span class="token punctuation">)</span>#define SysClockFreq            <span class="token punctuation">(</span><span class="token number">218000000</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>其实在ucos-iii 源码中，有一个功能是测量关中断时间的功能，就是使用STM32的时间戳，即记录程序运行的某个时刻，如果记录下程序前后的两个时刻点，即可以算出这段程序的运行时间。<br>但是有关内核寄存器的描述的资料非常少，还好找到一个（arm手册），里面有这些内核寄存器的详细描述，其中时间戳相关的寄存器在第10章和11章有详细的描述。关于资料想看的可以后台找我拿。</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台回复 “ <strong>DWT</strong> ”获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> Cortex-M </tag>
            
            <tag> DWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Linux的kfifo移植到STM32（支持os的互斥访问）</title>
      <link href="/kfifo/"/>
      <url>/kfifo/</url>
      
        <content type="html"><![CDATA[<h2 id="基于Linux的kfifo移植到STM32（支持os的互斥访问）"><a href="#基于Linux的kfifo移植到STM32（支持os的互斥访问）" class="headerlink" title="基于Linux的kfifo移植到STM32（支持os的互斥访问）"></a>基于Linux的kfifo移植到STM32（支持os的互斥访问）</h2><h3 id="关于kfifo"><a href="#关于kfifo" class="headerlink" title="关于kfifo"></a>关于kfifo</h3><p>kfifo是内核里面的一个First In First Out数据结构，它采用环形循环队列的数据结构来实现；它提供一个无边界的字节流服务，最重要的一点是，它使用并行无锁编程技术，即当它用于只有一个入队线程和一个出队线程的场情时，两个线程可以并发操作，而不需要任何加锁行为，就可以保证kfifo的线程安全。</p><blockquote><p>具体什么是环形缓冲区，请看我以前的文章</p></blockquote><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><blockquote><p>关于kfifo的相关概念我不会介绍，有兴趣可以看他的相关文档，我只将其实现过程移植重写，移植到适用stm32开发板上，并且按照我个人习惯重新命名，<strong>RingBuff</strong>-&gt;意为环形缓冲区</p></blockquote><h3 id="RingBuff-t"><a href="#RingBuff-t" class="headerlink" title="RingBuff_t"></a>RingBuff_t</h3><p>环形缓冲区的结构体成员变量，具体含义看注释。<br>  buffer: 用于存放数据的缓存<br>  size: buffer空间的大小<br>  in, out: 和buffer一起构成一个循环队列。 in指向buffer中队头，而且out指向buffer中的队尾</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> ringbuff <span class="token punctuation">{</span>    uint8_t <span class="token operator">*</span>buffer<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* 数据区域 */</span>    uint32_t size<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* 环形缓冲区大小 */</span>    uint32_t in<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 数据入队指针 (in % size) */</span>    uint32_t out<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/* 数据出队指针 (out % size) */</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_MUTEX</span>    MUTEX_T <span class="token operator">*</span>mutex<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/* 支持rtos的互斥 */</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token punctuation">}</span>RingBuff_t <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Create-RingBuff"><a href="#Create-RingBuff" class="headerlink" title="Create_RingBuff"></a>Create_RingBuff</h3><p>创建一个环形缓冲区，为了适应后续对缓冲区入队出队的高效操作，环形缓冲区的大小应为2^n字节，<br>如果不是这个大小，则系统默认裁剪以对应缓冲区字节。<br>当然还可以优化，不过我目前并未做，思路如下：如果系统支持动态分配内存，则向上对齐，避免浪费内存空间，否则就按照我默认的向下对齐，当内存越大，对齐导致内存泄漏则会越多。对齐采用的函数是<code>roundup_pow_of_two</code>。如果系统支持互斥量，那么还将创建一个互斥量用来做互斥访问，防止多线程同时使用导致数据丢失。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/************************************************************  * @brief   Create_RingBuff  * @param   rb：环形缓冲区句柄  *          buffer：环形缓冲区的数据区域  *          size：环形缓冲区的大小，缓冲区大小要为2^n  * @return  err_t：ERR_OK表示创建成功，其他表示失败  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    用于创建一个环形缓冲区  ***********************************************************/</span>err_t <span class="token function">Create_RingBuff</span><span class="token punctuation">(</span>RingBuff_t<span class="token operator">*</span> rb<span class="token punctuation">,</span>                       uint8_t <span class="token operator">*</span>buffer<span class="token punctuation">,</span>                      uint32_t size                                <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>rb <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>buffer <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">PRINT_ERR</span><span class="token punctuation">(</span><span class="token string">"data is null!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ERR_NULL<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">PRINT_DEBUG</span><span class="token punctuation">(</span><span class="token string">"ringbuff size is %d!"</span><span class="token punctuation">,</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 缓冲区大小必须为2^n字节,系统会强制转换,         否则可能会导致指针访问非法地址。         空间大小越大,强转时丢失内存越多 */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>size<span class="token operator">&amp;</span><span class="token punctuation">(</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        size <span class="token operator">=</span> <span class="token function">roundup_pow_of_two</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PRINT_DEBUG</span><span class="token punctuation">(</span><span class="token string">"change ringbuff size is %d!"</span><span class="token punctuation">,</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    rb<span class="token operator">-></span>buffer <span class="token operator">=</span> buffer<span class="token punctuation">;</span>    rb<span class="token operator">-></span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>    rb<span class="token operator">-></span>in <span class="token operator">=</span> rb<span class="token operator">-></span>out <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_MUTEX    </span>  <span class="token comment" spellcheck="true">/* 创建信号量不成功 */</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">create_mutex</span><span class="token punctuation">(</span>rb<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">PRINT_ERR</span><span class="token punctuation">(</span><span class="token string">"create mutex fail!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>ASSERT_ERR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ERR_NOK<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    <span class="token function">PRINT_DEBUG</span><span class="token punctuation">(</span><span class="token string">"create ringBuff ok!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ERR_OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="roundup-pow-of-two"><a href="#roundup-pow-of-two" class="headerlink" title="roundup_pow_of_two"></a>roundup_pow_of_two</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/************************************************************  * @brief   roundup_pow_of_two  * @param   size：传递进来的数据长度  * @return  size：返回处理之后的数据长度  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    用于处理数据，使数据长度必须为 2^n    *                     如果不是，则转换，丢弃多余部分，如    *                     roundup_pow_of_two(66) -> 返回 64  ***********************************************************/</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">roundup_pow_of_two</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token function">fls</span><span class="token punctuation">(</span>x<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//向下对齐</span>  <span class="token comment" spellcheck="true">//return (1UL &lt;&lt; fls(x - 1));            //向上对齐，用动态内存可用使用</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Delete-RingBuff"><a href="#Delete-RingBuff" class="headerlink" title="Delete_RingBuff"></a>Delete_RingBuff</h3><p>删除一个环形缓冲区，删除之后，缓冲区真正存储地址是不会被改变的（目前我是使用自定义数组做缓冲区的），但是删除之后，就无法对缓冲区进行读写操作。并且如果支持os的话，创建的互斥量会被删除。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/************************************************************  * @brief   Delete_RingBuff  * @param   rb：环形缓冲区句柄  * @return  err_t：ERR_OK表示成功，其他表示失败  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    删除一个环形缓冲区  ***********************************************************/</span>err_t <span class="token function">Delete_RingBuff</span><span class="token punctuation">(</span>RingBuff_t <span class="token operator">*</span>rb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>rb <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">PRINT_ERR</span><span class="token punctuation">(</span><span class="token string">"ringbuff is null!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ERR_NULL<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    rb<span class="token operator">-></span>buffer <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    rb<span class="token operator">-></span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    rb<span class="token operator">-></span>in <span class="token operator">=</span> rb<span class="token operator">-></span>out <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_MUTEX    </span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">deleta_mutex</span><span class="token punctuation">(</span>rb<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">PRINT_DEBUG</span><span class="token punctuation">(</span><span class="token string">"deleta mutex is fail!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ERR_NOK<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    <span class="token keyword">return</span> ERR_OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Write-RingBuff"><a href="#Write-RingBuff" class="headerlink" title="Write_RingBuff"></a>Write_RingBuff</h3><p>向环形缓冲区写入指定数据，支持线程互斥访问。用户想要写入缓冲区的数据长度不一定是真正入队的长度，在完成的时候还要看看返回值是否与用户需要的长度一致~<br>这个函数很有意思，也是比较高效的入队操作，将指定区域的数据拷贝到指定的缓冲区中，过程看注释即可</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/************************************************************  * @brief   Write_RingBuff  * @param   rb:环形缓冲区句柄  * @param   wbuff:写入的数据起始地址  * @param   len:写入数据的长度(字节)  * @return  len:实际写入数据的长度(字节)  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    这个函数会从buff空间拷贝len字节长度的数据到             rb环形缓冲区中的空闲空间。  ***********************************************************/</span>uint32_t <span class="token function">Write_RingBuff</span><span class="token punctuation">(</span>RingBuff_t <span class="token operator">*</span>rb<span class="token punctuation">,</span>                        uint8_t <span class="token operator">*</span>wbuff<span class="token punctuation">,</span>                         uint32_t len<span class="token punctuation">)</span><span class="token punctuation">{</span>  uint32_t l<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_MUTEX</span>  <span class="token comment" spellcheck="true">/* 请求互斥量，成功才能进行ringbuff的访问 */</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">request_mutex</span><span class="token punctuation">(</span>rb<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">PRINT_DEBUG</span><span class="token punctuation">(</span><span class="token string">"request mutex fail!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span>  <span class="token comment" spellcheck="true">/* 获取互斥量成功 */</span>  <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    len <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> rb<span class="token operator">-></span>size <span class="token operator">-</span> rb<span class="token operator">-></span>in <span class="token operator">+</span> rb<span class="token operator">-></span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 第一部分的拷贝:从环形缓冲区写入数据直至缓冲区最后一个地址 */</span>    l <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> rb<span class="token operator">-></span>size <span class="token operator">-</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>in <span class="token operator">&amp;</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>rb<span class="token operator">-></span>buffer <span class="token operator">+</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>in <span class="token operator">&amp;</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> wbuff<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 如果溢出则在缓冲区头写入剩余的部分       如果没溢出这句代码相当于无效 */</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>rb<span class="token operator">-></span>buffer<span class="token punctuation">,</span> wbuff <span class="token operator">+</span> l<span class="token punctuation">,</span> len <span class="token operator">-</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>    rb<span class="token operator">-></span>in <span class="token operator">+</span><span class="token operator">=</span> len<span class="token punctuation">;</span>    <span class="token function">PRINT_DEBUG</span><span class="token punctuation">(</span><span class="token string">"write ringBuff len is %d!"</span><span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_MUTEX</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/* 释放互斥量 */</span>  <span class="token function">release_mutex</span><span class="token punctuation">(</span>rb<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>  <span class="token keyword">return</span> len<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Read-RingBuff"><a href="#Read-RingBuff" class="headerlink" title="Read_RingBuff"></a>Read_RingBuff</h3><p>读取缓冲区数据到指定区域，用户指定读取长度，用户想要读取的长度不一定是真正读取的长度，在读取完成的时候还要看看返回值是否与用户需要的长度一致~也支持多线程互斥访问。<br>也是缓冲区出队的高效操作。过程看代码注释即可</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/************************************************************  * @brief   Read_RingBuff  * @param   rb:环形缓冲区句柄  * @param   wbuff:读取数据保存的起始地址  * @param   len:想要读取数据的长度(字节)  * @return  len:实际读取数据的长度(字节)  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    这个函数会从rb环形缓冲区中的数据区域拷贝len字节             长度的数据到rbuff空间。  ***********************************************************/</span>uint32_t <span class="token function">Read_RingBuff</span><span class="token punctuation">(</span>RingBuff_t <span class="token operator">*</span>rb<span class="token punctuation">,</span>                       uint8_t <span class="token operator">*</span>rbuff<span class="token punctuation">,</span>                        uint32_t len<span class="token punctuation">)</span><span class="token punctuation">{</span>  uint32_t l<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_MUTEX</span>  <span class="token comment" spellcheck="true">/* 请求互斥量，成功才能进行ringbuff的访问 */</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">request_mutex</span><span class="token punctuation">(</span>rb<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">PRINT_DEBUG</span><span class="token punctuation">(</span><span class="token string">"request mutex fail!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span>  <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    len <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> rb<span class="token operator">-></span>in <span class="token operator">-</span> rb<span class="token operator">-></span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 第一部分的拷贝:从环形缓冲区读取数据直至缓冲区最后一个 */</span>    l <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> rb<span class="token operator">-></span>size <span class="token operator">-</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>out <span class="token operator">&amp;</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>rbuff<span class="token punctuation">,</span> rb<span class="token operator">-></span>buffer <span class="token operator">+</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>out <span class="token operator">&amp;</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 如果溢出则在缓冲区头读取剩余的部分       如果没溢出这句代码相当于无效 */</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>rbuff <span class="token operator">+</span> l<span class="token punctuation">,</span> rb<span class="token operator">-></span>buffer<span class="token punctuation">,</span> len <span class="token operator">-</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>    rb<span class="token operator">-></span>out <span class="token operator">+</span><span class="token operator">=</span> len<span class="token punctuation">;</span>    <span class="token function">PRINT_DEBUG</span><span class="token punctuation">(</span><span class="token string">"read ringBuff len is %d!"</span><span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_MUTEX</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/* 释放互斥量 */</span>  <span class="token function">release_mutex</span><span class="token punctuation">(</span>rb<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>  <span class="token keyword">return</span> len<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取缓冲区信息"><a href="#获取缓冲区信息" class="headerlink" title="获取缓冲区信息"></a>获取缓冲区信息</h3><p>这些就比较简单了，看看缓冲区可读可写的数据有多少</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/************************************************************  * @brief   CanRead_RingBuff    * @param   rb:环形缓冲区句柄    * @return  uint32:可读数据长度 0 / len  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    可读数据长度  ***********************************************************/</span>uint32_t <span class="token function">CanRead_RingBuff</span><span class="token punctuation">(</span>RingBuff_t <span class="token operator">*</span>rb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> rb<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">PRINT_ERR</span><span class="token punctuation">(</span><span class="token string">"ringbuff is null!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>rb<span class="token operator">-></span>in <span class="token operator">==</span> rb<span class="token operator">-></span>out<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>rb<span class="token operator">-></span>in <span class="token operator">></span> rb<span class="token operator">-></span>out<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>in <span class="token operator">-</span> rb<span class="token operator">-></span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>size <span class="token operator">-</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>out <span class="token operator">-</span> rb<span class="token operator">-></span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/************************************************************  * @brief   CanRead_RingBuff    * @param   rb:环形缓冲区句柄    * @return  uint32:可写数据长度 0 / len  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    可写数据长度  ***********************************************************/</span>uint32_t <span class="token function">CanWrite_RingBuff</span><span class="token punctuation">(</span>RingBuff_t <span class="token operator">*</span>rb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> rb<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">PRINT_ERR</span><span class="token punctuation">(</span><span class="token string">"ringbuff is null!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>size <span class="token operator">-</span> <span class="token function">CanRead_RingBuff</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="附带"><a href="#附带" class="headerlink" title="附带"></a>附带</h3><p>这里的代码我是用于测试的，随便写的</p><pre><code>    RingBuff_t ringbuff_handle;    uint8_t rb[64];    uint8_t res[64];    Create_RingBuff(&amp;ringbuff_handle,                                 rb,                                sizeof(rb));            Write_RingBuff(&amp;ringbuff_handle,                     res,                      datapack.data_length);            PRINT_DEBUG("CanRead_RingBuff = %d!",CanRead_RingBuff(&amp;ringbuff_handle));            PRINT_DEBUG("CanWrite_RingBuff = %d!",CanWrite_RingBuff(&amp;ringbuff_handle));            Read_RingBuff(&amp;ringbuff_handle,                     res,                      datapack.data_length);</code></pre><h3 id="支持多个os的互斥量操作"><a href="#支持多个os的互斥量操作" class="headerlink" title="支持多个os的互斥量操作"></a>支持多个os的互斥量操作</h3><p>此处模仿了文件系统的互斥操作</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">if</span> USE_MUTEX</span><span class="token macro property">#<span class="token directive keyword">define</span>  MUTEX_TIMEOUT   1000     </span><span class="token comment" spellcheck="true">/* 超时时间 */</span><span class="token macro property">#<span class="token directive keyword">define</span>  MUTEX_T         mutex_t  </span><span class="token comment" spellcheck="true">/* 互斥量控制块 */</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token comment" spellcheck="true">/*********************************** mutex **************************************************/</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_MUTEX</span><span class="token comment" spellcheck="true">/************************************************************  * @brief   create_mutex  * @param   mutex:创建信号量句柄  * @return  创建成功为1，0为不成功。  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    创建一个互斥量,用户在os中互斥使用ringbuff，  *          支持的os有rtt、win32、ucos、FreeRTOS、LiteOS  ***********************************************************/</span><span class="token keyword">static</span> err_t <span class="token function">create_mutex</span><span class="token punctuation">(</span>MUTEX_T <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">{</span>  err_t ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    *mutex = rt_mutex_create("test_mux",RT_IPC_FLAG_PRIO); </span><span class="token comment" spellcheck="true">/* rtt */</span><span class="token comment" spellcheck="true">//    ret = (err_t)(*mutex != RT_NULL);</span><span class="token comment" spellcheck="true">//    *mutex = CreateMutex(NULL, FALSE, NULL);        </span><span class="token comment" spellcheck="true">/* Win32 */</span><span class="token comment" spellcheck="true">//    ret = (err_t)(*mutex != INVALID_HANDLE_VALUE);</span><span class="token comment" spellcheck="true">//    *mutex = OSMutexCreate(0, &amp;err);        </span><span class="token comment" spellcheck="true">/* uC/OS-II */</span><span class="token comment" spellcheck="true">//    ret = (err_t)(err == OS_NO_ERR);</span><span class="token comment" spellcheck="true">//    *mutex = xSemaphoreCreateMutex();    </span><span class="token comment" spellcheck="true">/* FreeRTOS */</span><span class="token comment" spellcheck="true">//    ret = (err_t)(*mutex != NULL);</span><span class="token comment" spellcheck="true">//  ret = LOS_MuxCreate(&amp;mutex);  </span><span class="token comment" spellcheck="true">/* LiteOS */</span><span class="token comment" spellcheck="true">//    ret = (err_t)(ret != LOS_OK);</span>  <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/************************************************************  * @brief   deleta_mutex  * @param   mutex:互斥量句柄  * @return  NULL  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    删除一个互斥量，支持的os有rtt、win32、ucos、FreeRTOS、LiteOS  ***********************************************************/</span><span class="token keyword">static</span> err_t <span class="token function">deleta_mutex</span><span class="token punctuation">(</span>MUTEX_T <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">{</span>    err_t ret<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    ret = rt_mutex_delete(mutex);    </span><span class="token comment" spellcheck="true">/* rtt */</span><span class="token comment" spellcheck="true">//    ret = CloseHandle(mutex);    </span><span class="token comment" spellcheck="true">/* Win32 */</span><span class="token comment" spellcheck="true">//    OSMutexDel(mutex, OS_DEL_ALWAYS, &amp;err);    </span><span class="token comment" spellcheck="true">/* uC/OS-II */</span><span class="token comment" spellcheck="true">//    ret = (err_t)(err == OS_NO_ERR);</span><span class="token comment" spellcheck="true">//  vSemaphoreDelete(mutex);        </span><span class="token comment" spellcheck="true">/* FreeRTOS */</span><span class="token comment" spellcheck="true">//    ret = 1;</span><span class="token comment" spellcheck="true">//  ret = LOS_MuxDelete(&amp;mutex);  </span><span class="token comment" spellcheck="true">/* LiteOS */</span><span class="token comment" spellcheck="true">//    ret = (err_t)(ret != LOS_OK);</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/************************************************************  * @brief   request_mutex  * @param   mutex:互斥量句柄  * @return  NULL  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    请求一个互斥量，得到互斥量的线程才允许进行访问缓冲区  *          支持的os有rtt、win32、ucos、FreeRTOS、LiteOS  ***********************************************************/</span><span class="token keyword">static</span> err_t <span class="token function">request_mutex</span><span class="token punctuation">(</span>MUTEX_T <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">{</span>    err_t ret<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    ret = (err_t)(rt_mutex_take(mutex, MUTEX_TIMEOUT) == RT_EOK);</span><span class="token comment" spellcheck="true">/* rtt */</span><span class="token comment" spellcheck="true">//    ret = (err_t)(WaitForSingleObject(mutex, MUTEX_TIMEOUT) == WAIT_OBJECT_0);    </span><span class="token comment" spellcheck="true">/* Win32 */</span><span class="token comment" spellcheck="true">//    OSMutexPend(mutex, MUTEX_TIMEOUT, &amp;err));        </span><span class="token comment" spellcheck="true">/* uC/OS-II */</span><span class="token comment" spellcheck="true">//    ret = (err_t)(err == OS_NO_ERR);</span><span class="token comment" spellcheck="true">//    ret = (err_t)(xSemaphoreTake(mutex, MUTEX_TIMEOUT) == pdTRUE);    </span><span class="token comment" spellcheck="true">/* FreeRTOS */</span><span class="token comment" spellcheck="true">//  ret = (err_t)(LOS_MuxPend(mutex,MUTEX_TIMEOUT) == LOS_OK);          </span><span class="token comment" spellcheck="true">/* LiteOS */</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/************************************************************  * @brief   release_mutex  * @param   mutex:互斥量句柄  * @return  NULL  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    释放互斥量，当线程使用完资源必须释放互斥量  *          支持的os有rtt、win32、ucos、FreeRTOS、LiteOS  ***********************************************************/</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">release_mutex</span><span class="token punctuation">(</span>MUTEX_T <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//    rt_mutex_release(mutex);</span><span class="token comment" spellcheck="true">/* rtt */</span><span class="token comment" spellcheck="true">//    ReleaseMutex(mutex);        </span><span class="token comment" spellcheck="true">/* Win32 */</span><span class="token comment" spellcheck="true">//    OSMutexPost(mutex);        </span><span class="token comment" spellcheck="true">/* uC/OS-II */</span><span class="token comment" spellcheck="true">//    xSemaphoreGive(mutex);    </span><span class="token comment" spellcheck="true">/* FreeRTOS */</span><span class="token comment" spellcheck="true">//  LOS_MuxPost(mutex);   </span><span class="token comment" spellcheck="true">/* LiteOS */</span><span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token comment" spellcheck="true">/*********************************** mutex **************************************************/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="debug-h"><a href="#debug-h" class="headerlink" title="debug.h"></a>debug.h</h3><p>最后送一份debug的简便操作源码，因为前文很多时候会调用<br><code>PRINT_ERR</code><br><code>PRINT_DEBUG</code></p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">ifndef</span> _DEBUG_H</span><span class="token macro property">#<span class="token directive keyword">define</span> _DEBUG_H</span><span class="token comment" spellcheck="true">/************************************************************  * @brief   debug.h  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    此文件用于打印日志信息  ***********************************************************/</span><span class="token comment" spellcheck="true">/*** @name Debug print * @{*/</span><span class="token macro property">#<span class="token directive keyword">define</span> PRINT_DEBUG_ENABLE        1        </span><span class="token comment" spellcheck="true">/* 打印调试信息 */</span><span class="token macro property">#<span class="token directive keyword">define</span> PRINT_ERR_ENABLE            1     </span><span class="token comment" spellcheck="true">/* 打印错误信息 */</span><span class="token macro property">#<span class="token directive keyword">define</span> PRINT_INFO_ENABLE            0        </span><span class="token comment" spellcheck="true">/* 打印个人信息 */</span><span class="token macro property">#<span class="token directive keyword">if</span> PRINT_DEBUG_ENABLE</span><span class="token macro property">#<span class="token directive keyword">define</span> PRINT_DEBUG(fmt, args...)      do{(printf("\n[DEBUG] >> "), printf(fmt, ##args));}while(0)     </span><span class="token macro property">#<span class="token directive keyword">else</span></span><span class="token macro property">#<span class="token directive keyword">define</span> PRINT_DEBUG(fmt, args...)         </span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">if</span> PRINT_ERR_ENABLE</span><span class="token macro property">#<span class="token directive keyword">define</span> PRINT_ERR(fmt, args...)      do{(printf("\n[ERR] >> "), printf(fmt, ##args));}while(0)     </span><span class="token macro property">#<span class="token directive keyword">else</span></span><span class="token macro property">#<span class="token directive keyword">define</span> PRINT_ERR(fmt, args...)           </span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">if</span> PRINT_INFO_ENABLE</span><span class="token macro property">#<span class="token directive keyword">define</span> PRINT_INFO(fmt, args...)      do{(printf("\n[INFO] >> "), printf(fmt, ##args));}while(0)     </span><span class="token macro property">#<span class="token directive keyword">else</span></span><span class="token macro property">#<span class="token directive keyword">define</span> PRINT_INFO(fmt, args...)           </span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token comment" spellcheck="true">/**@} */</span><span class="token comment" spellcheck="true">//针对不同的编译器调用不同的stdint.h文件</span><span class="token macro property">#<span class="token directive keyword">if</span> defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__)</span>    <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token comment" spellcheck="true">/* 断言 Assert */</span><span class="token macro property">#<span class="token directive keyword">define</span> AssertCalled(char,int)     printf("\nError:%s,%d\r\n",char,int)</span><span class="token macro property">#<span class="token directive keyword">define</span> ASSERT(x)   if((x)==0)  AssertCalled(__FILE__,__LINE__)</span><span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token punctuation">{</span>    ASSERT_ERR <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>                                <span class="token comment" spellcheck="true">/* 错误 */</span>    ASSERT_SUCCESS <span class="token operator">=</span> <span class="token operator">!</span>ASSERT_ERR    <span class="token comment" spellcheck="true">/* 正确 */</span><span class="token punctuation">}</span> Assert_ErrorStatus<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token punctuation">{</span>    FALSE <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">/* 假 */</span>    TRUE <span class="token operator">=</span> <span class="token operator">!</span>FALSE    <span class="token comment" spellcheck="true">/* 真 */</span><span class="token punctuation">}</span>ResultStatus<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">/* __DEBUG_H */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> Cortex-M </tag>
            
            <tag> kfifo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32进阶之串口环形缓冲区实现</title>
      <link href="/fifo/"/>
      <url>/fifo/</url>
      
        <content type="html"><![CDATA[<h1 id="队列的概念"><a href="#队列的概念" class="headerlink" title="队列的概念"></a>队列的概念</h1><p>在此之前，我们来回顾一下队列的基本概念：</p><p>队列 (Queue)：是一种先进先出(First In First Out ,简称 FIFO)的线性表，只允许在一端插入（入队），在另一端进行删除（出队）。<br><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/fifo-1.jpg" alt="fifo-1"></p><h1 id="队列的特点"><a href="#队列的特点" class="headerlink" title="队列的特点"></a>队列的特点</h1><p>类似售票排队窗口，先到的人看到能先买到票，然后先走，后来的人只能后买到票</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/fifo-2.jpg" alt="fifo-2"></p><h1 id="队列的常见两种形式"><a href="#队列的常见两种形式" class="headerlink" title="队列的常见两种形式"></a>队列的常见两种形式</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/fifo-3.jpg" alt="fifo-3"></p><h2 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h2><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/fifo-4.jpg" alt="fifo-4"></p><p>在计算机中，每个信息都是存储在存储单元中的，比喻一下吧，上图的一些小正方形格子就是一个个存储单元，你可以理解为常见的数组，存放我们一个个的信息。</p><p>当有大量数据的时候，我们不能存储所有的数据，那么计算机处理数据的时候，只能先处理先来的，那么处理完后呢，就会把数据释放掉，再处理下一个。那么，已经处理的数据的内存就会被浪费掉。因为后来的数据只能往后排队，如过要将剩余的数据都往前移动一次，那么效率就会低下了，肯定不现实，所以，环形队列就出现了。</p><h2 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h2><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/fifo-5.jpg" alt="fifo-5"></p><p>它的队列就是一个环，它避免了普通队列的缺点，就是有点难理解而已，其实它就是一个队列，一样有队列头，队列尾，一样是先进先出（FIFO）。我们采用顺时针的方式来对队列进行排序。</p><ul><li><p>队列头 (Head) : 允许进行删除的一端称为队首。</p></li><li><p>队列尾 (Tail) : 允许进行插入的一端称为队尾。</p></li></ul><p>环形队列的实现：在计算机中，也是没有环形的内存的，只不过是我们将顺序的内存处理过，让某一段内存形成环形，使他们首尾相连，简单来说，这其实就是一个数组，只不过有两个指针，一个指向列队头，一个指向列队尾。指向列队头的指针(Head)是缓冲区可读的数据，指向列队尾的指针(Tail)是缓冲区可写的数据，通过移动这两个指针(Head) &amp;(Tail)即可对缓冲区的数据进行读写操作了，直到缓冲区已满（头尾相接），将数据处理完，可以释放掉数据，又可以进行存储新的数据了。</p><p>实现的原理：初始化的时候，列队头与列队尾都指向0，当有数据存储的时候，数据存储在‘0’的地址空间，列队尾指向下一个可以存储数据的地方‘1’，再有数据来的时候，存储数据到地址‘1’，然后队列尾指向下一个地址‘2’。当数据要进行处理的时候，肯定是先处理‘0’空间的数据，也就是列队头的数据，处理完了数据，‘0’地址空间的数据进行释放掉，列队头指向下一个可以处理数据的地址‘1’。从而实现整个环形缓冲区的数据读写。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/fifo-6.jpg" alt="fifo-6"></p><p>看图，队列头就是指向已经存储的数据，并且这个数据是待处理的。下一个CPU处理的数据就是1；而队列尾则指向可以进行写数据的地址。当1处理了，就会把1释放掉。并且把队列头指向2。当写入了一个数据6，那么队列尾的指针就会指向下一个可以写的地址。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/fifo-7.jpg" alt="fifo-7"></p><h1 id="从队列到串口缓冲区的实现"><a href="#从队列到串口缓冲区的实现" class="headerlink" title="从队列到串口缓冲区的实现"></a>从队列到串口缓冲区的实现</h1><p>串口环形缓冲区收发：在很多入门级教程中，我们知道的串口收发都是：接收一个数据，触发中断，然后把数据发回来。这种处理方式是没有缓冲的，当数量太大的时候，亦或者当数据接收太快的时候，我们来不及处理已经收到的数据，那么，当再次收到数据的时候，就会将之前还未处理的数据覆盖掉。那么就会出现丢包的现象了，对我们的程序是一个致命的创伤。</p><p>那么如何避免这种情况的发生呢，很显然，上面说的一些队列的特性很容易帮我们实现我们需要的情况。将接受的数据缓存一下，让处理的速度有些许缓冲，使得处理的速度赶得上接收的速度，上面又已经分析了普通队列与环形队列的优劣了，那么我们肯定是用环形队列来进行实现了。下面就是代码的实现：</p><h2 id="定义一个结构体："><a href="#定义一个结构体：" class="headerlink" title="定义一个结构体："></a>定义一个结构体：</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    u16 Head<span class="token punctuation">;</span>               u16 Tail<span class="token punctuation">;</span>    u16 Lenght<span class="token punctuation">;</span>    u8 Ring_Buff<span class="token punctuation">[</span>RINGBUFF_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>RingBuff_t<span class="token punctuation">;</span>RingBuff_t ringBuff<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建一个ringBuff的缓冲区</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化结构体相关信息：使得我们的环形缓冲区是头尾相连的，并且里面没有数据，也就是空的队列。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief  RingBuff_Init * @param  void * @return void * @author 杰杰 * @date   2018 * @version v1.0 * @note   初始化环形缓冲区 */</span><span class="token keyword">void</span> <span class="token function">RingBuff_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//初始化相关信息</span>   ringBuff<span class="token punctuation">.</span>Head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   ringBuff<span class="token punctuation">.</span>Tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   ringBuff<span class="token punctuation">.</span>Lenght <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化效果如下：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/fifo-8.jpg" alt="fifo-8"></p><h2 id="写入环形缓冲区的代码实现："><a href="#写入环形缓冲区的代码实现：" class="headerlink" title="写入环形缓冲区的代码实现："></a>写入环形缓冲区的代码实现：</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief  Write_RingBuff * @param  u8 data * @return FLASE:环形缓冲区已满，写入失败;TRUE:写入成功 * @author 杰杰 * @date   2018 * @version v1.0 * @note   往环形缓冲区写入u8类型的数据 */</span>u8 <span class="token function">Write_RingBuff</span><span class="token punctuation">(</span>u8 data<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>ringBuff<span class="token punctuation">.</span>Lenght <span class="token operator">>=</span> RINGBUFF_LEN<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//判断缓冲区是否已满</span>    <span class="token punctuation">{</span>      <span class="token keyword">return</span> FLASE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ringBuff<span class="token punctuation">.</span>Ring_Buff<span class="token punctuation">[</span>ringBuff<span class="token punctuation">.</span>Tail<span class="token punctuation">]</span><span class="token operator">=</span>data<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    ringBuff.Tail++;</span>    ringBuff<span class="token punctuation">.</span>Tail <span class="token operator">=</span> <span class="token punctuation">(</span>ringBuff<span class="token punctuation">.</span>Tail<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>RINGBUFF_LEN<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//防止越界非法访问</span>    ringBuff<span class="token punctuation">.</span>Lenght<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> TRUE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="读取缓冲区的数据的代码实现："><a href="#读取缓冲区的数据的代码实现：" class="headerlink" title="读取缓冲区的数据的代码实现："></a>读取缓冲区的数据的代码实现：</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief  Read_RingBuff * @param  u8 *rData，用于保存读取的数据 * @return FLASE:环形缓冲区没有数据，读取失败;TRUE:读取成功 * @author 杰杰 * @date   2018 * @version v1.0 * @note   从环形缓冲区读取一个u8类型的数据 */</span>u8 <span class="token function">Read_RingBuff</span><span class="token punctuation">(</span>u8 <span class="token operator">*</span>rData<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>ringBuff<span class="token punctuation">.</span>Lenght <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//判断非空</span>    <span class="token punctuation">{</span>       <span class="token keyword">return</span> FLASE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token operator">*</span>rData <span class="token operator">=</span> ringBuff<span class="token punctuation">.</span>Ring_Buff<span class="token punctuation">[</span>ringBuff<span class="token punctuation">.</span>Head<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//先进先出FIFO，从缓冲区头出</span><span class="token comment" spellcheck="true">//   ringBuff.Head++;</span>   ringBuff<span class="token punctuation">.</span>Head <span class="token operator">=</span> <span class="token punctuation">(</span>ringBuff<span class="token punctuation">.</span>Head<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>RINGBUFF_LEN<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//防止越界非法访问</span>   ringBuff<span class="token punctuation">.</span>Lenght<span class="token operator">--</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> TRUE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于读写操作需要注意的地方有两个：</p><ol><li><p>判断队列是否为空或者满，如果空的话，是不允许读取数据的，返回FLASE。如果是满的话，也是不允许写入数据的，避免将已有数据覆盖掉。那么如果处理的速度赶不上接收的速度，可以适当增大缓冲区的大小，用空间换取时间。</p></li><li><p>防止指针越界非法访问，程序有说明，需要使用者对整个缓冲区的大小进行把握。</p></li></ol><p>那么在串口接收函数中：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">USART1_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">USART_GetITStatus</span><span class="token punctuation">(</span>USART1<span class="token punctuation">,</span> USART_IT_RXNE<span class="token punctuation">)</span> <span class="token operator">!=</span> RESET<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//接收中断</span>                   <span class="token punctuation">{</span>           <span class="token function">USART_ClearITPendingBit</span><span class="token punctuation">(</span>USART1<span class="token punctuation">,</span>USART_IT_RXNE<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//清楚标志位</span>           <span class="token function">Write_RingBuff</span><span class="token punctuation">(</span><span class="token function">USART_ReceiveData</span><span class="token punctuation">(</span>USART1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//读取接收到的数据</span>       <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/fifo-9.jpg" alt="fifo-9"></p><p>测试数据没有发生丢包现象</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>对于现在的阶段，杰杰我本人写代码也慢慢学会规范了。所有的代码片段均使用了可读性很强的，还有可移植性也很强的。我使用了宏定义来决定是否开启环形缓冲区的方式来收发数据，移植到大家的代码并不会有其他副作用，只需要开启宏定义即可使用了。</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token macro property">#<span class="token directive keyword">define</span> USER_RINGBUFF  1  </span><span class="token comment" spellcheck="true">//使用环形缓冲区形式接收数据</span> <span class="token macro property">#<span class="token directive keyword">if</span>  USER_RINGBUFF</span> <span class="token comment" spellcheck="true">/**如果使用环形缓冲形式接收串口数据***/</span> <span class="token macro property">#<span class="token directive keyword">define</span>  RINGBUFF_LEN          200     </span><span class="token comment" spellcheck="true">//定义最大接收字节数 200</span> <span class="token macro property">#<span class="token directive keyword">define</span>  FLASE   1 </span> <span class="token macro property">#<span class="token directive keyword">define</span>  TRUE    0 </span> <span class="token keyword">void</span> <span class="token function">RingBuff_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span> u8 <span class="token function">Write_RingBuff</span><span class="token punctuation">(</span>u8 data<span class="token punctuation">)</span><span class="token punctuation">;</span> u8 <span class="token function">Read_RingBuff</span><span class="token punctuation">(</span>u8 <span class="token operator">*</span>rData<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，我们完全可以用空闲中断与DMA传输，效率更高，但是某些单片机没有空闲中断与DMA，那么这种环形缓冲区的作用就很大了，并且移植简便。</p><blockquote><p>说明：文章部分截图来源慕课网james_yuan老师的课程</p></blockquote><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> Cortex-M </tag>
            
            <tag> fifo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32之串口DMA接收不定长数据</title>
      <link href="/dma/"/>
      <url>/dma/</url>
      
        <content type="html"><![CDATA[<h1 id="STM32之串口DMA接收不定长数据"><a href="#STM32之串口DMA接收不定长数据" class="headerlink" title="STM32之串口DMA接收不定长数据"></a>STM32之串口DMA接收不定长数据</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在使用stm32或者其他单片机的时候，会经常使用到串口通讯，那么如何有效地接收数据呢？假如这段数据是不定长的有如何高效接收呢？</p><blockquote><p>同学A：数据来了就会进入串口中断，在中断中读取数据就行了！</p></blockquote><blockquote><p><strong>中断就是打断程序正常运行，怎么能保证高效呢？经常把主程序打断，主程序还要不要运行了？</strong></p></blockquote><blockquote><p>同学B：串口可以配置成用DMA的方式接收数据，等接收完毕就可以去读取了！</p></blockquote><blockquote><p><strong>这个同学是对的，我们可以使用DMA去接收数据，不过DMA需要定长才能产生接收中断,如何接收不定长的数据呢？</strong></p></blockquote><h2 id="DMA简介"><a href="#DMA简介" class="headerlink" title="DMA简介"></a>DMA简介</h2><blockquote><p>题外话：其实，上面的问题是很有必要思考一下的，不断思考，才能进步。</p></blockquote><h3 id="什么是DMA"><a href="#什么是DMA" class="headerlink" title="什么是DMA"></a>什么是DMA</h3><p><strong>DMA</strong>：全称Direct Memory Access，即直接存储器访问</p><p>DMA 传输将数据从一个地址空间复制到另外一个地址空间。CPU只需初始化DMA即可，传输动作本身是由 DMA 控制器来实现和完成。典型的例子就是移动一个外部内存的区块到芯片内部更快的内存区。这样的操作并没有让处理器参与处理，CPU可以干其他事情，当DMA传输完成的时候产生一个中断，告诉CPU我已经完成了，然后CPU知道了就可以去处理数据了，这样子提高了CPU的利用率，因为CPU是大脑，主要做数据运算的工作，而不是去搬运数据。DMA 传输对于高效能嵌入式系统算法和网络是很重要的。</p><h3 id="在STM32的DMA资源"><a href="#在STM32的DMA资源" class="headerlink" title="在STM32的DMA资源"></a>在STM32的DMA资源</h3><p><strong>STM32F1系列</strong>的MCU有两个DMA控制器（DMA2只存在于大容量产品中），DMA1有7个通道，DMA2有5个通道，每个通道专门用来管理来自于一个或者多个外设对存储器的访问请求。还有一个仲裁器来协调各个DMA请求的优先权。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/f1-dam.png" alt="f1-dam"></p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/f1-dam2.png" alt="f1-dam2"></p><p><strong>而STM32F4/F7/H7系列</strong>的MCU有两个DMA控制器总共有16个数据流（每个DMA控制器8个），每一个DMA控制器都用于管理一个或多个外设的存储器访问请求。每个数据流总共可以有多达8个通道（或称请求）。每个通道都有一个仲裁器，用于处理 DMA 请求间的优先级。<br><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/f4-dam.png" alt="f4-dam"></p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/f4-dam2.png" alt="f4-dam2"></p><h3 id="DMA接收数据"><a href="#DMA接收数据" class="headerlink" title="DMA接收数据"></a>DMA接收数据</h3><p>DMA在接收数据的时候，串口接收DMA在初始化的时候就处于开启状态，一直等待数据的到来，在软件上无需做任何事情，只要在初始化配置的时候设置好配置就可以了。等到接收到数据的时候，告诉CPU去处理即可。</p><h3 id="判断数据接收完成"><a href="#判断数据接收完成" class="headerlink" title="判断数据接收完成"></a>判断数据接收完成</h3><blockquote><p>那么问题来了，怎么知道数据是否接收完成呢？</p></blockquote><p>其实，有很多方法：</p><ul><li>对于定长的数据，只需要判断一下数据的接收个数，就知道是否接收完成，这个很简单，暂不讨论。</li><li>对于不定长的数据，其实也有好几种方法，麻烦的我肯定不会介绍，有兴趣做复杂工作的同学可以在网上看看别人怎么做，下面这种方法是最简单的，充分利用了stm32的串口资源，效率也是非常之高。</li></ul><p><strong>DMA+串口空闲中断</strong></p><p>这两个资源配合，简直就是天衣无缝啊，无论接收什么不定长的数据，管你数据有多少，来一个我就收一个，就像广东人吃“山竹”，来一个吃一个~（最近风好大，我好怕）。</p><p>可能很多人在学习stm32的时候，都不知道idle是啥东西，先看看stm32串口的状态寄存器：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/idle.png" alt="idle"></p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/idle1.png" alt="idle1"></p><p>当我们检测到触发了串口总线空闲中断的时候，我们就知道这一波数据传输完成了，然后我们就能得到这些数据，去进行处理即可。这种方法是最简单的，根本不需要我们做多的处理，只需要配置好，串口就等着数据的到来，dma也是处于工作状态的，来一个数据就自动搬运一个数据。</p><h3 id="接收完数据时处理"><a href="#接收完数据时处理" class="headerlink" title="接收完数据时处理"></a>接收完数据时处理</h3><p>串口接收完数据是要处理的，那么处理的步骤是怎么样呢？</p><ul><li>暂时关闭串口接收DMA通道，有两个原因：1.防止后面又有数据接收到，产生干扰，因为此时的数据还未处理。2.DMA需要重新配置。</li><li>清DMA标志位。</li><li>从DMA寄存器中获取接收到的数据字节数（可有可无）。</li><li>重新设置DMA下次要接收的数据字节数，注意，数据传输数量范围为0至65535。这个寄存器只能在通道不工作(DMA_CCRx的EN=0)时写入。通道开启后该寄存器变为只读，指示剩余的待传输字节数目。寄存器内容在每次DMA传输后递减。数据传输结束后，寄存器的内容或者变为0；或者当该通道配置为自动重加载模式时，寄存器的内容将被自动重新加载为之前配置时的数值。当寄存器的内容为0时，无论通道是否开启，都不会发生任何数据传输。</li><li>给出信号量，发送接收到新数据标志，供前台程序查询。</li><li>开启DMA通道，等待下一次的数据接收，注意，对DMA的相关寄存器配置写入，如重置DMA接收数据长度，必须要在关闭DMA的条件进行，否则操作无效。</li></ul><p><strong>注意事项</strong></p><p>STM32的IDLE的中断在串口无数据接收的情况下，是不会一直产生的，产生的条件是这样的，当清除IDLE标志位后，必须有接收到第一个数据后，才开始触发，一断接收的数据断流，没有接收到数据，即产生IDLE中断。如果中断发送数据帧的速率很快，MCU来不及处理此次接收到的数据，中断又发来数据的话，这里不能开启，否则数据会被覆盖。有两种方式解决：</p><ol><li><p>在重新开启接收DMA通道之前，将Rx_Buf缓冲区里面的数据复制到另外一个数组中，然后再开启DMA，然后马上处理复制出来的数据。</p></li><li><p>建立双缓冲，重新配置DMA_MemoryBaseAddr的缓冲区地址，那么下次接收到的数据就会保存到新的缓冲区中，不至于被覆盖。</p></li></ol><h3 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h3><p>实验效果：<br>当外部给单片机发送数 据的时候，假设这帧数据长度是1000个字节，那么在单片机接收到一个字节的时候并不会产生串口中断，只是DMA在背后默默地把数据搬运到你指定的缓冲区里面。当整帧数据发送完毕之后串口才会产生一次中断，此时可以利用<code>DMA_GetCurrDataCounter()</code>函数计算出本次的数据接受长度，从而进行数据处理。</p><p><strong>串口的配置</strong><br>很简单，基本与使用串口的时候一致，只不过一般我们是打开接收缓冲区非空中断，而现在是打开空闲中断——<code>USART_ITConfig(DEBUG_USARTx, USART_IT_IDLE, ENABLE);</code>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/**  * @brief  USART GPIO 配置,工作参数配置  * @param  无  * @retval 无  */</span><span class="token keyword">void</span> <span class="token function">USART_Config</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>    USART_InitTypeDef USART_InitStructure<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 打开串口GPIO的时钟</span>    <span class="token function">DEBUG_USART_GPIO_APBxClkCmd</span><span class="token punctuation">(</span>DEBUG_USART_GPIO_CLK<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 打开串口外设的时钟</span>    <span class="token function">DEBUG_USART_APBxClkCmd</span><span class="token punctuation">(</span>DEBUG_USART_CLK<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将USART Tx的GPIO配置为推挽复用模式</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> DEBUG_USART_TX_GPIO_PIN<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_AF_PP<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>    <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>DEBUG_USART_TX_GPIO_PORT<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 将USART Rx的GPIO配置为浮空输入模式</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> DEBUG_USART_RX_GPIO_PIN<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_IN_FLOATING<span class="token punctuation">;</span>    <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>DEBUG_USART_RX_GPIO_PORT<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 配置串口的工作参数</span>    <span class="token comment" spellcheck="true">// 配置波特率</span>    USART_InitStructure<span class="token punctuation">.</span>USART_BaudRate <span class="token operator">=</span> DEBUG_USART_BAUDRATE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 配置 针数据字长</span>    USART_InitStructure<span class="token punctuation">.</span>USART_WordLength <span class="token operator">=</span> USART_WordLength_8b<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 配置停止位</span>    USART_InitStructure<span class="token punctuation">.</span>USART_StopBits <span class="token operator">=</span> USART_StopBits_1<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 配置校验位</span>    USART_InitStructure<span class="token punctuation">.</span>USART_Parity <span class="token operator">=</span> USART_Parity_No <span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 配置硬件流控制</span>    USART_InitStructure<span class="token punctuation">.</span>USART_HardwareFlowControl <span class="token operator">=</span>     USART_HardwareFlowControl_None<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 配置工作模式，收发一起</span>    USART_InitStructure<span class="token punctuation">.</span>USART_Mode <span class="token operator">=</span> USART_Mode_Rx <span class="token operator">|</span> USART_Mode_Tx<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 完成串口的初始化配置</span>    <span class="token function">USART_Init</span><span class="token punctuation">(</span>DEBUG_USARTx<span class="token punctuation">,</span> <span class="token operator">&amp;</span>USART_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 串口中断优先级配置</span>    <span class="token function">NVIC_Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_USART_DMA_RX </span>    <span class="token comment" spellcheck="true">// 开启 串口空闲IDEL 中断</span>    <span class="token function">USART_ITConfig</span><span class="token punctuation">(</span>DEBUG_USARTx<span class="token punctuation">,</span> USART_IT_IDLE<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 开启串口DMA接收</span>    <span class="token function">USART_DMACmd</span><span class="token punctuation">(</span>DEBUG_USARTx<span class="token punctuation">,</span> USART_DMAReq_Rx<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 使能串口DMA */</span>    <span class="token function">USARTx_DMA_Rx_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">else</span></span>    <span class="token comment" spellcheck="true">// 使能串口接收中断</span>    <span class="token function">USART_ITConfig</span><span class="token punctuation">(</span>DEBUG_USARTx<span class="token punctuation">,</span> USART_IT_RXNE<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">if</span> USE_USART_DMA_TX </span>    <span class="token comment" spellcheck="true">// 开启串口DMA发送</span><span class="token comment" spellcheck="true">//    USART_DMACmd(DEBUG_USARTx, USART_DMAReq_Tx, ENABLE); </span>    <span class="token function">USARTx_DMA_Tx_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    <span class="token comment" spellcheck="true">// 使能串口</span>    <span class="token function">USART_Cmd</span><span class="token punctuation">(</span>DEBUG_USARTx<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>串口DMA配置</strong></p><p>把DMA配置完成，就可以直接打开DMA了，让它处于工作状态，当有数据的时候就能直接搬运了。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">if</span> USE_USART_DMA_RX </span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">USARTx_DMA_Rx_Config</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    DMA_InitTypeDef DMA_InitStructure<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 开启DMA时钟</span>    <span class="token function">RCC_AHBPeriphClockCmd</span><span class="token punctuation">(</span>RCC_AHBPeriph_DMA1<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置DMA源地址：串口数据寄存器地址*/</span>    DMA_InitStructure<span class="token punctuation">.</span>DMA_PeripheralBaseAddr <span class="token operator">=</span> <span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span>USART_DR_ADDRESS<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 内存地址(要传输的变量的指针)</span>    DMA_InitStructure<span class="token punctuation">.</span>DMA_MemoryBaseAddr <span class="token operator">=</span> <span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span>Usart_Rx_Buf<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 方向：从内存到外设    </span>    DMA_InitStructure<span class="token punctuation">.</span>DMA_DIR <span class="token operator">=</span> DMA_DIR_PeripheralSRC<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 传输大小    </span>    DMA_InitStructure<span class="token punctuation">.</span>DMA_BufferSize <span class="token operator">=</span> USART_RX_BUFF_SIZE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 外设地址不增        </span>    DMA_InitStructure<span class="token punctuation">.</span>DMA_PeripheralInc <span class="token operator">=</span> DMA_PeripheralInc_Disable<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 内存地址自增</span>    DMA_InitStructure<span class="token punctuation">.</span>DMA_MemoryInc <span class="token operator">=</span> DMA_MemoryInc_Enable<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 外设数据单位    </span>    DMA_InitStructure<span class="token punctuation">.</span>DMA_PeripheralDataSize <span class="token operator">=</span>     DMA_PeripheralDataSize_Byte<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 内存数据单位</span>    DMA_InitStructure<span class="token punctuation">.</span>DMA_MemoryDataSize <span class="token operator">=</span> DMA_MemoryDataSize_Byte<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// DMA模式，一次或者循环模式</span>    <span class="token comment" spellcheck="true">//DMA_InitStructure.DMA_Mode = DMA_Mode_Normal ;</span>    DMA_InitStructure<span class="token punctuation">.</span>DMA_Mode <span class="token operator">=</span> DMA_Mode_Circular<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 优先级：中    </span>    DMA_InitStructure<span class="token punctuation">.</span>DMA_Priority <span class="token operator">=</span> DMA_Priority_VeryHigh<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 禁止内存到内存的传输</span>    DMA_InitStructure<span class="token punctuation">.</span>DMA_M2M <span class="token operator">=</span> DMA_M2M_Disable<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 配置DMA通道           </span>    <span class="token function">DMA_Init</span><span class="token punctuation">(</span>USART_RX_DMA_CHANNEL<span class="token punctuation">,</span> <span class="token operator">&amp;</span>DMA_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 清除DMA所有标志</span>    <span class="token function">DMA_ClearFlag</span><span class="token punctuation">(</span>DMA1_FLAG_TC5<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">DMA_ITConfig</span><span class="token punctuation">(</span>USART_RX_DMA_CHANNEL<span class="token punctuation">,</span> DMA_IT_TE<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使能DMA</span>    <span class="token function">DMA_Cmd</span> <span class="token punctuation">(</span>USART_RX_DMA_CHANNEL<span class="token punctuation">,</span>ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>接收完数据处理</strong></p><p>因为接收完数据之后，会产生一个idle中断，也就是空闲中断，那么我们就可以在中断服务函数中知道已经接收完了，就可以处理数据了，但是中断服务函数的上下文环境是中断，所以，尽量是快进快出，一般在中断中将一些标志置位，供前台查询。在中断中先判断我们的产生在中断的类型是不是idle中断，如果是则进行下一步，否则就无需理会。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/**  ******************************************************************  * @brief   串口中断服务函数  * @author  jiejie  * @version V1.0  * @date    2018-xx-xx  ******************************************************************  */</span> <span class="token keyword">void</span> <span class="token function">DEBUG_USART_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_USART_DMA_RX</span>    <span class="token comment" spellcheck="true">/* 使用串口DMA */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">USART_GetITStatus</span><span class="token punctuation">(</span>DEBUG_USARTx<span class="token punctuation">,</span>USART_IT_IDLE<span class="token punctuation">)</span><span class="token operator">!=</span>RESET<span class="token punctuation">)</span>    <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/* 接收数据 */</span>        <span class="token function">Receive_DataPack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 清除空闲中断标志位</span>        <span class="token function">USART_ReceiveData</span><span class="token punctuation">(</span> DEBUG_USARTx <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token macro property">#<span class="token directive keyword">else</span></span>  <span class="token comment" spellcheck="true">/* 接收中断 */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">USART_GetITStatus</span><span class="token punctuation">(</span>DEBUG_USARTx<span class="token punctuation">,</span>USART_IT_RXNE<span class="token punctuation">)</span><span class="token operator">!=</span>RESET<span class="token punctuation">)</span>    <span class="token punctuation">{</span>            <span class="token function">Receive_DataPack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Receive_DataPack()</strong></p><p>这个才是真正的接收数据处理函数，为什么我要将这个函数单独封装起来呢？因为这个函数其实是很重要的，因为我的代码兼容普通串口接收与空闲中断，不一样的接收类型其处理也不一样，所以直接封装起来更好，在源码中通过宏定义实现选择接收的方式！更考虑了兼容操作系统的，可能我会在系统中使用dma+空闲中断，所以，供前台查询的信号量就有可能不一样，可能需要修改，我就把它封装起来了。不过无所谓，都是一样的。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/************************************************************  * @brief   Uart_DMA_Rx_Data  * @param   NULL  * @return  NULL  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    使用串口 DMA 接收时调用的函数  ***********************************************************/</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_USART_DMA_RX</span><span class="token keyword">void</span> <span class="token function">Receive_DataPack</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 接收的数据长度 */</span>    uint32_t buff_length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 关闭DMA ，防止干扰 */</span>    <span class="token function">DMA_Cmd</span><span class="token punctuation">(</span>USART_RX_DMA_CHANNEL<span class="token punctuation">,</span> DISABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 暂时关闭dma，数据尚未处理 */</span>     <span class="token comment" spellcheck="true">/* 清DMA标志位 */</span>    <span class="token function">DMA_ClearFlag</span><span class="token punctuation">(</span> DMA1_FLAG_TC5 <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* 获取接收到的数据长度 单位为字节*/</span>    buff_length <span class="token operator">=</span> USART_RX_BUFF_SIZE <span class="token operator">-</span> <span class="token function">DMA_GetCurrDataCounter</span><span class="token punctuation">(</span>USART_RX_DMA_CHANNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 获取数据长度 */</span>    Usart_Rx_Sta <span class="token operator">=</span> buff_length<span class="token punctuation">;</span>    <span class="token function">PRINT_DEBUG</span><span class="token punctuation">(</span><span class="token string">"buff_length = %d\n "</span><span class="token punctuation">,</span>buff_length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 重新赋值计数值，必须大于等于最大可能接收到的数据帧数目 */</span>    USART_RX_DMA_CHANNEL<span class="token operator">-></span>CNDTR <span class="token operator">=</span> USART_RX_BUFF_SIZE<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 此处应该在处理完数据再打开，如在 DataPack_Process() 打开*/</span>    <span class="token function">DMA_Cmd</span><span class="token punctuation">(</span>USART_RX_DMA_CHANNEL<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* (OS)给出信号 ，发送接收到新数据标志，供前台程序查询 */</span>    <span class="token comment" spellcheck="true">/* 标记接收完成，在 DataPack_Handle 处理*/</span>    Usart_Rx_Sta <span class="token operator">|</span><span class="token operator">=</span> <span class="token number">0xC000</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*     DMA 开启，等待数据。注意，如果中断发送数据帧的速率很快，MCU来不及处理此次接收到的数据，    中断又发来数据的话，这里不能开启，否则数据会被覆盖。有2种方式解决：    1. 在重新开启接收DMA通道之前，将Rx_Buf缓冲区里面的数据复制到另外一个数组中，    然后再开启DMA，然后马上处理复制出来的数据。    2. 建立双缓冲，重新配置DMA_MemoryBaseAddr的缓冲区地址，那么下次接收到的数据就会    保存到新的缓冲区中，不至于被覆盖。    */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>f1使用dma是非常简单的，我在f4用dma的时候也遇到一些问题，最后看手册解决了，打算下一篇文章就写一下调试过程，没有什么是debug不能解决的，如果有，那就两次。今天台风天气，连着舍友的WiFi更新的文章~中国电信还是强，台风天气信号一点都不虚，我的移动卡一动不动-_-.</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台回复获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> Cortex-M </tag>
            
            <tag> DMA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纯C语言写的按键驱动，将按键逻辑与按键处理事件分离~</title>
      <link href="/button/"/>
      <url>/button/</url>
      
        <content type="html"><![CDATA[<h1 id="ButtonDrive"><a href="#ButtonDrive" class="headerlink" title="ButtonDrive"></a>ButtonDrive</h1><p>自己写的一个按键驱动，支持单双击、连按、长按；采用回调处理按键事件（自定义消抖时间），使用只需3步，创建按键，按键事件与回调处理函数链接映射，周期检查按键。<br>源码地址：<a href="https://github.com/jiejieTop/ButtonDrive" target="_blank" rel="noopener">https://github.com/jiejieTop/ButtonDrive</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天写了个按键驱动，参考了<a href="https://github.com/0x1abin/MultiButton" target="_blank" rel="noopener">MulitButton</a>的数据结构的用法，逻辑实现并不一样。<br>在这里感谢所有的开源开发者，让我从中学到了很多，同时网络也是一个好平台，也希望所有的开发者能形成良性循环，从网络中学知识，回馈到网络中去。感谢<a href="https://github.com/0x1abin/MultiButton" target="_blank" rel="noopener">MulitButton</a>的作者<a href="https://github.com/0x1abin" target="_blank" rel="noopener">0x1abin</a>，感谢两位rtt的大佬：<a href="https://github.com/uestczyh222" target="_blank" rel="noopener">大法师</a>、<a href="https://github.com/liu2guang" target="_blank" rel="noopener">流光</a>。</p><h2 id="Button-drive简介"><a href="#Button-drive简介" class="headerlink" title="Button_drive简介"></a>Button_drive简介</h2><p>Button_drive是一个小巧的按键驱动，支持单击、双击、长按、连续触发等（后续可以在按键控制块中添加触发事件），理论上可无限量扩展Button，Button_drive采用按键触发事件回调方式处理业务逻辑，支持在RTOS中使用，我目前仅在<a href="https://github.com/RT-Thread/rt-thread" target="_blank" rel="noopener">RT-Thread</a>上测试过。<br>写按键驱动的目的是想要将用户按键逻辑与按键处理事件分离，用户无需处理复杂麻烦的逻辑事件。</p><h2 id="Button-drive使用效果"><a href="#Button-drive使用效果" class="headerlink" title="Button_drive使用效果"></a>Button_drive使用效果</h2><ol><li><strong>单击与长按</strong></li></ol><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20191017200917803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qaWVqaWUuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="2"><li><strong>双击</strong></li></ol><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20191017200928625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qaWVqaWUuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="3"><li><strong>连按</strong></li></ol><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20191017200939523.png" alt="在这里插入图片描述"><br>4. <strong>连按释放</strong></p><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20191017200953789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qaWVqaWUuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li><p>创建按键句柄</p><pre><code>Button_t Button1;Button_t Button2; </code></pre></li><li><p>创建按键，初始化按键信息，包括按键名字、按键电平检测函数接口、按键触发电平。</p><pre><code>Button_Create("Button1",                //按键名字             &amp;Button1,                 //按键句柄             Read_Button1_Level,     //按键电平检测函数接口             BTN_TRIGGER);               //触发电平             ......</code></pre></li><li><p>按键触发事件与事件回调函数链接映射，当按键事件被触发的时候，自动跳转回调函数中处理业务逻辑。</p><pre><code>Button_Attach(&amp;Button1,BUTTON_DOWM,Btn2_Dowm_CallBack);        //按键单击Button_Attach(&amp;Button1,BUTTON_DOUBLE,Btn2_Double_CallBack);    //双击Button_Attach(&amp;Button1,BUTTON_LONG,Btn2_Long_CallBack);        //长按             .......</code></pre></li><li><p>周期调用回调按键处理函数即可，建议调用周期20-50ms。</p><pre><code>Button_Process();     //需要周期调用按键处理函数</code></pre></li></ol><hr><p>需要用户实现的 <strong>2</strong> 个函数：</p><ul><li>按键电平检测接口：<pre><code>uint8_t Read_Button1_Level(void){return GPIO_ReadInputDataBit(BTN1_GPIO_PORT,BTN1_GPIO_PIN);}</code></pre></li></ul><p>uint8_t Read_Button2_Level(void)<br>{<br>  return GPIO_ReadInputDataBit(BTN2_GPIO_PORT,BTN2_GPIO_PIN);<br>}</p><p>// 这是我在stm32上简单测试的伪代码，以实际源码为准</p><pre><code>- 按键逻辑处理</code></pre><p>void Btn1_Dowm_CallBack(void *btn)<br>{<br>  PRINT_INFO(“Button1 单击!”);<br>}</p><p>void Btn1_Double_CallBack(void *btn)<br>{<br>  PRINT_INFO(“Button1 双击!”);<br>}</p><p>void Btn1_Long_CallBack(void *btn)<br>{<br>  PRINT_INFO(“Button1 长按!”);</p><p>  Button_Delete(&amp;Button2);<br>  PRINT_INFO(“删除Button1”);<br>  Search_Button();<br>}</p><pre><code>##  特点Button_drive开放源码，按键控制块采用数据结构方式，按键事件采用枚举类型，确保不会重复，也便于添加用户需要逻辑，采用宏定义方式定义消抖时间、连按触发时间、双击时间间隔、长按时间等，便于修改。同时所有被创建的按键采用单链表方式连击，用户只管创建，无需理会按键处理，只需调用`Button_Process()`即可，在函数中会自动遍历所有被创建的按键。支持按键删除操作，用户无需在代码中删除对应的按键创建于映射链接代码，也无需删除关于按键的任何回调事件处理函数，只需调用`Button_Delete()`函数即可，这样子，就不会处理关于被删除按键的任何状态。当然目前按键内存不会释放，如果使用os的话，建议释放按键内存。##### 按键控制块```c/*    每个按键对应1个全局的结构体变量。    其成员变量是实现消抖和多种按键状态所必须的*/typedef struct button{    /* 下面是一个函数指针，指向判断按键手否按下的函数 */    uint8_t (*Read_Button_Level)(void); /* 读取按键电平函数，需要用户实现 */  char Name[BTN_NAME_MAX];  uint8_t Button_State              :   4;      /* 按键当前状态（按下还是弹起） */  uint8_t Button_Last_State         :   4;      /* 上一次的按键状态，用于判断双击 */  uint8_t Button_Trigger_Level      :   2;    /* 按键触发电平 */  uint8_t Button_Last_Level         :   2;    /* 按键当前电平 */  uint8_t Button_Trigger_Event;     /* 按键触发事件，单击，双击，长按等 */  Button_CallBack CallBack_Function[number_of_event];  uint8_t Button_Cycle;               /* 连续按键周期 */  uint8_t Timer_Count;            /* 计时 */  uint8_t Debounce_Time;        /* 消抖时间 */  uint8_t Long_Time;          /* 按键按下持续时间 */  struct button *Next;}Button_t;</code></pre><h5 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h5><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token punctuation">{</span>  BUTTON_DOWM <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>  BUTTON_UP<span class="token punctuation">,</span>  BUTTON_DOUBLE<span class="token punctuation">,</span>  BUTTON_LONG<span class="token punctuation">,</span>  BUTTON_CONTINUOS<span class="token punctuation">,</span>  BUTTON_CONTINUOS_FREE<span class="token punctuation">,</span>  BUTTON_ALL_RIGGER<span class="token punctuation">,</span>  number_of_event<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* 触发回调的事件 */</span>  NONE_TRIGGER<span class="token punctuation">}</span>Button_Event<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="宏定义选择"><a href="#宏定义选择" class="headerlink" title="宏定义选择"></a>宏定义选择</h5><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> BTN_NAME_MAX  32     </span><span class="token comment" spellcheck="true">//名字最大为32字节</span><span class="token comment" spellcheck="true">/* 按键消抖时间40ms, 建议调用周期为20ms 只有连续检测到40ms状态不变才认为有效，包括弹起和按下两种事件*/</span><span class="token macro property">#<span class="token directive keyword">define</span> CONTINUOS_TRIGGER             0  </span><span class="token comment" spellcheck="true">//是否支持连续触发，连发的话就不要检测单双击与长按了    </span><span class="token comment" spellcheck="true">/* 是否支持单击&amp;双击同时存在触发，如果选择开启宏定义的话，单双击都回调，只不过单击会延迟响应，   因为必须判断单击之后是否触发了双击否则，延迟时间是双击间隔时间 BUTTON_DOUBLE_TIME。   而如果不开启这个宏定义，建议工程中只存在单击/双击中的一个，否则，在双击响应的时候会触发一次单击，   因为双击必须是有一次按下并且释放之后才产生的 */</span><span class="token macro property">#<span class="token directive keyword">define</span> SINGLE_AND_DOUBLE_TRIGGER     1 </span><span class="token comment" spellcheck="true">/* 是否支持长按释放才触发，如果打开这个宏定义，那么长按释放之后才触发单次长按，   否则在长按指定时间就一直触发长按，触发周期由 BUTTON_LONG_CYCLE 决定 */</span><span class="token macro property">#<span class="token directive keyword">define</span> LONG_FREE_TRIGGER             0 </span><span class="token macro property">#<span class="token directive keyword">define</span> BUTTON_DEBOUNCE_TIME       2   </span><span class="token comment" spellcheck="true">//消抖时间      (n-1)*调用周期</span><span class="token macro property">#<span class="token directive keyword">define</span> BUTTON_CONTINUOS_CYCLE  1      </span><span class="token comment" spellcheck="true">//连按触发周期时间  (n-1)*调用周期  </span><span class="token macro property">#<span class="token directive keyword">define</span> BUTTON_LONG_CYCLE       1      </span><span class="token comment" spellcheck="true">//长按触发周期时间  (n-1)*调用周期 </span><span class="token macro property">#<span class="token directive keyword">define</span> BUTTON_DOUBLE_TIME      15     </span><span class="token comment" spellcheck="true">//双击间隔时间  (n-1)*调用周期  建议在200-600ms</span><span class="token macro property">#<span class="token directive keyword">define</span> BUTTON_LONG_TIME           50        </span><span class="token comment" spellcheck="true">/* 持续n秒((n-1)*调用周期 ms)，认为长按事件 */</span><span class="token macro property">#<span class="token directive keyword">define</span> TRIGGER_CB(event)   \        if(btn->CallBack_Function[event]) \          btn->CallBack_Function[event]((Button_t*)btn)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><pre class="line-numbers language-c"><code class="language-c">  <span class="token function">Button_Create</span><span class="token punctuation">(</span><span class="token string">"Button1"</span><span class="token punctuation">,</span>              <span class="token operator">&amp;</span>Button1<span class="token punctuation">,</span>               Read_KEY1_Level<span class="token punctuation">,</span>               KEY_ON<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">Button_Attach</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button1<span class="token punctuation">,</span>BUTTON_DOWM<span class="token punctuation">,</span>Btn1_Dowm_CallBack<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//单击</span>  <span class="token function">Button_Attach</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button1<span class="token punctuation">,</span>BUTTON_DOUBLE<span class="token punctuation">,</span>Btn1_Double_CallBack<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//双击</span>  <span class="token function">Button_Attach</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button1<span class="token punctuation">,</span>BUTTON_CONTINUOS<span class="token punctuation">,</span>Btn1_Continuos_CallBack<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//连按  </span>  <span class="token function">Button_Attach</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button1<span class="token punctuation">,</span>BUTTON_CONTINUOS_FREE<span class="token punctuation">,</span>Btn1_ContinuosFree_CallBack<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//连按释放  </span>  <span class="token function">Button_Attach</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button1<span class="token punctuation">,</span>BUTTON_LONG<span class="token punctuation">,</span>Btn1_Long_CallBack<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//长按</span>  <span class="token function">Button_Create</span><span class="token punctuation">(</span><span class="token string">"Button2"</span><span class="token punctuation">,</span>              <span class="token operator">&amp;</span>Button2<span class="token punctuation">,</span>               Read_KEY2_Level<span class="token punctuation">,</span>               KEY_ON<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">Button_Attach</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button2<span class="token punctuation">,</span>BUTTON_DOWM<span class="token punctuation">,</span>Btn2_Dowm_CallBack<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//单击</span>  <span class="token function">Button_Attach</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button2<span class="token punctuation">,</span>BUTTON_DOUBLE<span class="token punctuation">,</span>Btn2_Double_CallBack<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//双击</span>  <span class="token function">Button_Attach</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button2<span class="token punctuation">,</span>BUTTON_CONTINUOS<span class="token punctuation">,</span>Btn2_Continuos_CallBack<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//连按</span>  <span class="token function">Button_Attach</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button2<span class="token punctuation">,</span>BUTTON_CONTINUOS_FREE<span class="token punctuation">,</span>Btn2_ContinuosFree_CallBack<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//连按释放</span>  <span class="token function">Button_Attach</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button2<span class="token punctuation">,</span>BUTTON_LONG<span class="token punctuation">,</span>Btn2_Long_CallBack<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//长按</span>  <span class="token function">Get_Button_Event</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">Get_Button_Event</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p><a href="https://github.com/liu2guang" target="_blank" rel="noopener">流光</a>大佬的要求，让我玩一玩RTT的<a href="https://github.com/liu2guang/buildpkg" target="_blank" rel="noopener">rtkpgs</a>，打算用Button_drive练一练手吧。</p><h2 id="ButtonDrive在env使用"><a href="#ButtonDrive在env使用" class="headerlink" title="ButtonDrive在env使用"></a>ButtonDrive在env使用</h2><p>目前我已将按键驱动做成软件包（packages），如果使用RT-Thread操作系统的话，可以在env中直接配置使用!</p><p>步骤如下：</p><ol><li><strong>选择在线软件包</strong></li></ol><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20191017201032261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qaWVqaWUuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="2"><li><strong>选择软件包属性为外设相关</strong></li></ol><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/201910172010447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qaWVqaWUuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="3"><li><strong>选择button_drive</strong></li></ol><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20191017201103483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qaWVqaWUuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="4"><li><strong>进入驱动的选项配置（自带默认属性）</strong></li></ol><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20191017201118160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qaWVqaWUuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="5"><li><p><strong>如果不懂按键的配置是什么意思，按下“shift+？”，即可有解释</strong><br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20191017201124140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qaWVqaWUuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><strong>编译生成mdk/iar工程</strong></p></li></ol><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20191017201130458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qaWVqaWUuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20191017201134524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qaWVqaWUuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="关于rtkpgs"><a href="#关于rtkpgs" class="headerlink" title="关于rtkpgs"></a>关于<a href="https://github.com/liu2guang/buildpkg" target="_blank" rel="noopener">rtkpgs</a></h2><h2 id="简介-English"><a href="#简介-English" class="headerlink" title="简介 (English)"></a>简介 (<a href="/readme.en.md">English</a>)</h2><p>buildpkg 是用于生成 RT-Thread package 的快速构建工具。</p><p>一个优秀的 package 应该是这样的：</p><ol><li>代码优雅, 规范化。</li><li>examples 例程，提供通俗易懂的使用例程。</li><li>SConscript 文件，用于和 RT-Thread 环境一起进行编译。</li><li>README.md 文档，向用户提供必要的功能说明。</li><li>docs 文件夹, 放置除了 README 之外的其他细节文档。</li><li>license 许可文件，版权说明。</li></ol><p>为了方便快速的生成 RT-Thread package 规范化模板 以及 减轻开源仓库迁移 RT-Thread 的前期准备工作的负担，基于此目的的 buildpkg 应运而生，为开发 Rt-Thread 的 package 的开发者提供辅助开发工具。</p><table><thead><tr><th align="left">序号</th><th align="left">支持功能</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">构建 package 模板</td><td align="left">创建指定名称 package , 自动添加 readme /版本号/ github ci脚本/demo/开源协议文件</td></tr><tr><td align="left">2</td><td align="left">迁移开源仓库</td><td align="left">从指定 git 仓库构建 package , 自动添加readme/版本号/ github ci脚本/demo/开源协议文件, 但是迁移的仓库需要用户自己按照实际情况修改</td></tr><tr><td align="left">3</td><td align="left">更新 package</td><td align="left">生成package后可以再次更新之前设定的版本号，开源协议或者scons脚本等</td></tr></tbody></table><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="1-构建package"><a href="#1-构建package" class="headerlink" title="1. 构建package"></a>1. 构建package</h3><blockquote><p>buildpkg.exe make pkgdemo</p></blockquote><h3 id="2-迁移开源仓库"><a href="#2-迁移开源仓库" class="headerlink" title="2. 迁移开源仓库"></a>2. 迁移开源仓库</h3><blockquote><p>buildpkg.exe make cstring <a href="https://github.com/liu2guang/cstring.git" target="_blank" rel="noopener">https://github.com/liu2guang/cstring.git</a></p></blockquote><h3 id="3-更新package"><a href="#3-更新package" class="headerlink" title="3. 更新package"></a>3. 更新package</h3><blockquote><p>buildpkg.exe update pkgname</p></blockquote><h3 id="4-可选配置"><a href="#4-可选配置" class="headerlink" title="4. 可选配置"></a>4. 可选配置</h3><table><thead><tr><th align="left">长参数</th><th align="left">短参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">–version=v1.0.0</td><td align="left">-v v1.0.0</td><td align="left">设置 package 的版本</td></tr><tr><td align="left">–license=MIT</td><td align="left">-l MIT</td><td align="left">设置 package 所遵循的版权协议</td></tr><tr><td align="left">–submodule</td><td align="left">-s</td><td align="left">删除 git 子模块</td></tr></tbody></table><h2 id="测试平台"><a href="#测试平台" class="headerlink" title="测试平台"></a>测试平台</h2><table><thead><tr><th align="left">序号</th><th align="left">测试平台</th><th align="left">测试结果</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">win10</td><td align="left">exe测试通过, py测试通过</td></tr><tr><td align="left">2</td><td align="left">win7</td><td align="left">exe待测试, py待测试</td></tr><tr><td align="left">3</td><td align="left">mac</td><td align="left">py脚本不知道是否兼容, 没有测试条件, 后面维护下</td></tr><tr><td align="left">4</td><td align="left">linux</td><td align="left">py脚本不知道是否兼容, 没有测试条件, 后面维护下</td></tr></tbody></table><h2 id="联系人"><a href="#联系人" class="headerlink" title="联系人"></a>联系人</h2><ul><li>邮箱：<a href="mailto:1004383796@qq.com" target="_blank" rel="noopener">1004383796@qq.com</a></li><li>主页：<a href="https://github.com/liu2guang" target="_blank" rel="noopener">liu2guang</a></li><li>仓库：<a href="https://github.com/liu2guang" target="_blank" rel="noopener">Github</a>, <a href="https://github.com/liu2guang" target="_blank" rel="noopener">Gitee</a> </li></ul><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> ButtonDrive </tag>
            
            <tag> STM32 </tag>
            
            <tag> 开源项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继续学习FreeRTOS消息队列</title>
      <link href="/freertos-10/"/>
      <url>/freertos-10/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写在前面：杰杰这个月很忙~所以并没有时间更新，现在健身房闭馆装修，晚上有空就更新一下！其实在公众号没更新的这段日子，每天都有兄弟在来关注我的公众号，这让我受宠若惊，在这里谢谢大家的支持啦！！谢谢^</p></blockquote><p>在这里我们就跟着火哥的书来学习一下FreeRTOS的消息队列，这本书我觉得写得很好，基本都讲解到了，关于什么是消息队列，就请大家去看书，基础知识我暂时不说了。</p><p><strong>声明：本书绝大部分内容来自《FreeRTOS 内核实现与应用开发实战指南—基于野火 STM32 全系列（M3/4/7）开发板》，如涉及侵权请联系杰杰删除</strong></p><h3 id="FreeRTOS的消息队列支持"><a href="#FreeRTOS的消息队列支持" class="headerlink" title="FreeRTOS的消息队列支持"></a>FreeRTOS的消息队列支持</h3><ul><li>FreeRTOS 中使用队列数据结构实现任务异步通信工作，具有如下特性：</li><li>消息支持先进先出方式排队，支持异步读写工作方式。</li><li>读写队列均支持超时机制。</li><li>消息支持后进先出方式排队， 往队首发送消息（LIFO） 。</li><li>可以允许不同长度（不超过队列节点最大值）的任意类型消息。</li><li>一个任务能够从任意一个消息队列接收和发送消息。</li><li>多个任务能够从同一个消息队列接收和发送消息。</li><li>当队列使用结束后，可以通过删除队列函数进行删除。</li></ul><h3 id="FreeRTOS队列的特点"><a href="#FreeRTOS队列的特点" class="headerlink" title="FreeRTOS队列的特点"></a>FreeRTOS队列的特点</h3><p>一般来说，鱼与熊掌不可兼得，如果数据太多，那数据传输的速度必然是会慢下来，而如果采用引用传递的方式，当原始数据被修改的时候，数据有变得不安全，但是FreeRTOS支持拷贝与引用的方式进行数据的传输，变得更加灵活。<br>队列是通过拷贝传递数据的，但这并不妨碍队列通过引用来传递数据。当信息的大小到达一个临界点后，逐字节拷贝整个信息是不实际的，可以定义一个指向数据区域的指针，将指针传递即可。这种方法在物联网中是非常常用的。</p><h3 id="消息队列控制块"><a href="#消息队列控制块" class="headerlink" title="消息队列控制块"></a>消息队列控制块</h3><p>其实消息队列不仅仅是用于当做消息队列，FreeRTOS还把他当做信号量的数据结构来使用</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> QueueDefinition<span class="token punctuation">{</span>    int8_t <span class="token operator">*</span>pcHead<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">/* 指向队列存储区起始位置,即第一个队列项 */</span>    int8_t <span class="token operator">*</span>pcTail<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">/* 指向队列存储区结束后的下一个字节 */</span>    int8_t <span class="token operator">*</span>pcWriteTo<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* 指向下队列存储区的下一个空闲位置 */</span>    <span class="token keyword">union</span>                       <span class="token comment" spellcheck="true">/* 使用联合体用来确保两个互斥的结构体成员不会同时出现 */</span>    <span class="token punctuation">{</span>        int8_t <span class="token operator">*</span>pcReadFrom<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 当结构体用于队列时,这个字段指向出队项目中的最后一个. */</span>        UBaseType_t uxRecursiveCallCount<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 当结构体用于互斥量时,用作计数器,保存递归互斥量被"获取"的次数. */</span>    <span class="token punctuation">}</span> u<span class="token punctuation">;</span>    List_t xTasksWaitingToSend<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* 因为等待入队而阻塞的任务列表,按照优先级顺序存储 */</span>    List_t xTasksWaitingToReceive<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 因为等待队列项而阻塞的任务列表,按照优先级顺序存储 */</span>    <span class="token keyword">volatile</span> UBaseType_t uxMessagesWaiting<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*&lt; 当前队列的队列项数目 */</span>    UBaseType_t uxLength<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* 队列项的数目 */</span>    UBaseType_t uxItemSize<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* 每个队列项的大小 */</span>    <span class="token keyword">volatile</span> BaseType_t xRxLock<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 队列上锁后,存储从队列收到的列表项数目，如果队列没有上锁，设置为queueUNLOCKED */</span>    <span class="token keyword">volatile</span> BaseType_t xTxLock<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 队列上锁后,存储发送到队列的列表项数目，如果队列没有上锁，设置为queueUNLOCKED */</span>    <span class="token comment" spellcheck="true">/* 删除部分源码 */</span><span class="token punctuation">}</span> xQUEUE<span class="token punctuation">;</span><span class="token keyword">typedef</span> xQUEUE Queue_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先过一遍消息队列的数据结构，其实没啥东西的，记不住也没啥大问题，下面会用到就行了。</p><h3 id="创建消息队列"><a href="#创建消息队列" class="headerlink" title="创建消息队列"></a>创建消息队列</h3><p>FreeRTOS创建队列API函数是xQueueCreate()，但其实这是一个宏。真正被执行的函数是xQueueGenericCreate()，我们称这个函数为通用队列创建函数。</p><pre class="line-numbers language-c"><code class="language-c">    QueueHandle_t <span class="token function">xQueueGenericCreate</span><span class="token punctuation">(</span> <span class="token keyword">const</span> UBaseType_t uxQueueLength<span class="token punctuation">,</span> <span class="token keyword">const</span> UBaseType_t uxItemSize<span class="token punctuation">,</span> <span class="token keyword">const</span> uint8_t ucQueueType <span class="token punctuation">)</span>    <span class="token punctuation">{</span>    Queue_t <span class="token operator">*</span>pxNewQueue<span class="token punctuation">;</span>    size_t xQueueSizeInBytes<span class="token punctuation">;</span>    uint8_t <span class="token operator">*</span>pucQueueStorage<span class="token punctuation">;</span>        <span class="token function">configASSERT</span><span class="token punctuation">(</span> uxQueueLength <span class="token operator">></span> <span class="token punctuation">(</span> UBaseType_t <span class="token punctuation">)</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> uxItemSize <span class="token operator">==</span> <span class="token punctuation">(</span> UBaseType_t <span class="token punctuation">)</span> <span class="token number">0</span> <span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* 如果 uxItemSize 为 0，也就是单个消息空间大小为 0，这样子就不需要申请内存了，那么 xQueueSizeInBytes 也设置为 0 即可，设置为 0 是可以的，用作信号量的时候这个就可以设置为 0。*/</span>            xQueueSizeInBytes <span class="token operator">=</span> <span class="token punctuation">(</span> size_t <span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* 分配足够消息存储空间，空间的大小为队列长度*单个消息大小 */</span>            xQueueSizeInBytes <span class="token operator">=</span> <span class="token punctuation">(</span> size_t <span class="token punctuation">)</span> <span class="token punctuation">(</span> uxQueueLength <span class="token operator">*</span> uxItemSize <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*lint !e961 MISRA exception as the casts are only redundant for some ports. */</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/* FreeRTOS 调用 pvPortMalloc()函数向系统申请内存空间，内存大小为消息队列控制块大小加上消息存储空间大小，因为这段内存空间是需要保证连续的 */</span>        pxNewQueue <span class="token operator">=</span> <span class="token punctuation">(</span> Queue_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token function">pvPortMalloc</span><span class="token punctuation">(</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span> Queue_t <span class="token punctuation">)</span> <span class="token operator">+</span> xQueueSizeInBytes <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> pxNewQueue <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* 计算出消息存储空间的起始地址 */</span>            pucQueueStorage <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span> uint8_t <span class="token operator">*</span> <span class="token punctuation">)</span> pxNewQueue <span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span> Queue_t <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token macro property">#<span class="token directive keyword">if</span>( configSUPPORT_STATIC_ALLOCATION == 1 )</span>            <span class="token punctuation">{</span>                pxNewQueue<span class="token operator">-></span>ucStaticallyAllocated <span class="token operator">=</span> pdFALSE<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">/* configSUPPORT_STATIC_ALLOCATION */</span>            <span class="token function">prvInitialiseNewQueue</span><span class="token punctuation">(</span> uxQueueLength<span class="token punctuation">,</span> uxItemSize<span class="token punctuation">,</span> pucQueueStorage<span class="token punctuation">,</span> ucQueueType<span class="token punctuation">,</span> pxNewQueue <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> pxNewQueue<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>真正的初始化在下面这个函数中：</p><pre class="line-numbers language-c"><code class="language-c">BaseType_t <span class="token function">xQueueGenericReset</span><span class="token punctuation">(</span> QueueHandle_t xQueue<span class="token punctuation">,</span> BaseType_t xNewQueue <span class="token punctuation">)</span><span class="token punctuation">{</span>Queue_t <span class="token operator">*</span> <span class="token keyword">const</span> pxQueue <span class="token operator">=</span> <span class="token punctuation">(</span> Queue_t <span class="token operator">*</span> <span class="token punctuation">)</span> xQueue<span class="token punctuation">;</span>    <span class="token function">configASSERT</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">taskENTER_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 消息队列数据结构的相关初始化 */</span>        pxQueue<span class="token operator">-></span>pcTail <span class="token operator">=</span> pxQueue<span class="token operator">-></span>pcHead <span class="token operator">+</span> <span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>uxLength <span class="token operator">*</span> pxQueue<span class="token operator">-></span>uxItemSize <span class="token punctuation">)</span><span class="token punctuation">;</span>        pxQueue<span class="token operator">-></span>uxMessagesWaiting <span class="token operator">=</span> <span class="token punctuation">(</span> UBaseType_t <span class="token punctuation">)</span> <span class="token number">0U</span><span class="token punctuation">;</span>        pxQueue<span class="token operator">-></span>pcWriteTo <span class="token operator">=</span> pxQueue<span class="token operator">-></span>pcHead<span class="token punctuation">;</span>        pxQueue<span class="token operator">-></span>u<span class="token punctuation">.</span>pcReadFrom <span class="token operator">=</span> pxQueue<span class="token operator">-></span>pcHead <span class="token operator">+</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>uxLength <span class="token operator">-</span> <span class="token punctuation">(</span> UBaseType_t <span class="token punctuation">)</span> <span class="token number">1U</span> <span class="token punctuation">)</span> <span class="token operator">*</span> pxQueue<span class="token operator">-></span>uxItemSize <span class="token punctuation">)</span><span class="token punctuation">;</span>        pxQueue<span class="token operator">-></span>cRxLock <span class="token operator">=</span> queueUNLOCKED<span class="token punctuation">;</span>        pxQueue<span class="token operator">-></span>cTxLock <span class="token operator">=</span> queueUNLOCKED<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> xNewQueue <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">listLIST_IS_EMPTY</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>xTasksWaitingToSend <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">xTaskRemoveFromEventList</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>xTasksWaitingToSend <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">!=</span> pdFALSE <span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token function">queueYIELD_IF_USING_PREEMPTION</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span>                <span class="token punctuation">{</span>                    <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* Ensure the event queues start in the correct state. */</span>            <span class="token function">vListInitialise</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>xTasksWaitingToSend <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">vListInitialise</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>xTasksWaitingToReceive <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">taskEXIT_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> pdPASS<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化完成之后，为了让大家理解，消息队列是怎么样的，就给出一个示意图，黄色部分是消息队列的控制块，而绿色部分则是消息队列的存放消息的地方，在创建的时候，我们知道的消息队列长度与单个消息空间大小。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181203194804553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppZWppZW1jdQ==,size_16,color_FFFFFF,t_70" alt="此图截自野火FreeRTOS书籍"></p><h3 id="消息队列发送"><a href="#消息队列发送" class="headerlink" title="消息队列发送"></a>消息队列发送</h3><p>任务或者中断服务程序都可以给消息队列发送消息，当发送消息时，如果队列未满或者允许覆盖入队， FreeRTOS 会将消息拷贝到消息队列队尾，否则，会根据用户指定的阻塞超时时间进行阻塞，在这段时间中，如果队列一直不允许入队，该任务将保持阻塞状态以等待队列允许入队。当其它任务从其等待的队列中读取入了数据（队列未满），该任务将自动由阻塞态转为就绪态。当任务等待的时间超过了指定的阻塞时间，即使队列中还不允许入队，任务也会自动从阻塞态转移为就绪态，此时发送消息的任务或者中断程序会收到一个错误码 errQUEUE_FULL。<br>发送紧急消息的过程与发送消息几乎一样，唯一的不同是，当发送紧急消息时，发送的位置是消息队列队头而非队尾，这样，接收者就能够优先接收到紧急消息，从而及时进行消息处理。<br>下面是消息队列的发送API接口，函数中有FromISR则表明在中断中使用的。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181203195147150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppZWppZW1jdQ==,size_16,color_FFFFFF,t_70" alt="消息队列入队（发送）的API接口"></p><pre class="line-numbers language-c"><code class="language-c"><span class="token number">1</span> <span class="token comment" spellcheck="true">/*-----------------------------------------------------------*/</span> <span class="token number">2</span> BaseType_t <span class="token function">xQueueGenericSend</span><span class="token punctuation">(</span> QueueHandle_t xQueue<span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>     <span class="token number">3</span>                               <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">const</span> pvItemToQueue<span class="token punctuation">,</span>     <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">4</span>                               TickType_t xTicksToWait<span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">5</span>                               <span class="token keyword">const</span> BaseType_t xCopyPosition <span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">6</span> <span class="token punctuation">{</span> <span class="token number">7</span>     BaseType_t xEntryTimeSet <span class="token operator">=</span> pdFALSE<span class="token punctuation">,</span> xYieldRequired<span class="token punctuation">;</span> <span class="token number">8</span>     TimeOut_t xTimeOut<span class="token punctuation">;</span> <span class="token number">9</span>     Queue_t <span class="token operator">*</span> <span class="token keyword">const</span> pxQueue <span class="token operator">=</span> <span class="token punctuation">(</span> Queue_t <span class="token operator">*</span> <span class="token punctuation">)</span> xQueue<span class="token punctuation">;</span><span class="token number">10</span> <span class="token number">11</span>     <span class="token comment" spellcheck="true">/* 已删除一些断言操作 */</span><span class="token number">12</span> <span class="token number">13</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">14</span>         <span class="token function">taskENTER_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token number">15</span>         <span class="token punctuation">{</span><span class="token number">16</span>             <span class="token comment" spellcheck="true">/* 队列未满 */</span><span class="token number">17</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>uxMessagesWaiting <span class="token operator">&lt;</span> pxQueue<span class="token operator">-></span>uxLength <span class="token punctuation">)</span><span class="token number">18</span>                  <span class="token operator">||</span> <span class="token punctuation">(</span> xCopyPosition <span class="token operator">==</span> queueOVERWRITE <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>    <span class="token number">19</span>                 <span class="token function">traceQUEUE_SEND</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">20</span>                 xYieldRequired <span class="token operator">=</span><span class="token number">21</span>           <span class="token function">prvCopyDataToQueue</span><span class="token punctuation">(</span> pxQueue<span class="token punctuation">,</span> pvItemToQueue<span class="token punctuation">,</span> xCopyPosition <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token number">22</span> <span class="token number">23</span>                 <span class="token comment" spellcheck="true">/* 已删除使用队列集部分代码 */</span><span class="token number">24</span>                 <span class="token comment" spellcheck="true">/* 如果有任务在等待获取此消息队列 */</span><span class="token number">25</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">listLIST_IS_EMPTY</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>pxQueue<span class="token operator">-></span>xTasksWaitingToReceive<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span>pdFALSE<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token number">26</span>                     <span class="token comment" spellcheck="true">/* 将任务从阻塞中恢复 */</span><span class="token number">27</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">xTaskRemoveFromEventList</span><span class="token punctuation">(</span><span class="token number">28</span>                   <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>xTasksWaitingToReceive <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">!=</span>pdFALSE<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token number">29</span>                         <span class="token comment" spellcheck="true">/* 如果恢复的任务优先级比当前运行任务优先级还高，30                         那么需要进行一次任务切换 */</span><span class="token number">31</span>                         <span class="token function">queueYIELD_IF_USING_PREEMPTION</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token number">32</span>                     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">33</span>                         <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">34</span>                     <span class="token punctuation">}</span><span class="token number">35</span>                 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> xYieldRequired <span class="token operator">!=</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">36</span>                     <span class="token comment" spellcheck="true">/* 如果没有等待的任务，拷贝成功也需要任务切换 */</span><span class="token number">37</span>                     <span class="token function">queueYIELD_IF_USING_PREEMPTION</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token number">38</span>                 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">39</span>                     <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">40</span>                 <span class="token punctuation">}</span><span class="token number">41</span> <span class="token number">42</span>                 <span class="token function">taskEXIT_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token number">43</span>                 <span class="token keyword">return</span> pdPASS<span class="token punctuation">;</span><span class="token number">44</span>             <span class="token punctuation">}</span><span class="token number">45</span>             <span class="token comment" spellcheck="true">/* 队列已满 */</span><span class="token number">46</span>             <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token number">47</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span> xTicksToWait <span class="token operator">==</span> <span class="token punctuation">(</span> TickType_t <span class="token punctuation">)</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">48</span>                     <span class="token comment" spellcheck="true">/* 如果用户不指定阻塞超时时间，退出 */</span><span class="token number">49</span>                     <span class="token function">taskEXIT_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">)</span><span class="token number">50</span>                     <span class="token function">traceQUEUE_SEND_FAILED</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">51</span>                     <span class="token keyword">return</span> errQUEUE_FULL<span class="token punctuation">;</span><span class="token number">52</span>                 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> xEntryTimeSet <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token number">53</span>                     <span class="token comment" spellcheck="true">/* 初始化阻塞超时结构体变量，初始化进入54                 阻塞的时间xTickCount和溢出次数xNumOfOverflows */</span><span class="token number">55</span>                     <span class="token function">vTaskSetTimeOutState</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>xTimeOut <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token number">56</span>                     xEntryTimeSet <span class="token operator">=</span> pdTRUE<span class="token punctuation">;</span><span class="token number">57</span>                 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">58</span>                     <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">59</span>                 <span class="token punctuation">}</span><span class="token number">60</span>             <span class="token punctuation">}</span><span class="token number">61</span>         <span class="token punctuation">}</span><span class="token number">62</span>         <span class="token function">taskEXIT_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token number">63</span>         <span class="token comment" spellcheck="true">/* 挂起调度器 */</span><span class="token number">64</span>         <span class="token function">vTaskSuspendAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">65</span>         <span class="token comment" spellcheck="true">/* 队列上锁 */</span><span class="token number">66</span>         <span class="token function">prvLockQueue</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">67</span> <span class="token number">68</span>         <span class="token comment" spellcheck="true">/* 检查超时时间是否已经过去了 */</span><span class="token number">69</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">xTaskCheckForTimeOut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>xTimeOut<span class="token punctuation">,</span> <span class="token operator">&amp;</span>xTicksToWait<span class="token punctuation">)</span><span class="token operator">==</span>pdFALSE<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">(</span><span class="token number">17</span><span class="token punctuation">)</span><span class="token number">70</span>             <span class="token comment" spellcheck="true">/* 如果队列还是满的 */</span><span class="token number">71</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">prvIsQueueFull</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span> <span class="token operator">!=</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span>    <span class="token number">72</span>                 <span class="token function">traceBLOCKING_ON_QUEUE_SEND</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token number">73</span>                 <span class="token comment" spellcheck="true">/* 将当前任务添加到队列的等待发送列表中74                    以及阻塞延时列表，延时时间为用户指定的超时时间xTicksToWait */</span><span class="token number">75</span>                 <span class="token function">vTaskPlaceOnEventList</span><span class="token punctuation">(</span><span class="token number">76</span>                    <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>xTasksWaitingToSend <span class="token punctuation">)</span><span class="token punctuation">,</span> xTicksToWait <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">)</span><span class="token number">77</span>                 <span class="token comment" spellcheck="true">/* 队列解锁 */</span><span class="token number">78</span>                 <span class="token function">prvUnlockQueue</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token number">79</span> <span class="token number">80</span>                 <span class="token comment" spellcheck="true">/* 恢复调度器 */</span><span class="token number">81</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">xTaskResumeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">82</span>                     <span class="token function">portYIELD_WITHIN_API</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">83</span>                 <span class="token punctuation">}</span><span class="token number">84</span>             <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">85</span>                 <span class="token comment" spellcheck="true">/* 队列有空闲消息空间，允许入队 */</span><span class="token number">86</span>                 <span class="token function">prvUnlockQueue</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token function">87</span>                 <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span> <span class="token function">xTaskResumeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">88</span>             <span class="token punctuation">}</span><span class="token number">89</span>         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">90</span>             <span class="token comment" spellcheck="true">/* 超时时间已过，退出 */</span><span class="token number">91</span>             <span class="token function">prvUnlockQueue</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token function">92</span>             <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span> <span class="token function">xTaskResumeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">93</span> <span class="token number">94</span>             <span class="token function">traceQUEUE_SEND_FAILED</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">95</span>             <span class="token keyword">return</span> errQUEUE_FULL<span class="token punctuation">;</span><span class="token number">96</span>         <span class="token punctuation">}</span><span class="token number">97</span>     <span class="token punctuation">}</span><span class="token number">98</span> <span class="token punctuation">}</span><span class="token number">99</span> <span class="token comment" spellcheck="true">/*-----------------------------------------------------------*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果阻塞时间不为 0，任务会因为等待入队而进入阻塞， 在将任务设置为阻塞的过程中， 系统不希望有其它任务和中断操作这个队列的 xTasksWaitingToReceive 列表和 xTasksWaitingToSend 列表，因为可能引起其它任务解除阻塞，这可能会发生优先级翻转。比如任务 A 的优先级低于当前任务，但是在当前任务进入阻塞的过程中，任务 A 却因为其它原因解除阻塞了，这显然是要绝对禁止的。因此FreeRTOS 使用挂起调度器禁止其它任务操作队列，因为挂起调度器意味着任务不能切换并且不准调用可能引起任务切换的 API 函数。但挂起调度器并不会禁止中断，中断服务函数仍然可以操作队列事件列表，可能会解除任务阻塞、可能会进行上下文切换，这也是不允许的。于是，解决办法是不但挂起调度器，还要给队列上锁，禁止任何中断来操作队列。<br>再借用朱工精心制作的流程图加以理解：图片出自：<a href="https://blog.csdn.net/zhzht19861011/article/details/51510384" target="_blank" rel="noopener">https://blog.csdn.net/zhzht19861011/article/details/51510384</a><br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181203200214963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppZWppZW1jdQ==,size_16,color_FFFFFF,t_70" alt="消息队列入队流程"></p><p>消息队列出队的API函数接口：<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181203200731899.png" alt=""><br>消息队列出队过程分析，其实跟入队差不多，请看注释：</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token number">1</span> <span class="token comment" spellcheck="true">/*-----------------------------------------------------------*/</span> <span class="token number">2</span> BaseType_t <span class="token function">xQueueGenericReceive</span><span class="token punctuation">(</span> QueueHandle_t xQueue<span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>     <span class="token number">3</span>                                  <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">const</span> pvBuffer<span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">4</span>                                  TickType_t xTicksToWait<span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>     <span class="token number">5</span>                                  <span class="token keyword">const</span> BaseType_t xJustPeeking <span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">6</span> <span class="token punctuation">{</span> <span class="token number">7</span>     BaseType_t xEntryTimeSet <span class="token operator">=</span> pdFALSE<span class="token punctuation">;</span> <span class="token number">8</span>     TimeOut_t xTimeOut<span class="token punctuation">;</span> <span class="token number">9</span>     int8_t <span class="token operator">*</span>pcOriginalReadPosition<span class="token punctuation">;</span><span class="token number">10</span>     Queue_t <span class="token operator">*</span> <span class="token keyword">const</span> pxQueue <span class="token operator">=</span> <span class="token punctuation">(</span> Queue_t <span class="token operator">*</span> <span class="token punctuation">)</span> xQueue<span class="token punctuation">;</span><span class="token number">11</span> <span class="token number">12</span>     <span class="token comment" spellcheck="true">/* 已删除一些断言 */</span><span class="token number">13</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">14</span>         <span class="token function">taskENTER_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token number">15</span>         <span class="token punctuation">{</span><span class="token number">16</span>             <span class="token keyword">const</span> UBaseType_t uxMessagesWaiting <span class="token operator">=</span> pxQueue<span class="token operator">-></span>uxMessagesWaiting<span class="token punctuation">;</span> <span class="token number">17</span> <span class="token number">18</span>             <span class="token comment" spellcheck="true">/* 看看队列中有没有消息 */</span><span class="token number">19</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span> uxMessagesWaiting <span class="token operator">></span> <span class="token punctuation">(</span> UBaseType_t <span class="token punctuation">)</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>    <span class="token number">20</span>                 <span class="token comment" spellcheck="true">/*防止仅仅是读取消息，而不进行消息出队操作*/</span><span class="token number">21</span>                 pcOriginalReadPosition <span class="token operator">=</span> pxQueue<span class="token operator">-></span>u<span class="token punctuation">.</span>pcReadFrom<span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token number">22</span>                 <span class="token comment" spellcheck="true">/* 拷贝消息到用户指定存放区域pvBuffer */</span><span class="token number">23</span>                 <span class="token function">prvCopyDataFromQueue</span><span class="token punctuation">(</span> pxQueue<span class="token punctuation">,</span> pvBuffer <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token number">24</span> <span class="token number">25</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span> xJustPeeking <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token number">26</span>                     <span class="token comment" spellcheck="true">/* 读取消息并且消息出队 */</span><span class="token number">27</span>                     <span class="token function">traceQUEUE_RECEIVE</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token number">28</span> <span class="token number">29</span>                     <span class="token comment" spellcheck="true">/* 获取了消息，当前消息队列的消息个数需要减一 */</span><span class="token number">30</span>                     pxQueue<span class="token operator">-></span>uxMessagesWaiting <span class="token operator">=</span> uxMessagesWaiting <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token number">31</span>                     <span class="token comment" spellcheck="true">/* 判断一下消息队列中是否有等待发送消息的任务 */</span><span class="token number">32</span>                     <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">listLIST_IS_EMPTY</span><span class="token punctuation">(</span>            <span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token number">33</span>                              <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>xTasksWaitingToSend <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">34</span>                         <span class="token comment" spellcheck="true">/* 将任务从阻塞中恢复 */</span><span class="token number">35</span>                         <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">xTaskRemoveFromEventList</span><span class="token punctuation">(</span>        <span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token number">36</span>                                  <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>xTasksWaitingToSend <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">!=</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">37</span>                             <span class="token comment" spellcheck="true">/* 如果被恢复的任务优先级比当前任务高，会进行一次任务切换 */</span><span class="token number">38</span>                             <span class="token function">queueYIELD_IF_USING_PREEMPTION</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token number">39</span>                         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">40</span>                             <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">41</span>                         <span class="token punctuation">}</span><span class="token number">42</span>                     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">43</span>                         <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">44</span>                     <span class="token punctuation">}</span><span class="token number">45</span>                 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">)</span><span class="token number">46</span>                     <span class="token comment" spellcheck="true">/* 任务只是看一下消息（peek），并不出队 */</span>    <span class="token number">47</span>                     <span class="token function">traceQUEUE_PEEK</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">48</span> <span class="token number">49</span>                     <span class="token comment" spellcheck="true">/* 因为是只读消息 所以还要还原读消息位置指针 */</span><span class="token number">50</span>                     pxQueue<span class="token operator">-></span>u<span class="token punctuation">.</span>pcReadFrom <span class="token operator">=</span> pcOriginalReadPosition<span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token number">51</span> <span class="token number">52</span>                     <span class="token comment" spellcheck="true">/* 判断一下消息队列中是否还有等待获取消息的任务 */</span><span class="token number">53</span>                     <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">listLIST_IS_EMPTY</span><span class="token punctuation">(</span>            <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token number">54</span>                              <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>xTasksWaitingToReceive <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">55</span>                         <span class="token comment" spellcheck="true">/* 将任务从阻塞中恢复 */</span><span class="token number">56</span>                         <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">xTaskRemoveFromEventList</span><span class="token punctuation">(</span>            <span class="token number">57</span>                               <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>xTasksWaitingToReceive <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">!=</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">58</span>                             <span class="token comment" spellcheck="true">/* 如果被恢复的任务优先级比当前任务高，会进行一次任务切换 */</span><span class="token number">59</span>                             <span class="token function">queueYIELD_IF_USING_PREEMPTION</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token number">60</span>                         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">61</span>                             <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">62</span>                         <span class="token punctuation">}</span><span class="token number">63</span>                     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">64</span>                         <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">65</span>                     <span class="token punctuation">}</span><span class="token number">66</span>                 <span class="token punctuation">}</span><span class="token number">67</span> <span class="token number">68</span>                 <span class="token function">taskEXIT_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">(</span><span class="token number">17</span><span class="token punctuation">)</span><span class="token number">69</span>                 <span class="token keyword">return</span> pdPASS<span class="token punctuation">;</span><span class="token number">70</span>             <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token number">71</span>                 <span class="token comment" spellcheck="true">/* 消息队列中没有消息可读 */</span><span class="token number">72</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span> xTicksToWait <span class="token operator">==</span> <span class="token punctuation">(</span> TickType_t <span class="token punctuation">)</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">)</span>    <span class="token number">73</span>                     <span class="token comment" spellcheck="true">/* 不等待，直接返回 */</span><span class="token number">74</span>                     <span class="token function">taskEXIT_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">75</span>                     <span class="token function">traceQUEUE_RECEIVE_FAILED</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">76</span>                     <span class="token keyword">return</span> errQUEUE_EMPTY<span class="token punctuation">;</span><span class="token number">77</span>                 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> xEntryTimeSet <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token number">78</span>                     <span class="token comment" spellcheck="true">/* 初始化阻塞超时结构体变量，初始化进入79                     阻塞的时间xTickCount和溢出次数xNumOfOverflows */</span><span class="token number">80</span>                     <span class="token function">vTaskSetTimeOutState</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>xTimeOut <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token number">81</span>                     xEntryTimeSet <span class="token operator">=</span> pdTRUE<span class="token punctuation">;</span><span class="token number">82</span>                 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">83</span>                     <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">84</span>                 <span class="token punctuation">}</span><span class="token number">85</span>             <span class="token punctuation">}</span><span class="token number">86</span>         <span class="token punctuation">}</span><span class="token number">87</span>         <span class="token function">taskEXIT_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token number">88</span> <span class="token number">89</span>         <span class="token function">vTaskSuspendAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">90</span>         <span class="token function">prvLockQueue</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token number">91</span> <span class="token number">92</span>         <span class="token comment" spellcheck="true">/* 检查超时时间是否已经过去了*/</span><span class="token number">93</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">xTaskCheckForTimeOut</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>xTimeOut<span class="token punctuation">,</span> <span class="token operator">&amp;</span>xTicksToWait <span class="token punctuation">)</span> <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token number">94</span>             <span class="token comment" spellcheck="true">/* 如果队列还是空的 */</span><span class="token number">95</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">prvIsQueueEmpty</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span> <span class="token operator">!=</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">96</span>                 <span class="token function">traceBLOCKING_ON_QUEUE_RECEIVE</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">)</span>    <span class="token number">97</span>                 <span class="token comment" spellcheck="true">/* 将当前任务添加到队列的等待接收列表中98                    以及阻塞延时列表，阻塞时间为用户指定的超时时间xTicksToWait */</span><span class="token number">99</span>                 <span class="token function">vTaskPlaceOnEventList</span><span class="token punctuation">(</span>                <span class="token number">100</span>                     <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>xTasksWaitingToReceive <span class="token punctuation">)</span><span class="token punctuation">,</span> xTicksToWait <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">101</span>                 <span class="token function">prvUnlockQueue</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">102</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">xTaskResumeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token number">103</span>                     <span class="token comment" spellcheck="true">/* 如果有任务优先级比当前任务高，会进行一次任务切换 */</span><span class="token number">104</span>                     <span class="token function">portYIELD_WITHIN_API</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token number">105</span>                 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">106</span>                     <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">107</span>                 <span class="token punctuation">}</span><span class="token number">108</span>             <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">109</span>                 <span class="token comment" spellcheck="true">/* 如果队列有消息了，就再试一次获取消息 */</span><span class="token number">110</span>                 <span class="token function">prvUnlockQueue</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token function">111</span>                 <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span> <span class="token function">xTaskResumeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">112</span>             <span class="token punctuation">}</span><span class="token number">113</span>         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">114</span>             <span class="token comment" spellcheck="true">/* 超时时间已过，退出 */</span><span class="token number">115</span>             <span class="token function">prvUnlockQueue</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token function">116</span>             <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span> <span class="token function">xTaskResumeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">117</span> <span class="token number">118</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">prvIsQueueEmpty</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span> <span class="token operator">!=</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">119</span>                 <span class="token comment" spellcheck="true">/* 如果队列还是空的，返回错误代码errQUEUE_EMPTY */</span><span class="token number">120</span>                 <span class="token function">traceQUEUE_RECEIVE_FAILED</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">121</span>                 <span class="token keyword">return</span> errQUEUE_EMPTY<span class="token punctuation">;</span>                <span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">)</span><span class="token number">122</span>             <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">123</span>                 <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">124</span>             <span class="token punctuation">}</span><span class="token number">125</span>         <span class="token punctuation">}</span><span class="token number">126</span>     <span class="token punctuation">}</span><span class="token number">127</span> <span class="token punctuation">}</span><span class="token number">128</span> <span class="token comment" spellcheck="true">/*-----------------------------------------------------------*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS优化与错误排查方法</title>
      <link href="/freertos-9/"/>
      <url>/freertos-9/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>主要是为刚接触 FreeRTOS 的用户指出那些新手通常容易遇到的问题。这里把最主要的篇幅放在栈溢出以及栈溢出j检测上，因为栈相关的问题是初学者遇到最多的问题。</p><h3 id="printf-stdarg-c"><a href="#printf-stdarg-c" class="headerlink" title="printf-stdarg.c"></a>printf-stdarg.c</h3><p>当调用 <strong>C  标准库</strong> 的函数时，栈空间使用量可能会急剧上升，特别是 IO 与字符串处理函数，比如 sprintf()、printf()等。在 FreeRTOS 源码包中有一个名为 <strong>printf-stdarg.c</strong> 的文件。这个文件实现了一个栈效率优化版的小型 sprintf()、printf()，可以用来代替标准 C 库函数版本。在大多数情况下，这样做可以使得调用 sprintf()及相关函数的任务对栈空间的需求量小很多。<br>可能很多人都不知道freertos中有这样子的一个文件，它放在第三方资料中，路径为“<strong>FreeRTOSv9.0.0\FreeRTOS-Plus\Demo\FreeRTOS_Plus_UDP_and_CLI_LPC1830_GCC</strong>”，我们发布工程的时候就无需依赖 <strong>C 标准库</strong>，这样子就能减少栈的使用，能优化不少空间。<br>该文件源码（部分）：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">print</span><span class="token punctuation">(</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>out<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> va_list args <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">register</span> <span class="token keyword">int</span> width<span class="token punctuation">,</span> pad<span class="token punctuation">;</span>    <span class="token keyword">register</span> <span class="token keyword">int</span> pc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> scr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token operator">*</span>format <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">++</span>format<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'%'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token operator">++</span>format<span class="token punctuation">;</span>            width <span class="token operator">=</span> pad <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'\0'</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'%'</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> out<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token operator">++</span>format<span class="token punctuation">;</span>                pad <span class="token operator">=</span> PAD_RIGHT<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token operator">++</span>format<span class="token punctuation">;</span>                pad <span class="token operator">|</span><span class="token operator">=</span> PAD_ZERO<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> <span class="token operator">*</span>format <span class="token operator">>=</span> <span class="token string">'0'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>format <span class="token operator">&lt;=</span> <span class="token string">'9'</span><span class="token punctuation">;</span> <span class="token operator">++</span>format<span class="token punctuation">)</span> <span class="token punctuation">{</span>                width <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>                width <span class="token operator">+</span><span class="token operator">=</span> <span class="token operator">*</span>format <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'s'</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">register</span> <span class="token keyword">char</span> <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">va_arg</span><span class="token punctuation">(</span> args<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>                pc <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">prints</span> <span class="token punctuation">(</span>out<span class="token punctuation">,</span> s<span class="token operator">?</span>s<span class="token punctuation">:</span><span class="token string">"(null)"</span><span class="token punctuation">,</span> width<span class="token punctuation">,</span> pad<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'d'</span> <span class="token operator">||</span> <span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'i'</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>                pc <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">printi</span> <span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token function">va_arg</span><span class="token punctuation">(</span> args<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> width<span class="token punctuation">,</span> pad<span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'x'</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>                pc <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">printi</span> <span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token function">va_arg</span><span class="token punctuation">(</span> args<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> width<span class="token punctuation">,</span> pad<span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'X'</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>                pc <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">printi</span> <span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token function">va_arg</span><span class="token punctuation">(</span> args<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> width<span class="token punctuation">,</span> pad<span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'u'</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>                pc <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">printi</span> <span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token function">va_arg</span><span class="token punctuation">(</span> args<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> width<span class="token punctuation">,</span> pad<span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'c'</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/* char are converted to int then pushed on the stack */</span>                scr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token function">va_arg</span><span class="token punctuation">(</span> args<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>                scr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>                pc <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">prints</span> <span class="token punctuation">(</span>out<span class="token punctuation">,</span> scr<span class="token punctuation">,</span> width<span class="token punctuation">,</span> pad<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>        out<span class="token punctuation">:</span>            <span class="token function">printchar</span> <span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token operator">*</span>format<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>pc<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>out<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token operator">*</span>out <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>    <span class="token function">va_end</span><span class="token punctuation">(</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> pc<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    va_list args<span class="token punctuation">;</span>    <span class="token function">va_start</span><span class="token punctuation">(</span> args<span class="token punctuation">,</span> format <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">print</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span> format<span class="token punctuation">,</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">sprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>out<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    va_list args<span class="token punctuation">;</span>    <span class="token function">va_start</span><span class="token punctuation">(</span> args<span class="token punctuation">,</span> format <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">print</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>out<span class="token punctuation">,</span> format<span class="token punctuation">,</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">snprintf</span><span class="token punctuation">(</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> count<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    va_list args<span class="token punctuation">;</span>    <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span> count<span class="token punctuation">;</span>    <span class="token function">va_start</span><span class="token punctuation">(</span> args<span class="token punctuation">,</span> format <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">print</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> format<span class="token punctuation">,</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用的例子与 C 标准库基本一样：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token string">"Hello world!"</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>np <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> bs <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mi<span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    mi <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>bs<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"printf test\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s is null pointer\n"</span><span class="token punctuation">,</span> np<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d = 5\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d = - max int\n"</span><span class="token punctuation">,</span> mi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"char %c = 'a'\n"</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hex %x = ff\n"</span><span class="token punctuation">,</span> <span class="token number">0xff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hex %02x = 00\n"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"signed %d = unsigned %u = hex %x\n"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %s(s)%"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %s(s) with %%\n"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"justif: \"%-10s\"\n"</span><span class="token punctuation">,</span> <span class="token string">"left"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"justif: \"%10s\"\n"</span><span class="token punctuation">,</span> <span class="token string">"right"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">" 3: %04d zero padded\n"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">" 3: %-4d left justif.\n"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">" 3: %4d right justif.\n"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"-3: %04d zero padded\n"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"-3: %-4d left justif.\n"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"-3: %4d right justif.\n"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="栈计算"><a href="#栈计算" class="headerlink" title="栈计算"></a>栈计算</h3><p>每个任务都独立维护自己的栈空间， 任务栈空间总量在任务创建时进行设定。<code>uxTaskGetStackHighWaterMark()</code>主要用来查询指定任务的运行历史中， 其栈空间还差多少就要溢出。这个值被称为栈空间的<strong>High Water Mark</strong>。<br><strong>函数原型：</strong></p><pre><code>UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )</code></pre><p> 想要使用它，需要将对应的宏定义打开：<code>INCLUDE_uxTaskGetStackHighWaterMark</code></p><p><strong>函数描述：</strong><br>|参数|说明|<br>|–|–|<br>| xTask  | 被查询任务的句柄如果传入 NULL 句柄，则任务查询的是自身栈空间的高水线 |<br>| 返回值| 任务栈空间的实际使用量会随着任务执行和中断处理过程上下浮动。uxTaskGetStackHighWaterMark()返回从任务启动执行开始的运行历史中，栈空间具有的最小剩余量。这个值即是栈空间使用达到最深时的剩下的未使用的栈空间。这个值越是接近 0，则这个任务就越是离栈溢出不远。|</p><p>如果不知道怎么计算任务栈大小，就使用这个函数进行统计一下，然后将任务运行时最大的栈空间作为任务栈空间的80%大小即可。即假设统计得到的任务栈大小为常量 <strong>A</strong> ，那么在创建线程的时候需要 <strong>X</strong> 大小的空间，那么 <strong>X * 80% = A</strong>，算到的 <strong>X</strong> 作为任务栈大小就差不多了。</p><h3 id="运行时栈检测"><a href="#运行时栈检测" class="headerlink" title="运行时栈检测"></a>运行时栈检测</h3><p>FreeRTOS 包含两种运行时栈j检测机制，由 FreeRTOSConfig.h 中的配置常量configCHECK_FOR_STACK_OVERFLOW 进行控制。这两种方式都会增加上下切换开销。</p><p>栈溢出钩子函数(或称回调函数)由内核在j检测到栈溢出时调用。要使用栈溢出钩子函数，需要进行以下配置：</p><ul><li>在 FreeRTOSConfig.h 中把 configCHECK_FOR_STACK_OVERFLOW 设为 <strong>1</strong> 或者 <strong>2</strong>  。</li><li>提供钩子函数的具体实现，采用下面所示的函数名和函数原型。</li></ul><pre><code>void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed portCHAR *pcTaskName );</code></pre><p>补充说明：</p><ul><li>栈溢出钩子函数只是为了使跟踪调试栈空间错误更容易，而无法在栈溢出时对其进行恢复。函数的入口参数传入了任务句柄和任务名，但任务名很可能在溢出时已经遭到破坏。</li><li>栈溢出钩子函数还可以在中断的上下文中进行调用</li><li>某些微控制器在检测到内存访问错误时会产生错误异常，很可能在内核调用栈溢出钩子函数之前就触发了错误异常中断。</li></ul><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>当 <code>configCHECK_FOR_STACK_OVERFLOW</code> 设置为 <strong>1</strong> 时选用方法 <strong>1</strong>。<br>任务被交换出去的时候，该任务的整个上下文被保存到它自己的栈空间中。这时任务栈的使用应当达到了一个峰值。当 <code>configCHECK_FOR_STACK_OVERFLOW</code> 设为<strong>1</strong> 时，内核会在任务上下文保存后检查栈指针是否还指向有效栈空间。一旦检测到栈指针的指向已经超出任务栈的有效范围，栈溢出钩子函数就会被调用。<br>方法 1 具有较快的执行速度，但栈溢出有可能发生在两次上下文保存之间，这种情况不会被检测到，因为这种检测方式仅在任务切换中检测。</p><h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>将 <code>configCHECK_FOR_STACK_OVERFLOW</code> 设为 <strong>2</strong> 就可以选用方法 <strong>2</strong>。方法 <strong>2</strong>在方法 1 的基础上进行了一些补充。<br>当创建任务时，任务栈空间中就预置了一个标记。方法 <strong>2</strong> 会检查任务栈的最后 <strong>20个字节</strong>的数据，查看预置在这里的标记数据是否被覆盖。如果最后 <strong>20 个字节的标记数据</strong>与预设值不同，则栈溢出钩子函数就会被调用。<br>方法 <strong>2</strong> 没有方法 <strong>1</strong> 的执行速度快，但测试仅仅 20 个字节相对来说也是很快的。这种方法应该可以j检测到任何时候发生的栈溢出，虽然理论上还是有可能漏掉一些情况，但这些情况几乎是不可能发生的。</p><h3 id="其它常见错误"><a href="#其它常见错误" class="headerlink" title="其它常见错误"></a>其它常见错误</h3><blockquote><p>在一个 Demo 应用程序中增加了一个简单的任务，导致应用程序崩溃</p></blockquote><p>可能的情况：</p><ol><li>任务创建时需要在内存堆中分配空间。许多 Demo 应用程序定义的<strong>堆空间</strong>大小只够用于创建 Demo 任务——所以当任务创建完成后，就没有足够的剩余空间来增加其它的<strong>任务，队列或信号量</strong>。</li><li>空闲任务是在 <code>vTaskStartScheduler()</code>调用中自动创建的。如果由于内存不足而无法创建空闲任务，<code>vTaskStartScheduler()</code>会直接返回。所以一般在调用 <code>vTaskStartScheduler()</code>后加上一条空循环<code>for(;;) / while(1)</code>可以使这种错误更加容易调试。</li></ol><p><strong>如果要添加更多的任务，可以增加内存堆空间大小（修改配置文件），或是删掉一些已存在的 Demo任务。</strong></p><blockquote><p>在中断中调用一个 API 函数，导致应用程序崩溃</p></blockquote><h4 id="需要做的第一件事是检查中断是否导致了栈溢出。"><a href="#需要做的第一件事是检查中断是否导致了栈溢出。" class="headerlink" title="需要做的第一件事是检查中断是否导致了栈溢出。"></a>需要做的第一件事是检查中断是否导致了栈溢出。</h4><p><strong>然后检查API接口是否正确</strong>，除了具有后缀为<code>FromISR</code>函数名的 API 函数，千万不要在中断服务程序中调用其它 API 函数。</p><p><strong>除此之外，还需要注意中断的优先级：</strong><br><code>FreeRTOSConfig.h</code>文件中可以配置系统可管理的最高中断优先级数值，宏定义<code>configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</code>是用于配置basepri寄存器的，当basepri设置为某个值的时候，会让系统不响应比该优先级低的中断，而优先级比之更高的中断则不受影响。就是说当这个宏定义配置为<strong>5</strong>的时候，中断优先级数值在<strong>0、1、2、3、4</strong>的这些中断是不受FreeRTOS管理的，不可被屏蔽，<strong>同时也不能调用FreeRTOS中的API函数接口</strong>，而中断优先级在5到15的这些中断是受到系统管理，可以被屏蔽的，也可以调用FreeRTOS中的API函数接口。</p><blockquote><p>临界区无法正确嵌套</p></blockquote><p>除了 taskENTER_CRITICA()和 taskEXIT_CRITICAL()，千万不要在其它地方修改控制器的中断使能位或优先级标志。这两个宏维护了一个嵌套深度计数，所以只有当所有的嵌套调用都退出后计数值才会为 0，也才会使能中断。</p><blockquote><p>在调度器启动前应用程序就崩溃了</p></blockquote><p>这个问题我也会遇到，如果一个中断会产生上下文切换，则这个中断不能在调度器启动之前使能。这同样适用于那些需要读写队列或信号量的中断。在调度器启动之前，不能进行上下文切换。<br>还有一些 API 函数不能在调度器启动之前调用。在调用 vTaskStartScheduler()之前，最好是限定只使用创建任务，队列和信号量的 API 函数。<br>比如有一些初始化需要中断的，或者在初始化完成的时候回产生一个中断，这些驱动的初始化最好放在一个任务中进行，我是这样子处理的，在<code>main</code>函数中创建一个任务，在任务中进行bsp初始化，然后再创建消息队列、信号量、互斥量、事件以及任务等操作。</p><blockquote><p>在调度器挂起时调用 API 函数，导致应用程序崩溃</p></blockquote><p>调用 vTaskSuspendAll()使得调度器挂起，而唤醒调度器调用 xTaskResumeAll()。千万不要在调度器挂起时调用其它 API 函数。</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超详细的FreeRTOS移植全教程——基于srm32</title>
      <link href="/freertos-8/"/>
      <url>/freertos-8/</url>
      
        <content type="html"><![CDATA[<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>在移植之前，我们首先要获取到FreeRTOS的官方的源码包。这里我们提供两个下载链接:</p><blockquote><p>一个是官网：<a href="http://www.freertos.org/" target="_blank" rel="noopener">http://www.freertos.org/</a><br>另外一个是代码托管网站：<a href="https://sourceforge.net/projects/freertos/files/FreeRTOS/" target="_blank" rel="noopener">https://sourceforge.net/projects/freertos/files/FreeRTOS/</a></p></blockquote><p>这里我们演示如何在代码托管网站里面下载。打开网站链接之后，我们选择FreeRTOS的最新版本V9.0.0（2016年），尽管现在FreeRTOS的版本已经更新到V10.0.1了，但是我们还是选择V9.0.0，因为内核很稳定，并且网上资料很多，因为V10.0.0版本之后是亚马逊收购了FreeRTOS之后才出来的版本，主要添加了一些云端组件，我们本书所讲的FreeRTOS是实时内核，采用V9.0.0版本足以。</p><h3 id="简单介绍FreeRTOS"><a href="#简单介绍FreeRTOS" class="headerlink" title="简单介绍FreeRTOS"></a>简单介绍FreeRTOS</h3><p>FreeRTOS包含Demo例程和内核源码（比较重要，我们就需要提取该目录下的大部分文件）。<br> <strong>Source</strong>文件夹里面包含的是FreeRTOS内核的源代码，我们移植FreeRTOS的时候就需要这部分源代码；<br><strong>Demo</strong> 文件夹里面包含了FreeRTOS官方为各个单片机移植好的工程代码，FreeRTOS为了推广自己，会给各种半导体厂商的评估板写好完整的工程程序，这些程序就放在Demo这个目录下，这部分Demo非常有参考价值。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190130131602356.png" alt=""></p><h3 id="Source文件夹"><a href="#Source文件夹" class="headerlink" title="Source文件夹"></a>Source文件夹</h3><p>这里我们再重点分析下FreeRTOS/ Source文件夹下的文件，①和③包含的是FreeRTOS的通用的头文件和C文件，这两部分的文件试用于各种编译器和处理器，是通用的。需要移植的头文件和C文件放在②portblle这个文件夹。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190130131521162.png" alt=""></p><p>portblle文件夹，是与编译器相关的文件夹，在不同的编译器中使用不同的支持文件。①中的KEIL就是我们就是我们使用的编译器，其实KEIL里面的内容跟RVDS里面的内容一样，所以我们只需要③RVDS文件夹里面的内容即可，里面包含了各种处理器相关的文件夹，从文件夹的名字我们就非常熟悉了，我们学习的STM32有M0、M3、M4等各种系列，FreeRTOS是一个软件，单片机是一个硬件，FreeRTOS要想运行在一个单片机上面，它们就必须关联在一起。MemMang文件夹下存放的是跟内存管理相关的源文件。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190130131927278.png" alt=""></p><h3 id="移植过程"><a href="#移植过程" class="headerlink" title="移植过程"></a>移植过程</h3><h4 id="提取源码"><a href="#提取源码" class="headerlink" title="提取源码"></a>提取源码</h4><ol><li>首先在我们的STM32裸机工程模板根目录下新建一个文件夹，命名为“FreeRTOS”，并且在FreeRTOS文件夹下新建两个空文件夹，分别命名为“src”与“port”，src文件夹用于保存FreeRTOS中的核心源文件，也就是我们常说的‘.c文件’，port文件夹用于保存内存管理以及处理器架构相关代码，这些代码FreeRTOS官方已经提供给我们的，直接使用即可，在前面已经说了，FreeRTOS是软件，我们的开发版是硬件，软硬件必须有桥梁来连接，这些与处理器架构相关的代码，可以称之为RTOS硬件接口层，它们位于FreeRTOS/Source/Portable文件夹下。</li><li>打开FreeRTOS V9.0.0源码，在“FreeRTOSv9.0.0\FreeRTOS\Source”目录下找到所有的‘.c文件’，将它们拷贝到我们新建的src文件夹中，</li></ol><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190130133939483.png?" alt=""></p><ol start="3"><li>打开FreeRTOS V9.0.0源码，在“FreeRTOSv9.0.0\FreeRTOS\Source\portable”目录下找到“MemMang”文件夹与“RVDS”文件夹，将它们拷贝到我们新建的port文件夹中</li></ol><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190130134041761.png?" alt=""></p><ol start="4"><li>打开FreeRTOS V9.0.0源码，在“FreeRTOSv9.0.0\ FreeRTOS\Source”目录下找到“include”文件夹，它是我们需要用到FreeRTOS的一些头文件，将它直接拷贝到我们新建的FreeRTOS文件夹中，完成这一步之后就可以看到我们新建的FreeRTOS文件夹已经有3个文件夹，这3个文件夹就包含FreeRTOS的核心文件，至此，FreeRTOS的源码就提取完成。</li></ol><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190130134127226.png" alt=""></p><h4 id="添加到工程"><a href="#添加到工程" class="headerlink" title="添加到工程"></a>添加到工程</h4><p><strong>添加FreeRTOSConfig.h文件</strong><br>FreeRTOSConfig.h文件是FreeRTOS的工程配置文件，因为FreeRTOS是可以裁剪的实时操作内核，应用于不同的处理器平台，用户可以通过修改这个FreeRTOS内核的配置头文件来裁剪FreeRTOS的功能，所以我们把它拷贝一份放在user这个文件夹下面。<br>打开FreeRTOSv9.0.0源码，在“FreeRTOSv9.0.0\FreeRTOS\Demo”文件夹下面找到“CORTEX_STM32F103_Keil”这个文件夹，双击打开，在其根目录下找到这个“FreeRTOSConfig.h”文件，然后拷贝到我们工程的user文件夹下即可，等下我们需要对这个文件进行修改。</p><p><strong>创建工程分组</strong><br>接下来我们在mdk里面新建FreeRTOS/src和FreeRTOS/port两个组文件夹，其中FreeRTOS/src用于存放src文件夹的内容，FreeRTOS/port用于存放port\MemMang文件夹 与port\RVDS\ARM_CM3文件夹的内容。<br>然后我们将工程文件中FreeRTOS的内容添加到工程中去，按照已经新建的分组添加我们的FreeRTOS工程源码。<br>在FreeRTOS/port分组中添加MemMang文件夹中的文件只需选择其中一个即可，我们选择“heap_4.c”，这是FreeRTOS的一个内存管理源码文件。<br>添加完成后：</p><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190130134709392.png" alt=""></p><p>** 添加头文件路径**<br>FreeRTOS的源码已经添加到开发环境的组文件夹下面，编译的时候需要为这些源文件指定头文件的路径，不然编译会报错。FreeRTOS的源码里面只有FreeRTOS\include和FreeRTOS\port\RVDS\ARM_CM3这两个文件夹下面有头文件，只需要将这两个头文件的路径在开发环境里面指定即可。同时我们还将FreeRTOSConfig.h这个头文件拷贝到了工程根目录下的user文件夹下，所以user的路径也要加到开发环境里面。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190130134822959.png?" alt=""></p><h3 id="修改FreeRTOSConfig-h"><a href="#修改FreeRTOSConfig-h" class="headerlink" title="修改FreeRTOSConfig.h"></a>修改FreeRTOSConfig.h</h3><p>FreeRTOSConfig.h是直接从demo文件夹下面拷贝过来的，该头文件对裁剪整个FreeRTOS所需的功能的宏均做了定义，有些宏定义被使能，有些宏定义被失能，一开始我们只需要配置最简单的功能即可。要想随心所欲的配置FreeRTOS的功能，我们必须对这些宏定义的功能有所掌握，下面我们先简单的介绍下这些宏定义的含义，然后再对这些宏定义进行修改。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">ifndef</span> FREERTOS_CONFIG_H</span><span class="token macro property">#<span class="token directive keyword">define</span> FREERTOS_CONFIG_H</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"bsp_usart.h"</span></span><span class="token comment" spellcheck="true">//针对不同的编译器调用不同的stdint.h文件</span><span class="token macro property">#<span class="token directive keyword">if</span> defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__)</span>    <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span>    <span class="token keyword">extern</span> uint32_t SystemCoreClock<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token comment" spellcheck="true">//断言</span><span class="token macro property">#<span class="token directive keyword">define</span> vAssertCalled(char,int) printf("Error:%s,%d\r\n",char,int)</span><span class="token macro property">#<span class="token directive keyword">define</span> configASSERT(x) if((x)==0) vAssertCalled(__FILE__,__LINE__)</span><span class="token comment" spellcheck="true">/************************************************************************ *               FreeRTOS基础配置配置选项  *********************************************************************/</span><span class="token comment" spellcheck="true">/* 置1：RTOS使用抢占式调度器；置0：RTOS使用协作式调度器（时间片） *  * 注：在多任务管理机制上，操作系统可以分为抢占式和协作式两种。 * 协作式操作系统是任务主动释放CPU后，切换到下一个任务。 * 任务切换的时机完全取决于正在运行的任务。 */</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_PREEMPTION                      1</span><span class="token comment" spellcheck="true">//1使能时间片调度(默认式使能的)</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_TIME_SLICING                    1        </span><span class="token comment" spellcheck="true">/* 某些运行FreeRTOS的硬件有两种方法选择下一个要执行的任务： * 通用方法和特定于硬件的方法（以下简称“特殊方法”）。 *  * 通用方法： *      1.configUSE_PORT_OPTIMISED_TASK_SELECTION 为 0 或者硬件不支持这种特殊方法。 *      2.可以用于所有FreeRTOS支持的硬件 *      3.完全用C实现，效率略低于特殊方法。 *      4.不强制要求限制最大可用优先级数目 * 特殊方法： *      1.必须将configUSE_PORT_OPTIMISED_TASK_SELECTION设置为1。 *      2.依赖一个或多个特定架构的汇编指令（一般是类似计算前导零[CLZ]指令）。 *      3.比通用方法更高效 *      4.一般强制限定最大可用优先级数目为32 * 一般是硬件计算前导零指令，如果所使用的，MCU没有这些硬件指令的话此宏应该设置为0！ */</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_PORT_OPTIMISED_TASK_SELECTION            1                       </span><span class="token comment" spellcheck="true">/* 置1：使能低功耗tickless模式；置0：保持系统节拍（tick）中断一直运行 * 假设开启低功耗的话可能会导致下载出现问题，因为程序在睡眠中,可用以下办法解决 *  * 下载方法： *      1.将开发版正常连接好 *      2.按住复位按键，点击下载瞬间松开复位按键 *      *      1.通过跳线帽将 BOOT 0 接高电平(3.3V) *      2.重新上电，下载 *     *             1.使用FlyMcu擦除一下芯片，然后进行下载 *            STMISP -> 清除芯片(z) */</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_TICKLESS_IDLE                                                    0   </span><span class="token comment" spellcheck="true">/* * 写入实际的CPU内核时钟频率，也就是CPU指令执行频率，通常称为Fclk * Fclk为供给CPU内核的时钟信号，我们所说的cpu主频为 XX MHz， * 就是指的这个时钟信号，相应的，1/Fclk即为cpu时钟周期； */</span><span class="token macro property">#<span class="token directive keyword">define</span> configCPU_CLOCK_HZ                          (SystemCoreClock)</span><span class="token comment" spellcheck="true">//RTOS系统节拍中断的频率。即一秒中断的次数，每次中断RTOS都会进行任务调度</span><span class="token macro property">#<span class="token directive keyword">define</span> configTICK_RATE_HZ                          (( TickType_t )1000)</span><span class="token comment" spellcheck="true">//可使用的最大优先级</span><span class="token macro property">#<span class="token directive keyword">define</span> configMAX_PRIORITIES                      (32)</span><span class="token comment" spellcheck="true">//空闲任务使用的堆栈大小</span><span class="token macro property">#<span class="token directive keyword">define</span> configMINIMAL_STACK_SIZE                ((unsigned short)128)</span><span class="token comment" spellcheck="true">//任务名字字符串长度</span><span class="token macro property">#<span class="token directive keyword">define</span> configMAX_TASK_NAME_LEN                    (16)</span> <span class="token comment" spellcheck="true">//系统节拍计数器变量数据类型，1表示为16位无符号整形，0表示为32位无符号整形</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_16_BIT_TICKS                    0                      </span><span class="token comment" spellcheck="true">//空闲任务放弃CPU使用权给其他同优先级的用户任务</span><span class="token macro property">#<span class="token directive keyword">define</span> configIDLE_SHOULD_YIELD                    1           </span><span class="token comment" spellcheck="true">//启用队列</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_QUEUE_SETS                      1    </span><span class="token comment" spellcheck="true">//开启任务通知功能，默认开启</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_TASK_NOTIFICATIONS    1   </span><span class="token comment" spellcheck="true">//使用互斥信号量</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_MUTEXES                            1    </span><span class="token comment" spellcheck="true">//使用递归互斥信号量                                            </span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_RECURSIVE_MUTEXES            1   </span><span class="token comment" spellcheck="true">//为1时使用计数信号量</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_COUNTING_SEMAPHORES        1</span><span class="token comment" spellcheck="true">/* 设置可以注册的信号量和消息队列个数 */</span><span class="token macro property">#<span class="token directive keyword">define</span> configQUEUE_REGISTRY_SIZE                10                                 </span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_APPLICATION_TASK_TAG          0                       </span><span class="token comment" spellcheck="true">/*****************************************************************              FreeRTOS与内存申请有关配置选项                                               *****************************************************************/</span><span class="token comment" spellcheck="true">//支持动态内存申请</span><span class="token macro property">#<span class="token directive keyword">define</span> configSUPPORT_DYNAMIC_ALLOCATION        1    </span><span class="token comment" spellcheck="true">//支持静态内存</span><span class="token macro property">#<span class="token directive keyword">define</span> configSUPPORT_STATIC_ALLOCATION                    0                    </span><span class="token comment" spellcheck="true">//系统所有总的堆大小</span><span class="token macro property">#<span class="token directive keyword">define</span> configTOTAL_HEAP_SIZE                    ((size_t)(36*1024))    </span><span class="token comment" spellcheck="true">/***************************************************************             FreeRTOS与钩子函数有关的配置选项                                            **************************************************************/</span><span class="token comment" spellcheck="true">/* 置1：使用空闲钩子（Idle Hook类似于回调函数）；置0：忽略空闲钩子 *  * 空闲任务钩子是一个函数，这个函数由用户来实现， * FreeRTOS规定了函数的名字和参数：void vApplicationIdleHook(void )， * 这个函数在每个空闲任务周期都会被调用 * 对于已经删除的RTOS任务，空闲任务可以释放分配给它们的堆栈内存。 * 因此必须保证空闲任务可以被CPU执行 * 使用空闲钩子函数设置CPU进入省电模式是很常见的 * 不可以调用会引起空闲任务阻塞的API函数 */</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_IDLE_HOOK                        0      </span><span class="token comment" spellcheck="true">/* 置1：使用时间片钩子（Tick Hook）；置0：忽略时间片钩子 *  *  * 时间片钩子是一个函数，这个函数由用户来实现， * FreeRTOS规定了函数的名字和参数：void vApplicationTickHook(void ) * 时间片中断可以周期性的调用 * 函数必须非常短小，不能大量使用堆栈， * 不能调用以”FromISR" 或 "FROM_ISR”结尾的API函数 */</span> <span class="token comment" spellcheck="true">/*xTaskIncrementTick函数是在xPortSysTickHandler中断函数中被调用的。因此，vApplicationTickHook()函数执行的时间必须很短才行*/</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_TICK_HOOK                        0           </span><span class="token comment" spellcheck="true">//使用内存申请失败钩子函数</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_MALLOC_FAILED_HOOK            0 </span><span class="token comment" spellcheck="true">/* * 大于0时启用堆栈溢出检测功能，如果使用此功能  * 用户必须提供一个栈溢出钩子函数，如果使用的话 * 此值可以为1或者2，因为有两种栈溢出检测方法 */</span><span class="token macro property">#<span class="token directive keyword">define</span> configCHECK_FOR_STACK_OVERFLOW            0   </span><span class="token comment" spellcheck="true">/********************************************************************          FreeRTOS与运行时间和任务状态收集有关的配置选项   **********************************************************************/</span><span class="token comment" spellcheck="true">//启用运行时间统计功能</span><span class="token macro property">#<span class="token directive keyword">define</span> configGENERATE_RUN_TIME_STATS            0             </span> <span class="token comment" spellcheck="true">//启用可视化跟踪调试</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_TRACE_FACILITY                      0    </span><span class="token comment" spellcheck="true">/* 与宏configUSE_TRACE_FACILITY同时为1时会编译下面3个函数 * prvWriteNameToBuffer() * vTaskList(), * vTaskGetRunTimeStats()*/</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_STATS_FORMATTING_FUNCTIONS    1                       </span><span class="token comment" spellcheck="true">/********************************************************************                FreeRTOS与协程有关的配置选项                                                *********************************************************************/</span><span class="token comment" spellcheck="true">//启用协程，启用协程以后必须添加文件croutine.c</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_CO_ROUTINES                       0                 </span><span class="token comment" spellcheck="true">//协程的有效优先级数目</span><span class="token macro property">#<span class="token directive keyword">define</span> configMAX_CO_ROUTINE_PRIORITIES       ( 2 )                   </span><span class="token comment" spellcheck="true">/***********************************************************************                FreeRTOS与软件定时器有关的配置选项      **********************************************************************/</span> <span class="token comment" spellcheck="true">//启用软件定时器</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_TIMERS                            1                              </span><span class="token comment" spellcheck="true">//软件定时器优先级</span><span class="token macro property">#<span class="token directive keyword">define</span> configTIMER_TASK_PRIORITY                (configMAX_PRIORITIES-1)        </span><span class="token comment" spellcheck="true">//软件定时器队列长度</span><span class="token macro property">#<span class="token directive keyword">define</span> configTIMER_QUEUE_LENGTH                10                               </span><span class="token comment" spellcheck="true">//软件定时器任务堆栈大小</span><span class="token macro property">#<span class="token directive keyword">define</span> configTIMER_TASK_STACK_DEPTH          (configMINIMAL_STACK_SIZE*2)    </span><span class="token comment" spellcheck="true">/************************************************************            FreeRTOS可选函数配置选项                                                     ************************************************************/</span><span class="token macro property">#<span class="token directive keyword">define</span> INCLUDE_xTaskGetSchedulerState       1                       </span><span class="token macro property">#<span class="token directive keyword">define</span> INCLUDE_vTaskPrioritySet                 1</span><span class="token macro property">#<span class="token directive keyword">define</span> INCLUDE_uxTaskPriorityGet                 1</span><span class="token macro property">#<span class="token directive keyword">define</span> INCLUDE_vTaskDelete                           1</span><span class="token macro property">#<span class="token directive keyword">define</span> INCLUDE_vTaskCleanUpResources           1</span><span class="token macro property">#<span class="token directive keyword">define</span> INCLUDE_vTaskSuspend                       1</span><span class="token macro property">#<span class="token directive keyword">define</span> INCLUDE_vTaskDelayUntil                     1</span><span class="token macro property">#<span class="token directive keyword">define</span> INCLUDE_vTaskDelay                           1</span><span class="token macro property">#<span class="token directive keyword">define</span> INCLUDE_eTaskGetState                       1</span><span class="token macro property">#<span class="token directive keyword">define</span> INCLUDE_xTimerPendFunctionCall         1</span><span class="token comment" spellcheck="true">//#define INCLUDE_xTaskGetCurrentTaskHandle       1</span><span class="token comment" spellcheck="true">//#define INCLUDE_uxTaskGetStackHighWaterMark     0</span><span class="token comment" spellcheck="true">//#define INCLUDE_xTaskGetIdleTaskHandle          0</span><span class="token comment" spellcheck="true">/******************************************************************            FreeRTOS与中断有关的配置选项                                                 ******************************************************************/</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> __NVIC_PRIO_BITS</span>    <span class="token macro property">#<span class="token directive keyword">define</span> configPRIO_BITS               __NVIC_PRIO_BITS</span><span class="token macro property">#<span class="token directive keyword">else</span></span>    <span class="token macro property">#<span class="token directive keyword">define</span> configPRIO_BITS               4                  </span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token comment" spellcheck="true">//中断最低优先级</span><span class="token macro property">#<span class="token directive keyword">define</span> configLIBRARY_LOWEST_INTERRUPT_PRIORITY            15     </span><span class="token comment" spellcheck="true">//系统可管理的最高中断优先级</span><span class="token macro property">#<span class="token directive keyword">define</span> configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY    5 </span><span class="token macro property">#<span class="token directive keyword">define</span> configKERNEL_INTERRUPT_PRIORITY         ( configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )    </span><span class="token comment" spellcheck="true">/* 240 */</span><span class="token macro property">#<span class="token directive keyword">define</span> configMAX_SYSCALL_INTERRUPT_PRIORITY     ( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )</span><span class="token comment" spellcheck="true">/****************************************************************            FreeRTOS与中断服务函数有关的配置选项                         ****************************************************************/</span><span class="token macro property">#<span class="token directive keyword">define</span> xPortPendSVHandler     PendSV_Handler</span><span class="token macro property">#<span class="token directive keyword">define</span> vPortSVCHandler     SVC_Handler</span><span class="token comment" spellcheck="true">/* 以下为使用Percepio Tracealyzer需要的东西，不需要时将 configUSE_TRACE_FACILITY 定义为 0 */</span><span class="token macro property">#<span class="token directive keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"trcRecorder.h"</span></span><span class="token macro property">#<span class="token directive keyword">define</span> INCLUDE_xTaskGetCurrentTaskHandle               1   </span><span class="token comment" spellcheck="true">// 启用一个可选函数（该函数被 Trace源码使用，默认该值为0 表示不用）</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">/* FREERTOS_CONFIG_H */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改stm32f10x-it-c"><a href="#修改stm32f10x-it-c" class="headerlink" title="修改stm32f10x_it.c"></a>修改stm32f10x_it.c</h3><p>SysTick中断服务函数是一个非常重要的函数，FreeRTOS所有跟时间相关的事情都在里面处理，SysTick就是FreeRTOS的一个心跳时钟，驱动着FreeRTOS的运行，就像人的心跳一样，假如没有心跳，我们就相当于“死了”，同样的，FreeRTOS没有了心跳，那么它就会卡死在某个地方，不能进行任务调度，不能运行任何的东西，因此我们需要实现一个FreeRTOS的心跳时钟，FreeRTOS帮我们实现了SysTick的启动的配置：在port.c文件中已经实现vPortSetupTimerInterrupt()函数，并且FreeRTOS通用的SysTick中断服务函数也实现了：在port.c文件中已经实现xPortSysTickHandler()函数，所以移植的时候只需要我们在stm32f10x_it.c文件中实现我们对应（STM32）平台上的SysTick_Handler()函数即可。FreeRTOS为开发者考虑得特别多，PendSV_Handler()与SVC_Handler()这两个很重要的函数都帮我们实现了，在在port.c文件中已经实现xPortPendSVHandler()与vPortSVCHandler()函数，防止我们自己实现不了，那么在stm32f10x_it.c中就需要我们注释掉PendSV_Handler()与SVC_Handler()这两个函数了。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//void SVC_Handler(void)</span><span class="token comment" spellcheck="true">//{</span><span class="token comment" spellcheck="true">//}</span><span class="token comment" spellcheck="true">//void PendSV_Handler(void)</span><span class="token comment" spellcheck="true">//{</span><span class="token comment" spellcheck="true">//}</span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">xPortSysTickHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//systick中断服务函数</span><span class="token keyword">void</span> <span class="token function">SysTick_Handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token macro property">#<span class="token directive keyword">if</span> (INCLUDE_xTaskGetSchedulerState  == 1 )</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">xTaskGetSchedulerState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> taskSCHEDULER_NOT_STARTED<span class="token punctuation">)</span>      <span class="token punctuation">{</span>    <span class="token macro property">#<span class="token directive keyword">endif</span>  </span><span class="token comment" spellcheck="true">/* INCLUDE_xTaskGetSchedulerState */</span>          <span class="token function">xPortSysTickHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">#<span class="token directive keyword">if</span> (INCLUDE_xTaskGetSchedulerState  == 1 )</span>      <span class="token punctuation">}</span>    <span class="token macro property">#<span class="token directive keyword">endif</span>  </span><span class="token comment" spellcheck="true">/* INCLUDE_xTaskGetSchedulerState */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h3><p>这里，我们创建一个单任务，任务使用的栈和任务控制块是在创建任务的时候FreeRTOS动态分配的。<br>任务必须是一个死循环，否则任务将通过LR返回，如果LR指向了非法的内存就会产生HardFault_Handler，而FreeRTOS指向一个死循环，那么任务返回之后就在死循环中执行，这样子的任务是不安全的，所以避免这种情况，任务一般都是死循环并且无返回值的。<br><strong>并且每个任务循环主体中应该有阻塞任务的函数，否则就会饿死比它优先级更低的任务！！！</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* FreeRTOS头文件 */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"FreeRTOS.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"task.h"</span></span><span class="token comment" spellcheck="true">/* 开发板硬件bsp头文件 */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"bsp_led.h"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">AppTaskCreate</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* AppTask任务 */</span> <span class="token comment" spellcheck="true">/* 创建任务句柄 */</span><span class="token keyword">static</span> TaskHandle_t AppTask_Handle <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      BaseType_t xReturn <span class="token operator">=</span> pdPASS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 定义一个创建信息返回值，默认为pdPASS */</span>  <span class="token comment" spellcheck="true">/* 开发板硬件初始化 */</span>  <span class="token function">BSP_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 创建AppTaskCreate任务 */</span>  xReturn <span class="token operator">=</span> <span class="token function">xTaskCreate</span><span class="token punctuation">(</span><span class="token punctuation">(</span>TaskFunction_t <span class="token punctuation">)</span>AppTask<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">/* 任务入口函数 */</span>                        <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span>    <span class="token punctuation">)</span><span class="token string">"AppTask"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">/* 任务名字 */</span>                        <span class="token punctuation">(</span>uint16_t       <span class="token punctuation">)</span><span class="token number">512</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">/* 任务栈大小 */</span>                        <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span>          <span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">/* 任务入口函数参数 */</span>                        <span class="token punctuation">(</span>UBaseType_t    <span class="token punctuation">)</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* 任务的优先级 */</span>                        <span class="token punctuation">(</span>TaskHandle_t<span class="token operator">*</span>  <span class="token punctuation">)</span><span class="token operator">&amp;</span>AppTask_Handle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 任务控制块指针 */</span>   <span class="token comment" spellcheck="true">/* 启动任务调度 */</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>pdPASS <span class="token operator">==</span> xReturn<span class="token punctuation">)</span>    <span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 启动任务，开启调度 */</span>  <span class="token keyword">else</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 正常不会执行到这里 */</span>    <span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">AppTask</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> parameter<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        LED1_ON<span class="token punctuation">;</span>        <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 延时500个tick */</span>        LED1_OFF<span class="token punctuation">;</span>             <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 延时500个tick */</span>                     <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从单片机到操作系统⑦——深入了解FreeRTOS的延时机制</title>
      <link href="/freertos-7/"/>
      <url>/freertos-7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>没研究过操作系统的源码都不算学过操作系统</p></blockquote><h1 id="FreeRTOS-时间管理"><a href="#FreeRTOS-时间管理" class="headerlink" title="FreeRTOS 时间管理"></a>FreeRTOS 时间管理</h1><p>时间管理包括两个方面：系统节拍以及任务延时管理。</p><h2 id="系统节拍："><a href="#系统节拍：" class="headerlink" title="系统节拍："></a>系统节拍：</h2><p>在前面的文章也讲得很多，想要系统正常运行，那么时钟节拍是必不可少的，<code>FreeRTOS</code>的时钟节拍通常由<code>SysTick</code>提供，它周期性的产生定时中断，所谓的时钟节拍管理的核心就是这个定时中断的服务程序。<code>FreeRTOS</code>的时钟节拍isr中核心的工作就是调用<code>vTaskIncrementTick()</code>函数。具体见上之前的文章。</p><h2 id="延时管理"><a href="#延时管理" class="headerlink" title="延时管理"></a>延时管理</h2><p>FreeRTOS提供了两个系统延时函数：</p><ul><li>相对延时函数<code>vTaskDelay()</code></li><li>绝对延时函数<code>vTaskDelayUntil()</code>。</li></ul><p>这些延时函数可不像我们以前用裸机写代码的延时函数操作系统不允许CPU在死等消耗着时间，因为这样效率太低了。</p><p>同时，要告诫学操作系统的同学，千万别用裸机的思想去学操作系统。</p><h2 id="任务延时"><a href="#任务延时" class="headerlink" title="任务延时"></a>任务延时</h2><p>任务可能需要延时，两种情况，一种是任务被<code>vTaskDelay</code>或者<code>vTaskDelayUntil</code>延时，另外一种情况就是任务等待事件（比如等待某个信号量、或者某个消息队列）时候指定了<code>timeout</code>（即最多等待timeout时间，如果等待的事件还没发生，则不再继续等待），在每个任务的循环中都必须要有阻塞的情况出现，否则比该任务优先级低的任务就永远无法运行。</p><h2 id="相对延时与绝对延时的区别"><a href="#相对延时与绝对延时的区别" class="headerlink" title="相对延时与绝对延时的区别"></a>相对延时与绝对延时的区别</h2><p><strong>相对延时：vTaskDelay()：</strong></p><p>相对延时是指每次延时都是从任务执行函数<code>vTaskDelay()</code>开始，延时指定的时间结束</p><p><strong>绝对延时：vTaskDelayUntil()：</strong></p><p>绝对延时是指调用<code>vTaskDelayUntil()</code>的任务每隔x时间运行一次。也就是任务周期运行。</p><p><strong>相对延时：vTaskDelay()</strong></p><p>相对延时<code>vTaskDelay()</code>是从调用<code>vTaskDelay()</code>这个函数的时候开始延时，但是任务执行的时候，可能发生了中断，导致任务执行时间变长了，但是整个任务的延时时间还是1000个tick，这就不是周期性了，简单看看下面代码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vTaskA</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> pvParameters <span class="token punctuation">)</span>   <span class="token punctuation">{</span>      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">//  ...</span>         <span class="token comment" spellcheck="true">//  这里为任务主体代码</span>         <span class="token comment" spellcheck="true">//  ...</span>         <span class="token comment" spellcheck="true">/* 调用相对延时函数,阻塞1000个tick */</span>         <span class="token function">vTaskDelay</span><span class="token punctuation">(</span> <span class="token number">1000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可能说的不够明确，可以看看图解。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos-delay-1.png" alt="freertos-delay-1"></p><p>当任务运行的时候，假设被某个高级任务或者是中断打断了，那么任务的执行时间就更长了，然而延时还是延时<code>1000</code>个<code>tick</code>这样子，整个系统的时间就混乱了。</p><p>如果还不够明确，看看vTaskDelay()的源码</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vTaskDelay</span><span class="token punctuation">(</span> <span class="token keyword">const</span> TickType_t xTicksToDelay <span class="token punctuation">)</span><span class="token punctuation">{</span>    BaseType_t xAlreadyYielded <span class="token operator">=</span> pdFALSE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 延迟时间为零只会强制切换任务。 */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> xTicksToDelay <span class="token operator">></span> <span class="token punctuation">(</span> TickType_t <span class="token punctuation">)</span> 0U <span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">configASSERT</span><span class="token punctuation">(</span> uxSchedulerSuspended <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">vTaskSuspendAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">traceTASK_DELAY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/*将当前任务从就绪列表中移除,并根据当前系统节拍            计数器值计算唤醒时间,然后将任务加入延时列表 */</span>            <span class="token function">prvAddCurrentTaskToDelayedList</span><span class="token punctuation">(</span> xTicksToDelay<span class="token punctuation">,</span> pdFALSE <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        xAlreadyYielded <span class="token operator">=</span> <span class="token function">xTaskResumeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* 强制执行一次上下文切换 */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> xAlreadyYielded <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">portYIELD_WITHIN_API</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>(1):如果传递进来的延时时间是<code>0</code>，只能进行强制切换任务了，调用的是<code>portYIELD_WITHIN_API()</code>，它其实是一个宏，真正起作用的是<code>portYIELD()</code>，下面是它的源码：</li></ul><pre class="line-numbers language-js"><code class="language-js">#define <span class="token function">portYIELD</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                                \<span class="token punctuation">{</span>                                                                \    <span class="token comment" spellcheck="true">/* 设置PendSV以请求上下文切换。 */</span>                            \    portNVIC_INT_CTRL_REG <span class="token operator">=</span> portNVIC_PENDSVSET_BIT<span class="token punctuation">;</span>                \    <span class="token function">__dsb</span><span class="token punctuation">(</span> portSY_FULL_READ_WRITE <span class="token punctuation">)</span><span class="token punctuation">;</span>                            \    <span class="token function">__isb</span><span class="token punctuation">(</span> portSY_FULL_READ_WRITE <span class="token punctuation">)</span><span class="token punctuation">;</span>                            \<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>(2):挂起当前任务</li></ul><p>然后将当前任务从就绪列表删除，然后加入到延时列表。是调用函数<code>prvAddCurrentTaskToDelayedList()</code>完成这一过程的。由于这个函数篇幅过长，就不讲解了，有兴趣可以看看，我就简单说说过程。在<code>FreeRTOS</code>中有这么一个变量，是用来记录<code>systick</code>的值的。</p><pre class="line-numbers language-js"><code class="language-js">PRIVILEGED_DATA <span class="token keyword">static</span> volatile TickType_t xTickCount     <span class="token operator">=</span> <span class="token punctuation">(</span> TickType_t <span class="token punctuation">)</span> 0U<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在每次<code>tick</code>中断时<code>xTickCount</code>加一，它的值表示了系统节拍中断的次数，那么啥时候唤醒被加入延时列表的任务呢？其实很简单，FreeRTOS的做法将<code>xTickCount</code>(当前系统时间) + <code>xTicksToDelay</code>(要延时的时间)即可。当这个相对的延时时间到了之后就唤醒了，这个<code>(xTickCount+ xTicksToDelay)</code>时间会被记录在该任务的任务控制块中。</p><p>看到这肯定有人问，这个变量是<code>TickType_t</code>类型(32位)的，那肯定会溢出啊，没错，是变量都会有溢出的一天，可是<code>FreeRTOS</code>乃是世界第一的操作系统啊，<code>FreeRTOS</code>使用了两个延时列表：</p><p><code>xDelayedTaskList1 和 xDelayedTaskList2</code></p><p>并使用两个列表指针类型变量<code>pxDelayedTaskList</code>和<code>pxOverflowDelayedTaskList</code>分别指向上面的延时列表1和延时列表2（在创建任务时将延时列表指针指向延时列表）如果内核判断出<code>xTickCount+xTicksToDelay</code>溢出，就将当前任务挂接到列表指针 <code>pxOverflowDelayedTaskList</code>指向的列表中，否则就挂接到列表指针<code>pxDelayedTaskList</code>指向的列表中。当时间到了，就会将延时的任务从延时列表中删除，加入就绪列表中，当然这时候就是由调度器觉得任务能不能运行了，如果任务的优先级大于当前运行的任务，那么调度器才会进行任务的调度。</p><p><strong>绝对延时：vTaskDelayUntil()</strong></p><p><code>vTaskDelayUntil()</code>的参数指定了确切的滴答计数值</p><p>调用<code>vTaskDelayUntil()</code>是希望任务以固定频率定期执行，而不受外部的影响，任务从上一次运行开始到下一次运行开始的时间间隔是绝对的，而不是相对的。假设主体任务被打断<code>0.3s</code>，但是下次唤醒的时间是固定的，所以还是会周期运行。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos-delay-2.png" alt="freertos-delay-2"></p><p>下面看看<code>vTaskDelayUntil()</code>的使用方法，注意了，这<code>vTaskDelayUntil()</code>的使用方法与<code>vTaskDelay()</code>不一样：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vTaskA</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> pvParameters <span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/* 用于保存上次时间。调用后系统自动更新 */</span>    <span class="token keyword">static</span> portTickType PreviousWakeTime<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 设置延时时间，将时间转为节拍数 */</span>    <span class="token keyword">const</span> portTickType TimeIncrement <span class="token operator">=</span> <span class="token function">pdMS_TO_TICKS</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 获取当前系统时间 */</span>    PreviousWakeTime <span class="token operator">=</span> <span class="token function">xTaskGetTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">/* 调用绝对延时函数,任务时间间隔为1000个tick */</span>         <span class="token function">vTaskDelayUntil</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>PreviousWakeTime，TimeIncrement <span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//  ...</span>         <span class="token comment" spellcheck="true">//  这里为任务主体代码</span>         <span class="token comment" spellcheck="true">//  ...</span>     <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在使用的时候要将延时时间转化为系统节拍，在任务主体之前要调用延时函数。</p><p>任务会先调用<code>vTaskDelayUntil()</code>使任务进入阻塞态，等到时间到了就从阻塞中解除，然后执行主体代码，任务主体代码执行完毕。会继续调用<code>vTaskDelayUntil()</code>使任务进入阻塞态，然后就是循环这样子执行。即使任务在执行过程中发生中断，那么也不会影响这个任务的运行周期，仅仅是缩短了阻塞的时间而已。</p><p>下面来看看<code>vTaskDelayUntil()</code>的源码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vTaskDelayUntil</span><span class="token punctuation">(</span> TickType_t <span class="token operator">*</span> <span class="token keyword">const</span> pxPreviousWakeTime<span class="token punctuation">,</span> <span class="token keyword">const</span> TickType_t xTimeIncrement <span class="token punctuation">)</span><span class="token punctuation">{</span>    TickType_t xTimeToWake<span class="token punctuation">;</span>    BaseType_t xAlreadyYielded<span class="token punctuation">,</span> xShouldDelay <span class="token operator">=</span> pdFALSE<span class="token punctuation">;</span>    <span class="token function">configASSERT</span><span class="token punctuation">(</span> pxPreviousWakeTime <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">configASSERT</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> xTimeIncrement <span class="token operator">></span> 0U <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">configASSERT</span><span class="token punctuation">(</span> uxSchedulerSuspended <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">vTaskSuspendAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                 <span class="token comment" spellcheck="true">// (1)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 保存系统节拍中断次数计数器 */</span>        <span class="token keyword">const</span> TickType_t xConstTickCount <span class="token operator">=</span> xTickCount<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 生成任务要唤醒的滴答时间。*/</span>        xTimeToWake <span class="token operator">=</span> <span class="token operator">*</span>pxPreviousWakeTime <span class="token operator">+</span> xTimeIncrement<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* pxPreviousWakeTime中保存的是上次唤醒时间,唤醒后需要一定时间执行任务主体代码,            如果上次唤醒时间大于当前时间,说明节拍计数器溢出了 具体见图片 */</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> xConstTickCount <span class="token operator">&lt;</span> <span class="token operator">*</span>pxPreviousWakeTime <span class="token punctuation">)</span>        <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">/* 由于此功能，滴答计数已溢出持续呼唤。 在这种情况下，我们唯一的时间实际延迟是如果唤醒时间也溢出，              唤醒时间大于滴答时间。 当这个就是这样，好像两个时间都没有溢出。*/</span>           <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> xTimeToWake <span class="token operator">&lt;</span> <span class="token operator">*</span>pxPreviousWakeTime <span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span> xTimeToWake <span class="token operator">></span> xConstTickCount <span class="token punctuation">)</span> <span class="token punctuation">)</span>           <span class="token punctuation">{</span>               xShouldDelay <span class="token operator">=</span> pdTRUE<span class="token punctuation">;</span>           <span class="token punctuation">}</span>           <span class="token keyword">else</span>           <span class="token punctuation">{</span>               <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">/* 滴答时间没有溢出。 在这种情况下，如果唤醒时间溢出，              或滴答时间小于唤醒时间，我们将延迟。*/</span>           <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> xTimeToWake <span class="token operator">&lt;</span> <span class="token operator">*</span>pxPreviousWakeTime <span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span> xTimeToWake <span class="token operator">></span> xConstTickCount <span class="token punctuation">)</span> <span class="token punctuation">)</span>           <span class="token punctuation">{</span>               xShouldDelay <span class="token operator">=</span> pdTRUE<span class="token punctuation">;</span>           <span class="token punctuation">}</span>           <span class="token keyword">else</span>           <span class="token punctuation">{</span>               <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">/* 更新唤醒时间,为下一次调用本函数做准备. */</span>      <span class="token operator">*</span>pxPreviousWakeTime <span class="token operator">=</span> xTimeToWake<span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span> xShouldDelay <span class="token operator">!=</span> pdFALSE <span class="token punctuation">)</span>      <span class="token punctuation">{</span>          <span class="token function">traceTASK_DELAY_UNTIL</span><span class="token punctuation">(</span> xTimeToWake <span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* prvAddCurrentTaskToDelayedList（）需要块时间，而不是唤醒时间，因此减去当前的滴答计数。 */</span>          <span class="token function">prvAddCurrentTaskToDelayedList</span><span class="token punctuation">(</span> xTimeToWake <span class="token operator">-</span> xConstTickCount<span class="token punctuation">,</span> pdFALSE <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">else</span>      <span class="token punctuation">{</span>          <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  xAlreadyYielded <span class="token operator">=</span> <span class="token function">xTaskResumeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 如果xTaskResumeAll尚未执行重新安排，我们可能会让自己入睡。*/</span>  <span class="token keyword">if</span><span class="token punctuation">(</span> xAlreadyYielded <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">portYIELD_WITHIN_API</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span>  <span class="token punctuation">{</span>    <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与相对延时函数<code>vTaskDelay</code>不同，本函数增加了一个参数<code>pxPreviousWakeTime</code>用于指向一个变量，变量保存上次任务解除阻塞的时间，此后函数<code>vTaskDelayUntil()</code>在内部自动更新这个变量。由于变量<code>xTickCount</code>可能会溢出，所以程序必须检测各种溢出情况，并且要保证延时周期不得小于任务主体代码执行时间。</p><p>就会有以下3种情况，才能将任务加入延时链表中。</p><p>请记住这几个单词的含义：</p><ul><li><code>xTimeIncrement</code>：任务周期时间</li><li><code>pxPreviousWakeTime</code>：上一次唤醒的时间点</li><li><code>xTimeToWake</code>：下一次唤醒的系统时间点</li><li><code>xConstTickCount</code>：进入延时的时间点</li></ul><ol start="3"><li>第三种情况：常规无溢出的情况。</li></ol><p>以时间为横轴，上一次唤醒的时间点小于下一次唤醒的时间点，这是很正常的情况。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos-delay-3.png" alt="freertos-delay-3"></p><ol start="2"><li>第二种情况：唤醒时间计数器（<code>xTimeToWake</code>）溢出情况。</li></ol><p>也就是代码中<code>if( ( xTimeToWake &lt; *pxPreviousWakeTime ) || ( xTimeToWake &gt; xConstTickCount ) )</code></p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos-delay-4.png" alt="freertos-delay-4"></p><ol><li>第一种情况：唤醒时间（<code>xTimeToWake</code>）与进入延时的时间点（<code>xConstTickCount</code>）都溢出情况。</li></ol><p>也就是代码中<code>if( ( xTimeToWake &lt; *pxPreviousWakeTime ) &amp;&amp; ( xTimeToWake &gt; xConstTickCount ) )</code></p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos-delay-5.png" alt="freertos-delay-5"></p><p>从图中可以看出不管是溢出还是无溢出，都要求在下次唤醒任务之前，当前任务主体代码必须被执行完。也就是说任务执行的时间不允许大于延时的时间，总不能存在每<code>10ms</code>就要执行一次<code>20ms</code>时间的任务吧。计算的唤醒时间合法后，就将当前任务加入延时列表，同样延时列表也有两个。每次系统节拍中断，中断服务函数都会检查这两个延时列表，查看延时的任务是否到期，如果时间到期，则将任务从延时列表中删除，重新加入就绪列表。如果新加入就绪列表的任务优先级大于当前任务，则会触发一次上下文切换。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果任务调用相对延时，其运行周期完全是不可测的，如果任务的优先级不是最高的话，其误差更大，就好比一个必须要在<code>5ms</code>内相应的任务，假如使用了相对延时1ms，那么很有可能在该任务执行的时候被更高优先级的任务打断，从而错过<code>5ms</code>内的相应，但是调用绝对延时，则任务会周期性将该任务在阻塞列表中解除，但是，任务能不能运行，还得取决于任务的优先级，如果优先级最高的话，任务周期还是比较精确的（相对<code>vTaskDelay</code>来说），如果想要更加想精确周期性执行某个任务，可以使用系统节拍钩子函数<code>vApplicationTickHook()</code>，它在<code>tick</code>中断服务函数中被调用，因此这个函数中的代码必须简洁，并且不允许出现阻塞的情况。</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0开始学FreeRTOS-(列表&amp;列表项)-6</title>
      <link href="/freertos-6/"/>
      <url>/freertos-6/</url>
      
        <content type="html"><![CDATA[<h1 id="FreeRTOS列表-amp-列表项的源码解读"><a href="#FreeRTOS列表-amp-列表项的源码解读" class="headerlink" title="FreeRTOS列表&amp;列表项的源码解读"></a>FreeRTOS列表&amp;列表项的源码解读</h1><p>第一次看列表与列表项的时候，感觉很像是链表，虽然我自己的链表也不太会，但是就是感觉很像。</p><p>在FreeRTOS中，列表与列表项使用得非常多，是FreeRTOS的一个数据结构，学习过数据结构的同学都知道，数据结构能使我们处理数据更加方便快速，能快速找到数据，在FreeRTOS中，这种列表与列表项更是必不可少的，能让我们的系统跑起来更加流畅迅速。</p><p>言归正传，FreeRTOS中使用了大量的列表（List）与列表项（Listitem），在FreeRTOS调度器中，就是用到这些来跟着任务，了解任务的状态，处于挂起、阻塞态、还是就绪态亦或者是运行态。这些信息都会在各自任务的列表中得到。</p><p>看任务控制块（tskTaskControlBlock）中的两个列表项：</p><pre class="line-numbers language-js"><code class="language-js">ListItem_t xStateListItem<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* &lt;任务的状态列表项目引用的列表表示该任务的状态（就绪，已阻止，暂停）。*/</span>ListItem_t xEventListItem<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* &lt;用于从事件列表中引用任务。*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>一个是状态的列表项，一个是事件列表项。他们在创建任务就会被初始化，列表项的初始化是根据实际需要来初始化的，下面会说。</p><h1 id="FreeRTOS列表-amp-列表项的结构体"><a href="#FreeRTOS列表-amp-列表项的结构体" class="headerlink" title="FreeRTOS列表&amp;列表项的结构体"></a>FreeRTOS列表&amp;列表项的结构体</h1><p>既然知道列表与列表项的重要性，那么我们来解读FreeRTOS中的list.c与list.h的源码吧。从头文件lsit.h开始，看到定义了一些结构体：</p><pre class="line-numbers language-js"><code class="language-js"> struct xLIST_ITEM<span class="token punctuation">{</span>    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE <span class="token comment" spellcheck="true">/* &lt;如果configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES设置为1，则设置为已知值。*/</span>    configLIST_VOLATILE TickType_t xItemValue<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* &lt;正在列出的值。在大多数情况下，这用于按降序对列表进行排序。 */</span>    struct xLIST_ITEM <span class="token operator">*</span> configLIST_VOLATILE pxNext<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* &lt;指向列表中下一个ListItem_t的指针。 */</span>    struct xLIST_ITEM <span class="token operator">*</span> configLIST_VOLATILE pxPrevious<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* &lt;指向列表中前一个ListItem_t的指针。 */</span>    <span class="token keyword">void</span> <span class="token operator">*</span> pvOwner<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* &lt;指向包含列表项目的对象（通常是TCB）的指针。因此，包含列表项目的对象与列表项目本身之间存在双向链接。 */</span>    <span class="token keyword">void</span> <span class="token operator">*</span> configLIST_VOLATILE pvContainer<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* &lt;指向此列表项目所在列表的指针（如果有）。 */</span>    listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE <span class="token comment" spellcheck="true">/* &lt;如果configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES设置为1，则设置为已知值。*/</span><span class="token punctuation">}</span><span class="token punctuation">;</span>typedef struct xLIST_ITEM ListItem_t<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 由于某种原因，lint希望将其作为两个单独的定义。 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>列表项结构体的一些注意的地方：</p><p><strong>xItemValue</strong> 用于列表项的排序，类似1—2—3—4</p><p><strong>pxNext</strong> 指向下一个列表项的指针<br><strong>pxPrevious</strong> 指向上（前）一个列表项的指针</p><p>这两个指针实现了类似双向链表的功能</p><p><strong>pvOwner</strong> 指向包含列表项目的对象（通常是任务控制块TCB）的指针。因此，包含列表项目的对象与列表项目本身之间存在双向链接。</p><p><strong>pvContainer</strong> 记录了该列表项属于哪个列表，说白点就是这个儿子是谁生的。。。</p><p>同时定义了一个MINI的列表项的结构体，MINI列表项是删减版的列表项，因为很多时候不需要完全版的列表项。就不用浪费那么多内存空间了，这或许就是FreeRTOS是轻量级操作系统的原因吧，能省一点是一点。MINI列表项：</p><pre class="line-numbers language-js"><code class="language-js">struct xMINI_LIST_ITEM<span class="token punctuation">{</span>    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE           <span class="token comment" spellcheck="true">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span>    configLIST_VOLATILE TickType_t xItemValue<span class="token punctuation">;</span>    struct xLIST_ITEM <span class="token operator">*</span> configLIST_VOLATILE pxNext<span class="token punctuation">;</span>    struct xLIST_ITEM <span class="token operator">*</span> configLIST_VOLATILE pxPrevious<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>typedef struct xMINI_LIST_ITEM MiniListItem_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再定义了一个列表的结构体，可能看到这里，一些同学已经蒙了，列表与列表项是啥关系啊，按照杰杰的理解，是类似父子关系的，一个列表中，包含多个列表项，就像一个父亲，生了好多孩子，而列表就是父亲，列表项就是孩子。</p><pre class="line-numbers language-js"><code class="language-js">typedef struct xLIST<span class="token punctuation">{</span>    listFIRST_LIST_INTEGRITY_CHECK_VALUE <span class="token comment" spellcheck="true">/* &lt;如果configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES设置为1，则设置为已知值。*/</span>    configLIST_VOLATILE UBaseType_t uxNumberOfItems<span class="token punctuation">;</span>    ListItem_t <span class="token operator">*</span> configLIST_VOLATILE pxIndex<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* &lt;用于遍历列表。 指向由listGET_OWNER_OF_NEXT_ENTRY（）调用返回的后一个列表项。*/</span>    MiniListItem_t xListEnd<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* &lt;List item包含最大可能的项目值，这意味着它始终在列表的末尾，因此用作标记。*/</span>    listSECOND_LIST_INTEGRITY_CHECK_VALUE <span class="token comment" spellcheck="true">/* &lt;如果configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES设置为1，则设置为已知值。*/</span><span class="token punctuation">}</span> List_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>列表的结构体中值得注意的是：<br><strong>uxNumberOfItems</strong> 是用来记录列表中列表项的数量的，就是记录父亲有多少个儿子，当然女儿也行~。</p><p><strong>pxIndex</strong> 是索引编号，用来遍历列表的，调用宏listGET_OWNER_OF_NEXT_ENTRY（）之后索引就会指向返回当前列表项的下一个列表项。</p><p><strong>xListEnd</strong> 指向的是最后一个列表项，并且这个列表项是MiniListItem属性的，是一个迷你列表项。</p><h1 id="列表的初始化"><a href="#列表的初始化" class="headerlink" title="列表的初始化"></a>列表的初始化</h1><p>函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vListInitialise</span><span class="token punctuation">(</span> List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxList <span class="token punctuation">)</span><span class="token punctuation">{</span>     pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">/*lint The mini list structure is used as the list end to save RAM.  This is checked and valid. */</span>     pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd<span class="token punctuation">.</span>xItemValue <span class="token operator">=</span> portMAX_DELAY<span class="token punctuation">;</span>     pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd<span class="token punctuation">.</span>pxNext <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/*lint The mini list structure is used as the list end to save RAM.  This is checked and valid. */</span>     pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd<span class="token punctuation">.</span>pxPrevious <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*lint The mini list structure is used as the list end to save RAM.  This is checked and valid. */</span>     pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token operator">=</span> <span class="token punctuation">(</span> UBaseType_t <span class="token punctuation">)</span> 0U<span class="token punctuation">;</span>     <span class="token function">listSET_LIST_INTEGRITY_CHECK_1_VALUE</span><span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">listSET_LIST_INTEGRITY_CHECK_2_VALUE</span><span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将列表的索引指向列表中的xListEnd，也就是末尾的列表项（迷你列表项）</p><p>列表项的xItemValue数值为portMAX_DELAY，也就是0xffffffffUL，如果在16位处理器中则为0xffff。</p><p>列表项的pxNext与pxPrevious这两个指针都指向自己本身xListEnd。</p><p>初始化完成的时候列表项的数目为0个。因为还没添加列表项嘛~。</p><p><img src="./images/loading.png" data-original="https://img-blog.csdn.net/20180609234203180" alt=""></p><h1 id="列表项的初始化"><a href="#列表项的初始化" class="headerlink" title="列表项的初始化"></a>列表项的初始化</h1><p>函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vListInitialiseItem</span><span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxItem <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* Make sure the list item is not recorded as being on a list. */</span>    pxItem<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> NULL<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Write known values into the list item if    configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span>    <span class="token function">listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE</span><span class="token punctuation">(</span> pxItem <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE</span><span class="token punctuation">(</span> pxItem <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只需要让列表项的<code>pvContainer</code>指针指向<code>NULL</code>即可，这样子就使得列表项不属于任何一个列表，因为列表项的初始化是要根据实际的情况来进行初始化的。</p><p>例如任务创建时用到的一些列表项初始化：</p><pre class="line-numbers language-js"><code class="language-js">pxNewTCB<span class="token operator">-</span><span class="token operator">></span>pcTaskName<span class="token punctuation">[</span> configMAX_TASK_NAME_LEN <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>pxNewTCB<span class="token operator">-</span><span class="token operator">></span>uxPriority <span class="token operator">=</span> uxPriority<span class="token punctuation">;</span>pxNewTCB<span class="token operator">-</span><span class="token operator">></span>uxBasePriority <span class="token operator">=</span> uxPriority<span class="token punctuation">;</span>pxNewTCB<span class="token operator">-</span><span class="token operator">></span>uxMutexesHeld <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">vListInitialiseItem</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxNewTCB<span class="token operator">-</span><span class="token operator">></span>xStateListItem <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">vListInitialiseItem</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxNewTCB<span class="token operator">-</span><span class="token operator">></span>xEventListItem <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 或者是在定时器相关的初始化中：</p><pre class="line-numbers language-js"><code class="language-js">pxNewTimer<span class="token operator">-</span><span class="token operator">></span>pcTimerName <span class="token operator">=</span> pcTimerName<span class="token punctuation">;</span>pxNewTimer<span class="token operator">-</span><span class="token operator">></span>xTimerPeriodInTicks <span class="token operator">=</span> xTimerPeriodInTicks<span class="token punctuation">;</span>pxNewTimer<span class="token operator">-</span><span class="token operator">></span>uxAutoReload <span class="token operator">=</span> uxAutoReload<span class="token punctuation">;</span>pxNewTimer<span class="token operator">-</span><span class="token operator">></span>pvTimerID <span class="token operator">=</span> pvTimerID<span class="token punctuation">;</span>pxNewTimer<span class="token operator">-</span><span class="token operator">></span>pxCallbackFunction <span class="token operator">=</span> pxCallbackFunction<span class="token punctuation">;</span><span class="token function">vListInitialiseItem</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxNewTimer<span class="token operator">-</span><span class="token operator">></span>xTimerListItem <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="列表项的末尾插入"><a href="#列表项的末尾插入" class="headerlink" title="列表项的末尾插入"></a>列表项的末尾插入</h1><p>函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vListInsertEnd</span><span class="token punctuation">(</span> List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxList<span class="token punctuation">,</span> ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxNewListItem <span class="token punctuation">)</span><span class="token punctuation">{</span>    ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxIndex <span class="token operator">=</span> pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token punctuation">;</span>    <span class="token function">listTEST_LIST_INTEGRITY</span><span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listTEST_LIST_ITEM_INTEGRITY</span><span class="token punctuation">(</span> pxNewListItem <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listGET_OWNER_OF_NEXT_ENTRY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token operator">*</span><span class="token operator">/</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIndex<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  1 </span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  2</span>     <span class="token comment" spellcheck="true">/* Only used during decision coverage testing. */</span>    <span class="token function">mtCOVERAGE_TEST_DELAY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  3 </span>    pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//  4</span>    <span class="token comment" spellcheck="true">/* Remember which list the item is in. */</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> pxList<span class="token punctuation">;</span>    <span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>传入的参数：</p><ul><li><p>pxList：列表项要插入的列表。</p></li><li><p>pxNewListItem：要插入的列表项是什么。</p></li></ul><p>从末尾插入，那就要先知道哪里是头咯，我们在列表中的成员<code>pxIndex</code>就是用来遍历列表项的啊，那它指向的地方就是列表项的头，那么既然<code>FreeRTOS</code>中的列表很像数据结构中的双向链表，那么，我们可以把它看成一个环，是首尾相连的，那么函数中说的末尾，就是列表项头的前一个，很显然其结构图应该是下图这样子的（初始化结束后<code>pxIndex</code>指向了<code>xListEnd</code>）：<br><img src="./images/loading.png" data-original="https://img-blog.csdn.net/20180609234229499" alt=""></p><p>为什么是这样子的呢，一句句代码来解释：</p><p>一开始：</p><pre class="line-numbers language-js"><code class="language-js">ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxIndex <span class="token operator">=</span> pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>保存了一开始的索引列表项（xListEnd）的指向。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIndex<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//  1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新列表项的下一个指向为索引列表项，也就是绿色的箭头。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//  2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>刚开始我们初始化完成的时候pxIndex-&gt;pxPrevious的指向为自己xListEnd，那么xNewListItem-&gt;pxPrevious的指向为xListEnd。如2紫色的箭头。</p><pre class="line-numbers language-js"><code class="language-js">pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//  3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>索引列表项（xListEnd）的上一个列表项还是自己，那么自己的下一个列表项指向就是指向了pxNewListItem。</p><pre class="line-numbers language-js"><code class="language-js">pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">//  4</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这句就很容易理解啦。如图的4橙色的箭头。</p><p>插入完毕的时候标记一下新的列表项插入了哪个列表，并且将uxNumberOfItems进行加一，以表示多了一个列表项。</p><p>为什么源码要这样子写呢？因为这只是两个列表项，一个列表含有多个列表项，那么这段代码的通用性就很强了。无论原本列表中有多少个列表项，也无论pxIndex指向哪个列表项！<br><img src="./images/loading.png" data-original="https://img-blog.csdn.net/20180609234241856" alt=""><br><img src="./images/loading.png" data-original="https://img-blog.csdn.net/2018060923424853" alt=""></p><p>看看是不是按照源码中那样插入呢？</p><h1 id="列表项的插入"><a href="#列表项的插入" class="headerlink" title="列表项的插入"></a>列表项的插入</h1><p>源码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vListInsert</span><span class="token punctuation">(</span> List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxList<span class="token punctuation">,</span> ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxNewListItem <span class="token punctuation">)</span><span class="token punctuation">{</span>ListItem_t <span class="token operator">*</span>pxIterator<span class="token punctuation">;</span><span class="token keyword">const</span> TickType_t xValueOfInsertion <span class="token operator">=</span> pxNewListItem<span class="token operator">-</span><span class="token operator">></span>xItemValue<span class="token punctuation">;</span>    <span class="token function">listTEST_LIST_INTEGRITY</span><span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listTEST_LIST_ITEM_INTEGRITY</span><span class="token punctuation">(</span> pxNewListItem <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> xValueOfInsertion <span class="token operator">==</span> portMAX_DELAY <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        pxIterator <span class="token operator">=</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd<span class="token punctuation">.</span>pxPrevious<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span> pxIterator <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>xItemValue <span class="token operator">&lt;=</span> xValueOfInsertion<span class="token punctuation">;</span> pxIterator <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* There is nothing to do here, just iterating to the wanted            insertion position. */</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIterator<span class="token punctuation">;</span>    pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Remember which list the item is in.  This allows fast removal of the    item later. */</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> pxList<span class="token punctuation">;</span>    <span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>传入的参数：</p><ul><li><p>pxList：列表项要插入的列表。</p></li><li><p>pxNewListItem：要插入的列表项是什么。</p></li></ul><p>pxList决定了插入哪个列表，pxNewListItem中的xItemValue值决定了列表项插入列表的位置。</p><pre class="line-numbers language-js"><code class="language-js">ListItem_t <span class="token operator">*</span>pxIterator<span class="token punctuation">;</span>  <span class="token keyword">const</span> TickType_t xValueOfInsertion <span class="token operator">=</span> pxNewListItem<span class="token operator">-</span><span class="token operator">></span>xItemValue<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>定义一个辅助的列表项pxIterator，用来迭代找出插入新列表项的位置，并且保存获取要插入的列表项pxNewListItem的xItemValue。</p><p>如果打开了列表项完整性检查，就要用户实现configASSERT()，源码中有说明。</p><p>既然是要插入列表项，那么肯定是要知道列表项的位置了，如果新插入列表项的xItemValue是最大的话（portMAX_DELAY），就直接插入列表项的末尾。否则就需要比较列表中各个列表项的xItemValue的大小来进行排列。然后得出新列表项插入的位置。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span><span class="token punctuation">(</span> pxIterator <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>xItemValue <span class="token operator">&lt;=</span> xValueOfInsertion<span class="token punctuation">;</span> pxIterator <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面源码就是实现比较的过程。</p><p>与上面的从列表项末尾插入的源码一样，FreeRTOS的代码通用性很强，逻辑思维也很强。</p><p>如果列表中列表项的数量为0，那么插入的列表项就是在初始化列表项的后面。如下图所示：<br><img src="./images/loading.png" data-original="https://img-blog.csdn.net/20180609234309563" alt=""></p><p>过程分析：<br>新列表项的pxNext指向pxIterator-&gt;pxNext，也就是指向了xListEnd（pxIterator）。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而xListEnd（pxIterator）的pxPrevious指向则为pxNewListItem。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新列表项的（pxPrevious）指针指向xListEnd（pxIterator）</p><p>pxIterator 的 pxNext 指向了新列表项</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIterator<span class="token punctuation">;</span>pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>与从末尾插入列表项其实是一样的，前提是当前列表中列表项的数目为0。</p><p>假如列表项中已经有了元素呢，过程又是不一样的了。原来的列表是下图这样子的：</p><p><img src="./images/loading.png" data-original="https://img-blog.csdn.net/20180609234309563" alt=""><br>假设插入的列表项的xItemValue是2，而原有的列表项的xItemValue值是3，那么，按照源码，我们插入的列表项是在中间了。而pxIterator则是①号列表项。</p><p>插入后的效果：<br><img src="./images/loading.png" data-original="https://img-blog.csdn.net/20180609234320730" alt=""><br>分析一下插入的过程：</p><p>新的列表项的pxNext指向的是pxIterator-&gt;pxNext，也就是③号列表项。因为一开始pxIterator-&gt;pxNext=指向的就是③号列表项！！</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而pxNewListItem-&gt;pxNext 即③号列表项的指向上一个列表项指针（pxPrevious）的则指向新插入的列表项，也就是②号列表项了。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新插入列表项的指向上一个列表项的指针pxNewListItem-&gt;pxPrevious指向了辅助列表项pxIterator。很显然要连接起来嘛！</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIterator<span class="token punctuation">;</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同理，pxIterator列表项的指向下一个列表项的指针则指向新插入的列表项了pxNewListItem。</p><pre class="line-numbers language-js"><code class="language-js">pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而其他没改变指向的地方不需改动。（图中的两条直线做的连接线是不需要改动的）<br>当插入完成的时候，记录一下新插入的列表项属于哪个列表。并且让该列表下的列表项数目加一。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> pxList<span class="token punctuation">;</span>         <span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="删除列表项"><a href="#删除列表项" class="headerlink" title="删除列表项"></a>删除列表项</h1><p>源码：</p><pre class="line-numbers language-js"><code class="language-js">UBaseType_t <span class="token function">uxListRemove</span><span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxItemToRemove <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">/* The list item knows which list it is in.  Obtain the list from the listitem. */</span>List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxList <span class="token operator">=</span> <span class="token punctuation">(</span> List_t <span class="token operator">*</span> <span class="token punctuation">)</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pvContainer<span class="token punctuation">;</span>    pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>    pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Only used during decision coverage testing. */</span>    <span class="token function">mtCOVERAGE_TEST_DELAY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Make sure the index is left pointing to a valid item. */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">==</span> pxItemToRemove <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> NULL<span class="token punctuation">;</span>    <span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token punctuation">)</span><span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实删除是很简单的，不用想都知道，要删除列表项，那肯定要知道该列表项是属于哪个列表吧，pvContainer就是记录列表项是属于哪个列表的。</p><p>删除就是把列表中的列表项从列表中去掉，其本质其实就是把他们的连接关系删除掉，然后让删除的列表项的前后两个列表连接起来就行了，假如是只有一个列表项，那么删除之后，列表就回到了初始化的状态了。</p><pre class="line-numbers language-js"><code class="language-js">pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两句代码就实现了将删除列表项的前后两个列表项连接起来。</p><p>按照上面的讲解可以理解这两句简单的代码啦。</p><p>假如删除的列表项是当前索引的列表项，那么在删除之后，列表中的pxIndex就要指向删除列表项的上一个列表项了。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">==</span> pxItemToRemove <span class="token punctuation">)</span><span class="token punctuation">{</span>      pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当然还要把当前删除的列表项的pvContainer指向NULL，让它不属于任何一个列表，因为，删除的本质是删除的仅仅是列表项的连接关系，其内存是没有释放掉的，假如是动态内存分配的话。<br>并且要把当前列表中列表项的数目返回一下。</p><p>至此，列表的源码基本讲解完毕。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>大家还可以了解一下遍历列表的宏，它在list.h文件中：</p><pre class="line-numbers language-js"><code class="language-js">define <span class="token function">listGET_OWNER_OF_NEXT_ENTRY</span><span class="token punctuation">(</span> pxTCB<span class="token punctuation">,</span> pxList <span class="token punctuation">)</span>                                        \<span class="token punctuation">{</span>                                                                                            \List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxConstList <span class="token operator">=</span> <span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span>                                                    \    <span class="token comment" spellcheck="true">/* Increment the index to the next item and return the item, ensuring */</span>                \    <span class="token comment" spellcheck="true">/* we don't return the marker used at the end of the list.  */</span>                          \    <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span>                            \    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">==</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span> <span class="token punctuation">)</span>  \    <span class="token punctuation">{</span>                                                                                       \        <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span>                        \    <span class="token punctuation">}</span>                                                                                       \    <span class="token punctuation">(</span> pxTCB <span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token operator">-</span><span class="token operator">></span>pvOwner<span class="token punctuation">;</span>                                          \<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一个宏，用于列表的遍历，返回的是列表中列表项的pxOwner成员，每次调用这个宏（函数）的时候，其pxIndex索引会指向当前返回列表项的下一个列表项。</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0开始学FreeRTOS-(消息队列)-5</title>
      <link href="/freertos-5/"/>
      <url>/freertos-5/</url>
      
        <content type="html"><![CDATA[<h2 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h2><p>曾经有人问我，FreeRTOS那么多API，到底怎么记住呢？<br>我想说，其实API不难记，就是有点难找，因为FreeRTOS的API很多都是带参宏，所以跳来跳去的比较麻烦，而且注释也很多，要找还真不是那么容易，不过也没啥，一般都会有API手册的，我就告诉大家一下：<br><strong>FreeRTOS Kernel: Reference Manual</strong><br>FreeRTOS内核：参考手册，大家可以在<a href="https://www.freertos.org/Documentation/RTOS_book.html" target="_blank" rel="noopener">官网下载</a>，也能在后台得到。<br>当然书本是英文的，如果英语像我这样子不咋地的同学，可以用谷歌浏览器在官网直接看API手册，直接翻译一下就行了。传送门：<a href="https://www.freertos.org/a00018.html" target="_blank" rel="noopener">https://www.freertos.org/a00018.html</a><br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/2019013113211022.png?" alt="Reference Manual"><br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190131133629940.png?" alt="FreeRTOS官网的API"></p><h2 id="FreeRTOS消息队列"><a href="#FreeRTOS消息队列" class="headerlink" title="FreeRTOS消息队列"></a>FreeRTOS消息队列</h2><p>基于 FreeRTOS 的应用程序由一组独立的任务构成——每个任务都是具有独立权限的程序。这些独立的任务之间的通讯与同步一般都是基于操作系统提供的IPC通讯机制，而FreeRTOS 中所有的通信与同步机制都是基于队列实现的。<br>消息队列是一种常用于任务间通信的数据结构，队列可以在任务与任务间、中断和任务间传送信息，实现了任务接收来自其他任务或中断的不固定长度的消息。任务能够从队列里面读取消息，当队列中的消息是空时，挂起读取任务，用户还可以指定挂起的任务时间；当队列中有新消息时，挂起的读取任务被唤醒并处理新消息，消息队列是一种异步的通信方式。</p><h3 id="队列特性"><a href="#队列特性" class="headerlink" title="队列特性"></a>队列特性</h3><h4 id="1-数据存储"><a href="#1-数据存储" class="headerlink" title="1.数据存储"></a>1.数据存储</h4><p>队列可以保存有限个具有确定长度的数据单元。队列可以保存的最大单元数目被称为队列的“深度”。在队列创建时需要设定其深度和每个单元的大小。<br>通常情况下，队列被作为 FIFO(先进先出)缓冲区使用，即数据由队列尾写入，从队列首读出。当然，由队列首写入也是可能的。<br>往队列写入数据是通过字节拷贝把数据复制存储到队列中；从队列读出数据使得把队列中的数据拷贝删除。 </p><h4 id="2-读阻塞"><a href="#2-读阻塞" class="headerlink" title="2.读阻塞"></a>2.读阻塞</h4><p>当某个任务试图读一个队列时，其可以指定一个阻塞超时时间。在这段时间中，如果队列为空，该任务将保持阻塞状态以等待队列数据有效。当其它任务或中断服务例程往其等待的队列中写入了数据，该任务将自动由阻塞态转移为就绪态。当等待的时间超过了指定的阻塞时间，即使队列中尚无有效数据，任务也会自动从阻塞态转移为就绪态。<br>由于队列可以被多个任务读取，所以对单个队列而言，也可能有多个任务处于阻塞状态以等待队列数据有效。这种情况下，一旦队列数据有效，只会有一个任务会被解除阻塞，这个任务就是所有等待任务中优先级最高的任务。而如果所有等待任务的优先级相同，那么被解除阻塞的任务将是等待最久的任务。</p><blockquote><p>说些题外话，ucos中是具有广播消息的，当有多个任务阻塞在队列上，当发送消息的时候可以选择广播消息，那么这些阻塞的任务都能被解除阻塞。</p></blockquote><h4 id="3-写阻塞"><a href="#3-写阻塞" class="headerlink" title="3.写阻塞"></a>3.写阻塞</h4><p>与读阻塞想反，任务也可以在写队列时指定一个阻塞超时时间。这个时间是当被写队列已满时，任务进入阻塞态以等待队列空间有效的最长时间。<br>由于队列可以被多个任务写入，所以对单个队列而言，也可能有多个任务处于阻塞状态以等待队列空间有效。这种情况下，一旦队列空间有效，只会有一个任务会被解除阻塞，这个任务就是所有等待任务中优先级最高的任务。而如果所有等待任务的优先级相同，那么被解除阻塞的任务将是等待最久的任务。</p><h3 id="消息队列的工作流程"><a href="#消息队列的工作流程" class="headerlink" title="消息队列的工作流程"></a>消息队列的工作流程</h3><h4 id="1-发送消息"><a href="#1-发送消息" class="headerlink" title="1.发送消息"></a>1.发送消息</h4><p>任务或者中断服务程序都可以给消息队列发送消息，当发送消息时，如果队列未满或者允许覆盖入队， FreeRTOS 会将消息拷贝到消息队列队尾，否则，会根据用户指定的阻塞超时时间进行阻塞，在这段时间中，如果队列一直不允许入队，该任务将保持阻塞状态以等待队列允许入队。当其它任务从其等待的队列中读取入了数据（队列未满），该任务将自动由阻塞态转为就绪态。当任务等待的时间超过了指定的阻塞时间，即使队列中还不允许入队，任务也会自动从阻塞态转移为就绪态，此时发送消息的任务或者中断程序会收到一个错误码 errQUEUE_FULL。<br>发送紧急消息的过程与发送消息几乎一样，唯一的不同是，当发送紧急消息时，发送的位置是消息队列队头而非队尾，这样，接收者就能够优先接收到紧急消息，从而及时进行消息处理。<br>下面是消息队列的发送API接口，函数中有FromISR则表明在中断中使用的。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181203195147150.png?" alt="消息队列入队（发送）的API接口"></p><pre><code>1 /*-----------------------------------------------------------*/ 2 BaseType_t xQueueGenericSend( QueueHandle_t xQueue,        (1)     3                               const void * const pvItemToQueue,     (2) 4                               TickType_t xTicksToWait,        (3) 5                               const BaseType_t xCopyPosition )    (4) 6 { 7     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired; 8     TimeOut_t xTimeOut; 9     Queue_t * const pxQueue = ( Queue_t * ) xQueue;10 11     /* 已删除一些断言操作 */12 13     for ( ;; ) {14         taskENTER_CRITICAL();                    (5)15         {16             /* 队列未满 */17             if ( ( pxQueue-&gt;uxMessagesWaiting &lt; pxQueue-&gt;uxLength )18                  || ( xCopyPosition == queueOVERWRITE ) ) {    (6)    19                 traceQUEUE_SEND( pxQueue );20                 xYieldRequired =21           prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ); (7)22 23                 /* 已删除使用队列集部分代码 */24                 /* 如果有任务在等待获取此消息队列 */25       if ( listLIST_IS_EMPTY(&amp;(pxQueue-&gt;xTasksWaitingToReceive))==pdFALSE){ (8)26                     /* 将任务从阻塞中恢复 */27             if ( xTaskRemoveFromEventList(28                   &amp;( pxQueue-&gt;xTasksWaitingToReceive ) )!=pdFALSE) { (9)29                         /* 如果恢复的任务优先级比当前运行任务优先级还高，30                         那么需要进行一次任务切换 */31                         queueYIELD_IF_USING_PREEMPTION();    (10)32                     } else {33                         mtCOVERAGE_TEST_MARKER();34                     }35                 } else if ( xYieldRequired != pdFALSE ) {36                     /* 如果没有等待的任务，拷贝成功也需要任务切换 */37                     queueYIELD_IF_USING_PREEMPTION();        (11)38                 } else {39                     mtCOVERAGE_TEST_MARKER();40                 }41 42                 taskEXIT_CRITICAL();                (12)43                 return pdPASS;44             }45             /* 队列已满 */46             else {                        (13)47                 if ( xTicksToWait == ( TickType_t ) 0 ) {48                     /* 如果用户不指定阻塞超时时间，退出 */49                     taskEXIT_CRITICAL();            (14)50                     traceQUEUE_SEND_FAILED( pxQueue );51                     return errQUEUE_FULL;52                 } else if ( xEntryTimeSet == pdFALSE ) {    53                     /* 初始化阻塞超时结构体变量，初始化进入54                 阻塞的时间xTickCount和溢出次数xNumOfOverflows */55                     vTaskSetTimeOutState( &amp;xTimeOut );        (15)56                     xEntryTimeSet = pdTRUE;57                 } else {58                     mtCOVERAGE_TEST_MARKER();59                 }60             }61         }62         taskEXIT_CRITICAL();                    (16)63         /* 挂起调度器 */64         vTaskSuspendAll();65         /* 队列上锁 */66         prvLockQueue( pxQueue );67 68         /* 检查超时时间是否已经过去了 */69         if (xTaskCheckForTimeOut(&amp;xTimeOut, &amp;xTicksToWait)==pdFALSE){ (17)70             /* 如果队列还是满的 */71             if ( prvIsQueueFull( pxQueue ) != pdFALSE ) {    (18)    72                 traceBLOCKING_ON_QUEUE_SEND( pxQueue );    73                 /* 将当前任务添加到队列的等待发送列表中74                    以及阻塞延时列表，延时时间为用户指定的超时时间xTicksToWait */75                 vTaskPlaceOnEventList(76                    &amp;( pxQueue-&gt;xTasksWaitingToSend ), xTicksToWait );(19)77                 /* 队列解锁 */78                 prvUnlockQueue( pxQueue );            (20)79 80                 /* 恢复调度器 */81                 if ( xTaskResumeAll() == pdFALSE ) {82                     portYIELD_WITHIN_API();83                 }84             } else {85                 /* 队列有空闲消息空间，允许入队 */86                 prvUnlockQueue( pxQueue );            (21)87                 ( void ) xTaskResumeAll();88             }89         } else {90             /* 超时时间已过，退出 */91             prvUnlockQueue( pxQueue );                (22)92             ( void ) xTaskResumeAll();93 94             traceQUEUE_SEND_FAILED( pxQueue );95             return errQUEUE_FULL;96         }97     }98 }99 /*-----------------------------------------------------------*/</code></pre><p>如果阻塞时间不为 0，任务会因为等待入队而进入阻塞， 在将任务设置为阻塞的过程中， 系统不希望有其它任务和中断操作这个队列的 xTasksWaitingToReceive 列表和 xTasksWaitingToSend 列表，因为可能引起其它任务解除阻塞，这可能会发生优先级翻转。比如任务 A 的优先级低于当前任务，但是在当前任务进入阻塞的过程中，任务 A 却因为其它原因解除阻塞了，这显然是要绝对禁止的。因此FreeRTOS 使用挂起调度器禁止其它任务操作队列，因为挂起调度器意味着任务不能切换并且不准调用可能引起任务切换的 API 函数。但挂起调度器并不会禁止中断，中断服务函数仍然可以操作队列阻塞列表，可能会解除任务阻塞、可能会进行上下文切换，这也是不允许的。于是，<strong>FreeRTOS解决办法是不但挂起调度器，还要给队列上锁，禁止任何中断来操作队列。</strong><br>下面来看看流程图：<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190131164341932.png?" alt="消息队列发送流程"><br>相比在任务中调用的发送函数，在中断中调用的函数会更加简单一些， 没有任务阻塞操作。<br>函数 xQueueGenericSend中插入数据后， 会检查等待接收链表是否有任务等待，如果有会恢复就绪。如果恢复的任务优先级比当前任务高， 则会触发任务切换；但是在中断中调用的这个函数的做法是返回一个参数标志是否需要触发任务切换，并不在中断中切换任务。<br>在任务中调用的函数中有锁定和解锁队列的操作， 锁定队列的时候， 队列的事件链表不能被修改。 而在被中断中发送消息的处理是： 当遇到队列被锁定的时候， 将新数据插入到队列后， 并不会直接恢复因为等待接收的任务， 而是累加了计数， 当队列解锁的时候， 会根据这个计数， 对应恢复几个任务。<br>遇到队列满的情况， 函数会直接返回， 而不是阻塞等待， 因为在中断中阻塞是不允许的！！！</p><pre><code> 1 BaseType_t xQueueGenericSendFromISR( 2        QueueHandle_t xQueue, 3        const void * const pvItemToQueue, 4        /* 不在中断函数中触发任务切换， 而是返回一个标记 */ 5        BaseType_t * const pxHigherPriorityTaskWoken, 6        const BaseType_t xCopyPosition ) 7{ 8    BaseType_t xReturn; 9    UBaseType_t uxSavedInterruptStatus;10    Queue_t * const pxQueue = ( Queue_t * ) xQueue;1112    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();13    {14        // 判断队列是否有空间插入新内容15        if( ( pxQueue-&gt;uxMessagesWaiting &lt; pxQueue-&gt;uxLength ) || ( xCopyPosition == queueOVERWRITE ) )16        {17            const int8_t cTxLock = pxQueue-&gt;cTxLock;1819            // 中断中不能使用互斥锁， 所以拷贝函数只是拷贝数据，20            // 没有任务优先级继承需要考虑21            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );2223            // 判断队列是否被锁定24            if( cTxLock == queueUNLOCKED )25            {26            #if ( configUSE_QUEUE_SETS == 1 )27                // 集合相关代码28            #else /* configUSE_QUEUE_SETS */29                {30                    // 将最高优先级的等待任务恢复到就绪链表31                    if( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )32                    {33                        if( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE)34                        {35                            // 如果有高优先级的任务被恢复36                            // 此处不直接触发任务切换， 而是返回一个标记37                            if( pxHigherPriorityTaskWoken != NULL )38                            {39                                *pxHigherPriorityTaskWoken = pdTRUE;40                            }41                        }42                    }43                }44            #endif /* configUSE_QUEUE_SETS */45            }46            else47            {48                // 队列被锁定， 不能修改事件链表49                // 增加计数， 记录需要接触几个任务到就绪50                // 在解锁队列的时候会根据这个计数恢复任务51                pxQueue-&gt;cTxLock = ( int8_t ) ( cTxLock + 1 );52            }53            xReturn = pdPASS;54        }55        else56        {57            // 队列满 直接返回 不阻塞58            xReturn = errQUEUE_FULL;59        }60    }6162    // 恢复中断的优先级63    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );6465    return xReturn;66}</code></pre><h4 id="消息队列读取"><a href="#消息队列读取" class="headerlink" title="消息队列读取"></a>消息队列读取</h4><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181203200731899.png" alt="消息读取"><br>任务调用接收函数收取队列消息， 函数首先判断当前队列是否有未读消息， 如果没有， 则会判断参数 xTicksToWait, 决定直接返回函数还是阻塞等待。<br>如果队列中有消息未读， 首先会把待读的消息复制到传进来的指针所指内， 然后判断函数参数 xJustPeeking == pdFALSE的时候， 符合的话， 说明这个函数读取了数据， 需要把被读取的数据做出队处理， 如果不是， 则只是查看一下（peek），只是返回数据，但是不会把数据清除。<br>对于正常读取数据的操作， 清除数据后队列会空出空位， 所以查看队列中的等待列表中是否有任务等发送数据而被挂起， 有的话恢复一个任务就绪， 并根据优先级判断是否需要出进行任务切换。<br>对于只是查看数据的， 由于没有清除数据， 所以没有空间新空出，不需要检查发送等待链表， 但是会检查接收等待链表， 如果有任务挂起会切换其到就绪并判断是否需要切换。</p><p>消息队列出队过程分析，其实跟入队差不多，请看注释：</p><pre><code> 1 /*-----------------------------------------------------------*/ 2 BaseType_t xQueueGenericReceive( QueueHandle_t xQueue,        (1)     3                                  void * const pvBuffer,        (2) 4                                  TickType_t xTicksToWait,    (3)     5                                  const BaseType_t xJustPeeking )    (4) 6 { 7     BaseType_t xEntryTimeSet = pdFALSE; 8     TimeOut_t xTimeOut; 9     int8_t *pcOriginalReadPosition;10     Queue_t * const pxQueue = ( Queue_t * ) xQueue;11 12     /* 已删除一些断言 */13     for ( ;; ) {14         taskENTER_CRITICAL();                    (5)15         {16             const UBaseType_t uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting; 17 18             /* 看看队列中有没有消息 */19             if ( uxMessagesWaiting &gt; ( UBaseType_t ) 0 ) {    (6)    20                 /*防止仅仅是读取消息，而不进行消息出队操作*/21                 pcOriginalReadPosition = pxQueue-&gt;u.pcReadFrom;    (7)22                 /* 拷贝消息到用户指定存放区域pvBuffer */23                 prvCopyDataFromQueue( pxQueue, pvBuffer );    (8)24 25                 if ( xJustPeeking == pdFALSE ) {        (9)26                     /* 读取消息并且消息出队 */27                     traceQUEUE_RECEIVE( pxQueue );    28 29                     /* 获取了消息，当前消息队列的消息个数需要减一 */30                     pxQueue-&gt;uxMessagesWaiting = uxMessagesWaiting - 1;  (10)31                     /* 判断一下消息队列中是否有等待发送消息的任务 */32                     if ( listLIST_IS_EMPTY(            (11)33                              &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE ) {34                         /* 将任务从阻塞中恢复 */35                         if ( xTaskRemoveFromEventList(        (12)36                                  &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE ) {37                             /* 如果被恢复的任务优先级比当前任务高，会进行一次任务切换 */38                             queueYIELD_IF_USING_PREEMPTION();    (13)39                         } else {40                             mtCOVERAGE_TEST_MARKER();41                         }42                     } else {43                         mtCOVERAGE_TEST_MARKER();44                     }45                 } else {                    (14)46                     /* 任务只是看一下消息（peek），并不出队 */    47                     traceQUEUE_PEEK( pxQueue );48 49                     /* 因为是只读消息 所以还要还原读消息位置指针 */50                     pxQueue-&gt;u.pcReadFrom = pcOriginalReadPosition; (15)51 52                     /* 判断一下消息队列中是否还有等待获取消息的任务 */53                     if ( listLIST_IS_EMPTY(            (16)54                              &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE ) {55                         /* 将任务从阻塞中恢复 */56                         if ( xTaskRemoveFromEventList(            57                               &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE ) {58                             /* 如果被恢复的任务优先级比当前任务高，会进行一次任务切换 */59                             queueYIELD_IF_USING_PREEMPTION();    60                         } else {61                             mtCOVERAGE_TEST_MARKER();62                         }63                     } else {64                         mtCOVERAGE_TEST_MARKER();65                     }66                 }67 68                 taskEXIT_CRITICAL();                (17)69                 return pdPASS;70             } else {                        (18)71                 /* 消息队列中没有消息可读 */72                 if ( xTicksToWait == ( TickType_t ) 0 ) {    (19)    73                     /* 不等待，直接返回 */74                     taskEXIT_CRITICAL();75                     traceQUEUE_RECEIVE_FAILED( pxQueue );76                     return errQUEUE_EMPTY;77                 } else if ( xEntryTimeSet == pdFALSE ) {        78                     /* 初始化阻塞超时结构体变量，初始化进入79                     阻塞的时间xTickCount和溢出次数xNumOfOverflows */80                     vTaskSetTimeOutState( &amp;xTimeOut );        (20)81                     xEntryTimeSet = pdTRUE;82                 } else {83                     mtCOVERAGE_TEST_MARKER();84                 }85             }86         }87         taskEXIT_CRITICAL();                    88 89         vTaskSuspendAll();90         prvLockQueue( pxQueue );                (21)91 92         /* 检查超时时间是否已经过去了*/93         if ( xTaskCheckForTimeOut( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE ) {(22)94             /* 如果队列还是空的 */95             if ( prvIsQueueEmpty( pxQueue ) != pdFALSE ) {96                 traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );    (23)    97                 /* 将当前任务添加到队列的等待接收列表中98                    以及阻塞延时列表，阻塞时间为用户指定的超时时间xTicksToWait */99                 vTaskPlaceOnEventList(                100                     &amp;( pxQueue-&gt;xTasksWaitingToReceive ), xTicksToWait );101                 prvUnlockQueue( pxQueue );102                 if ( xTaskResumeAll() == pdFALSE ) {        103                     /* 如果有任务优先级比当前任务高，会进行一次任务切换 */104                     portYIELD_WITHIN_API();            105                 } else {106                     mtCOVERAGE_TEST_MARKER();107                 }108             } else {109                 /* 如果队列有消息了，就再试一次获取消息 */110                 prvUnlockQueue( pxQueue );            (24)111                 ( void ) xTaskResumeAll();112             }113         } else {114             /* 超时时间已过，退出 */115             prvUnlockQueue( pxQueue );                (25)116             ( void ) xTaskResumeAll();117 118             if ( prvIsQueueEmpty( pxQueue ) != pdFALSE ) {119                 /* 如果队列还是空的，返回错误代码errQUEUE_EMPTY */120                 traceQUEUE_RECEIVE_FAILED( pxQueue );121                 return errQUEUE_EMPTY;                (26)122             } else {123                 mtCOVERAGE_TEST_MARKER();124             }125         }126     }127 }128 /*-----------------------------------------------------------*/</code></pre><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>如果队列存储的数据较大时，那最好是利用队列来传递数据的指针而不是数据本身，因为传递数据的时候是需要CPU一字节一字节地将数据拷贝进队列或从队列拷贝出来。而传递指针无论是在处理速度上还是内存空间利用上都更有效。但是，当利用队列传递指针时，一定要十分小心地做到以下两点：</p><h4 id="1-指针指向的内存空间的所有权必须明确"><a href="#1-指针指向的内存空间的所有权必须明确" class="headerlink" title="1.指针指向的内存空间的所有权必须明确"></a>1.指针指向的内存空间的所有权必须明确</h4><p>当任务间通过指针共享内存时，应该从根本上保证所不会有任意两个任务同时修改共享内存中的数据，或是以其它行为方式使得共享内存数据无效或产生一致性问题。原则上，共享内存在其指针发送到队列之前，其内容只允许被发送任务访问；共享内存指针从队列中被读出之后，其内容亦只允许被接收任务访问。</p><h4 id="2-指针指向的内存空间必须有效"><a href="#2-指针指向的内存空间必须有效" class="headerlink" title="2.指针指向的内存空间必须有效"></a>2.指针指向的内存空间必须有效</h4><p>如果指针指向的内存空间是动态分配的，只应该有一个任务负责对其进行内存释放。当这段内存空间被释放之后，就不应该有任何一个任务再访问这段空间。<br>并且最最最重要的是禁止使用指针访问<strong>任务栈上</strong>的空间，也就是局部变量。因为当栈发生改变后，栈上的数据将不再有效。</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0开始学FreeRTOS-(任务调度)-4</title>
      <link href="/freertos-4/"/>
      <url>/freertos-4/</url>
      
        <content type="html"><![CDATA[<p>大家晚上好，我是杰杰，最近挺忙的，好久没有更新了，今天周末就吐血更新一下吧！</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>FreeRTOS</code>是一个是实时内核，任务是程序执行的最小单位，也是调度器处理的基本单位，移植了<code>FreeRTOS</code>，则避免不了对任务的管理，在多个任务运行的时候，任务切换显得尤为重要。而任务切换的效率会决定了系统的稳定性与效率。</p><p><code>FreeRTOS</code>的任务切换是干嘛的呢，<code>rtos</code>的实际是永远运行的是具有最高优先级的运行态任务，而那些之前在就绪态的任务怎么变成运行态使其得以运行呢，这就是我们<code>FreeRTOS</code>任务切换要做的事情，它要做的是找到最高优先级的就绪态任务，并且让它获得cpu的使用权，这样，它就能从就绪态变成运行态，这样子，整个系统的实时性就会很好，响应也会很好，而不会让程序阻塞卡死。</p><p>要知道怎么实现任务切换，那就要知道任务切换的机制，在不同的<code>cpu（mcu）</code>中，触发的方式可能会不一样，现在是以Cortex-M3为例来讲讲任务的切换。为了大家能看懂本文，我就抛转引玉一下，<code>引用《Cortex-M3权威指南-中文版》的部分语句（如涉及侵权，请联系杰杰删除）</code></p><h1 id="SVC-和-PendSV"><a href="#SVC-和-PendSV" class="headerlink" title="SVC 和 PendSV"></a>SVC 和 PendSV</h1><p>SVC（系统服务调用，亦简称系统调用）和 <code>PendSV</code>（<code>Pended System Call</code>，可悬起系统调用），它们多用于在操作系统之上的软件开发中。<code>SVC</code> 用于产生系统函数的调用请求。例如，操作系统不让用户程序直接访问硬件，而是通过提供一些系统服务函数，用户程序使用 SVC 发出对系统服务函数的呼叫请求，以这种方法调用它们来间接访问硬件。因此，当用户程序想要控制特定的硬件时，它就会产生一个 <code>SVC</code> 异常，然后操作系统提供的 <code>SVC</code> 异常服务例程得到执行，它再调用相关的操作系统函数，后者完成用户程序请求的服务。</p><p>另一个相关的异常是<code>PendSV</code>（可悬起的系统调用），它和 <code>SVC</code> 协同使用。一方面，<code>SVC</code>异常是必须立即得到响应的（若因优先级不比当前正处理的高，或是其它原因使之无法立即响应，将发生硬 fault——译者注），应用程序执行 <code>SVC</code> 时都是希望所需的请求立即得到响应。另一方面，PendSV 则不同，它是可以像普通的中断一样被悬起的（不像 <code>SVC</code> 那样）。OS 可以利用它“缓期执行”一个异常——直到其它重要的任务完成后才执行动作。悬起 <code>PendSV</code> 的方法是：手工往 <code>NVIC</code> 的<code>PendSV</code> 悬起寄存器中写 1。悬起后，如果优先级不够高，则将缓期等待执行。</p><p>如果一个发生的异常不能被即刻响应，就称它被“悬起”(pending)。不过，少数 fault异常是不允许被悬起的。一个异常被悬起的原因，可能是系统当前正在执行一个更高优先级异常的服务例程，或者因相关掩蔽位的设置导致该异常被除能。对于每个异常源，在被悬起的情况下，都会有一个对应的“悬起状态寄存器”保存其异常请求，直到该异常能够执行为止，这与传统的 ARM 是完全不同的。在以前，是由产生中断的设备保持住请求信号。现在NVIC 的悬起状态寄存器的出现解决了这个问题，即使后来设备已经释放了请求信号，曾经的中断请求也不会错失。</p><h1 id="系统任务切换的工程分析"><a href="#系统任务切换的工程分析" class="headerlink" title="系统任务切换的工程分析"></a>系统任务切换的工程分析</h1><p>在系统中正常执行的任务（假设没有外部中断<code>IRQ</code>），用<code>Systick</code>直接做上下文切换是完全没有问题的，如图：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/switch.png" alt="switch"></p><p>但是问题是几乎很少嵌入式的设备会不用其丰富的中断响应，所以，直接用systick做系统的上下文切换那是不实际的，这存在很大的风险，因为假设<code>systick</code>打断了一个中断（<code>IRQ</code>），立即做出上下文切换的话，则触犯用法 <code>fault</code>异常，除了重启你没有其他办法了，这样子做出来的产品就是垃圾！！用我老板的话说就是写的什么狗屎！！！如图所示：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/IRQ-switch.png" alt="IRQ-switch"></p><p>那这么说这样不行那也不行，怎么办啊？请看看前面接介绍的<code>PendSV</code>，是不是有点豁然开朗了？<code>PendSV</code> 来完美解决这个问题。<code>PendSV</code> 异常会自动延迟上下文切换的请求，直到其它的<code>ISR</code> 都完成了处理后才放行。为实现这个机制，需要把 <code>PendSV</code> 编程为最低优先级的异常。如果<code>OS</code>检测到某 <code>IRQ</code>正在活动并且被 SysTick 抢占，它将悬起一个 <code>PendSV</code> 异常，以便缓期执行上下文切换。</p><p>懂了吗？就是说，只要将<code>PendSV</code>的优先级设为最低的，systick即使是打断了IRQ，它也不会马上进行上下文切换，而是等到IRQ执行完，<code>PendSV</code> 服务例程才开始执行，并且在里面执行上下文切换。过程如图所示：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/pendsv-switch.png" alt="pendsv-switch"></p><h1 id="任务切换的源码实现"><a href="#任务切换的源码实现" class="headerlink" title="任务切换的源码实现"></a>任务切换的源码实现</h1><p>过程差不多了解了，那看看FreeRTOS中怎么实现吧！！</p><p>FreeRTOS有两种方法触发任务切换：</p><ol><li><p>一种就是<code>systick</code>触发<code>PendSV</code>异常，这是最经常使用的。</p></li><li><p>另一种是主动进行切换任务，执行系统调用，比如普通任务可以使用taskYIELD()强制任务切换，中断服务程序中使用<code>portYIELD_FROM_ISR()</code>强制任务切换。</p></li></ol><h2 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h2><p>先说说第一种吧，就在<code>systick</code>中断中调用<code>xPortSysTickHandler()</code>;</p><p>下面是源码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">xPortSysTickHandler</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">vPortRaiseBASEPRI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Increment the RTOS tick. */</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">xTaskIncrementTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> pdFALSE <span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* A context switch is required.  Context switching is performed in            the PendSV interrupt.  Pend the PendSV interrupt. */</span>            portNVIC_INT_CTRL_REG <span class="token operator">=</span> portNVIC_PENDSVSET_BIT<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">vPortClearBASEPRIFromISR</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它的执行过程是这样子的，屏蔽所有中断，因为SysTick以最低的中断优先级运行，所以当这个中断执行时所有中断必须被屏蔽。vPortRaiseBASEPRI();就是屏蔽所有中断的。而且并不需要保存本次中断的值，因为systick的中断优先级是已知的，执行完直接恢复所有中断即可。</p><p>在<code>xTaskIncrementTick()</code>中会对<code>tick</code>的计数值进行自加，然后检查有没有处于就绪态的最优先级任务，如果有，则返回非零值，然后表示需要进行任务切换，而并非马上进行任务切换，此处要注意，它只是向中断状态寄存器<code>bit28</code>位写入<code>1</code>，只是将<code>PendSV</code>挂起，假如没有比<code>PendSV</code>更高优先级的中断，它才会进入<code>PendSV</code>中断服务函数进行任务切换。</p><pre class="line-numbers language-js"><code class="language-js">#define portNVIC_PENDSVSET_BIT        <span class="token punctuation">(</span> 1UL <span class="token operator">&lt;</span><span class="token operator">&lt;</span> 28UL <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后解除屏蔽所有中断。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">vPortClearBASEPRIFromISR</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h2><p>另一种方法是主动进行任务切换，不管是使用taskYIELD()还是portYIELD_FROM_ISR()，最终都会执行下面的代码：</p><pre class="line-numbers language-js"><code class="language-js">#define <span class="token function">portYIELD</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                                                \<span class="token punctuation">{</span>                                                                                \    <span class="token comment" spellcheck="true">/* Set a PendSV to request a context switch. */</span>                             \    portNVIC_INT_CTRL_REG <span class="token operator">=</span> portNVIC_PENDSVSET_BIT<span class="token punctuation">;</span>                             \                                                                           <span class="token function">__dsb</span><span class="token punctuation">(</span> portSY_FULL_READ_WRITE <span class="token punctuation">)</span><span class="token punctuation">;</span>                                            \    <span class="token function">__isb</span><span class="token punctuation">(</span> portSY_FULL_READ_WRITE <span class="token punctuation">)</span><span class="token punctuation">;</span>                                            \<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这<code>portYIELD()</code>其实是一个宏定义来的。同样是向中断状态寄存器<code>bit28位写入1</code>，将<code>PendSV</code>挂起，然后等待任务的切换。</p><p>具体的任务切换源码</p><p>一直在说怎么进行任务切换的，好像还没看到任务切换的源码啊，哎，下面来看看任务切换的真面目！！</p><pre class="line-numbers language-js"><code class="language-js">__asm <span class="token keyword">void</span> <span class="token function">xPortPendSVHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    extern uxCriticalNesting<span class="token punctuation">;</span>    extern pxCurrentTCB<span class="token punctuation">;</span>    extern vTaskSwitchContext<span class="token punctuation">;</span>    PRESERVE8    mrs r0<span class="token punctuation">,</span> psp    isb    ldr r3<span class="token punctuation">,</span> <span class="token operator">=</span>pxCurrentTCB       <span class="token comment" spellcheck="true">/* Get the location of the current TCB. */</span>    ldr r2<span class="token punctuation">,</span> <span class="token punctuation">[</span>r3<span class="token punctuation">]</span>    stmdb r0<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>r4<span class="token operator">-</span>r11<span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">/* Save the remaining registers. */</span>    str r0<span class="token punctuation">,</span> <span class="token punctuation">[</span>r2<span class="token punctuation">]</span>                <span class="token comment" spellcheck="true">/* Save the new top of stack into the first member of the TCB. */</span>    stmdb sp<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>r3<span class="token punctuation">,</span> r14<span class="token punctuation">}</span>    mov r0<span class="token punctuation">,</span> #configMAX_SYSCALL_INTERRUPT_PRIORITY    msr basepri<span class="token punctuation">,</span> r0    dsb    isb    bl vTaskSwitchContext    mov r0<span class="token punctuation">,</span> #<span class="token number">0</span>    msr basepri<span class="token punctuation">,</span> r0    ldmia sp<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>r3<span class="token punctuation">,</span> r14<span class="token punctuation">}</span>    ldr r1<span class="token punctuation">,</span> <span class="token punctuation">[</span>r3<span class="token punctuation">]</span>    ldr r0<span class="token punctuation">,</span> <span class="token punctuation">[</span>r1<span class="token punctuation">]</span>                <span class="token comment" spellcheck="true">/* The first item in pxCurrentTCB is the task top of stack. */</span>    ldmia r0<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>r4<span class="token operator">-</span>r11<span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">/* Pop the registers and the critical nesting count. */</span>    msr psp<span class="token punctuation">,</span> r0    isb    bx r14    nop<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不是我不想看，是我看到汇编就头大啊，这几天我也在看源码，实在是头大。</p><p>找到核心的函数看看就好啦，不管那么多，有兴趣的可以研究一下中断代码，有不懂的也很欢迎你们来问我，一起研究研究，也是不错的选择。</p><p>下面是看重点的地方了：</p><pre class="line-numbers language-js"><code class="language-js">mov r0<span class="token punctuation">,</span>             #configMAX_SYSCALL_INTERRUPT_PRIORITYmsr basepri<span class="token punctuation">,</span> r0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两句代码是关闭中断的。关中断就得干活了，嘿嘿嘿~</p><pre class="line-numbers language-js"><code class="language-js">bl vTaskSwitchContext<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>BL是跳转指令嘛，这个我还是有点懂的。</p><p>调用函数<code>vTaskSwitchContext()</code>,寻找新的任务运行,通过使变量<code>pxCurrentTCB</code>指向新的任务来实现任务切换,然后就是打开中断，退出去了。</p><p>寻找下一个要运行任务</p><p>是不是感觉没什么大不了的样子，如果你是这样子觉得的，可能还没学到家，赶紧去看看<code>FreeRTOS</code>的源码，在<code>config.h</code>配置文件中是不是有一个叫做硬件查找下一个运行的任务呢？<code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code>，这个在<code>FreeRTOS</code>中叫做特殊方法，其实也是硬件查找啦，但是并不是每种单片机都支持的，如果是不支持的话，只能选择软件查找的方法了，就是所谓的通用方法。通用方法我就不多说了，因为我用的是<code>STM32</code>，他是<code>支持硬件方法</code>的，这样子效率更高，所以我也没必要去研究他的软件方法，假如有兴趣的小伙伴可以研读一下源码，有不懂的可以向我提问，源码如下：</p><pre class="line-numbers language-js"><code class="language-js">#define <span class="token function">taskSELECT_HIGHEST_PRIORITY_TASK</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                                            \    <span class="token punctuation">{</span>                                                                                                   \    UBaseType_t uxTopPriority <span class="token operator">=</span> uxTopReadyPriority<span class="token punctuation">;</span>                                                     \                                                                                                        \        <span class="token comment" spellcheck="true">/* Find the highest priority queue that contains ready tasks. */</span>                                \        <span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token function">listLIST_IS_EMPTY</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxReadyTasksLists<span class="token punctuation">[</span> uxTopPriority <span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span>                           \        <span class="token punctuation">{</span>                                                                                               \            <span class="token function">configASSERT</span><span class="token punctuation">(</span> uxTopPriority <span class="token punctuation">)</span><span class="token punctuation">;</span>                                                              \            <span class="token operator">--</span>uxTopPriority<span class="token punctuation">;</span>                                                                            \        <span class="token punctuation">}</span>                                                                                               \                                                                                                        \        <span class="token comment" spellcheck="true">/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of                        \        the same priority get an equal share of the processor time. */</span>                                  \        <span class="token function">listGET_OWNER_OF_NEXT_ENTRY</span><span class="token punctuation">(</span> pxCurrentTCB<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxReadyTasksLists<span class="token punctuation">[</span> uxTopPriority <span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>           \        uxTopReadyPriority <span class="token operator">=</span> uxTopPriority<span class="token punctuation">;</span>                                                             \    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* taskSELECT_HIGHEST_PRIORITY_TASK */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而硬件的方法源码则在下面：</p><pre class="line-numbers language-js"><code class="language-js">    #define <span class="token function">taskSELECT_HIGHEST_PRIORITY_TASK</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                                      \    <span class="token punctuation">{</span>                                                                                               \        UBaseType_t uxTopPriority<span class="token punctuation">;</span>                                                                  \                                                                                                    \        <span class="token comment" spellcheck="true">/* Find the highest priority list that contains ready tasks. */</span>                             \        <span class="token function">portGET_HIGHEST_PRIORITY</span><span class="token punctuation">(</span> uxTopPriority<span class="token punctuation">,</span> uxTopReadyPriority <span class="token punctuation">)</span><span class="token punctuation">;</span>                              \        <span class="token function">configASSERT</span><span class="token punctuation">(</span> <span class="token function">listCURRENT_LIST_LENGTH</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxReadyTasksLists<span class="token punctuation">[</span> uxTopPriority <span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>     \        <span class="token function">listGET_OWNER_OF_NEXT_ENTRY</span><span class="token punctuation">(</span> pxCurrentTCB<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxReadyTasksLists<span class="token punctuation">[</span> uxTopPriority <span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>       \    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* taskSELECT_HIGHEST_PRIORITY_TASK() */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其方法是利用硬件提供的计算前导零指令CLZ，具体宏定义为：</p><pre class="line-numbers language-js"><code class="language-js">#define <span class="token function">portGET_HIGHEST_PRIORITY</span><span class="token punctuation">(</span> uxTopPriority<span class="token punctuation">,</span> uxReadyPriorities <span class="token punctuation">)</span> uxTopPriority <span class="token operator">=</span> <span class="token punctuation">(</span> 31UL <span class="token operator">-</span> <span class="token punctuation">(</span> uint32_t <span class="token punctuation">)</span> <span class="token function">__clz</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> uxReadyPriorities <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>静态变量<code>uxTopReadyPriority</code>包含了处于就绪态任务的最高优先级的信息，因为<code>FreeRTOS</code>运行的永远是处于最高优先级的运行态，而下个处于最高优先级的就绪态则必定会在下次任务切换的时候运行，<code>uxTopReadyPriority</code>使用每一位来表示任务是否处于就绪态，比如变量<code>uxTopReadyPriority</code>的<code>bit0为1</code>，则表示存在优先级为0的任务处于就绪态，<code>bit6为1</code>则表示存在优先级为6的任务处于就绪态。并且，由于<code>bit0</code>的优先级高于<code>bit6</code>，那么下个任务就是bit0的任务运行了（数组越低优先级越高）。由于32位整形数最多只有<code>32</code>位，因此使用这种特殊方法限定最大可用优先级数目为<code>32</code>，即优先级<code>0~31</code>。得到了下个处于最高优先级就绪态任务了，就调用<code>listGET_OWNER_OF_NEXT_ENTRY</code>来获取下一个任务的列表项，然后将该列表项的任务控制块TCB赋值给<code>pxCurrentTCB</code>，那么我们就得到下一个要运行的任务了。</p><p>至此，任务切换已经完成。</p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0开始学FreeRTOS-(列表与列表项)-3</title>
      <link href="/freertos-3/"/>
      <url>/freertos-3/</url>
      
        <content type="html"><![CDATA[<h1 id="FreeRTOS列表-amp-列表项的源码解读"><a href="#FreeRTOS列表-amp-列表项的源码解读" class="headerlink" title="FreeRTOS列表&amp;列表项的源码解读"></a>FreeRTOS列表&amp;列表项的源码解读</h1><p>第一次看列表与列表项的时候，感觉很像是链表，虽然我自己的链表也不太会，但是就是感觉很像。</p><p>在<code>FreeRTOS</code>中，列表与列表项使用得非常多，是<code>FreeRTOS</code>的一个数据结构，学习过数据结构的同学都知道，数据结构能使我们处理数据更加方便快速，能快速找到数据，在<code>FreeRTOS</code>中，这种列表与列表项更是必不可少的，能让我们的系统跑起来更加流畅迅速。</p><p>言归正传，<code>FreeRTOS</code>中使用了大量的列表<code>（List）</code>与列表项<code>（Listitem）</code>，在<code>FreeRTOS</code>调度器中，就是用到这些来跟着任务，了解任务的状态，处于挂起、阻塞态、还是就绪态亦或者是运行态。这些信息都会在各自任务的列表中得到。</p><p>看任务控制块<code>（tskTaskControlBlock）</code>中的两个列表项：</p><pre class="line-numbers language-js"><code class="language-js">ListItem_t xStateListItem<span class="token punctuation">;</span> <span class="token regex">/ * &lt;任务的状态列表项目引用的列表表示该任务的状态（就绪，已阻止，暂停）。*/</span>ListItem_t xEventListItem<span class="token punctuation">;</span> <span class="token regex">/ * &lt;用于从事件列表中引用任务。*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一个是状态的列表项，一个是事件列表项。他们在创建任务就会被初始化，列表项的初始化是根据实际需要来初始化的，下面会说。</p><h1 id="FreeRTOS列表-amp-列表项的结构体"><a href="#FreeRTOS列表-amp-列表项的结构体" class="headerlink" title="FreeRTOS列表&amp;列表项的结构体"></a>FreeRTOS列表&amp;列表项的结构体</h1><p>既然知道列表与列表项的重要性，那么我们来解读FreeRTOS中的list.c与list.h的源码吧。从头文件lsit.h开始，看到定义了一些结构体：</p><pre class="line-numbers language-js"><code class="language-js">struct xLIST_ITEM<span class="token punctuation">{</span>listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE <span class="token regex">/ * &lt;如果configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES设置为1，则设置为已知值。* /</span>configLIST_VOLATILE TickType_t xItemValue<span class="token punctuation">;</span> <span class="token regex">/ * &lt;正在列出的值。在大多数情况下，这用于按降序对列表进行排序。 * /</span>struct xLIST_ITEM <span class="token operator">*</span> configLIST_VOLATILE pxNext<span class="token punctuation">;</span> <span class="token regex">/ * &lt;指向列表中下一个ListItem_t的指针。 * /</span>struct xLIST_ITEM <span class="token operator">*</span> configLIST_VOLATILE pxPrevious<span class="token punctuation">;</span> <span class="token regex">/ * &lt;指向列表中前一个ListItem_t的指针。 * /</span><span class="token keyword">void</span> <span class="token operator">*</span> pvOwner<span class="token punctuation">;</span> <span class="token regex">/ * &lt;指向包含列表项目的对象（通常是TCB）的指针。因此，包含列表项目的对象与列表项目本身之间存在双向链接。 * /</span><span class="token keyword">void</span> <span class="token operator">*</span> configLIST_VOLATILE pvContainer<span class="token punctuation">;</span> <span class="token regex">/ * &lt;指向此列表项目所在列表的指针（如果有）。 * /</span>listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE <span class="token regex">/ * &lt;如果configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES设置为1，则设置为已知值。* /</span><span class="token punctuation">}</span><span class="token punctuation">;</span>typedef struct xLIST_ITEM ListItem_t<span class="token punctuation">;</span> <span class="token regex">/ *由于某种原因，lint希望将其作为两个单独的定义。 * /</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="列表项结构体的一些注意的地方："><a href="#列表项结构体的一些注意的地方：" class="headerlink" title="列表项结构体的一些注意的地方："></a>列表项结构体的一些注意的地方：</h2><p><code>xItemValue</code> 用于列表项的排序，类似1—2—3—4</p><p><code>pxNext</code> 指向下一个列表项的指针</p><p><code>pxPrevious</code> 指向上（前）一个列表项的指针</p><p>这两个指针实现了类似双向链表的功能</p><p><code>pvOwner</code> 指向包含列表项目的对象（<code>通常是任务控制块TCB</code>）的指针。因此，包含列表项目的对象与列表项目本身之间存在双向链接。</p><p><code>pvContainer</code> 记录了该列表项属于哪个列表，说白点就是这个儿子是谁生的。。。</p><p>同时定义了一个MINI的列表项的结构体，MINI列表项是删减版的列表项，因为很多时候不需要完全版的列表项。就不用浪费那么多内存空间了，这或许就是FreeRTOS是轻量级操作系统的原因吧，能省一点是一点。MINI列表项：</p><pre class="line-numbers language-js"><code class="language-js">struct xMINI_LIST_ITEM<span class="token punctuation">{</span>    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE           <span class="token comment" spellcheck="true">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span>    configLIST_VOLATILE TickType_t xItemValue<span class="token punctuation">;</span>    struct xLIST_ITEM <span class="token operator">*</span> configLIST_VOLATILE pxNext<span class="token punctuation">;</span>    struct xLIST_ITEM <span class="token operator">*</span> configLIST_VOLATILE pxPrevious<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>typedef struct xMINI_LIST_ITEM MiniListItem_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再定义了一个列表的结构体，可能看到这里，一些同学已经蒙了，列表与列表项是啥关系啊，按照杰杰的理解，是类似父子关系的，一个列表中，包含多个列表项，就像一个父亲，生了好多孩子，而列表就是父亲，列表项就是孩子。</p><pre class="line-numbers language-js"><code class="language-js">typedef struct xLIST<span class="token punctuation">{</span>listFIRST_LIST_INTEGRITY_CHECK_VALUE <span class="token regex">/ * &lt;如果configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES设置为1，则设置为已知值。* /</span>configLIST_VOLATILE UBaseType_t uxNumberOfItems<span class="token punctuation">;</span>ListItem_t <span class="token operator">*</span> configLIST_VOLATILE pxIndex<span class="token punctuation">;</span> <span class="token regex">/ * &lt;用于遍历列表。 指向由listGET_OWNER_OF_NEXT_ENTRY（）调用返回的后一个列表项。*/</span>MiniListItem_t xListEnd<span class="token punctuation">;</span> <span class="token regex">/ * &lt;List item包含最大可能的项目值，这意味着它始终在列表的末尾，因此用作标记。*/</span>listSECOND_LIST_INTEGRITY_CHECK_VALUE <span class="token regex">/ * &lt;如果configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES设置为1，则设置为已知值。* /</span><span class="token punctuation">}</span> List_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>列表的结构体中值得注意的是：<br><code>uxNumberOfItems</code> 是用来记录列表中列表项的数量的，就是记录父亲有多少个儿子，当然女儿也行~。</p><p><code>pxIndex</code> 是索引编号，用来遍历列表的，调用宏<code>listGET_OWNER_OF_NEXT_ENTRY（）</code>之后索引就会指向返回当前列表项的下一个列表项。</p><p><code>xListEnd</code> 指向的是最后一个列表项，并且这个列表项是<code>MiniListItem</code>属性的，是一个迷你列表项。</p><h1 id="列表的初始化"><a href="#列表的初始化" class="headerlink" title="列表的初始化"></a>列表的初始化</h1><p>  函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vListInitialise</span><span class="token punctuation">(</span> List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxList <span class="token punctuation">)</span><span class="token punctuation">{</span>    pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">/*lint The mini list structure is used as the list end to save RAM.  This is checked and valid. */</span>    pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd<span class="token punctuation">.</span>xItemValue <span class="token operator">=</span> portMAX_DELAY<span class="token punctuation">;</span>    pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd<span class="token punctuation">.</span>pxNext <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/*lint The mini list structure is used as the list end to save RAM.  This is checked and valid. */</span>    pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd<span class="token punctuation">.</span>pxPrevious <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*lint The mini list structure is used as the list end to save RAM.  This is checked and valid. */</span>    pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token operator">=</span> <span class="token punctuation">(</span> UBaseType_t <span class="token punctuation">)</span> 0U<span class="token punctuation">;</span>    <span class="token function">listSET_LIST_INTEGRITY_CHECK_1_VALUE</span><span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listSET_LIST_INTEGRITY_CHECK_2_VALUE</span><span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将列表的索引指向列表中的<code>xListEnd</code>，也就是末尾的列表项<code>（迷你列表项）</code></p><p>列表项的<code>xItemValue</code>数值为<code>portMAX_DELAY</code>，也就是<code>0xffffffffUL</code>，如果在16位处理器中则为<code>0xffff</code>。</p><p>列表项的pxNext与pxPrevious这两个指针都指向自己本身<code>xListEnd</code>。</p><p>初始化完成的时候列表项的数目为<code>0</code>个。因为还没添加列表项嘛~。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos4.png" alt="freertos4"></p><h1 id="列表项的初始化"><a href="#列表项的初始化" class="headerlink" title="列表项的初始化"></a>列表项的初始化</h1><p> 函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vListInitialiseItem</span><span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxItem <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* Make sure the list item is not recorded as being on a list. */</span>    pxItem<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> NULL<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Write known values into the list item if    configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span>    <span class="token function">listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE</span><span class="token punctuation">(</span> pxItem <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE</span><span class="token punctuation">(</span> pxItem <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只需要让列表项的pvContainer指针指向NULL即可，这样子就使得列表项不属于任何一个列表，因为列表项的初始化是要根据实际的情况来进行初始化的。</p><p>例如任务创建时用到的一些列表项初始化：</p><pre class="line-numbers language-js"><code class="language-js">pxNewTCB<span class="token operator">-</span><span class="token operator">></span>pcTaskName<span class="token punctuation">[</span> configMAX_TASK_NAME_LEN <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>pxNewTCB<span class="token operator">-</span><span class="token operator">></span>uxPriority <span class="token operator">=</span> uxPriority<span class="token punctuation">;</span>pxNewTCB<span class="token operator">-</span><span class="token operator">></span>uxBasePriority <span class="token operator">=</span> uxPriority<span class="token punctuation">;</span>pxNewTCB<span class="token operator">-</span><span class="token operator">></span>uxMutexesHeld <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">vListInitialiseItem</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxNewTCB<span class="token operator">-</span><span class="token operator">></span>xStateListItem <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">vListInitialiseItem</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxNewTCB<span class="token operator">-</span><span class="token operator">></span>xEventListItem <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>又或者是在定时器相关的初始化中：</p><pre class="line-numbers language-js"><code class="language-js">pxNewTimer<span class="token operator">-</span><span class="token operator">></span>pcTimerName <span class="token operator">=</span> pcTimerName<span class="token punctuation">;</span>pxNewTimer<span class="token operator">-</span><span class="token operator">></span>xTimerPeriodInTicks <span class="token operator">=</span> xTimerPeriodInTicks<span class="token punctuation">;</span>pxNewTimer<span class="token operator">-</span><span class="token operator">></span>uxAutoReload <span class="token operator">=</span> uxAutoReload<span class="token punctuation">;</span>pxNewTimer<span class="token operator">-</span><span class="token operator">></span>pvTimerID <span class="token operator">=</span> pvTimerID<span class="token punctuation">;</span>pxNewTimer<span class="token operator">-</span><span class="token operator">></span>pxCallbackFunction <span class="token operator">=</span> pxCallbackFunction<span class="token punctuation">;</span><span class="token function">vListInitialiseItem</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxNewTimer<span class="token operator">-</span><span class="token operator">></span>xTimerListItem <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="列表项的末尾插入"><a href="#列表项的末尾插入" class="headerlink" title="列表项的末尾插入"></a>列表项的末尾插入</h1><p>  函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vListInsertEnd</span><span class="token punctuation">(</span> List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxList<span class="token punctuation">,</span> ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxNewListItem <span class="token punctuation">)</span><span class="token punctuation">{</span>    ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxIndex <span class="token operator">=</span> pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token punctuation">;</span>    <span class="token function">listTEST_LIST_INTEGRITY</span><span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listTEST_LIST_ITEM_INTEGRITY</span><span class="token punctuation">(</span> pxNewListItem <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listGET_OWNER_OF_NEXT_ENTRY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token operator">*</span><span class="token operator">/</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIndex<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  1 </span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  2</span>    <span class="token comment" spellcheck="true">/* Only used during decision coverage testing. */</span>    <span class="token function">mtCOVERAGE_TEST_DELAY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  3 </span>    pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//  4</span>    <span class="token comment" spellcheck="true">/* Remember which list the item is in. */</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> pxList<span class="token punctuation">;</span>    <span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>传入的参数：</p><p><code>pxList</code>：列表项要插入的列表。</p><p><code>pxNewListItem</code>：要插入的列表项是什么。</p><p>从末尾插入，那就要先知道哪里是头咯，我们在列表中的成员<code>pxIndex</code>就是用来遍历列表项的啊，那它指向的地方就是列表项的头，那么既然FreeRTOS中的列表很像数据结构中的双向链表，那么，我们可以把它看成一个环，是首尾相连的，那么函数中说的末尾，就是列表项头的前一个，很显然其结构图应该是下图这样子的（初始化结束后<code>pxIndex</code>指向了<code>xListEnd</code>）：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos5.png" alt="freertos5"></p><p>为什么是这样子的呢，一句句代码来解释：</p><p>一开始：</p><pre class="line-numbers language-js"><code class="language-js">ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxIndex <span class="token operator">=</span> pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>保存了一开始的索引列表项（<code>xListEnd</code>）的指向。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIndex<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//  1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新列表项的下一个指向为索引列表项，也就是绿色的箭头。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>刚开始我们初始化完成的时候<code>pxIndex-&gt;pxPrevious</code>的指向为自己xListEnd，那么<code>xNewListItem-&gt;pxPrevious</code>的指向为xListEnd。如2紫色的箭头。</p><pre class="line-numbers language-js"><code class="language-js">pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>索引列表项（xListEnd）的上一个列表项还是自己，那么自己的下一个列表项指向就是指向了<code>pxNewListItem</code>。</p><pre class="line-numbers language-js"><code class="language-js">pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//  4</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这句就很容易理解啦。如图的4橙色的箭头。</p><p>插入完毕的时候标记一下新的列表项插入了哪个列表，并且将<code>uxNumberOfItems</code>进行加一，以表示多了一个列表项。</p><p>为什么源码要这样子写呢？因为这只是两个列表项，一个列表含有多个列表项，那么这段代码的通用性就很强了。无论原本列表中有多少个列表项，也无论<code>pxIndex</code>指向哪个列表项！</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos6.png" alt="freertos6"></p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos7.png" alt="freertos7"></p><p>看看是不是按照源码中那样插入呢？</p><h1 id="列表项的插入"><a href="#列表项的插入" class="headerlink" title="列表项的插入"></a>列表项的插入</h1><p> 源码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vListInsert</span><span class="token punctuation">(</span> List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxList<span class="token punctuation">,</span> ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxNewListItem <span class="token punctuation">)</span><span class="token punctuation">{</span>ListItem_t <span class="token operator">*</span>pxIterator<span class="token punctuation">;</span><span class="token keyword">const</span> TickType_t xValueOfInsertion <span class="token operator">=</span> pxNewListItem<span class="token operator">-</span><span class="token operator">></span>xItemValue<span class="token punctuation">;</span>    <span class="token function">listTEST_LIST_INTEGRITY</span><span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listTEST_LIST_ITEM_INTEGRITY</span><span class="token punctuation">(</span> pxNewListItem <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span> xValueOfInsertion <span class="token operator">==</span> portMAX_DELAY <span class="token punctuation">)</span>   <span class="token punctuation">{</span>        pxIterator <span class="token operator">=</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd<span class="token punctuation">.</span>pxPrevious<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span> pxIterator <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>xItemValue <span class="token operator">&lt;=</span> xValueOfInsertion<span class="token punctuation">;</span> pxIterator <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* There is nothing to do here, just iterating to the wanted            insertion position. */</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIterator<span class="token punctuation">;</span>    pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Remember which list the item is in.  This allows fast removal of the    item later. */</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> pxList<span class="token punctuation">;</span>    <span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>传入的参数：</p><p><code>pxList</code>：列表项要插入的列表。<br><code>pxNewListItem</code>：要插入的列表项是什么。</p><p>pxList决定了插入哪个列表，<code>pxNewListItem</code>中的<code>xItemValue</code>值决定了列表项插入列表的位置。</p><pre class="line-numbers language-js"><code class="language-js">ListItem_t <span class="token operator">*</span>pxIterator<span class="token punctuation">;</span>  <span class="token keyword">const</span> TickType_t xValueOfInsertion <span class="token operator">=</span> pxNewListItem<span class="token operator">-</span><span class="token operator">></span>xItemValue<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>定义一个辅助的列表项pxIterator，用来迭代找出插入新列表项的位置，并且保存获取要插入的列表项<code>pxNewListItem</code>的xItemValue。</p><p>如果打开了列表项完整性检查，就要用户实现<code>configASSERT()</code>，源码中有说明。</p><p>既然是要插入列表项，那么肯定是要知道列表项的位置了，如果新插入列表项的<code>xItemValue</code>是最大的话<code>（portMAX_DELAY）</code>，就直接插入列表项的末尾。否则就需要比较列表中各个列表项的<code>xItemValue</code>的大小来进行排列。然后得出新列表项插入的位置。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span><span class="token punctuation">(</span> pxIterator <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>xItemValue <span class="token operator">&lt;=</span> xValueOfInsertion<span class="token punctuation">;</span> pxIterator <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面源码就是实现比较的过程。</p><p>与上面的从列表项末尾插入的源码一样，FreeRTOS的代码通用性很强，逻辑思维也很强。</p><p>如果列表中列表项的数量为0，那么插入的列表项就是在初始化列表项的后面。如下图所示：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos8.png" alt="freertos8"></p><h2 id="过程分析："><a href="#过程分析：" class="headerlink" title="过程分析："></a>过程分析：</h2><p>新列表项的<code>pxNext</code>指向<code>pxIterator-&gt;pxNext</code>，也就是指向了<code>xListEnd（pxIterator）</code>。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而xListEnd（pxIterator）的pxPrevious指向则为pxNewListItem。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新列表项的<code>（pxPrevious）</code>指针指向<code>xListEnd（pxIterator）</code></p><p><code>pxIterator</code> 的 <code>pxNext</code> 指向了<code>新</code>列表项</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIterator<span class="token punctuation">;</span>pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>与从末尾插入列表项其实是一样的，前提是当前列表中列表项的数目为0。</p><p>假如列表项中已经有了元素呢，过程又是不一样的了。原来的列表是下图这样子的：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos9.png" alt="freertos9"></p><p>假设插入的列表项的<code>xItemValue</code>是<code>2</code>，而原有的列表项的<code>xItemValue</code>值是<code>3</code>，那么，按照源码，我们插入的列表项是在中间了。而pxIterator则是①号列表项。</p><p>插入后的效果：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos10.png" alt="freertos10"></p><p>分析一下插入的过程：</p><p>新的列表项的<code>pxNext</code>指向的是<code>pxIterator-&gt;pxNext</code>，也就是③号列表项。因为一开始pxIterator-&gt;pxNext=指向的就是③号列表项！！</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而pxNewListItem-&gt;pxNext 即③号列表项的指向上一个列表项指针（<code>pxPrevious</code>）的则指向新插入的列表项，也就是②号列表项了。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新插入列表项的指向上一个列表项的指针<code>pxNewListItem-&gt;pxPrevious</code>指向了辅助列表项<code>pxIterator</code>。很显然要连接起来嘛！</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIterator<span class="token punctuation">;</span>     <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同理，<code>pxIterator</code>列表项的指向下一个列表项的指针则指向新插入的列表项了<code>pxNewListItem</code>。</p><pre class="line-numbers language-js"><code class="language-js">pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而其他没改变指向的地方不需改动。（图中的两条直线做的连接线是不需要改动的）</p><p>当插入完成的时候，记录一下新插入的列表项属于哪个列表。并且让该列表下的列表项数目加一。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> pxList<span class="token punctuation">;</span>         <span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="删除列表项"><a href="#删除列表项" class="headerlink" title="删除列表项"></a>删除列表项</h1><pre><code>源码：</code></pre><pre class="line-numbers language-js"><code class="language-js">UBaseType_t <span class="token function">uxListRemove</span><span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxItemToRemove <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">/* The list item knows which list it is in.  Obtain the list from the listitem. */</span>List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxList <span class="token operator">=</span> <span class="token punctuation">(</span> List_t <span class="token operator">*</span> <span class="token punctuation">)</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pvContainer<span class="token punctuation">;</span>    pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>    pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Only used during decision coverage testing. */</span>    <span class="token function">mtCOVERAGE_TEST_DELAY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Make sure the index is left pointing to a valid item. */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">==</span> pxItemToRemove <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> NULL<span class="token punctuation">;</span>    <span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token punctuation">)</span><span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  其实删除是很简单的，不用想都知道，要删除列表项，那肯定要知道该列表项是属于哪个列表吧，pvContainer就是记录列表项是属于哪个列表的。</p><p>  删除就是把列表中的列表项从列表中去掉，其本质其实就是把他们的连接关系删除掉，然后让删除的列表项的前后两个列表连接起来就行了，假如是只有一个列表项，那么删除之后，列表就回到了初始化的状态了。</p><pre class="line-numbers language-js"><code class="language-js">pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两句代码就实现了将删除列表项的前后两个列表项连接起来。</p><p>按照上面的讲解可以理解这两句简单的代码啦。</p><p>假如删除的列表项是当前索引的列表项，那么在删除之后，列表中的pxIndex就要指向删除列表项的上一个列表项了。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">==</span> pxItemToRemove <span class="token punctuation">)</span>  <span class="token punctuation">{</span>     pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当然还要把当前删除的列表项的<code>pvContainer</code>指向<code>NULL</code>，让它不属于任何一个列表，因为，删除的本质是删除的仅仅是列表项的连接关系，其内存是没有释放掉的，假如是动态内存分配的话。</p><p>并且要把当前列表中列表项的数目返回一下。</p><p>至此，列表的源码基本讲解完毕。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>大家还可以了解一下遍历列表的宏，它在list.h文件中：</p><pre class="line-numbers language-js"><code class="language-js">define <span class="token function">listGET_OWNER_OF_NEXT_ENTRY</span><span class="token punctuation">(</span> pxTCB<span class="token punctuation">,</span> pxList <span class="token punctuation">)</span>                                        \<span class="token punctuation">{</span>                                                                                            \List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxConstList <span class="token operator">=</span> <span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span>                                                    \    <span class="token comment" spellcheck="true">/* Increment the index to the next item and return the item, ensuring */</span>                \    <span class="token comment" spellcheck="true">/* we don't return the marker used at the end of the list.  */</span>                          \    <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span>                            \    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">==</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span> <span class="token punctuation">)</span>  \    <span class="token punctuation">{</span>                                                                                       \         <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span>                        \    <span class="token punctuation">}</span>                                                                                       \    <span class="token punctuation">(</span> pxTCB <span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token operator">-</span><span class="token operator">></span>pvOwner<span class="token punctuation">;</span>                                          \<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一个宏，用于列表的遍历，返回的是列表中列表项的<code>pxOwner</code>成员，每次调用这个宏（函数）的时候，其pxIndex索引会指向当前返回列表项的下一个列表项。</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0开始学FreeRTOS-(创建任务)-2</title>
      <link href="/freertos-2/"/>
      <url>/freertos-2/</url>
      
        <content type="html"><![CDATA[<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>开始今天的内容之前，先补充一下上篇文章<a href="https://jiejietop.gitee.io/freertos-1/" target="_blank" rel="noopener">从单片机到操作系统-1</a>的一点点遗漏的知识点。</p><pre class="line-numbers language-js"><code class="language-js"> BaseType_t <span class="token function">xTaskCreate</span><span class="token punctuation">(</span>       TaskFunction_t pvTaskCode<span class="token punctuation">,</span>                               <span class="token keyword">const</span> char <span class="token operator">*</span> <span class="token keyword">const</span> pcName<span class="token punctuation">,</span>                               uint16_t usStackDepth<span class="token punctuation">,</span>                               <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters<span class="token punctuation">,</span>                               UBaseType_t uxPriority<span class="token punctuation">,</span>                               TaskHandle_t <span class="token operator">*</span>pvCreatedTask                           <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 创建任务中的堆栈大小问题，在task.h中有这样子的描述：</p><pre class="line-numbers language-js"><code class="language-js"> <span class="token comment" spellcheck="true">/*** @param usStackDepth The size of the task stack specified as the number of variables the stack * can hold - not the number of bytes.  For example, if the stack is 16 bits wide and  * usStackDepth is defined as 100, 200 byteswill be allocated for stack storage.*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当任务创建时，内核会分为每个任务分配属于任务自己的唯一堆栈。usStackDepth 值用于告诉内核为它应该分配多大的栈空间。</p><p>这个值指定的是栈空间可以保存多少个字(word) ，而不是多少个字节(byte)。</p><p>文档也有说明，如果是16位宽度的话，假如usStackDepth = 100；那么就是200个字节（byte）。</p><p>当然，我用的是stm32，32位宽度的， usStackDepth=100；那么就是400个字节（byte）。</p><p>好啦，补充完毕。下面正式开始我们今天的主题。</p><hr><p>我自己学的是应用层的东西，很多底层的东西我也不懂，水平有限，出错了还请多多包涵。</p><p>其实我自己写文章的时候也去跟着火哥的书看着底层的东西啦，但是本身自己也是不懂，不敢乱写。所以，这个《从单片机到操作系统》系列的文章，我会讲一点底层，更多的是应用层，主要是用的方面。</p><p>按照一般的写代码的习惯，在main函数里面各类初始化完毕了，并且创建任务成功了，那么，可以开启任务调度了。</p><pre class="line-numbers language-js"><code class="language-js">int <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">NVIC_PriorityGroupConfig</span><span class="token punctuation">(</span>NVIC_PriorityGroup_4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置系统中断优先级分组4    </span>    <span class="token function">Delay_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//延时函数初始化     </span>    <span class="token function">Uart_Init</span><span class="token punctuation">(</span><span class="token number">115200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//初始化串口</span>    <span class="token function">LED_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//初始化LED</span>    <span class="token function">KEY_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//创建开始任务</span>    <span class="token function">xTaskCreate</span><span class="token punctuation">(</span><span class="token punctuation">(</span>TaskFunction_t <span class="token punctuation">)</span>start_task<span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">//任务函数</span>                <span class="token punctuation">(</span><span class="token keyword">const</span> char<span class="token operator">*</span>    <span class="token punctuation">)</span><span class="token string">"start_task"</span><span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">//任务名称</span>                <span class="token punctuation">(</span>uint16_t       <span class="token punctuation">)</span>START_STK_SIZE<span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">//任务堆栈大小</span>                <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span>          <span class="token punctuation">)</span>NULL<span class="token punctuation">,</span>                  <span class="token comment" spellcheck="true">//传递给任务函数的参数</span>                <span class="token punctuation">(</span>UBaseType_t    <span class="token punctuation">)</span>START_TASK_PRIO<span class="token punctuation">,</span>       <span class="token comment" spellcheck="true">//任务优先级</span>                <span class="token punctuation">(</span>TaskHandle_t<span class="token operator">*</span>  <span class="token punctuation">)</span><span class="token operator">&amp;</span>StartTask_Handler<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//任务句柄              </span>    <span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//开启任务调度</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>来大概看看分析一下创建任务的过程，虽然说会用就行，但是也是要知道了解一下的。</p><p>注意：下面说的创建任务均为xTaskCreate（动态创建）而非静态创建。</p><pre class="line-numbers language-js"><code class="language-js">pxStack <span class="token operator">=</span> <span class="token punctuation">(</span> StackType_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token function">pvPortMalloc</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span> size_t <span class="token punctuation">)</span> usStackDepth <span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">sizeof</span><span class="token punctuation">(</span> StackType_t <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*lint !e961 MISRA exception as the casts are only redundant for some ports. */</span>             <span class="token keyword">if</span><span class="token punctuation">(</span> pxStack <span class="token operator">!=</span> NULL <span class="token punctuation">)</span>             <span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">/* Allocate space for the TCB. */</span>                 pxNewTCB <span class="token operator">=</span> <span class="token punctuation">(</span> TCB_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token function">pvPortMalloc</span><span class="token punctuation">(</span> <span class="token function">sizeof</span><span class="token punctuation">(</span> TCB_t <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">/*lint !e961 MISRA exception as the casts are only redundant for some paths. */</span>                 <span class="token keyword">if</span><span class="token punctuation">(</span> pxNewTCB <span class="token operator">!=</span> NULL <span class="token punctuation">)</span>                 <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">/* Store the stack location in the TCB. */</span>                    pxNewTCB<span class="token operator">-</span><span class="token operator">></span>pxStack <span class="token operator">=</span> pxStack<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span>                <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">/* The stack cannot be used as the TCB was not created.  Free                    it again. */</span>                    <span class="token function">vPortFree</span><span class="token punctuation">(</span> pxStack <span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                pxNewTCB <span class="token operator">=</span> NULL<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先是利用<code>pvPortMalloc</code>给任务的堆栈分配空间，<code>if( pxStack != NULL )</code>如果内存申请成功，就接着给任务控制块申请内存。<code>pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );</code>同样是使用<code>pvPortMalloc();</code>如果任务控制块内存申请失败则释放 之前已经申请成功的任务堆栈<code>的内存vPortFree( pxStack );</code></p><p>然后就初始化任务相关的东西，并且将新初始化的任务控制块添加到列表中<code>prvAddNewTaskToReadyList( pxNewTCB );</code></p><p>  最后返回任务的状态，如果是成功了就是<code>pdPASS</code>，假如失败了就是返回<code>errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;</code></p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">prvInitialiseNewTask</span><span class="token punctuation">(</span>    pxTaskCode<span class="token punctuation">,</span>                          pcName<span class="token punctuation">,</span>                          <span class="token punctuation">(</span> uint32_t <span class="token punctuation">)</span> usStackDepth<span class="token punctuation">,</span>                         pvParameters<span class="token punctuation">,</span>                         uxPriority<span class="token punctuation">,</span>                          pxCreatedTask<span class="token punctuation">,</span>                         pxNewTCB<span class="token punctuation">,</span>                          NULL <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">prvAddNewTaskToReadyList</span><span class="token punctuation">(</span> pxNewTCB <span class="token punctuation">)</span><span class="token punctuation">;</span>            xReturn <span class="token operator">=</span> pdPASS<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            xReturn <span class="token operator">=</span> errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> xReturn<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 相关宏定义</span>#define pdPASS            <span class="token punctuation">(</span> pdTRUE <span class="token punctuation">)</span>#define pdTRUE            <span class="token punctuation">(</span> <span class="token punctuation">(</span> BaseType_t <span class="token punctuation">)</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token comment" spellcheck="true">/* FreeRTOS error definitions. */</span>#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY    <span class="token punctuation">(</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体的<code>static void prvInitialiseNewTask()</code>实现请参考<code>FreeRTOS</code>的<code>tasks.c</code>文件的<code>767</code>行代码。具体的<code>static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )</code>实现请参考<code>FreeRTOS</code>的<code>tasks.c</code>文件的<code>963</code>行代码。</p><p>因为这些是<code>tasks.c</code>中的<code>静态的函数</code>，仅供xTaskCreate创建任务内部调用的，我们无需理会这些函数的实现过程，当然如果需要请自行了解。</p><p>创建完任务就开启任务调度了：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//开启任务调度</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在任务调度里面，会创建一个空闲任务（我们将的都是动态创建任务，静态创建其实一样的）</p><pre class="line-numbers language-js"><code class="language-js">xReturn <span class="token operator">=</span> <span class="token function">xTaskCreate</span><span class="token punctuation">(</span>    prvIdleTask<span class="token punctuation">,</span>                          <span class="token string">"IDLE"</span><span class="token punctuation">,</span> configMINIMAL_STACK_SIZE<span class="token punctuation">,</span>                          <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> NULL<span class="token punctuation">,</span>                          <span class="token punctuation">(</span> tskIDLE_PRIORITY <span class="token operator">|</span> portPRIVILEGE_BIT <span class="token punctuation">)</span><span class="token punctuation">,</span>                          <span class="token operator">&amp;</span>xIdleTaskHandle <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */</span>    <span class="token punctuation">}</span>相关宏定义：#define tskIDLE_PRIORITY            <span class="token punctuation">(</span> <span class="token punctuation">(</span> UBaseType_t <span class="token punctuation">)</span> 0U <span class="token punctuation">)</span>#ifndef portPRIVILEGE_BIT    #define portPRIVILEGE_BIT <span class="token punctuation">(</span> <span class="token punctuation">(</span> UBaseType_t <span class="token punctuation">)</span> <span class="token number">0x00</span> <span class="token punctuation">)</span>#endif#define configUSE_TIMERS                        <span class="token number">1</span>                               <span class="token comment" spellcheck="true">//为1时启用软件定时器</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的代码我们可以看出，空闲任务的优先级是tskIDLE_PRIORITY为0，也就是说空闲任务的优先级最低。当CPU没事干的时候才执行空闲任务，以待随时切换优先级更高的任务。</p><p>如果使用了软件定时器的话，我们还需要创建定时器任务，创建的函数是：</p><pre class="line-numbers language-js"><code class="language-js">#<span class="token keyword">if</span> <span class="token punctuation">(</span> configUSE_TIMERS <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span>    BaseType_t <span class="token function">xTimerCreateTimerTask</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后还要把中断关一下</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">portDISABLE_INTERRUPTS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>至于为什么关中断，也有说明：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* Interrupts are turned off here, toensure a tick does not occurbefore or during the call toxPortStartScheduler().  The stacks ofthe created tasks contain a status wordwith interrupts switched onso interrupts will automatically getre-enabled when the first taskstarts to run. */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>中断在这里被关闭，以确保不会发生滴答在调用xPortStartScheduler（）之前或期间。堆栈创建的任务包含一个打开中断的状态字因此中断将在第一个任务时自动重新启用开始运行。</p><p>那么如何打开中断呢？？？？这是个很重要的问题</p><p>别担心，我们在SVC中断服务函数里面就会打开中断的</p><p>看代码：</p><pre class="line-numbers language-js"><code class="language-js">__asm <span class="token keyword">void</span> <span class="token function">vPortSVCHandler</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>         PRESERVE8         ldr    r3<span class="token punctuation">,</span> <span class="token operator">=</span>pxCurrentTCB  <span class="token comment" spellcheck="true">/* Restore the context. */</span>         ldrr1<span class="token punctuation">,</span> <span class="token punctuation">[</span>r3<span class="token punctuation">]</span>                            <span class="token comment" spellcheck="true">/* UsepxCurrentTCBConst to get the pxCurrentTCB address. */</span>         ldrr0<span class="token punctuation">,</span> <span class="token punctuation">[</span>r1<span class="token punctuation">]</span>                            <span class="token comment" spellcheck="true">/* Thefirst item in pxCurrentTCB is the task top of stack. */</span>         ldmiar0<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>r4<span class="token operator">-</span>r11<span class="token punctuation">}</span>             <span class="token comment" spellcheck="true">/* Pop theregisters that are not automatically saved on exception entry and the criticalnesting count. */</span>         msrpsp<span class="token punctuation">,</span> r0                                   <span class="token comment" spellcheck="true">/*Restore the task stack pointer. */</span>         isb         movr0<span class="token punctuation">,</span> #<span class="token number">0</span>         msr  basepri<span class="token punctuation">,</span> r0         orrr14<span class="token punctuation">,</span> #<span class="token number">0xd</span>         bxr14<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">msr  basepri<span class="token punctuation">,</span> r0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就是它把中断打开的。看不懂没所谓，我也不懂汇编，看得懂知道就好啦。</p><pre class="line-numbers language-js"><code class="language-js">xSchedulerRunning <span class="token operator">=</span> pdTRUE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>任务调度开始运行</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* If configGENERATE_RUN_TIME_STATS isdefined then the followingmacro must be defined to configure thetimer/counter used to generatethe run time counter time base. */</span><span class="token function">portCONFIGURE_TIMER_FOR_RUN_TIME_STATS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果<code>configGENERATE_RUN_TIME_STATS</code>使用时间统计功能，这个宏为<code>1</code>，那么用户必须实现一个宏<code>portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();</code>用来配置一个定时器或者计数器。</p><p>来到我们的重点了，开启任务调度，那么任务到这了就不会返回了。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">xPortStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> pdFALSE <span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/*Should not reach here as if the scheduler is running the    functionwill not return. */</span>                    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就能开启第一个任务了，感觉好难是吧，我一开始也是觉得的，但是写了这篇文章，觉得还行吧，也不算太难，可能也是在查看代码跟别人的书籍吧，写东西其实还是蛮好的，能加深理解，写过文章的人就知道，懂了不一定能写出来，所以，我还是很希望朋友们能投稿的。杰杰随时欢迎。。。</p><p>开始任务就按照套路模板添加自己的代码就好啦，很简单的。</p><p>先创建任务：</p><pre class="line-numbers language-js"><code class="language-js"> <span class="token function">xTaskCreate</span><span class="token punctuation">(</span><span class="token punctuation">(</span>TaskFunction_t <span class="token punctuation">)</span>led0_task<span class="token punctuation">,</span>                  <span class="token punctuation">(</span><span class="token keyword">const</span> char<span class="token operator">*</span>    <span class="token punctuation">)</span><span class="token string">"led0_task"</span><span class="token punctuation">,</span>                <span class="token punctuation">(</span>uint16_t       <span class="token punctuation">)</span>LED0_STK_SIZE<span class="token punctuation">,</span>              <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span>          <span class="token punctuation">)</span>NULL<span class="token punctuation">,</span>                                                  <span class="token punctuation">(</span>UBaseType_t    <span class="token punctuation">)</span>LED0_TASK_PRIO<span class="token punctuation">,</span>                 <span class="token punctuation">(</span>TaskHandle_t<span class="token operator">*</span>  <span class="token punctuation">)</span><span class="token operator">&amp;</span>LED0Task_Handler<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//创建LED1任务</span>  <span class="token function">xTaskCreate</span><span class="token punctuation">(</span><span class="token punctuation">(</span>TaskFunction_t <span class="token punctuation">)</span>led1_task<span class="token punctuation">,</span>                  <span class="token punctuation">(</span><span class="token keyword">const</span> char<span class="token operator">*</span>    <span class="token punctuation">)</span><span class="token string">"led1_task"</span><span class="token punctuation">,</span>                <span class="token punctuation">(</span>uint16_t       <span class="token punctuation">)</span>LED1_STK_SIZE<span class="token punctuation">,</span>              <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span>          <span class="token punctuation">)</span>NULL<span class="token punctuation">,</span>              <span class="token punctuation">(</span>UBaseType_t    <span class="token punctuation">)</span>LED1_TASK_PRIO<span class="token punctuation">,</span>              <span class="token punctuation">(</span>TaskHandle_t<span class="token operator">*</span>  <span class="token punctuation">)</span><span class="token operator">&amp;</span>LED1Task_Handler<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建完任务就开启任务调度：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token number">1</span><span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//开启任务调度</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后具体实现任务函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//LED0任务函数</span><span class="token keyword">void</span> <span class="token function">led0_task</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pvParameters<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>       LED0<span class="token operator">=</span><span class="token operator">~</span>LED0<span class="token punctuation">;</span>       <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//LED1任务函数</span><span class="token keyword">void</span> <span class="token function">led1_task</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pvParameters<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>       LED1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>       <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       LED1<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>       <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好啦，今天的介绍到这了为止，后面还会持续更新，敬请期待哦~</p><p>欢迎大家一起来讨论操作系统的知识</p><p>我们的群号是：783234154</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0开始学FreeRTOS-1</title>
      <link href="/freertos-1/"/>
      <url>/freertos-1/</url>
      
        <content type="html"><![CDATA[<p>我们知道，（单核）单片机某一时刻只能干一件事，会造成单片机资源的浪费，而且还有可能响应不够及时，所以，在比较庞大的程序或者是要求实时性比较高的情况下，我们可以移植操作系统。因为这种情况下操作系统比裸机方便很多，效率也高。下面，杰杰将带你们走进FreeRTOS的世界随便看看。</p><p>下面正式开始本文内容。</p><p>在没有用到操作系统之前，单片机的运行是顺序执行，就是说，很多时候，单片机在执行这件事的时候，无法切换到另一件事。这就造成了资源的浪费，以及错过了突发的信号。那么，用上了操作系统的时候，很容易避免了这样的问题。</p><p>很简单，从感觉上，单片机像是同时在干多件事，为什么说像呢，因为单片机的执行速度很快，快到我们根本没办法感觉出来，但是同时做两件事是不可能的，在（单核）单片机中，因为它的硬件结构决定了CPU只能在一个时间段做一件事如：<br><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos-1.jpg" alt="not os"></p><p>如这张图，都是按照顺序来执行这些事的，假设每个任务（事件）的time无限小，小到我们根本没法分辨出来，那么我们也会感觉单片机在同时做这六件事。</p><p>真相就是：所有任务都好像在执行，但实际上在任何一个时刻都只有一个任务在执行</p><p>如是加上了中断系统的话，就可以将上图理解为下图：<br><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos2.png" alt="os"></p><p>通常把程序分为两部分：前台系统和后台系统。 简单的小系统通常是前后台系统，这样的程序包括一个死循环和若干个中断服务程序：应用程序是一个无限循环，循环中调用API函数完成所需的操作，这个大循环就叫做后台系统。中断服务程序用于处理系统的异步事件，也就是前台系统。前台是中断级，后台是任务级。简单来说就是程序一直按顺序执行，有中断来了就做中断（前台）的事情。处理完中断（前台）的事情，就回到大循环（后台）继续按顺序执行。</p><p>那么问题来了，这样子的系统肯定不是好的系统，我在做第一个任务的时候想做第四个任务，根本做不到啊，其实也能做到，让程序执行的指针cp指向第四个任务就行了。但是任务一旦复杂，那么整个工程的代码的结构，可移植性，及可读性，肯定会差啦。</p><p> FreeRTOS</p><p>那么操作系统的移植就是不可或缺的了。什么叫RTOS？：Real Time OS，实时操作系统，强调的是实时性，就是要规定什么时间该做什么任务。那么假如同一个时刻，需要执行两个或者多个任务怎么办。那么我们可以人为地把任务划分优先级，哪个任务重要，就先做，因为前面一直强调，单片机无法同时做两件事，在某一个时刻只能做一件事。</p><p>那么FreeRTOS是怎么操作的呢？先看看FreeRTOS的内核吧：</p><p>FreeRTOS是一个可裁剪、可剥夺型的多任务内核，而且没有任务数限制。FreeRTOS提供了实时操作系统所需的所有功能，包括资源管理、同步、任务通信等。 FreeRTOS是用C和汇编来写的，其中绝大部分都是用C语言编写的，只有极少数的与处理器密切相关的部分代码才是用汇编写的，FreeRTOS结构简洁，可读性很强！RTOS的内核负责管理所有的任务，内核决定了运行哪个任务，何时停止当前任务切换到其他任务，这个是内核的多任务管理能力。</p><p>可剥夺内核顾名思义就是可以剥夺其他任务的CPU使用权，它总是运行就绪任务中的优先级最高的那个任务。<br><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos3.png" alt="freertos"></p><p>在FreeRTOS中，每个任务都是无限循环的，一般来说任务是不会结束运行的，也不允许有返回值，任务的结构一般都是</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">While</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">/****一直在循环执行*****/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果不需要这个任务了，那就把它删除。</p><p>移植的教程我就不写了，超级简单的，按照已有的大把教程来做就行了。（如果没有资源，可以在后台找我，我给一份移植的教程/源码）</p><p>其实FreeRTOS的运用及其简单，移植成功按照自己的意愿来配置即可，而且FreeRTOS有很多手册，虽然作者英语很差，但是我有谷歌翻译！！！哈哈哈</p><p>既然一直都说任务任务，那肯定要有任务啊，创建任务：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// task. h  task.c</span>BaseType_t <span class="token function">xTaskCreate</span><span class="token punctuation">(</span>      TaskFunction_t pvTaskCode<span class="token punctuation">,</span>                              <span class="token keyword">const</span> char <span class="token operator">*</span> <span class="token keyword">const</span> pcName<span class="token punctuation">,</span>                              uint16_t usStackDepth<span class="token punctuation">,</span>                              <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters<span class="token punctuation">,</span>                              UBaseType_t uxPriority<span class="token punctuation">,</span>                              TaskHandle_t <span class="token operator">*</span>pvCreatedTask                          <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数的原型都有，按照字面的理解</p><pre class="line-numbers language-js"><code class="language-js">TaskFunction_t pvTaskCode        <span class="token comment" spellcheck="true">//传递进来的是任务函数</span><span class="token keyword">const</span> char <span class="token operator">*</span> <span class="token keyword">const</span> pcName         <span class="token comment" spellcheck="true">//传递进来的是任务Name</span>uint16_t usStackDepth            <span class="token comment" spellcheck="true">//传入的是堆栈的大小</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在这里要说明一下，在裸机中开发，我们不管局部变量还是全局变量，反正定义了就能用，中断发生时，函数返回地址发哪里，我们也不管。但是在操作系统中，我们必须弄清楚我们的参数是怎么储存的，他们的大小是多大，就需要我们去定义这个堆栈的大小。它就是用来存放我们的这些东西的。太小，导致堆栈溢出，发生异常。（栈是单片机 RAM 里面一段连续的内存空间）</p><p>因为在多任务系统中，每个任务都是独立的，互不干扰的，所以要为每个任务都分配独立的栈空间。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token operator">*</span>pvParameters              <span class="token comment" spellcheck="true">//传递给任务函数的参数</span>UBaseType_t uxPriority          <span class="token comment" spellcheck="true">//任务优先级</span>TaskHandle_t <span class="token operator">*</span>pvCreatedTask     <span class="token comment" spellcheck="true">//任务句柄</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>任务句柄也是很重要的东西，我们怎么删除任务也是要用到任务句柄，其实说白了，我操作系统怎么知道你是什么任务，靠的就是任务句柄的判断，才知道哪个任务在执行，哪个任务被挂起。下一个要执行的任务是哪个等等，靠的都是任务句柄。</p><p>那么要使用这些东西，我们肯定要实现啦，下面就是实现的定义，要定义优先级，堆栈大小，任务句柄，任务函数等。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//任务优先级</span>#define LED_TASK_PRIO           <span class="token number">2</span><span class="token comment" spellcheck="true">//任务堆栈大小     </span>#define LED_STK_SIZE             <span class="token number">50</span><span class="token comment" spellcheck="true">//任务句柄</span>TaskHandle_t LED_Task_Handler<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//任务函数</span><span class="token keyword">void</span> <span class="token function">LED_Task</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pvParameters<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建任务后，可以开启任务调度了，然后系统就开始运行。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">xTaskCreate</span><span class="token punctuation">(</span><span class="token punctuation">(</span>TaskFunction_t <span class="token punctuation">)</span>LED_Task<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//任务函数</span>            <span class="token punctuation">(</span><span class="token keyword">const</span> char<span class="token operator">*</span>    <span class="token punctuation">)</span><span class="token string">"led_task"</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">//任务名称</span>            <span class="token punctuation">(</span>uint16_t       <span class="token punctuation">)</span>LED_STK_SIZE<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//任务堆栈大小</span>            <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span>          <span class="token punctuation">)</span>NULL<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//传递给任务函数的参数</span>            <span class="token punctuation">(</span>UBaseType_t    <span class="token punctuation">)</span>START_TASK_PRIO<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//任务优先级</span>            <span class="token punctuation">(</span>TaskHandle_t<span class="token operator">*</span>  <span class="token punctuation">)</span><span class="token operator">&amp;</span>LED_Task_Handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//任务句柄 </span> <span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//开启任务调度</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个创建任务的函数 xTaskCreate 是有返回值的，其返回值的类型是BaseType_t。</p><p>我们在描述中看看：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// @return pdPASS if the task was successfully created and added to a readylist, otherwise an error code defined in the file projdefs.h</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们其实可以在任务调度的时候判断一下返回值是否为pdPASS从而知道任务创是否建成功。并且打印一个信息作为调试。因为后面使用信号量这些的时候都要知道信号量是否创建成功，使得代码健壮一些。免得有隐藏的bug。</p><p>然后就是具体实现我们的任务LED_Task是在做什么的</p><p>当然可以实现多个任务。还是很简单的。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//LED任务函数</span><span class="token keyword">void</span> <span class="token function">LED_Task</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pvParameters<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        LED0  <span class="token operator">=</span>  <span class="token operator">!</span>LED0<span class="token punctuation">;</span>        <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是一个简单的操作系统的概述。</p><p>下一篇，应该是讲述开启任务调度与任务切换的具体过程。</p><p>这个可以参考野火的书籍《从 0 到 1 教你写 uCOS-III》</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openmv学习之旅-2</title>
      <link href="/openmv-2/"/>
      <url>/openmv-2/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是杰杰。</p><p>从上一篇openmv的学习中<a href="https://jiejietop.gitee.io/openmv-1/" target="_blank" rel="noopener">openmv学习之旅-1</a></p><p>我们可以很简单运用micropython在openmv上做我们想做的事情。</p><p>Python这个东西用起来是很简单的，，下面来说说改善色块追踪的算法</p><p>先做个改善前的分析吧：</p><p>改善前：</p><pre class="line-numbers language-js"><code class="language-js">API：find_blobs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>thresholds</code> 是颜色的阈值。这个参数是一个列表，可以包含多个颜色。在返回的色块对象blob可以调用code方法，来判断是什么颜色的色块。</p><p><code>roi</code> 是“感兴趣区”。</p><p><code>x_stride</code> 就是查找的色块的x方向上最小宽度的像素，默认为2。</p><p><code>y_stride</code> 就是查找的色块的y方向上最小宽度的像素，默认为1。</p><p><code>area_threshold</code> 面积阈值，如果色块被框起来的面积小于这个值，会被过滤掉。</p><p><code>pixels_threshold</code> 像素个数阈值，如果色块像素数量小于这个值，会被过滤掉</p><p><code>merge</code> 合并，如果设置为True，那么合并所有重叠的blob为一个。 注意：这会合并所有的blob，无论是什么颜色的。如果你想混淆多种颜色的blob，只需要分别调用不同颜色阈值的find_blobs。</p><pre class="line-numbers language-js"><code class="language-js">blobs <span class="token operator">=</span> img<span class="token punctuation">.</span><span class="token function">find_blobs</span><span class="token punctuation">(</span><span class="token punctuation">[</span>red<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>find_blobs</code> 对象返回的是多个 <code>blob</code> 的列表。<br>而一个 <code>blobs</code> 列表里包含很多 <code>blob</code> 对象， <code>blobs</code> 对象就是色块，每个 <code>blobs</code> 对象包含一个色块的信息。</p><p>blob有多个方法：</p><p><code>blob.rect()</code> 返回这个色块的外框——矩形元组(x, y, w, h)，可以直接在image.draw_rectangle中使用。</p><p><code>blob.x()</code> 返回色块的外框的x坐标（int），也可以通过blob[0]来获取。</p><p><code>blob.y()</code>返回色块的外框的y坐标（int），也可以通过blob[1]来获取。</p><p><code>blob.w()</code>返回色块的外框的宽度w（int），也可以通过blob[2]来获取。</p><p><code>blob.h()</code>返回色块的外框的高度h（int），也可以通过blob[3]来获取。</p><p><code>blob.pixels()</code> 返回色块的像素数量（int），也可以通过blob[4]来获取。</p><p><code>blob.cx()</code> 返回色块的外框的中心x坐标（int），也可以通过blob[5]来获取。</p><p><code>blob.cy()</code> 返回色块的外框的中心y坐标（int），也可以通过blob[6]来获取。</p><p><code>blob.rotation()</code>返回色块的旋转角度（单位为弧度）（float）。如果色块类似一个铅笔，那么这个值为0-180°。如果色块是一个圆，那么这个值是无用的。如果色块完全没有对称性，那么你会得到0-360°，也可以通过blob[7]来获取。</p><p><code>blob.code()</code>返回一个16bit数字，每一个bit会对应每一个阈值。</p><p>（上面的知识在openmv的官网上都有说明）</p><p>下面是说说调用find_blobs来做色块的追踪的原理</p><p>它是全幅图像扫描，它有优点也有缺点</p><p>先说说优点吧:信息全面，全幅图像的搜索，把所有色块都搜索进来了</p><p>但是缺点也不少：①：运算的速度，是很慢的，有些地方我们根本不需要扫描它。</p><p>②：色块的数量，很多时候，会有很多延时差不多的色块过来干扰，导致追踪失败。</p><p>源码：</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">import</span> sensor<span class="token punctuation">,</span> image<span class="token punctuation">,</span> time red_threshold_01 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span> sensor<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>  sensor<span class="token punctuation">.</span>set_pixformat<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>RGB565<span class="token punctuation">)</span> sensor<span class="token punctuation">.</span>set_framesize<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>QVGA<span class="token punctuation">)</span>  sensor<span class="token punctuation">.</span>skip_frames<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>  sensor<span class="token punctuation">.</span>set_auto_whitebal<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span> clock <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    clock<span class="token punctuation">.</span>tick<span class="token punctuation">(</span><span class="token punctuation">)</span>    img <span class="token operator">=</span> sensor<span class="token punctuation">.</span>snapshot<span class="token punctuation">(</span><span class="token punctuation">)</span>     blobs <span class="token operator">=</span> img<span class="token punctuation">.</span>find_blobs<span class="token punctuation">(</span><span class="token punctuation">[</span>red_threshold_01<span class="token punctuation">]</span><span class="token punctuation">,</span>                             area_threshold<span class="token operator">=</span><span class="token number">150</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> blobs<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#如果找到了目标颜色</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>blobs<span class="token punctuation">)</span>        <span class="token keyword">for</span> b <span class="token keyword">in</span> blobs<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#迭代找到的目标颜色区域</span>            <span class="token comment" spellcheck="true"># Draw a rect around the blob.</span>            img<span class="token punctuation">.</span>draw_rectangle<span class="token punctuation">(</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># rect</span>            <span class="token comment" spellcheck="true">#用矩形标记出目标颜色区域</span>            img<span class="token punctuation">.</span>draw_cross<span class="token punctuation">(</span>b<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># cx, cy</span>            <span class="token comment" spellcheck="true">#在目标颜色区域的中心画十字形标记</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>clock<span class="token punctuation">.</span>fps<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果图：<br><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/openmv1.png" alt="openmv1"></p><p>运算速度：<br><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/openmv2.png" alt="openmv2"></p><p>从拍摄完到扫描完，每秒只能处理二十多帧图像，而且是简单的处理。</p><p>虽然脱机运行速度可以快一倍。但是还是比较慢的。</p><p>肯定要改进啊。</p><p>以下是改进扫描算法的思想：</p><p>①：首先做一次全幅图像的扫描，找到我们需要的色块。</p><p>②：我们得到色块的信息：如色块的长、宽、及色块的位置</p><p>③：我们只扫描色块周围的区域（ROI）</p><p>④：假设在新的ROI找不到我们需要的色块，就重新来。</p><p>这个方法类似于飞思卡尔的边缘检测。</p><p>其实这个改进是非常简单的。因为我们需要的东西在microPython中全部都有。</p><p>只需要拿到find_blobs的返回的东西就好啦。</p><p>算法示意图<br><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/openmv3.jpg" alt="openmv3"></p><p>绿色的是我们追踪的色块，</p><p>而红色的框是我们第一次全局扫描得到的东西</p><p>那么我们只需在红色的框之外做一次扫描就能得到绿色块啦</p><p>实现的源码</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">import</span> sensor<span class="token punctuation">,</span> image<span class="token punctuation">,</span> time <span class="token comment" spellcheck="true">#red_threshold_01 = (45, 100, -60, 80, 34, 91)</span> red_threshold_01 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">72</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">)</span> sensor<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>  sensor<span class="token punctuation">.</span>set_pixformat<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>RGB565<span class="token punctuation">)</span> sensor<span class="token punctuation">.</span>set_framesize<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>QVGA<span class="token punctuation">)</span>  sensor<span class="token punctuation">.</span>skip_frames<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>  sensor<span class="token punctuation">.</span>set_auto_whitebal<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#关闭白平衡。白平衡是默认开启的，在颜色识别中，需要关闭白平衡</span>clock <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span> img <span class="token operator">=</span> sensor<span class="token punctuation">.</span>snapshot<span class="token punctuation">(</span><span class="token punctuation">)</span>blobs <span class="token operator">=</span> img<span class="token punctuation">.</span>find_blobs<span class="token punctuation">(</span><span class="token punctuation">[</span>red_threshold_01<span class="token punctuation">]</span><span class="token punctuation">,</span>                         area_threshold<span class="token operator">=</span><span class="token number">150</span><span class="token punctuation">)</span>last_blobs <span class="token operator">=</span> blobs<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    clock<span class="token punctuation">.</span>tick<span class="token punctuation">(</span><span class="token punctuation">)</span>     img <span class="token operator">=</span> sensor<span class="token punctuation">.</span>snapshot<span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token keyword">if</span> last_blobs<span class="token punctuation">:</span>         <span class="token keyword">for</span> b <span class="token keyword">in</span> blobs<span class="token punctuation">:</span>            x1 <span class="token operator">=</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">7</span>            y1 <span class="token operator">=</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">7</span>            w1 <span class="token operator">=</span> b<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">12</span>            h1 <span class="token operator">=</span> b<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">12</span>            <span class="token comment" spellcheck="true">#print(b.cx(),b.cy())</span>         roi2 <span class="token operator">=</span> <span class="token punctuation">(</span>x1<span class="token punctuation">,</span>y1<span class="token punctuation">,</span>w1<span class="token punctuation">,</span>h1<span class="token punctuation">)</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>roi2<span class="token punctuation">)</span>         blobs <span class="token operator">=</span> img<span class="token punctuation">.</span>find_blobs<span class="token punctuation">(</span><span class="token punctuation">[</span>red_threshold_01<span class="token punctuation">]</span><span class="token punctuation">,</span>                                    roi <span class="token operator">=</span> roi2<span class="token punctuation">,</span>                                    area_threshold<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">)</span>         last_blobs <span class="token operator">=</span> blobs    <span class="token keyword">else</span><span class="token punctuation">:</span>        blobs <span class="token operator">=</span> img<span class="token punctuation">.</span>find_blobs<span class="token punctuation">(</span><span class="token punctuation">[</span>red_threshold_01<span class="token punctuation">]</span><span class="token punctuation">,</span>                                    area_threshold<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">)</span>        last_blobs <span class="token operator">=</span> blobs    <span class="token keyword">if</span> last_blobs<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#如果找到了目标颜色</span>        <span class="token comment" spellcheck="true">#  print(blobs)</span>        <span class="token keyword">for</span> b <span class="token keyword">in</span> last_blobs<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#迭代找到的目标颜色区域</span>            img<span class="token punctuation">.</span>draw_rectangle<span class="token punctuation">(</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>             img<span class="token punctuation">.</span>draw_cross<span class="token punctuation">(</span>b<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"帧率 : "</span><span class="token punctuation">,</span>clock<span class="token punctuation">.</span>fps<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改善后的帧率的确是快了不少的：基本能快一倍以上，当然，物体在图片越大，处理的速度会越慢。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/openmv4.png" alt="openmv4"></p><p>帧率达到了  45  ，并且，对于运动中的物体，也能很好的追踪出来，减少无关物体的干扰。</p><p>按照这个思想，我们还能把这个物体分成四条边来扫描：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/openmv5.jpg" alt="openmv5"></p><p>那么是不是只需要扫描到这个物体的四条边，并且证明四条边的点都有重合，那么，我们就能知道这个物体是一个整体从而得到物体的位置。。。。</p><p>当然，这只是想法。对于程序员任何的功能想法的实现都需要代码的实现，这代码我就不实现了，有兴趣的可以试试。。。</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openmv学习之旅-1</title>
      <link href="/openmv-1/"/>
      <url>/openmv-1/</url>
      
        <content type="html"><![CDATA[<p>最近入手了个OpenMv。<br>装IDE这种小事就不说了。说说真正入门的操作吧。对Python也没啥要求。我也是这样子马上上手的，当然在过程我是学习了Python的。</p><h1 id="1：绘制矩形"><a href="#1：绘制矩形" class="headerlink" title="1：绘制矩形"></a>1：绘制矩形</h1><p>函数说明</p><pre class="line-numbers language-python"><code class="language-python">image<span class="token punctuation">.</span>draw_rectangle（rect_tuple，颜色<span class="token operator">=</span>白色）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数</p><p><code>rect_tuple</code></p><p>格式（x，y，w，h）</p><p>矩阵的起始坐标，（x，y），即矩形的左上角坐标</p><p><code>w</code>：矩形的宽度</p><p><code>h</code>：矩形的高度</p><p><code>x，y，w，h</code>均为整数</p><p><code>颜色</code></p><p>颜色，填入灰度值<code>（0-255）</code>，或者 RGB 值<code>（r，g，b）</code></p><h1 id="下面简单画个矩形"><a href="#下面简单画个矩形" class="headerlink" title="下面简单画个矩形"></a>下面简单画个矩形</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/openmv-1-openmv.png" alt="openmv-1-openmv"></p><h1 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h1><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sensor<span class="token punctuation">,</span> image<span class="token punctuation">,</span> timesensor<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>                      <span class="token comment" spellcheck="true"># Reset and initialize the sensor.</span>sensor<span class="token punctuation">.</span>set_pixformat<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>RGB565<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># Set pixel format to RGB565 (or GRAYSCALE)</span>sensor<span class="token punctuation">.</span>set_framesize<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>QVGA<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Set frame size to QVGA (320x240)</span>sensor<span class="token punctuation">.</span>skip_frames<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># Wait for settings take effect.</span>clock <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># Create a clock object to track the FPS.</span>x <span class="token operator">=</span> <span class="token number">100</span>y <span class="token operator">=</span> <span class="token number">100</span>width <span class="token operator">=</span> <span class="token number">100</span>height <span class="token operator">=</span> <span class="token number">100</span>rect_tuple <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">)</span>rgb_white <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># (r=255, g=255, b=255) -> white color</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    clock<span class="token punctuation">.</span>tick<span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true"># Update the FPS clock.</span>    img <span class="token operator">=</span> sensor<span class="token punctuation">.</span>snapshot<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true"># Take a picture and return the image.</span>    img<span class="token punctuation">.</span>draw_string<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token string">"(%d, %d)"</span><span class="token operator">%</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> color<span class="token operator">=</span>rgb_white<span class="token punctuation">)</span>    img<span class="token punctuation">.</span>draw_rectangle<span class="token punctuation">(</span>rect_tuple<span class="token punctuation">,</span> color<span class="token operator">=</span>rgb_white<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>clock<span class="token punctuation">.</span>fps<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Note: OpenMV Cam runs about half as fast when connected</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是简单画矩形的图像，想要改变矩形位置就改变的x，y（图像左上角起点）</p><p>想要改变矩形面积就改变宽度，高度（图像宽＆高）改变线条颜色就改变 rgb_white</p><p>2：绘制十字</p><p>函数说明</p><pre class="line-numbers language-python"><code class="language-python">image<span class="token punctuation">.</span>draw_cross（x，y，size <span class="token operator">=</span> <span class="token number">5</span>，color <span class="token operator">=</span> White）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数</p><p><code>X</code></p><p>十字中心的 X 坐标</p><p><code>Y</code></p><p>十字中心的 y 坐标</p><p><code>尺寸</code></p><p>十字的长度</p><p><code>颜色</code></p><p>颜色，填入灰度值（0-255），或者 RGB 值（r，g，b）</p><p>样例代码</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sensor<span class="token punctuation">,</span> image<span class="token punctuation">,</span> timesensor<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>                      <span class="token comment" spellcheck="true"># Reset and initialize the sensor.</span>sensor<span class="token punctuation">.</span>set_pixformat<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>RGB565<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Set pixel format to RGB565 (or GRAYSCALE)</span>sensor<span class="token punctuation">.</span>set_framesize<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>QVGA<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Set frame size to QVGA (320x240)</span>sensor<span class="token punctuation">.</span>skip_frames<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># Wait for settings take effect.</span>clock <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># Create a clock object to track the FPS.</span>x <span class="token operator">=</span> <span class="token number">150</span>y <span class="token operator">=</span> <span class="token number">150</span>size <span class="token operator">=</span> <span class="token number">20</span>rgb_white <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># (r=255, g=255, b=255) -> white color</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    clock<span class="token punctuation">.</span>tick<span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true"># Update the FPS clock.</span>    img <span class="token operator">=</span> sensor<span class="token punctuation">.</span>snapshotA<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true"># Take a picture and return the image.</span>    img<span class="token punctuation">.</span>draw_string<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token string">"(%d, %d)"</span><span class="token operator">%</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> color<span class="token operator">=</span>rgb_white<span class="token punctuation">)</span>    img<span class="token punctuation">.</span>draw_cross<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> size<span class="token operator">=</span>size<span class="token punctuation">,</span> color<span class="token operator">=</span>rgb_white<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>clock<span class="token punctuation">.</span>fps<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># Note: OpenMV Cam runs about half as fast when connected</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>学会简单画图，就可以使用 openmv 来做色彩追踪了。</p><p>未完待续……下篇用openmv来做色彩追踪</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机C语言知识用法之#define</title>
      <link href="/c-define/"/>
      <url>/c-define/</url>
      
        <content type="html"><![CDATA[<h1 id="define的定义："><a href="#define的定义：" class="headerlink" title="#define的定义："></a>#define的定义：</h1><p>#define是C语言中的一个预处理指令，其中的“#”表示这是一条预处理命令·。凡是以“#”开头的均为预处理命令，“define”为宏定义命令，“标识符”为所定义的宏名。</p><pre class="line-numbers language-js"><code class="language-js">#define TIME_NUM  <span class="token number">1000</span>  <span class="token comment" spellcheck="true">//定义一个时间数</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一个简单的TIME_NUM 就定义好了，它代表1000，如果在程序里面写:</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>TIME_NUM <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token punctuation">.</span>    <span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译器在处理这个代码之前会对TIME_NUM 进行处理替换为1000。这样的定义看起来类似于普通的常量定义CONST，但也有着不同，因为define的定义更像是简单的文本替换，而不是作为一个量来使用。</p><h1 id="define的语法："><a href="#define的语法：" class="headerlink" title="#define的语法："></a>#define的语法：</h1><h2 id="语法一"><a href="#语法一" class="headerlink" title="语法一:"></a>语法一:</h2><pre class="line-numbers language-js"><code class="language-js">#define      标识符    被标识符代表的字符串      <span class="token comment" spellcheck="true">//这种用法很简单,就是一种替换.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="语法二"><a href="#语法二" class="headerlink" title="语法二:"></a>语法二:</h2><pre class="line-numbers language-js"><code class="language-js">#define     标识符<span class="token punctuation">[</span><span class="token punctuation">(</span>参数<span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>参数n<span class="token punctuation">)</span><span class="token punctuation">]</span>      被标识符代表的字符串        <span class="token comment" spellcheck="true">//其中,在 "被标识符代表的字符串" 中出现的形参将在使用时被实参替代. 就像写函数一样.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-js"><code class="language-js">#define    ADD_NUM     <span class="token number">10</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以这样子用:</p><pre class="line-numbers language-js"><code class="language-js">#define    <span class="token function">ADD</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>     <span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个定义就将返回两个数中较大的那个，看到了吗？<br>因为这个“函数”没有类型检查，就好像一个函数模板似的，当然，它绝对没有模板那么安全就是了。可以作为一个简单的模板来使用而已。<br>但是这样做的话存在隐患，例子如下：</p><pre class="line-numbers language-js"><code class="language-js">#define <span class="token function">ADD</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>   a<span class="token operator">+</span>b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在一般使用的时候是没有问题的，但是如果遇到如：c * Add(a,b) * d的时候就会出现问题，代数式的本意是a+b然后去和c，d相乘，但是因为使用了define（它只是一个简单的替换），所以式子实际上变成了  c<em>a + b</em>d 所以，用#define要注意顺序</p><p>一般我个人用#define在单片机程序上的话，我一般只做简单的替换。</p><pre class="line-numbers language-js"><code class="language-js">#define TIME_NUM   <span class="token punctuation">(</span><span class="token number">60</span><span class="token operator">*</span><span class="token number">60</span><span class="token operator">*</span><span class="token number">24</span><span class="token punctuation">)</span>UL<span class="token comment" spellcheck="true">//定义一个一天时间有多少秒</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外举一个例子：</p><pre class="line-numbers language-js"><code class="language-js">#define pin <span class="token punctuation">(</span>int<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pin a<span class="token punctuation">,</span>b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>本意是a和b都是int型指针，但是实际上变成int* a,b;<br>a是int型指针，而b是int型变量。<br>这是应该使用typedef来代替define，这样a和b就都是int型指针了。<br>所以我们在定义的时候，养成一个良好的习惯，建议所有的层次都要加括号。</p><p>而且，宏在单片机代码中用的很多，常数的替换、地址的偏移，等等都用得上<br>用宏来修改移植代码更加便捷，代码更容易使人读懂。。。。</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hellolo world</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="hello"><a href="#hello" class="headerlink" title="hello"></a>hello</h1><blockquote><p>网络的好朋友，你好，我是杰杰！如果我的博客有什么不足的地方，欢迎向我反馈；如果我的博客对你有帮助，那是我的荣幸！如果觉得文章很好，欢迎动动小手指，点个赞或者转发        —–杰杰。</p></blockquote><p>欢迎关注我个人微信公众号，来一起全栈开发~<br><img src="./images/loading.png" data-original="https://imgconvert.csdnimg.cn/aHR0cDovL2ppZWppZTAxLnRvcC9Mb2dvL0daLnBuZw?x-oss-process=image/format,png" alt=""></p><h1 id="网络协议栈-【推荐】"><a href="#网络协议栈-【推荐】" class="headerlink" title="网络协议栈 【推荐】"></a>网络协议栈 【推荐】</h1><ol><li><a href="https://blog.csdn.net/jiejiemcu/article/details/85233198" target="_blank" rel="noopener">lwip源码下载地址</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88024614" target="_blank" rel="noopener">TCP/IP协议栈扫盲班</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88204770" target="_blank" rel="noopener">网络底层知识</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88406088" target="_blank" rel="noopener">ARP协议原理</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88879553" target="_blank" rel="noopener">LwIP中的ARP实现（1）之ARP缓存表的数据结构</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88887437" target="_blank" rel="noopener">LwIP中的ARP实现（2）之ARP缓存表的超时处理</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88887466" target="_blank" rel="noopener">LwIP中的ARP实现（3）之发送ARP请求包</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88887494" target="_blank" rel="noopener">LwIP中的ARP实现（4）之ARP数据包接收</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88887520" target="_blank" rel="noopener">LwIP中的ARP实现（5）之ARP数据包发送 </a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/89072812" target="_blank" rel="noopener">IP协议基础扫盲班</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/89072834" target="_blank" rel="noopener">IP地址相关知识深入了解~</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/89072573" target="_blank" rel="noopener">IP数据报格式分析</a></li></ol><p>未完待续…</p><h1 id="RTOS操作系统相关"><a href="#RTOS操作系统相关" class="headerlink" title="RTOS操作系统相关"></a>RTOS操作系统相关</h1><ol><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/86701792" target="_blank" rel="noopener">FreeRTOS移植——基于stm32f1</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80308052" target="_blank" rel="noopener">【连载】从单片机到操作系统③——走进FreeRTOS</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80463911" target="_blank" rel="noopener">【连载】从单片机到操作系统④——FreeRTOS创建任务&amp;开启调度详解</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80637559" target="_blank" rel="noopener">【连载】从单片机到操作系统⑤——FreeRTOS列表&amp;列表项的源码解读</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/81039707" target="_blank" rel="noopener">【连载】从单片机到操作系统⑥——FreeRTOS任务切换机制详解</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/81515788" target="_blank" rel="noopener">【连载】从单片机到操作系统⑦——深入了解FreeRTOS的延时机制</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82534974" target="_blank" rel="noopener">RTOS的临界段知识详解</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/86715766" target="_blank" rel="noopener">FreeRTOS消息队列</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/87174666" target="_blank" rel="noopener">FreeRTOS优化与错误排查方法</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/84778522" target="_blank" rel="noopener">继续学习FreeRTOS~</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82588304" target="_blank" rel="noopener">RT-Thread内核实现的思维导图——线程&amp;调度器</a></p><p>未完待续…</p></li></ol><h1 id="STM8"><a href="#STM8" class="headerlink" title="STM8"></a>STM8</h1><ol><li><a href="https://blog.csdn.net/jiejiemcu/article/details/80543012" target="_blank" rel="noopener"> STM8L051F3_0d_基础介绍</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/80219795" target="_blank" rel="noopener">STM8L051F3_0b_开发环境搭建</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/80219830" target="_blank" rel="noopener">STM8L051F3_0c_新建工程</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/80543043" target="_blank" rel="noopener">STM8L051F3_01_GPIO应用</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/80574810" target="_blank" rel="noopener">STM8L051F3_02_EXTI应用</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/80629051" target="_blank" rel="noopener">STM8L051F3_03_CLK应用</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/80659610" target="_blank" rel="noopener">STM8L051F3_04_PWR应用</a></li></ol><p>未完待续…</p><h1 id="STM32"><a href="#STM32" class="headerlink" title="STM32"></a>STM32</h1><ol><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80179096" target="_blank" rel="noopener">【干货】老外的GitHub整理的stm32f4驱动库</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80542667" target="_blank" rel="noopener">【重写】简析stm32启动过程</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80563422" target="_blank" rel="noopener">STM32进阶之串口环形缓冲区实现</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80565426" target="_blank" rel="noopener">嵌入式重定向 printf</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82227824" target="_blank" rel="noopener">数据处理相关源码</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82743945" target="_blank" rel="noopener">STM32之串口DMA接收不定长数据</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82898387" target="_blank" rel="noopener">基于Linux的kfifo移植到STM32（支持os的互斥访问）</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/83685631" target="_blank" rel="noopener">纯C语言写的按键驱动，将按键逻辑与按键处理事件分离~</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/83932913" target="_blank" rel="noopener">一种Cortex-M内核中的精确延时方法</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/87615397" target="_blank" rel="noopener">CmBacktrace: ARM Cortex-M 系列 MCU 错误追踪库</a></p><p>未完待续…</p></li></ol><h1 id="学习随笔"><a href="#学习随笔" class="headerlink" title="学习随笔"></a>学习随笔</h1><ol><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82049104" target="_blank" rel="noopener">git常用命令</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82262712" target="_blank" rel="noopener">vs code 随笔</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82430157" target="_blank" rel="noopener">STM32等处理器的MDK离线支持包下载地址</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/84857382" target="_blank" rel="noopener">mdk5.26、5.27下载地址</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/85165949" target="_blank" rel="noopener">mdk工程的批量操作文件</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/87340868" target="_blank" rel="noopener">PDF Drive</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/87904149" target="_blank" rel="noopener">基于腾讯云Ubuntu主机搭建ghost</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/88097620" target="_blank" rel="noopener">基于ubuntu腾讯云主机搭建书库</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/88070640" target="_blank" rel="noopener">http客户端</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80543529" target="_blank" rel="noopener">基于小程序、单片机与PLC组合的共享车库信息平台平台【已经实现】</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/79307249" target="_blank" rel="noopener">超声波测距原理与实现</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/79469682" target="_blank" rel="noopener">openmv学习之旅①</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80579893" target="_blank" rel="noopener">openmv学习之旅②之色块追踪算法的改善</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80537935" target="_blank" rel="noopener">【野火®】i.MX RT1052评测——移植RT-Thread</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80495612" target="_blank" rel="noopener">开源一个串口上位机源码</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80543069" target="_blank" rel="noopener">win10 64位JLink v8固件丢失修复经验</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/79307319" target="_blank" rel="noopener">如何阅读看懂datasheet</a></p><p>未完待续…</p></li></ol><h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><ol><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80861760" target="_blank" rel="noopener">C语言字符串匹配与数据提取源码</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/79307332" target="_blank" rel="noopener">单片机C语言知识用法之#define</a></p><p>未完待续…</p></li></ol><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
