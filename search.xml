<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【ROS入门-6】ROS工作空间、package 及 catkin 编译系统</title>
      <link href="/ros-6/"/>
      <url>/ros-6/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>其实从前几篇文章中我也有提及过<strong>ROS 工作空间</strong>，而且代码也是在工作空间中编译、运行的。</p><p>其实在 ROS 中，我们创建的软件代码，都会被组织成功能包的形式，所以在我们开始代码之前，第一步是创建一个容纳我们的工作空间。</p><p>因此本文将介绍<strong>ROS工作空间、package 及 catkin 编译系统</strong>。</p><h1 id="ROS系列文章"><a href="#ROS系列文章" class="headerlink" title="ROS系列文章"></a>ROS系列文章</h1><ul><li><p><a href="https://jiedev.com/ros-1/">【ROS入门-1】手把手教你在Ubuntu18.04安装ROS Melodic</a></p></li><li><p><a href="https://jiedev.com/ros-2/">【ROS入门-2】带你看ROS文件系统及其工具</a></p></li><li><p><a href="https://jiedev.com/ros-3/">【ROS入门-3】嘴对嘴讲解ROS的核心概念——节点与节点管理器</a></p></li><li><p><a href="https://jiedev.com/ros-4/">【ROS入门-4】嘴对嘴讲解ROS的核心概念——ROS话题通信机制</a></p></li><li><p><a href="https://jiedev.com/ros-5/">【ROS入门-5】深入了解ROS话题通信机制的过程</a></p></li><li><p><a href="https://jiedev.com/ros-6/">【ROS入门-6】ROS工作空间、package 及 catkin 编译系统</a></p></li></ul><h1 id="ROS-工作空间"><a href="#ROS-工作空间" class="headerlink" title="ROS 工作空间"></a>ROS 工作空间</h1><p>简单地说，ROS 工作空间（ROS workspace）就是统一存放 ROS 文件的地方，这里的文件包括源码、功能包、编译产生的中间文件等，一个项目的所有 ROS 文件最好都放在一个 workspace 中，便于统一管理、编译和调用。</p><p>一般来说，对于初学者，ROS的工作空间不需要经常建立，因为很多代码只是demo，一般只建立一个就好了，但是如果你的工作涉及大量的功能包，或者涉及几个相互独立的的项目，还是建立多个工作空间比较好，这东西看情况使用就好了。</p><p>我们可以在任意位置创建工作目录，一般来说工作空间都有4个文件夹：</p><ul><li><p>src：代码空间，是用来放置我们的功能包的，包括功能包的代码、功能包的配置文件配置等，这个功能包可以是自己写的，也可以是别人的功能包，总之都放在这。</p></li><li><p>build：编译空间，里面会有编译时产生的一些中间的文件，这个文件夹大家基本上是不用去关心的。</p></li><li><p>devel：开发空间，里面会放置我们编译生成的一些可执行文件，还包括一些库、一些脚本等等都放在这里。</p></li><li><p>install： 安装空间，在编译成功后，可以使用<code>make install</code>命令将可执行文件安装到该空间中，这个文件夹并不一定需要，实际上很多工作空间都不需要这个文件夹。</p></li></ul><h1 id="创建工作空间"><a href="#创建工作空间" class="headerlink" title="创建工作空间"></a>创建工作空间</h1><p>在任意目录下创建一个文件夹，名字你随意起，我就起ros_ws，然后在这个文件夹下创建src文件夹：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros017.png" alt="ros017"></p><p>然后在这个src文件夹下运行以下命令去初始化工作空间：</p><pre class="line-numbers language-bash"><code class="language-bash">catkin_init_workspace<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后你就会发现在src目录下生成了一个<code>CMakeLists.txt</code>文件，这其实是CMake的构建规则的文件，这个文件包含了一系列的编译指令，包括应该生成哪种可执行文件，需要哪些源文件，以及在哪里可以找到所需的头文件和链接库。当然，这个文件表明 catkin 在内部使用了 CMake。有兴趣的可以去看看我以前的博文，就是讲解CMake的。</p><h1 id="编译工作空间"><a href="#编译工作空间" class="headerlink" title="编译工作空间"></a>编译工作空间</h1><p>工作空间里面虽然没有任何代码，<strong>但是你依然可以去编译啊</strong>，只不过是一个空的工程，那在这里我们一样可以针对ROS的空的空间做编译，大家可以来熟悉一下这个编译的方式，我们要回到你的这个工作空间的根目录ros_ws，在这个目录下进行编译。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> <span class="token punctuation">..</span><span class="token comment" spellcheck="true"># 编译</span>catkin_make<span class="token comment" spellcheck="true"># 输出内容</span>······-- Using Python nosetests: /usr/bin/nosetests-2.7-- catkin 0.7.23-- BUILD_SHARED_LIBS is on-- BUILD_SHARED_LIBS is on-- Configuring <span class="token keyword">done</span>-- Generating <span class="token keyword">done</span>-- Build files have been written to: /home/jie/ros_ws/build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到有对应的内容输出了，就表示编译成功，然后你的ros_ws目录下回多了两个文件夹，分别为build、devel，这两个文件夹的作用就是前面讲解的了。</p><h1 id="导出环境变量"><a href="#导出环境变量" class="headerlink" title="导出环境变量"></a>导出环境变量</h1><p>devel目录就是我们的环境变量，假设我们当前的工作空间有代码，那么编译成功后会产生可执行文件，那么ROS如何去找到这个可执行文件呢，它不是全能的，需要我们去指定这个可执行文件在哪里，它才能找到，因此我们需要将编译产生的可执行文件、脚本等内容都要告诉系统，我称之为<strong>导出环境变量</strong>。</p><p>如果你查看一下在<code>devel</code>文件夹里面你可以看到几个setup.sh文件。source这些文件中的任何一个都可以将当前工作空间设置在ROS工作环境的最顶层。</p><p>如果你的终端是bash（Ubuntu默认终端），那么就运行：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">source</span> devel/setup.bash <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我个人用的终端是zsh，我是修改过了的，我运行以下命令：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">source</span> devel/setup.zsh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后用<code>echo $ROS_PACKAGE_PATH</code>命令去检查环境变量是否导出，当输出包含了你工作空间的目录就表示环境变量已经导出成功了：</p><pre class="line-numbers language-bash"><code class="language-bash">➜  ros_ws <span class="token keyword">echo</span> <span class="token variable">$ROS_PACKAGE_PATH</span> /home/jie/ros_ws/src:/opt/ros/melodic/share<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="创建功能包"><a href="#创建功能包" class="headerlink" title="创建功能包"></a>创建功能包</h1><p>写代码就要创建一个功能包，放着源码文件，在工作空间的src目录下可以直接运行<code>catkin_create_pkg</code>命令去创建功能包，这个命令有非常多的功能，你可以通过<code>catkin_create_pkg -h</code>去细看它的功能，而我就简单讲解一下：</p><p>简单的命令用法：</p><pre class="line-numbers language-bash"><code class="language-bash">catkin_create_pkg <span class="token punctuation">[</span>功能包名称<span class="token punctuation">]</span> <span class="token punctuation">[</span>依赖功能包1<span class="token punctuation">]</span> <span class="token punctuation">[</span>依赖功能包2<span class="token punctuation">]</span> <span class="token punctuation">[</span>依赖功能包n<span class="token punctuation">]</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建mytopic001功能包，依赖roscpp、rospy、std_msgs这几个功能包，其实rospy不是必须的，我们目前写的是c++的代码，不过放进去都无所谓。</p><pre class="line-numbers language-bash"><code class="language-bash">catkin_create_pkg mytopic001 roscpp rospy std_msgs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>catkin_create_pkg</code>命令在创建用户功能包时会生成catkin构建系统所需的CMakeLists.txt和package.xml文件，还有存放代码的src文件夹，和include文件夹，注意这里的src并不是工作目录下的src，而是功能包的src文件夹。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros018.png" alt="ros018"></p><p>你可以手动去修改功能包的依赖关系，比如编辑<code>package.xml</code>文件：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros019.png" alt="ros019"></p><h1 id="添加源代码"><a href="#添加源代码" class="headerlink" title="添加源代码"></a>添加源代码</h1><p>我们将上一篇文章<a href="https://jiedev.com/ros-4/">【ROS入门-4】嘴对嘴讲解ROS的核心概念——ROS话题通信机制</a>的源代码添加到这个工作空间中，存放的位置是：<code>ros_ws/src/mytopic001/src</code>，</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros020.png" alt="ros020"></p><h1 id="修改构建规则"><a href="#修改构建规则" class="headerlink" title="修改构建规则"></a>修改构建规则</h1><p>修改<code>ros_ws/src/mytopic001</code>目录下的<code>CMakeLists.txt</code>文件就是修改对应的构建规则，可以在这个文件中设置可执行文件的创建规则、依赖关系、连接关系等等。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">add_executable</span><span class="token punctuation">(</span>publisher_topic src<span class="token operator">/</span>publisher_topic<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span><span class="token function">target_link_libraries</span><span class="token punctuation">(</span>publisher_topic $<span class="token punctuation">{</span>catkin_LIBRARIES<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">add_executable</span><span class="token punctuation">(</span>subscriber_topic src<span class="token operator">/</span>subscriber_topic<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span><span class="token function">target_link_libraries</span><span class="token punctuation">(</span>subscriber_topic $<span class="token punctuation">{</span>catkin_LIBRARIES<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros021.png" alt="ros021"></p><p>其实如果你会了CMake后，这东西是非常简单的。。。上面的操作起始就是编译两个可执行文件<code>publisher_topic</code>和<code>subscriber_topic</code>，分别执行发布与订阅的操作。</p><h1 id="编译功能包"><a href="#编译功能包" class="headerlink" title="编译功能包"></a>编译功能包</h1><p>回到工作空间的根目录下<code>ros_ws</code>，运行<code>catkin_make</code>命令编译，当输出以下内容时，表示编译成功：</p><pre class="line-numbers language-bash"><code class="language-bash">catkin_make<span class="token comment" spellcheck="true"># 输出内容</span>······Scanning dependencies of target subscriber_topicScanning dependencies of target publisher_topic<span class="token punctuation">[</span> 50%<span class="token punctuation">]</span> Building CXX object mytopic001/CMakeFiles/publisher_topic.dir/src/publisher_topic.cpp.o<span class="token punctuation">[</span> 50%<span class="token punctuation">]</span> Building CXX object mytopic001/CMakeFiles/subscriber_topic.dir/src/subscriber_topic.cpp.o<span class="token punctuation">[</span> 75%<span class="token punctuation">]</span> Linking CXX executable /home/jie/ros_ws/devel/lib/mytopic001/publisher_topic<span class="token punctuation">[</span>100%<span class="token punctuation">]</span> Linking CXX executable /home/jie/ros_ws/devel/lib/mytopic001/subscriber_topic<span class="token punctuation">[</span>100%<span class="token punctuation">]</span> Built target publisher_topic<span class="token punctuation">[</span>100%<span class="token punctuation">]</span> Built target subscriber_topic<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>步骤如下：</p><ol><li>首先导出环境变量（注意根据你的终端配置运行命令）</li></ol><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">source</span> devel/setup.zsh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>运行节点管理器</li></ol><pre class="line-numbers language-bash"><code class="language-bash">roscore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>在新终端运行发布者节点，也是需要导出环境变量的，不然ROS找不到你的可执行程序位置</li></ol><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">source</span> ros_ws/devel/setup.zshrosrun mytopic001 publisher_topic <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="4"><li>在新终端运行订阅者者节点</li></ol><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">source</span> ros_ws/devel/setup.zshrosrun mytopic001 subscriber_topic <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最终效果：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros022.png" alt="ros022"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/ZhangRelay/article/details/79302460" target="_blank" rel="noopener">张老师的书籍《ROS_Robot_Programming》</a></p><p><a href="https://blog.csdn.net/jiejiemcu/category_9558411.html" target="_blank" rel="noopener">CMake实战教程</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 机器人操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS入门-5】深入了解ROS话题通信机制的过程</title>
      <link href="/ros-5/"/>
      <url>/ros-5/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇文章中简单了解了ROS话题通信机制，但是它内部的通信过程，很多人都是不知道的，今天我看了 <a href="https://item.jd.com/12377412.html" target="_blank" rel="noopener"> 胡春旭的书籍——《ROS机器人开发实践》</a>，又加深了对ROS话题通信的理解，打算接着讲解一下其过程是怎么样的。</p><h1 id="ROS系列文章"><a href="#ROS系列文章" class="headerlink" title="ROS系列文章"></a>ROS系列文章</h1><ul><li><p><a href="https://jiedev.com/ros-1/">【ROS入门-1】手把手教你在Ubuntu18.04安装ROS Melodic</a></p></li><li><p><a href="https://jiedev.com/ros-2/">【ROS入门-2】带你看ROS文件系统及其工具</a></p></li><li><p><a href="https://jiedev.com/ros-3/">【ROS入门-3】嘴对嘴讲解ROS的核心概念——节点与节点管理器</a></p></li><li><p><a href="https://jiedev.com/ros-4/">【ROS入门-4】嘴对嘴讲解ROS的核心概念——ROS话题通信机制</a></p></li><li><p><a href="https://jiedev.com/ros-5/">【ROS入门-5】深入了解ROS话题通信机制的过程</a></p></li></ul><h1 id="节点的连接"><a href="#节点的连接" class="headerlink" title="节点的连接"></a>节点的连接</h1><p>一个节点需要与系统中其他节点进行通信才有意义，系统中任何单独的一个节点其实都是没有意义的。下图是一个话题通讯的过程示意图，一个节点通过节点管理器连接到另一个节点，最终请求话题数据流。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros016.png" alt="ros016"></p><blockquote><p>ps：在ROS中有两个节点：一个是发布者<code>Talker</code>，另一个是订阅者<code>Listener</code>，两个节点分别发布、订阅同一个话题<code>bar</code>。</p></blockquote><h1 id="①发布者Talker注册"><a href="#①发布者Talker注册" class="headerlink" title="①发布者Talker注册"></a>①发布者<code>Talker</code>注册</h1><p>在系统中，节点与节点是没有任何关系的，都靠节点管理器来处理相关的请求与服务，首先第一步，发布者<code>Talker</code>需要向节点管理器<code>ROS Master</code>注册相关信息，包括节点的信息、需要发布的话题名等，然后节点管理器<code>ROS Master</code>会记录下来<code>Talker</code>节点的信息。</p><h1 id="②订阅者Listener注册"><a href="#②订阅者Listener注册" class="headerlink" title="②订阅者Listener注册"></a>②订阅者<code>Listener</code>注册</h1><p>同理订阅者<code>Listener</code>也需要向节点管理器<code>ROS Master</code>注册相关信息，这其实是启动两个节点时候就已经做了的事情。</p><h1 id="③节点管理器ROS-Master进行话题匹配"><a href="#③节点管理器ROS-Master进行话题匹配" class="headerlink" title="③节点管理器ROS Master进行话题匹配"></a>③节点管理器<code>ROS Master</code>进行话题匹配</h1><p>因为发布者<code>Talker</code>与订阅者<code>Listener</code>节点都在节点管理器<code>ROS Master</code>注册了信息，那么节点管理器<code>ROS Master</code>就会发现有相同的话题信息，此时它就需要将订阅与发布话题的两个节点匹配在一起，会通过RPC向订阅者<code>Listener</code>发送<code>Talker</code>节点的RPC地址信息。</p><h1 id="④订阅者Listener向Talker发送连接请求"><a href="#④订阅者Listener向Talker发送连接请求" class="headerlink" title="④订阅者Listener向Talker发送连接请求"></a>④订阅者<code>Listener</code>向<code>Talker</code>发送连接请求</h1><p>订阅者<code>Listener</code>知道发布者<code>Talker</code>后，就会主动找到它，并且通过RPC向T<code>Talker</code><br>发送连接请求，传输订阅的话题名、消息类型以及通信协议。</p><h1 id="⑤发布者Talker确认连接请求"><a href="#⑤发布者Talker确认连接请求" class="headerlink" title="⑤发布者Talker确认连接请求"></a>⑤发布者<code>Talker</code>确认连接请求</h1><p><code>Talker</code>接收到<code>Listener</code>发送的连接请求后，继续通过RPC向<code>Listener</code>确认连接信息，同时发送自身相关的信息。</p><h1 id="⑥Listener尝试与Talker建立网络连接"><a href="#⑥Listener尝试与Talker建立网络连接" class="headerlink" title="⑥Listener尝试与Talker建立网络连接"></a>⑥<code>Listener</code>尝试与<code>Talker</code>建立网络连接</h1><p>Listener接收到确认信息后，使用TCP尝试与<code>Talker</code>建立网络连接。</p><h1 id="⑦Talker向Listener发布消息"><a href="#⑦Talker向Listener发布消息" class="headerlink" title="⑦Talker向Listener发布消息"></a>⑦<code>Talker</code>向<code>Listener</code>发布消息</h1><p>成功建立连接后，<code>Talker</code>开始向<code>Listener</code>发送话题消息数据。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在节点与节点建立连接前，他们的通信协议都是RPC，而这主要都是依赖于节点管理器的，在节点与节点建立连接后，就直接是使用TCP协议进行数据传输，而不需要依赖节点管理器，此时节点管理器允许被关闭，但在关闭后，其他节点就不能订阅、发布这个话题消息了。</p><p>总之节点管理器<code>ROS Master</code>在节点建立连接的过程中起到了重要作用，<strong>但是并不参与节点之间最终的数据传输。</strong></p><h1 id="引用说明"><a href="#引用说明" class="headerlink" title="引用说明"></a>引用说明</h1><p>本文的部分截图来自书籍<a href="https://item.jd.com/12377412.html" target="_blank" rel="noopener">《ROS机器人开发实践》 胡春旭 著</a>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingTopics" target="_blank" rel="noopener">ROS官方wiki</a></p><p><a href="https://joveh-h.blog.csdn.net/article/details/90551432" target="_blank" rel="noopener">ROS笔记（7） 话题通信</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 机器人操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS入门-4】嘴对嘴讲解ROS的核心概念——ROS话题通信机制</title>
      <link href="/ros-4/"/>
      <url>/ros-4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我要给大家来介绍一下ROS当中一些核心的概念，帮助大家去在后面的ROS学习当中更快地吸收这些概念，今天讲解的是ROS中的通信机制——话题通信。</p><h1 id="ROS系列文章"><a href="#ROS系列文章" class="headerlink" title="ROS系列文章"></a>ROS系列文章</h1><ul><li><p><a href="https://jiedev.com/ros-1/">【ROS入门-1】手把手教你在Ubuntu18.04安装ROS Melodic</a></p></li><li><p><a href="https://jiedev.com/ros-2/">【ROS入门-2】带你看ROS文件系统及其工具</a></p></li><li><p><a href="https://jiedev.com/ros-3/">【ROS入门-3】嘴对嘴讲解ROS的核心概念——节点与节点管理器</a></p></li><li><p><a href="https://jiedev.com/ros-4/">【ROS入门-4】嘴对嘴讲解ROS的核心概念——ROS话题通信机制</a></p></li><li><p><a href="https://jiedev.com/ros-5/">【ROS入门-5】深入了解ROS话题通信机制的过程</a></p></li></ul><h1 id="ROS的通信机制"><a href="#ROS的通信机制" class="headerlink" title="ROS的通信机制"></a>ROS的通信机制</h1><p>从前面的文章我们知道，ROS的通信机制是一个 <strong><code>松散耦合的分布式软件框架</code></strong> 设计而来的，而节点间的通讯就会必然是有几种通讯方式，那ROS主要给节点之间提供三种核心的通讯方式，一种叫做话题（topic），一种叫做服务（server），以及基于RPC的参数服务器。</p><p><strong>我们接下来讲解ROS的核心概念——ROS话题通信机制。</strong></p><h1 id="话题（topic）"><a href="#话题（topic）" class="headerlink" title="话题（topic）"></a>话题（topic）</h1><p><code>话题</code>就是ROS中一个数据传输的<strong>有名字的通道</strong>。当一个节点想要分享信息时，它就会发布(publish)消息到对应的一个或者多个话题；当一个节点想要接收信息时，它就会订阅(subscribe)它所需要的一个或者多个话题。 ROS节点管理器负责确保发布节点和订阅节点能找到对方；<strong>而且消息是直接地从发布节点传递到订阅节点，中间并不经过节点管理器转交。</strong></p><p>topic这个单词对我来说是非常熟悉的，因为我在物联网领域老是捣鼓网络协议栈，在MQTT协议里面经常看到topic，巧合的是ROS中的topic跟MQTT协议中的topic是非常像的，基本可以说是同样的模型，但MQTT协议里面需要服务器转发数据。</p><p>比如我们看下面这张图：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros012.png" alt="ros012"></p><p>话题通讯的模型比较简单，这张图的模型里面会分为<strong>发布者（publisher）</strong>和<strong>订阅者（subscriber）</strong>，话题的这种通讯的方式是单向数据传输。比如说有一个节点它要发布一个数据，这个摄像头驱动节点它来驱动摄像头，并且获取摄像头的数据，然后传出来给处理数据的节点去处理，所以它会不断的往外发送一些图像数据，那它发到哪里呢？这个节点作为发布者，需要向某个<code>话题（topic，也可以称为主题）</code>发布这些数据，那么当系统中可能有多个节点要去处理图像，比如有一个节点是需要显示图像数据的，有一个节点是做图像处理的，它们实现要获取到这些数据后，才能处理对吧，而这些节点就是订阅者，它们从<code>话题（topic）</code>中接收这些数据，然后去处理它。</p><h1 id="发布者"><a href="#发布者" class="headerlink" title="发布者"></a>发布者</h1><p>发布者：发布（publish）是指以将数据发布到某个话题中，为了可以正常执行发布操作。发布者（publisher）必须在节点管理器上注册自己的话题等多种信息。</p><p><strong>发布者</strong>的工作过程如下：</p><ol><li><p>向节点管理器注册节点。</p></li><li><p>告诉管理器要向哪个话题发布数据。</p></li><li><p>节点运行时采集数据，然后发布到这个话题。</p></li></ol><h1 id="订阅者"><a href="#订阅者" class="headerlink" title="订阅者"></a>订阅者</h1><p>订阅是指订阅者节点想要接收来自某个话题的数据。为了可以正常执行订阅的操作，订阅者节点必须在节点管理器上注册自己想要订阅的话题等多种信息，并从节点管理器接收来自发布者的数据信息，同一个话题可以有多个发布者也可以有多个订阅者，但一般情况下发布者只有一个，而订阅者是一个或者多个。</p><p><strong>订阅者</strong>的工作过程如下：</p><ol><li><p>向节点管理器注册节点。</p></li><li><p>订阅话题，告诉管理器要接收哪个话题的数据。</p></li><li><p>节点运行时就接收数据，然后去处理数据（一般来说会注册回调函数，当有数据的时候就在回调函数中处理）。</p></li></ol><p>总的来说，话题就像是一个数据传输的管道。打个比方，你可以在运输牛奶的管道接到牛奶，在运输煤气的管道上接收到煤气，在水管上接到水。。。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros013.png" alt="ros013"></p><p>就拿上面的图来说，<code>Camera Node</code>节点是发布者，它负责采集图像数据并且发布；<code>Image Processing Node</code>节点是订阅者，在接收到图像数据后要去处理数据，<code>Image Display Node</code>节点也是订阅者，在接收到图像数据后要去显示图像的数据。</p><p>话题通讯它是一种<strong>异步通讯</strong>，因为我们没有办法知道发布者跟订阅者之间单向传输的这个时效性啊，我可能发不出去之后，订阅者可能等很长时间啊或者阻塞才会接收，到那很多情况下，我们更希望我的数据发出去之后，对方能给我一个。</p><h1 id="消息（Message）"><a href="#消息（Message）" class="headerlink" title="消息（Message）"></a>消息（Message）</h1><p>大家有没有考虑过，话题之间的数据叫什么呢？没错，就是叫<strong>消息</strong>。</p><p>节点之间通过消息（message）来发送和接收数据。消息是用来描述我们传输话题数据的，消息可以是各种类型的数据，比如整形、浮点型、字符等不定程度的数据，我们还可以在消息中使用一些数据结构来描述这些消息。</p><h1 id="用C-来写话题通信的代码"><a href="#用C-来写话题通信的代码" class="headerlink" title="用C++来写话题通信的代码"></a>用C++来写话题通信的代码</h1><p>因为本系列文章还没介绍到工作空间，那么就先简单看看怎么去写代码吧：</p><ul><li>头文件</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;ros/ros.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;geometry_msgs/Twist.h></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="发布者-1"><a href="#发布者-1" class="headerlink" title="发布者"></a>发布者</h2><ul><li>创建节点句柄，并且告诉节点管理器准备向<code>test_topic</code>话题发布消息。</li></ul><pre class="line-numbers language-c"><code class="language-c">    <span class="token comment" spellcheck="true">// ROS节点初始化</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">init</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"publisher_topic"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建节点句柄</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span>NodeHandle n<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建一个Publisher，发布名为test_topic，消息类型为gstd_msgs::String，队列长度100</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span>Publisher pub_topic <span class="token operator">=</span> n<span class="token punctuation">.</span>advertise<span class="token operator">&lt;</span>std_msgs<span class="token punctuation">:</span><span class="token punctuation">:</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"test_topic"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>填充消息的内容并且向话题发布消息：</li></ul><pre class="line-numbers language-c"><code class="language-c">    <span class="token comment" spellcheck="true">// 初始化std_msgs::String类型的消息</span>    std_msgs<span class="token punctuation">:</span><span class="token punctuation">:</span>String str_msg<span class="token punctuation">;</span>    str_msg<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token string">"this is a test_topic message!"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 发布消息</span>    pub_topic<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span>str_msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="订阅者-1"><a href="#订阅者-1" class="headerlink" title="订阅者"></a>订阅者</h2><ul><li>创建节点句柄，并且告诉节点管理器订阅一个话题<code>test_topic</code></li></ul><pre class="line-numbers language-c"><code class="language-c">    <span class="token comment" spellcheck="true">// 接收到订阅的消息后，会进入消息回调函数</span>    <span class="token keyword">void</span> <span class="token function">test_topic_cb</span><span class="token punctuation">(</span><span class="token keyword">const</span> std_msgs<span class="token punctuation">:</span><span class="token punctuation">:</span>String<span class="token punctuation">:</span><span class="token punctuation">:</span>ConstPtr<span class="token operator">&amp;</span> msg<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将接收到的消息打印出来</span>        <span class="token function">ROS_INFO</span><span class="token punctuation">(</span><span class="token string">"I heard: [%s]"</span><span class="token punctuation">,</span> msg<span class="token operator">-></span>data<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 初始化ROS节点</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">init</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"subscriber_topic"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建节点句柄</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span>NodeHandle n<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建一个Subscriber，订阅名为test_topic的消息，注册回调函数test_topic_cb</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span>Subscriber sub_topic <span class="token operator">=</span> n<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"test_topic"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> test_topic_cb<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>循环等待来自话题<code>test_topic</code>的消息，当收到消息后会进入回调函数<code>test_topic_cb()</code>中处理：</li></ul><pre class="line-numbers language-c"><code class="language-c">    <span class="token comment" spellcheck="true">// 循环等待回调函数</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">spin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此处需要在工作空间进行实验，分别打开新的终端运行节点管理器、发布者节点、订阅者节点，实验效果如下：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros014.png" alt="ros014"></p><h1 id="使用rqt-graph"><a href="#使用rqt-graph" class="headerlink" title="使用rqt_graph"></a>使用rqt_graph</h1><p><code>publisher_topic</code>节点和<code>subscriber_topic</code>节点之间是通过一个<code>test_topic</code>话题来互相通信的，我们可以使用<code>rqt_graph</code>来显示当前运行的节点和话题。</p><p>rqt_graph是rqt程序包中的一部分，如果你没有安装，请通过以下命令来安装：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> ros-<span class="token operator">&lt;</span>distro<span class="token operator">></span>-rqt<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> ros-<span class="token operator">&lt;</span>distro<span class="token operator">></span>-rqt-common-plugins<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将 <code>&lt;distro&gt;</code>替换成你所安装的版本（比如 kinetic、melodic 等）。</p><p>在一个新终端中运行:</p><pre class="line-numbers language-bash"><code class="language-bash">rosrun rqt_graph rqt_graph<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你会看到以下界面：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros015.png" alt="ros015"></p><h1 id="源码附录"><a href="#源码附录" class="headerlink" title="源码附录"></a>源码附录</h1><ul><li>subscriber_topic.cpp:</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;ros/ros.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;std_msgs/String.h></span></span><span class="token comment" spellcheck="true">// 接收到订阅的消息后，会进入消息回调函数</span><span class="token keyword">void</span> <span class="token function">test_topic_cb</span><span class="token punctuation">(</span><span class="token keyword">const</span> std_msgs<span class="token punctuation">:</span><span class="token punctuation">:</span>String<span class="token punctuation">:</span><span class="token punctuation">:</span>ConstPtr<span class="token operator">&amp;</span> msg<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 将接收到的消息打印出来</span>    <span class="token function">ROS_INFO</span><span class="token punctuation">(</span><span class="token string">"I heard: [%s]"</span><span class="token punctuation">,</span> msg<span class="token operator">-></span>data<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化ROS节点</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">init</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"subscriber_topic"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建节点句柄</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span>NodeHandle n<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建一个Subscriber，订阅名为test_topic的消息，注册回调函数test_topic_cb</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span>Subscriber sub_topic <span class="token operator">=</span> n<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"test_topic"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> test_topic_cb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 循环等待回调函数</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">spin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>publisher_topic.cpp:</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;ros/ros.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"std_msgs/String.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ROS节点初始化</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">init</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"publisher_topic"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建节点句柄</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span>NodeHandle n<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建一个Publisher，发布名为test_topic，消息类型为gstd_msgs::String，队列长度100</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span>Publisher pub_topic <span class="token operator">=</span> n<span class="token punctuation">.</span>advertise<span class="token operator">&lt;</span>std_msgs<span class="token punctuation">:</span><span class="token punctuation">:</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"test_topic"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置循环的频率</span>    ros<span class="token punctuation">:</span><span class="token punctuation">:</span>Rate <span class="token function">loop_rate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>ros<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 初始化std_msgs::String类型的消息</span>        std_msgs<span class="token punctuation">:</span><span class="token punctuation">:</span>String str_msg<span class="token punctuation">;</span>        str_msg<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token string">"this is a test_topic message!"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 发布消息</span>        pub_topic<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span>str_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 按照循环频率延时</span>        loop_rate<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当然你也可以用Python语言来实现话题通信，可以参考我后文中给出的链接~</p></blockquote><h1 id="引用说明"><a href="#引用说明" class="headerlink" title="引用说明"></a>引用说明</h1><p>本文的部分截图来自<a href="https://github.com/huchunxu/ros_21_tutorials" target="_blank" rel="noopener">《古月·ROS入门21讲》</a>的课件。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingTopics" target="_blank" rel="noopener">ROS官方wiki</a></p><p><a href="https://joveh-h.blog.csdn.net/article/details/90551432" target="_blank" rel="noopener">ROS笔记（7） 话题通信</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 机器人操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS入门-3】嘴对嘴讲解ROS的核心概念——节点与节点管理器</title>
      <link href="/ros-3/"/>
      <url>/ros-3/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我要给大家来介绍一下ROS当中一些核心的概念，帮助大家去在后面的ROS学习当中更快地吸收这些概念。</p><h1 id="ROS系列文章"><a href="#ROS系列文章" class="headerlink" title="ROS系列文章"></a>ROS系列文章</h1><ul><li><p><a href="https://jiedev.com/ros-1/">【ROS入门-1】手把手教你在Ubuntu18.04安装ROS Melodic</a></p></li><li><p><a href="https://jiedev.com/ros-2/">【ROS入门-2】带你看ROS文件系统及其工具</a></p></li><li><p><a href="https://jiedev.com/ros-3/">【ROS入门-3】嘴对嘴讲解ROS的核心概念——节点与节点管理器</a></p></li><li><p><a href="https://jiedev.com/ros-4/">【ROS入门-4】嘴对嘴讲解ROS的核心概念——ROS话题通信机制</a></p></li><li><p><a href="https://jiedev.com/ros-5/">【ROS入门-5】深入了解ROS话题通信机制的过程</a></p></li></ul><h1 id="ROS的通信机制"><a href="#ROS的通信机制" class="headerlink" title="ROS的通信机制"></a>ROS的通信机制</h1><p>ROS的通信机制是一个 <strong><code>松散耦合的分布式软件框架</code></strong> 设计而来的，比如下面这张图：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros009.png" alt="ros009"></p><p>在这个图当中看到这里面有很多Node（节点），每个节点是在整个机器人中完成一个具体功能的这样一个一个的进程，比如说一个Node是完成图像的识别，另一个Node就完成图像驱动，然后它们之间会有一系列的图像之间的一个数据的传输，所有节点之间它的位置也不是固定的，比如说我们这有两台电脑，一个A，一个B，一些节点运行在A当中，一些节点运行在B当中，它们可以通过一系列的这个数据的传输方式来完成通讯（后面会讲解这个通信方式）。</p><p>还有每个节点它的编程语言也不是也不是固定的，比如说这个Node是用Python开发，它有很好的便利性，另一个节点是用C++开发，它有很高的效率等等。我们可以分布式完成这件的开发，最终只要有统一的这个通讯的标准，就可以完成我们整个系统这样一个搭建了，那这里面就会有很多的节点，节点之间会有很多的通讯，很多的数据，然后它包括通讯的方式，包括所有节点的一个管理，会涉及到很多核心通信机制。</p><p><strong>我们接下来讲解ROS的核心概念——节点与节点管理器。</strong></p><h1 id="节点（Node）"><a href="#节点（Node）" class="headerlink" title="节点（Node）"></a>节点（Node）</h1><p>首先看一张图片，我们结合图片来讲解：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros010.png" alt="ros010"></p><p>首先最重要的概念就是节点啊，<strong>节点在ROS当中是一个最小处理器单元</strong>，它是一个执行单元。</p><p>比如说它要执行某个任务，它其实相当于我们系统里面的某一个具体的进程，无论是完成图像识别也好，完成摄像头的驱动也好，或者是完成你的思路算法的这个处理也好，它都是一个处理任务的进程。建议为一个目的创建一个节点，建议设计时注重可重用性，将每个程序细分化，但节点在整个系统中的名称必须是唯一的。</p><p>不同节点之间我们可以用不同的编程语言，比如说有的人善于做图像处理，他就可以用Python来做处理，有的人善于做驱动。他可能要用C++或C来完成这个设备的驱动，最终大家可以通过ROS框架完成很快这个功能的拼接，那这个ROS里面也是给我们提供了这样一系列的机制，很快速完成这样一个分布式的工作。</p><p>节点在整个系统当中的名称必须是唯一的啊，比如说你要干一个什么事儿，要做一个命名，而为了方便我们整个的管理，每一个节点的名字都必须是唯一的，否则会重名重名之后你的ROS就找不到具体是哪个节点了。</p><p><strong>总结一下节点的特性：</strong></p><ul><li><p>执行具体任务的进程、独立运行的可执行文件。</p></li><li><p>不同节点可使用不同的编程语言，可分布式运行在不同的主机。</p></li><li><p>节点在系统中的名称必须是唯一的。</p></li><li><p>所有节点之间的消息通信都必须使用节点管理器。</p></li></ul><p>可以使用<code>rosrun</code>命令运行一个包内的节点（不需要知道这个包的路径）。</p><pre class="line-numbers language-bash"><code class="language-bash">rosrun <span class="token punctuation">[</span>包名字<span class="token punctuation">]</span> <span class="token punctuation">[</span>节点名字<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="节点管理器（Master）"><a href="#节点管理器（Master）" class="headerlink" title="节点管理器（Master）"></a>节点管理器（Master）</h1><blockquote><p>在某些书籍资料中，节点管理器也被称作是主节点，都是一个意思的东西。</p></blockquote><p>节点管理器（Master）负责节点到节点的连接和消息通信，类似于服务器（Server）。<code>roscore</code>是它的运行命令，当运行节点管理器时，你可以注册每个节点的名字，并根据需要获取信息。没有节点管理器，就不能在节点之间建立访问和消息交流（如话题和服务），所以我们从上面的途中就看到一个很关键的成员——ROS Master。</p><p>系统中的每个节点都需要去找<code>Master</code>去注册，需要告诉<code>Master</code>，我要启动了，我要干个什么事，我要跟谁去发什么数据，这些的管理的这个注册信息都是由<code>Master</code>一手掌握的，简单来说就是<code>Master</code>里面会有一个小本本，它会把所有的节点的各种信息都记下来，然后帮助它们，比如让节点与节点之间去建立连接等。</p><p>就拿上面的图来说，<code>Image Processing Node</code>节点要去处理数据，<code>Camera Node</code>节点要去发布图像数据，<code>Image Display Node</code>节点要去显示图像的数据，那这里面两个节点之间就会发生一个图像的传输，那<code>Master</code>就是要帮助两者建立起来一个传输数据的渠道啊，不然两个毫无瓜葛的节点怎么知道彼此的存在呢。</p><p>在<code>Master</code>里面还有很重要的功能，就是它提供一个<strong>参数服务器</strong>的功能，这个东西很重要，上面会记录一些全局变量的变量名跟变量值，那这个变量名和变量值就可以由各个节点去访问、去设置或者去读写，然后节点之间就可以通过这些变量的设置来读取一些配置文件的信息，读取一些参数配置啊等等。</p><p><strong>总结一下节点管理器的特性：</strong></p><ul><li><p>为节点提供命名和注册服务。</p></li><li><p>跟踪和记录话题/服务通信，辅助节点相互查找、建立连接。</p></li><li><p>提供参数服务器，节点使用此服务器存储和检索运行时的参数。</p></li></ul><h1 id="简单运行"><a href="#简单运行" class="headerlink" title="简单运行"></a>简单运行</h1><p>大家可以去运行一下节点管理器与节点：</p><ul><li>运行节点管理器：</li></ul><pre class="line-numbers language-bash"><code class="language-bash">roscore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros004.png" alt="节点管理器"></p><ul><li>在新终端运行一个节点：</li></ul><pre class="line-numbers language-bash"><code class="language-bash">rosrun turtlesim turtlesim_node<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在新终端列出当前运行的节点：</li></ul><pre class="line-numbers language-bash"><code class="language-bash">rosnode list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>效果如下：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros011.png" alt="ros011"></p><h1 id="引用说明"><a href="#引用说明" class="headerlink" title="引用说明"></a>引用说明</h1><p>本文的部分截图来自<a href="https://github.com/huchunxu/ros_21_tutorials" target="_blank" rel="noopener">《古月·ROS入门21讲》</a>的课件。</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingNodes" target="_blank" rel="noopener">ROS官方wiki</a></p><p><a href="https://joveh-h.blog.csdn.net/article/details/90477682" target="_blank" rel="noopener">ROS笔记（6） ROS通讯机制</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 机器人操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS入门-2】带你看ROS文件系统及其工具</title>
      <link href="/ros-2/"/>
      <url>/ros-2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ROS的架构经过设计并划分成了三部分， 每一部分都代表一个层级的概念：</p><ul><li>文件系统级（Filesystem level）</li></ul><p>主要有ROS的内部构成、 文件夹结构， 以及工作所需的核心文件。</p><ul><li>计算图级（Computation Graph level）</li></ul><p>主要是进程和系统之间的通信，包括建立系统、 处理各类进程、 与多台计算机通信等。</p><ul><li>社区级（Community level）</li></ul><p>主要是在开发人员之间共享知识、 算法和代码，塑造了ROS强大的开源社区。</p><h1 id="ROS系列文章"><a href="#ROS系列文章" class="headerlink" title="ROS系列文章"></a>ROS系列文章</h1><ul><li><p><a href="https://jiedev.com/ros-1/">【ROS入门-1】手把手教你在Ubuntu18.04安装ROS Melodic</a></p></li><li><p><a href="https://jiedev.com/ros-2/">【ROS入门-2】带你看ROS文件系统及其工具</a></p></li><li><p><a href="https://jiedev.com/ros-3/">【ROS入门-3】嘴对嘴讲解ROS的核心概念——节点与节点管理器</a></p></li><li><p><a href="https://jiedev.com/ros-4/">【ROS入门-4】嘴对嘴讲解ROS的核心概念——ROS话题通信机制</a></p></li><li><p><a href="https://jiedev.com/ros-5/">【ROS入门-5】深入了解ROS话题通信机制的过程</a></p></li></ul><h1 id="本章的准备工作"><a href="#本章的准备工作" class="headerlink" title="本章的准备工作"></a>本章的准备工作</h1><p>本文章中我们将会用到<code>ros-tutorials</code>程序包，要先用apt命令去安装：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y ros-<span class="token operator">&lt;</span>distro<span class="token operator">></span>-ros-tutorials<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 <code>&lt;distro&gt;</code>替换成你所安装的版本（比如 kinetic、melodic 等）。</p><p>从我们上一篇文章安装的是<code>melodic</code>版本，那么命令就是：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y ros-melodic-ros-tutorials<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="ROS文件系统的概念"><a href="#ROS文件系统的概念" class="headerlink" title="ROS文件系统的概念"></a>ROS文件系统的概念</h1><p>ROS文件系统可以将项目构建过程集中化， 同时提供很好的灵活性和工具来分散之间的依赖性。</p><h2 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h2><p>功能包，也可以被称之为软件包，是ROS应用程序代码的组织单元，每个功能包都可以包含程序库、可执行文件、脚本或者其它手动创建的东西。</p><h2 id="Manifest"><a href="#Manifest" class="headerlink" title="Manifest"></a>Manifest</h2><p>清单，它包含了关于<code>Packages</code>的维护者、许可协议、依赖关系以及编译标志等的信息，由一个名为<code>package.xml</code>的文件管理。</p><h2 id="Metapackage"><a href="#Metapackage" class="headerlink" title="Metapackage"></a>Metapackage</h2><p>元功能包：多个具有某些功能的包组织在一起，称为元功能包。</p><h2 id="Metapackage-Manifest"><a href="#Metapackage-Manifest" class="headerlink" title="Metapackage Manifest"></a>Metapackage Manifest</h2><p>元功能包清单：由一个名字为<code>package.xml</code>的文件管理，类似普通功能包但有一个XML格式的导出标记。 </p><h1 id="文件系统工具"><a href="#文件系统工具" class="headerlink" title="文件系统工具"></a>文件系统工具</h1><p>由于ROS中大量代码分散在众多的packages和Metapackage之中，linux本身的命令工具ls和cd已不能满足检索要求，因此ROS提供了一套自己的命令工具来完成与这些命令相似的工作。</p><h2 id="rospack"><a href="#rospack" class="headerlink" title="rospack"></a>rospack</h2><p><code>rospack</code>允许用户获取功能包的有关信息，比如我们找一个<code>roscpp</code>功能包所在的位置，可以通过以下命令：</p><pre class="line-numbers language-bash"><code class="language-bash">➜  ~ rospack <span class="token function">find</span> roscpp/opt/ros/melodic/share/roscpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>rospack</code>的用法是：</p><pre class="line-numbers language-bash"><code class="language-bash">rospack <span class="token function">find</span> <span class="token punctuation">[</span>功能包名称<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros006.png" alt="ros006"></p><h2 id="roscd"><a href="#roscd" class="headerlink" title="roscd"></a>roscd</h2><p><code>roscd</code>是<code>rosbash</code>命令集中的一部分，它允许你直接切换（cd）工作目录到某个软件包或者软件包集当中。</p><p><code>roscd</code>的用法是：</p><pre class="line-numbers language-bash"><code class="language-bash">roscd <span class="token punctuation">[</span>功能包名称<span class="token punctuation">[</span>/子目录<span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比如切换到<code>roscpp</code>目录下：</p><pre class="line-numbers language-bash"><code class="language-bash">roscd roscpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比如切换到<code>roscpp</code>的子目录<code>msg</code>下：</p><pre class="line-numbers language-bash"><code class="language-bash">roscd roscpp/msg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros007.png" alt="ros007"></p><h2 id="rosls"><a href="#rosls" class="headerlink" title="rosls"></a>rosls</h2><p>这个命令更linux下的ls很像，但它允许你在任何位置列出某个功能包的当前目录或者其子目录的内容，而不需要在绝对路径执行ls。</p><p><code>rosls</code>的用法是：</p><pre class="line-numbers language-bash"><code class="language-bash">rosls <span class="token punctuation">[</span>功能包名称<span class="token punctuation">[</span>/子目录<span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比如列出<code>roscpp</code>目录下的内容：</p><pre class="line-numbers language-bash"><code class="language-bash">rosls roscpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比如列出<code>roscpp</code>的子目录<code>msg</code>下的内容：</p><pre class="line-numbers language-bash"><code class="language-bash">rosls roscpp/msg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros008.png" alt="ros008"></p><p><strong>同时它们都支持<code>Tab补全</code>，非常方便</strong></p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="http://wiki.ros.org/cn/ROS/Tutorials/NavigatingTheFilesystem" target="_blank" rel="noopener">ROS官方wiki</a></p><p><a href="https://joveh-h.blog.csdn.net/article/details/90412882" target="_blank" rel="noopener">ROS笔记（5） ROS架构</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 机器人操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS入门-1】手把手教你在Ubuntu18.04安装ROS Melodic</title>
      <link href="/ros-1/"/>
      <url>/ros-1/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>先来一张ROS的美照：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ROS_Lunar_Loggerhead.png" alt="ROS_Lunar_Loggerhead"></p><h1 id="ROS系列文章"><a href="#ROS系列文章" class="headerlink" title="ROS系列文章"></a>ROS系列文章</h1><ul><li><p><a href="https://jiedev.com/ros-1/">【ROS入门-1】手把手教你在Ubuntu18.04安装ROS Melodic</a></p></li><li><p><a href="https://jiedev.com/ros-2/">【ROS入门-2】带你看ROS文件系统及其工具</a></p></li><li><p><a href="https://jiedev.com/ros-3/">【ROS入门-3】嘴对嘴讲解ROS的核心概念——节点与节点管理器</a></p></li><li><p><a href="https://jiedev.com/ros-4/">【ROS入门-4】嘴对嘴讲解ROS的核心概念——ROS话题通信机制</a></p></li><li><p><a href="https://jiedev.com/ros-5/">【ROS入门-5】深入了解ROS话题通信机制的过程</a></p></li></ul><p><strong>参考官方wiki安装：</strong><br><a href="http://wiki.ros.org/melodic/Installation/Ubuntu" target="_blank" rel="noopener">http://wiki.ros.org/melodic/Installation/Ubuntu</a></p><p>在Ubuntu的【软件和更新】配置如下：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros001.png" alt="ros001"></p><h1 id="添加软件源"><a href="#添加软件源" class="headerlink" title="添加软件源"></a>添加软件源</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> sh -c <span class="token string">'echo "deb http://packages.ros.org/ros/ubuntu <span class="token variable"><span class="token variable">$(</span>lsb_release -sc<span class="token variable">)</span></span> main" > /etc/apt/sources.list.d/ros-latest.list'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="配置秘钥"><a href="#配置秘钥" class="headerlink" title="配置秘钥"></a>配置秘钥</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt-key adv --keyserver <span class="token string">'hkp://keyserver.ubuntu.com:80'</span> --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="更新软件源"><a href="#更新软件源" class="headerlink" title="更新软件源"></a>更新软件源</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="安装一些依赖"><a href="#安装一些依赖" class="headerlink" title="安装一些依赖"></a>安装一些依赖</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> -y python-rosdep2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>ROS中有许多不同的库和工具，官方提供了四种默认：</p><ul><li>桌面完整版（推荐）</li></ul><p>其实也是不完整的，只是包含了绝大部分成常用的软件包跟开发工具，后续开发的一些工具还是要手动安装，但相对于官方的其他版本，这已经是最全功能的版本了。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> -y ros-melodic-desktop-full<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>桌面版本（非完整）</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> -y ros-melodic-desktop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>基础版本，只有一些基础的内容。</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> -y ros-melodic-ros-base<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>独立版本</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> ros-melodic-PACKAGE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你还可以安装一个特定的ROS包:<br>比如：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> ros-melodic-slam-gmapping<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们只选择 <strong><code>桌面完整版</code></strong> 进行安装，大约半小时左右就安装好了，时间取决于你的网速。</p><h1 id="初始化rosdep"><a href="#初始化rosdep" class="headerlink" title="初始化rosdep"></a>初始化rosdep</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> rosdep init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后他会提示我们更新软件源的依赖：</p><pre class="line-numbers language-bash"><code class="language-bash">Recommended: please run    rosdep update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="更新软件源的依赖"><a href="#更新软件源的依赖" class="headerlink" title="更新软件源的依赖"></a>更新软件源的依赖</h1><pre class="line-numbers language-bash"><code class="language-bash">rosdep update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当出现以下log时表示更新成功：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros002.png" alt="ros002"></p><p>如果出错请参考文末的 <strong>【错误排查】</strong></p><h1 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h1><p>为了能每次在终端打开时，都能将ROS环境变量自动设置好，我们可以这样做：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"source /opt/ros/melodic/setup.bash"</span> <span class="token operator">>></span> ~/.bashrc<span class="token function">source</span> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="构建软件包的依赖关系"><a href="#构建软件包的依赖关系" class="headerlink" title="构建软件包的依赖关系"></a>构建软件包的依赖关系</h1><p>到目前为止，我们已经安装了运行核心ROS软件包所需的软件。为了创建和管理自己的ROS工作区，有各种工具和要求分别分发，我们可以通过一个 <code>rosinstall</code> 命令轻松下载ROS软件包的许多源代码树。</p><p>安装此工具和其他依赖项以构建ROS软件包，运行：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> -y python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>支持，ROS的核心组件以及一些工具都已经安装完成。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros003.png" alt="ros003"></p><h1 id="验证ROS是否安装成功"><a href="#验证ROS是否安装成功" class="headerlink" title="验证ROS是否安装成功"></a>验证ROS是否安装成功</h1><pre class="line-numbers language-bash"><code class="language-bash">roscore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>出现以下内容表示安装成功：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros004.png" alt="ros004"></p><p>如果没有出现这个命令，则表示安装不太完全，再次运行安装ROS命令：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> -y ros-melodic-desktop-full<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接着再运行一个ROS的指令（需要打开新的终端），启动小海龟的仿真器：</p><pre class="line-numbers language-bash"><code class="language-bash">rosrun turtlesim turtlesim_node<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后打开新的终端运行以下命令：然后通过键盘的上下左右键去控制小海龟的运动：</p><pre class="line-numbers language-bash"><code class="language-bash">rosrun turtlesim turtle_teleop_key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>效果如下：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/ros005.png" alt="ros005"></p><h1 id="错误排查参考"><a href="#错误排查参考" class="headerlink" title="错误排查参考"></a>错误排查参考</h1><p>出现的错误可以参考以下博文，感谢各位博主的解决方案：</p><ul><li><p><a href="https://blog.csdn.net/mrh1714348719/article/details/103803110" target="_blank" rel="noopener">ubuntu安装ROS进行到rosdep update时出现错误，如ERROR: unable to process source …</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/77483614" target="_blank" rel="noopener">ROS:sudo rosdep init出错常规方法都无效后解决办法记录</a></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 机器人操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个基于socket API之上的跨平台MQTT客户端，支持qos2</title>
      <link href="/mqttclient/"/>
      <url>/mqttclient/</url>
      
        <content type="html"><![CDATA[<h1 id="mqttclient"><a href="#mqttclient" class="headerlink" title="mqttclient"></a>mqttclient</h1><p><strong>一个基于socket API之上的跨平台MQTT客户端</strong></p><p>基于socket API的MQTT客户端，拥有非常简洁的API接口，以极少的资源实现QOS2的服务质量，并且无缝衔接了mbedtls加密库。</p><h2 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h2><ul><li><p><strong>基于标准BSD socket之上开发</strong>，只要是兼容BSD socket的系统均可使用。</p></li><li><p><strong>稳定</strong>：无论是<code>掉线重连</code>，<code>丢包重发</code>，都是严格<code>遵循MQTT协议标准</code>执行，除此之外对<strong>大数据量</strong>的测试无论是收是发，都是非常稳定（一次发送<code>135K</code>数据，3秒一次），高频测试也是非常稳定（7个主题同时收发，每秒一次，也就是1秒14个mqtt报文，服务质量QoS0、QoS1、QoS2都有）。因为作者以极少的资源设计了<code>记录机制</code>，对采用QoS1服务质量的报文必须保证到达一次，当发布的主题（qos1、qos2都适用）没有被服务器收到时会自动重发，而对QoS2服务质量的报文保证有且只有处理一次（如果不相信它稳定性的同学可以自己去修改源码，专门为QoS2服务质量去做测试，故意不回复<code>PUBREC</code>包，让服务器重发QoS2报文，且看看客户端是否有且只有处理一次），而对于掉线重连的稳定性，这种则是<strong>基本操作</strong>了，没啥好说的，在自动重连后还会自动重新订阅主题，保证主题不会丢失，因此在测试中稳定性极好。</p></li><li><p><strong>轻量级</strong>：整个代码工程极其简单，不使用mbedtls情况下，占用资源极少，作者曾使用esp8266模组与云端通信，整个工程代码消耗的RAM不足15k（包括系统占用的开销，对数据的处理开销，而此次还是未优化的情况下，还依旧完美保留了掉线重连的稳定性，但是对应qos1、qos2服务质量的报文则未做测试，因为STM32F103C8T6芯片资源实在是太少了，折腾不起）。</p></li><li><p><strong>无缝衔接mbedtls加密传输</strong>，让网络传输更加安全，而且接口层完全不需要用户理会，无论是否加密，mqttclient对用户提供的API接口是<strong>没有变化</strong>的，这就很好的兼容了一套代应用层的码可以加密传输也可以不加密传输。</p></li><li><p><strong>拥有极简的API接口</strong>，总的来说，mqttclient的配置都有默认值，基本无需配置都能使用的，也可以随意配置，对配置都有健壮性检测，这样子设计的API接口也是非常简单。</p></li><li><p><strong>有非常好的代码风格与思想</strong>：整个代码采用分层式设计，代码实现采用异步处理的思想，降低耦合，提高性能，具体体现在什么地方呢？很简单，目前市面上很多MQTT客户端发布主题都是要阻塞等待ack，这是非常暴力的行为，阻塞当前线程等待服务器的应答，那如果我想要发送数据怎么办，或者我要重复检测数据怎么办，你可能会说，指定阻塞时间等待，那如果网络延迟，ack迟迟不来，我就白等了吗，对于qos1、qos2的服务质量怎么办，所以说这种还是要异步处理的思想，我发布主题，那我发布出去就好了，不需要等待，对于qos1、qos2服务质量的MQTT报文，如果服务器没收到，那我重发就可以，这种重发也是异步的处理，完全不会阻塞当前线程。</p></li><li><p><strong>MQTT协议支持主题通配符<code>“#”、“+”</code>。</strong></p></li><li><p><strong>订阅的主题与消息处理完全分离</strong>，让编程逻辑更加简单易用，用户无需理会错综复杂的逻辑关系。</p></li><li><p><strong>mqttclient内部已实现保活处理机制</strong>，无需用户过多关心理会，用户只需专心处理应用功能即可。</p></li><li><p><strong>无缝衔接salof</strong>：它是一个同步异步日志输出框架，在空闲时候输出对应的日志信息，也可以将信息写入flash中保存，方便调试。</p></li><li><p><strong>不对外产生依赖。</strong></p></li></ul><h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><p>拥有非常明确的分层框架。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/mqttclient.png" alt="整体框架"></p><p><strong>目前已实现了Linux、TencentOS tiny、RT-Thread平台（已做成软件包，名字为<code>kawaii-mqtt</code>），除此之外TencentOS tiny的AT框架亦可以使用（RAM消耗不足15K），并且稳定性极好！</strong></p><table><thead><tr><th>平台</th><th>代码位置</th></tr></thead><tbody><tr><td>Linux</td><td><a href="https://github.com/jiejieTop/mqttclient" target="_blank" rel="noopener">https://github.com/jiejieTop/mqttclient</a></td></tr><tr><td>TencentOS tiny</td><td><a href="https://github.com/Tencent/TencentOS-tiny/tree/master/board/Fire_STM32F429" target="_blank" rel="noopener">https://github.com/Tencent/TencentOS-tiny/tree/master/board/Fire_STM32F429</a></td></tr><tr><td>TencentOS tiny AT 框架</td><td><a href="https://github.com/jiejieTop/gokit3-board-mqttclient" target="_blank" rel="noopener">https://github.com/jiejieTop/gokit3-board-mqttclient</a></td></tr><tr><td>RT-Thread</td><td><a href="https://github.com/jiejieTop/kawaii-mqtt" target="_blank" rel="noopener">https://github.com/jiejieTop/kawaii-mqtt</a></td></tr></tbody></table><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><table><thead><tr><th>发布版本</th><th>描述</th></tr></thead><tbody><tr><td>[v1.0.0]</td><td>初次发布，完成基本概念及其稳定性验证</td></tr><tr><td>[v1.0.1]</td><td>修复主动与服务器断开连接时的逻辑</td></tr></tbody></table><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>欢迎以 <a href="https://github.com/jiejieTop/mqttclient/issues" target="_blank" rel="noopener">GitHub Issues</a> 的形式提交问题和bug报告</p><h2 id="版权和许可"><a href="#版权和许可" class="headerlink" title="版权和许可"></a>版权和许可</h2><p>mqttclient 由 <a href="https://github.com/jiejieTop/mqttclient/blob/master/LICENSE" target="_blank" rel="noopener">Apache License v2.0</a> 许可 提供。</p><p>简单谈谈关于开源协议的描述，<a href="https://github.com/jiejieTop/mqttclient/blob/master/LICENSE" target="_blank" rel="noopener">Apache License v2.0</a> 鼓励代码共享和尊重原作者的著作权，可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布（作为开源或闭源商业软件），<strong>但本源码必须保留作者版权声明</strong>。</p><h2 id="linux平台下测试使用"><a href="#linux平台下测试使用" class="headerlink" title="linux平台下测试使用"></a>linux平台下测试使用</h2><h3 id="安装cmake："><a href="#安装cmake：" class="headerlink" title="安装cmake："></a>安装cmake：</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> cmake<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在<code>mqttclient/test/test.c</code>文件中修改以下内容：</p><pre class="line-numbers language-c"><code class="language-c">    init_params<span class="token punctuation">.</span>connect_params<span class="token punctuation">.</span>network_params<span class="token punctuation">.</span>network_ssl_params<span class="token punctuation">.</span>ca_crt <span class="token operator">=</span> <span class="token function">test_ca_get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* CA证书 */</span>    init_params<span class="token punctuation">.</span>connect_params<span class="token punctuation">.</span>network_params<span class="token punctuation">.</span>addr <span class="token operator">=</span> <span class="token string">"xxxxxxx"</span><span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">/* 服务器域名 */</span>    init_params<span class="token punctuation">.</span>connect_params<span class="token punctuation">.</span>network_params<span class="token punctuation">.</span>port <span class="token operator">=</span> <span class="token string">"8883"</span><span class="token punctuation">;</span>                                <span class="token comment" spellcheck="true">/* 服务器端口号 */</span>    init_params<span class="token punctuation">.</span>connect_params<span class="token punctuation">.</span>user_name <span class="token operator">=</span> <span class="token string">"xxxxxxx"</span><span class="token punctuation">;</span>                                       <span class="token comment" spellcheck="true">/* 用户名 */</span>    init_params<span class="token punctuation">.</span>connect_params<span class="token punctuation">.</span>password <span class="token operator">=</span> <span class="token string">"xxxxxxx"</span><span class="token punctuation">;</span>                                        <span class="token comment" spellcheck="true">/* 密码 */</span>    init_params<span class="token punctuation">.</span>connect_params<span class="token punctuation">.</span>client_id <span class="token operator">=</span> <span class="token string">"xxxxxxx"</span><span class="token punctuation">;</span>                                       <span class="token comment" spellcheck="true">/* 客户端id */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="mbedtls"><a href="#mbedtls" class="headerlink" title="mbedtls"></a>mbedtls</h3><p>默认不打开mbedtls。</p><p><a href="https://github.com/jiejieTop/salof" target="_blank" rel="noopener">salof</a> 全称是：<code>Synchronous Asynchronous Log Output Framework</code>（同步异步日志输出框架），它是一个同步异步日志输出框架，在空闲时候输出对应的日志信息，并且该库与mqttclient无缝衔接。</p><p><strong>配置对应的日志输出级别：</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> BASE_LEVEL      (0)</span><span class="token macro property">#<span class="token directive keyword">define</span> ASSERT_LEVEL    (BASE_LEVEL + 1)            </span><span class="token comment" spellcheck="true">/* 日志输出级别：断言级别（非常高优先级） */</span><span class="token macro property">#<span class="token directive keyword">define</span> ERR_LEVEL       (ASSERT_LEVEL + 1)          </span><span class="token comment" spellcheck="true">/* 日志输出级别：错误级别（高优先级） */</span><span class="token macro property">#<span class="token directive keyword">define</span> WARN_LEVEL      (ERR_LEVEL + 1)             </span><span class="token comment" spellcheck="true">/* 日志输出级别：警告级别（中优先级） */</span><span class="token macro property">#<span class="token directive keyword">define</span> INFO_LEVEL      (WARN_LEVEL + 1)            </span><span class="token comment" spellcheck="true">/* 日志输出级别：信息级别（低优先级） */</span><span class="token macro property">#<span class="token directive keyword">define</span> DEBUG_LEVEL     (INFO_LEVEL + 1)            </span><span class="token comment" spellcheck="true">/* 日志输出级别：调试级别（更低优先级） */</span><span class="token macro property">#<span class="token directive keyword">define</span>         LOG_LEVEL                   WARN_LEVEL      </span><span class="token comment" spellcheck="true">/* 日志输出级别 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>日志其他选项：</strong></p><ul><li>终端带颜色</li><li>时间戳</li><li>标签</li></ul><h3 id="mqttclient的配置"><a href="#mqttclient的配置" class="headerlink" title="mqttclient的配置"></a>mqttclient的配置</h3><p>配置mqtt等待应答列表的最大值，对于qos1 qos2服务质量有要求的可以将其设置大一点，当然也必须资源跟得上，它主要是保证qos1 qos2的mqtt报文能准确到达服务器。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_ACK_HANDLER_NUM_MAX            64</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选择MQTT协议的版本，默认为4，表示使用MQTT 3.1.1版本，而3则表示为MQTT 3.1版本。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_VERSION                        4           </span><span class="token comment" spellcheck="true">// 4 is mqtt 3.1.1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置默认的保活时间，它主要是保证MQTT客户端与服务器的保持活性连接，单位为 秒 ，比如MQTT客户端与服务器100S没有发送数据了，有没有接收到数据，此时MQTT客户端会发送一个ping包，确认一下这个会话是否存在，如果收到服务器的应答，那么说明这个会话还是存在的，可以随时收发数据，而如果不存在了，就清除会话。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_KEEP_ALIVE_INTERVAL            100         </span><span class="token comment" spellcheck="true">// unit: second</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>默认的命令超时，它主要是用于socket读写超时，在MQTT初始化时可以指定:</p><pre><code>#define     MQTT_DEFAULT_CMD_TIMEOUT            4000</code></pre><p>默认主题的长度，主题是支持通配符的，如果主题太长则会被截断：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_TOPIC_LEN_MAX                  64</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>默认的算法数据缓冲区的大小，如果要发送大量数据则修改大一些，在MQTT初始化时可以指定：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_DEFAULT_BUF_SIZE               1024</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>线程相关的配置，如线程栈，线程优先级，线程时间片等：<br>在linux环境下可以是不需要理会这些参数的，而在RTOS平台则需要配置，如果不使用mbedtls，线程栈2048字节已足够，而使用mbedtls加密后，需要配置4096字节以上。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_THREAD_STACK_SIZE              2048    </span><span class="token comment" spellcheck="true">// 线程栈</span><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_THREAD_PRIO                    5       </span><span class="token comment" spellcheck="true">// 线程优先级</span><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_THREAD_TICK                    50      </span><span class="token comment" spellcheck="true">// 线程时间片</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>默认的重连时间间隔，当发生掉线时，会以这个时间间隔尝试重连：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_RECONNECT_DEFAULT_DURATION     1000</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其他不需要怎么配置的东西：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_MAX_PACKET_ID                  (0xFFFF - 1)    </span><span class="token comment" spellcheck="true">// mqtt报文id</span><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_MAX_CMD_TIMEOUT                20000           </span><span class="token comment" spellcheck="true">//最大的命令超时参数</span><span class="token macro property">#<span class="token directive keyword">define</span>     MQTT_MIN_CMD_TIMEOUT                1000            </span><span class="token comment" spellcheck="true">//最小的命令超时参数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>ps：以上参数基本不需要怎么配置的，直接用即可~</p></blockquote><h3 id="编译-amp-运行"><a href="#编译-amp-运行" class="headerlink" title="编译 &amp; 运行"></a>编译 &amp; 运行</h3><pre class="line-numbers language-bash"><code class="language-bash">./build.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行<code>build.sh</code>脚本后会在 <code>./build/bin/</code>目录下生成可执行文件<code>mqtt-client</code>，直接运行即可。</p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><ul><li>整体采用分层式设计，代码实现采用异步设计方式，降低耦合。</li><li>消息的处理使用回调的方式处理：用户指定<code>[订阅的主题]</code>与指定<code>[消息的处理函数]</code></li><li>不对外产生依赖</li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><code>mqttclient</code>拥有非常简洁的<code>api</code>接口</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">mqtt_keep_alive</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mqtt_init</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">,</span> client_init_params_t<span class="token operator">*</span> init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mqtt_release</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mqtt_connect</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mqtt_disconnect</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mqtt_subscribe</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> topic_filter<span class="token punctuation">,</span> mqtt_qos_t qos<span class="token punctuation">,</span> message_handler_t msg_handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mqtt_unsubscribe</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> topic_filter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mqtt_publish</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> topic_filter<span class="token punctuation">,</span> mqtt_message_t<span class="token operator">*</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mqtt_yield</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout_ms<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p><strong>mqtt_client_t 结构</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> mqtt_client <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span>              packet_id<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span>               ping_outstanding<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span>               ack_handler_number<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span>               <span class="token operator">*</span>read_buf<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span>               <span class="token operator">*</span>write_buf<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>                cmd_timeout<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>                read_buf_size<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>                write_buf_size<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>                reconnect_try_duration<span class="token punctuation">;</span>    <span class="token keyword">void</span>                        <span class="token operator">*</span>reconnect_date<span class="token punctuation">;</span>    reconnect_handler_t         reconnect_handler<span class="token punctuation">;</span>    client_state_t              client_state<span class="token punctuation">;</span>    platform_mutex_t            write_lock<span class="token punctuation">;</span>    platform_mutex_t            global_lock<span class="token punctuation">;</span>    list_t                      msg_handler_list<span class="token punctuation">;</span>    list_t                      ack_handler_list<span class="token punctuation">;</span>    network_t                   <span class="token operator">*</span>network<span class="token punctuation">;</span>    platform_thread_t           <span class="token operator">*</span>thread<span class="token punctuation">;</span>    platform_timer_t            reconnect_timer<span class="token punctuation">;</span>    platform_timer_t            last_sent<span class="token punctuation">;</span>    platform_timer_t            last_received<span class="token punctuation">;</span>    connect_params_t            <span class="token operator">*</span>connect_params<span class="token punctuation">;</span><span class="token punctuation">}</span> mqtt_client_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该结构主要维护以下内容：</p><ol><li>读写数据缓冲区<code>read_buf、write_buf</code></li><li>命令超时时间<code>cmd_timeout</code>（主要是读写阻塞时间、等待响应的时间、重连等待时间）</li><li>维护<code>ack</code>链表<code>ack_handler_list</code>，这是异步实现的核心，所有等待响应的报文都会被挂载到这个链表上</li><li>维护消息处理列表<code>msg_handler_list</code>，这是<code>mqtt</code>协议必须实现的内容，所有来自服务器的<code>publish</code>报文都会被处理（前提是订阅了对应的消息）</li><li>维护一个网卡接口<code>network</code></li><li>维护一个内部线程<code>thread</code>，所有来自服务器的mqtt包都会在这里被处理！</li><li>两个定时器，分别是掉线重连定时器与保活定时器<code>reconnect_timer、last_sent、last_received</code></li><li>一些连接的参数<code>connect_params</code></li></ol><h2 id="mqttclient实现"><a href="#mqttclient实现" class="headerlink" title="mqttclient实现"></a>mqttclient实现</h2><p>以下是整个框架的实现方式，方便大家更容易理解mqttclient的代码与设计思想，让大家能够修改源码与使用，还可以提交pr或者issues，开源的世界期待各位大神的参与，感谢！</p><p>除此之外以下代码的<code>记录机制</code>与其<code>超时处理机制</code>是非常好的编程思想，大家有兴趣一定要看源代码！</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">mqtt_init</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">,</span> client_init_params_t<span class="token operator">*</span> init<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>主要是配置<code>mqtt_client_t</code>结构的相关信息，如果没有指定初始化参数，则系统会提供默认的参数。<br>但连接部分的参数则必须指定：</p><pre class="line-numbers language-c"><code class="language-c">    init_params<span class="token punctuation">.</span>connect_params<span class="token punctuation">.</span>network_params<span class="token punctuation">.</span>addr <span class="token operator">=</span> <span class="token string">"[你的mqtt服务器IP地址或者是域名]"</span><span class="token punctuation">;</span>    init_params<span class="token punctuation">.</span>connect_params<span class="token punctuation">.</span>network_params<span class="token punctuation">.</span>port <span class="token operator">=</span> <span class="token number">1883</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//端口号</span>    init_params<span class="token punctuation">.</span>connect_params<span class="token punctuation">.</span>user_name <span class="token operator">=</span> <span class="token string">"jiejietop"</span><span class="token punctuation">;</span>    init_params<span class="token punctuation">.</span>connect_params<span class="token punctuation">.</span>password <span class="token operator">=</span> <span class="token string">"123456"</span><span class="token punctuation">;</span>    init_params<span class="token punctuation">.</span>connect_params<span class="token punctuation">.</span>client_id <span class="token operator">=</span> <span class="token string">"clientid"</span><span class="token punctuation">;</span>    <span class="token function">mqtt_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>client<span class="token punctuation">,</span> <span class="token operator">&amp;</span>init_params<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">mqtt_connect</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数只有 <code>mqtt_client_t</code> 类型的指针，字符串类型的<code>主题</code>（支持通配符”#” “+”），主题的<code>服务质量</code>，以及收到报文的<code>处理函数</code>，如不指定则有默认处理函数。连接服务器则是使用非异步的方式设计，因为必须等待连接上服务器才能进行下一步操作。</p><p>过程如下：</p><ol><li>调用底层的连接函数连接上服务器：</li></ol><pre class="line-numbers language-c"><code class="language-c">c<span class="token operator">-></span>network<span class="token operator">-></span><span class="token function">connect</span><span class="token punctuation">(</span>c<span class="token operator">-></span>network<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>序列化<code>mqtt</code>的<code>CONNECT</code>报文并且发送</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTSerialize_connect</span><span class="token punctuation">(</span>c<span class="token operator">-></span>write_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>write_buf_size<span class="token punctuation">,</span> <span class="token operator">&amp;</span>connect_data<span class="token punctuation">)</span><span class="token function">mqtt_send_packet</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>connect_timer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li>等待来自服务器的<code>CONNACK</code>报文</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_wait_packet</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> CONNACK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>connect_timer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>连接成功后创建一个内部线程<code>mqtt_yield_thread</code>，并在合适的时候启动它：</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">platform_thread_init</span><span class="token punctuation">(</span><span class="token string">"mqtt_yield_thread"</span><span class="token punctuation">,</span> mqtt_yield_thread<span class="token punctuation">,</span> c<span class="token punctuation">,</span> MQTT_THREAD_STACK_SIZE<span class="token punctuation">,</span> MQTT_THREAD_PRIO<span class="token punctuation">,</span> MQTT_THREAD_TICK<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> c<span class="token operator">-></span>thread<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">mqtt_set_client_state</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> CLIENT_STATE_CONNECTED<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">platform_thread_startup</span><span class="token punctuation">(</span>c<span class="token operator">-></span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">platform_thread_start</span><span class="token punctuation">(</span>c<span class="token operator">-></span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/* start run mqtt thread */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>而对于重连来说则不会重新创建线程，直接改变客户端状态为连接状态即可:</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_set_client_state</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> CLIENT_STATE_CONNECTED<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="订阅报文"><a href="#订阅报文" class="headerlink" title="订阅报文"></a>订阅报文</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">mqtt_subscribe</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> topic_filter<span class="token punctuation">,</span> mqtt_qos_t qos<span class="token punctuation">,</span> message_handler_t handler<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>订阅报文使用异步设计来实现的：<br>过程如下：</p><ol><li>序列化订阅报文并且发送给服务器</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTSerialize_subscribe</span><span class="token punctuation">(</span>c<span class="token operator">-></span>write_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>write_buf_size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">mqtt_get_next_packet_id</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>topic<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>qos<span class="token punctuation">)</span><span class="token function">mqtt_send_packet</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>timer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>创建对应的消息处理节点，这个消息节点在收到服务器的<code>SUBACK</code>订阅应答报文后会挂载到消息处理列表<code>msg_handler_list</code>上</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_msg_handler_create</span><span class="token punctuation">(</span>topic_filter<span class="token punctuation">,</span> qos<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>在发送了报文给服务器那就要等待服务器的响应了，先记录这个等待<code>SUBACK</code></li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_ack_list_record</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> SUBACK<span class="token punctuation">,</span> <span class="token function">mqtt_get_next_packet_id</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> msg_handler<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h3><p>与订阅报文的逻辑基本差不多的~</p><ol><li>序列化订阅报文并且发送给服务器</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTSerialize_unsubscribe</span><span class="token punctuation">(</span>c<span class="token operator">-></span>write_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>write_buf_size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> packet_id<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>topic<span class="token punctuation">)</span><span class="token function">mqtt_send_packet</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>timer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>创建对应的消息处理节点，这个消息节点在收到服务器的<code>UNSUBACK</code>取消订阅应答报文后将消息处理列表<code>msg_handler_list</code>上的已经订阅的主题消息节点销毁</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_msg_handler_create</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>topic_filter<span class="token punctuation">,</span> QOS0<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>在发送了报文给服务器那就要等待服务器的响应了，先记录这个等待<code>UNSUBACK</code></li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_ack_list_record</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> UNSUBACK<span class="token punctuation">,</span> packet_id<span class="token punctuation">,</span> len<span class="token punctuation">,</span> msg_handler<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="发布报文"><a href="#发布报文" class="headerlink" title="发布报文"></a>发布报文</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">mqtt_publish</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> topic_filter<span class="token punctuation">,</span> mqtt_message_t<span class="token operator">*</span> msg<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数只有 <code>mqtt_client_t</code> 类型的指针，字符串类型的<code>主题</code>（支持通配符），要发布的消息（包括<code>服务质量</code>、<code>消息主体</code>）。</p><pre class="line-numbers language-c"><code class="language-c">    mqtt_message_t msg<span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>qos <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>payload <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> buf<span class="token punctuation">;</span>    <span class="token function">mqtt_publish</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>client<span class="token punctuation">,</span> <span class="token string">"testtopic1"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>核心思想都差不多，过程如下：</p><ol><li>先序列化发布报文，然后发送到服务器</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTSerialize_publish</span><span class="token punctuation">(</span>c<span class="token operator">-></span>write_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>write_buf_size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> msg<span class="token operator">-></span>qos<span class="token punctuation">,</span> msg<span class="token operator">-></span>retained<span class="token punctuation">,</span> msg<span class="token operator">-></span>id<span class="token punctuation">,</span>              topic<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>msg<span class="token operator">-></span>payload<span class="token punctuation">,</span> msg<span class="token operator">-></span>payloadlen<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">mqtt_send_packet</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>timer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>对于QOS0的逻辑，不做任何处理，对于QOS1和QOS2的报文则需要记录下来，在没收到服务器应答的时候进行重发</li></ol><pre class="line-numbers language-c"><code class="language-c">    <span class="token keyword">if</span> <span class="token punctuation">(</span>QOS1 <span class="token operator">==</span> msg<span class="token operator">-></span>qos<span class="token punctuation">)</span> <span class="token punctuation">{</span>        rc <span class="token operator">=</span> <span class="token function">mqtt_ack_list_record</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> PUBACK<span class="token punctuation">,</span> <span class="token function">mqtt_get_next_packet_id</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>QOS2 <span class="token operator">==</span> msg<span class="token operator">-></span>qos<span class="token punctuation">)</span> <span class="token punctuation">{</span>        rc <span class="token operator">=</span> <span class="token function">mqtt_ack_list_record</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> PUBREC<span class="token punctuation">,</span> <span class="token function">mqtt_get_next_packet_id</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>还有非常重要的一点，重发报文的MQTT报文头部需要设置DUP标志位，这是MQTT协议的标准，因此，在重发的时候作者直接操作了报文的DUP标志位，因为修改DUP标志位的函数我没有从MQTT库中找到，所以我封装了一个函数，这与LwIP中的交叉存取思想是一个道理，它假设我知道MQTT报文的所有操作，所以我可以操作它，这样子可以提高很多效率：</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_set_publish_dup</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* may resend this data, set the udp flag in advance */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="内部线程"><a href="#内部线程" class="headerlink" title="内部线程"></a>内部线程</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">mqtt_yield_thread</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>主要是对<code>mqtt_yield</code>函数的返回值做处理，比如在<code>disconnect</code>的时候销毁这个线程。</p><h3 id="核心的处理函数"><a href="#核心的处理函数" class="headerlink" title="核心的处理函数"></a>核心的处理函数</h3><ol><li>数据包的处理<code>mqtt_packet_handle</code></li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">mqtt_packet_handle</span><span class="token punctuation">(</span>mqtt_client_t<span class="token operator">*</span> c<span class="token punctuation">,</span> platform_timer_t<span class="token operator">*</span> timer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对不同的包使用不一样的处理：</p><pre class="line-numbers language-c"><code class="language-c">    <span class="token keyword">switch</span> <span class="token punctuation">(</span>packet_type<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">/* timed out reading packet */</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> CONNACK<span class="token punctuation">:</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> PUBACK<span class="token punctuation">:</span>        <span class="token keyword">case</span> PUBCOMP<span class="token punctuation">:</span>            rc <span class="token operator">=</span> <span class="token function">mqtt_puback_and_pubcomp_packet_handle</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> timer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> SUBACK<span class="token punctuation">:</span>            rc <span class="token operator">=</span> <span class="token function">mqtt_suback_packet_handle</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> timer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> UNSUBACK<span class="token punctuation">:</span>            rc <span class="token operator">=</span> <span class="token function">mqtt_unsuback_packet_handle</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> timer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> PUBLISH<span class="token punctuation">:</span>            rc <span class="token operator">=</span> <span class="token function">mqtt_publish_packet_handle</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> timer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> PUBREC<span class="token punctuation">:</span>        <span class="token keyword">case</span> PUBREL<span class="token punctuation">:</span>            rc <span class="token operator">=</span> <span class="token function">mqtt_pubrec_and_pubrel_packet_handle</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> timer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> PINGRESP<span class="token punctuation">:</span>            c<span class="token operator">-></span>ping_outstanding <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>            <span class="token keyword">goto</span> exit<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>并且做保活的处理：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_keep_alive</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当发生超时后</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">platform_timer_is_expired</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token operator">-></span>last_sent<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">platform_timer_is_expired</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token operator">-></span>last_received<span class="token punctuation">)</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>序列号一个心跳包并且发送给服务器</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTSerialize_pingreq</span><span class="token punctuation">(</span>c<span class="token operator">-></span>write_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>write_buf_size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">mqtt_send_packet</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当再次发生超时后，表示与服务器的连接已断开，需要重连的操作，设置客户端状态为断开连接</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_set_client_state</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> CLIENT_STATE_DISCONNECTED<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li><code>ack</code>链表的扫描，当收到服务器的报文时，对ack列表进行扫描操作</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_ack_list_scan</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当超时后就销毁ack链表节点：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_ack_handler_destroy</span><span class="token punctuation">(</span>ack_handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然下面这几种报文则需要重发操作：（<code>PUBACK 、PUBREC、 PUBREL 、PUBCOMP</code>，保证QOS1 QOS2的服务质量）</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ack_handler<span class="token operator">-></span>type <span class="token operator">==</span>  PUBACK<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>ack_handler<span class="token operator">-></span>type <span class="token operator">==</span>  PUBREC<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>ack_handler<span class="token operator">-></span>type <span class="token operator">==</span>  PUBREL<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>ack_handler<span class="token operator">-></span>type <span class="token operator">==</span>  PUBCOMP<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">mqtt_ack_handler_resend</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> ack_handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li>保持活性的时间过去了，可能掉线了，需要重连操作</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_try_reconnect</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重连成功后尝试重新订阅报文，保证恢复原始状态~</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_try_resubscribe</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="发布应答与发布完成报文的处理"><a href="#发布应答与发布完成报文的处理" class="headerlink" title="发布应答与发布完成报文的处理"></a>发布应答与发布完成报文的处理</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">mqtt_puback_and_pubcomp_packet_handle</span><span class="token punctuation">(</span>mqtt_client_t <span class="token operator">*</span>c<span class="token punctuation">,</span> platform_timer_t <span class="token operator">*</span>timer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>反序列化报文</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTDeserialize_ack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>packet_type<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dup<span class="token punctuation">,</span> <span class="token operator">&amp;</span>packet_id<span class="token punctuation">,</span> c<span class="token operator">-></span>read_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>read_buf_size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>取消对应的ack记录</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_ack_list_unrecord</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> packet_type<span class="token punctuation">,</span> packet_id<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="订阅应答报文的处理"><a href="#订阅应答报文的处理" class="headerlink" title="订阅应答报文的处理"></a>订阅应答报文的处理</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">mqtt_suback_packet_handle</span><span class="token punctuation">(</span>mqtt_client_t <span class="token operator">*</span>c<span class="token punctuation">,</span> platform_timer_t <span class="token operator">*</span>timer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>反序列化报文</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTDeserialize_suback</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>packet_id<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>count<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>granted_qos<span class="token punctuation">,</span> c<span class="token operator">-></span>read_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>read_buf_size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>取消对应的ack记录</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_ack_list_unrecord</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> packet_type<span class="token punctuation">,</span> packet_id<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>安装对应的订阅消息处理函数，如果是已存在的则不会安装</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_msg_handlers_install</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> msg_handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="取消订阅应答报文的处理"><a href="#取消订阅应答报文的处理" class="headerlink" title="取消订阅应答报文的处理"></a>取消订阅应答报文的处理</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">mqtt_unsuback_packet_handle</span><span class="token punctuation">(</span>mqtt_client_t <span class="token operator">*</span>c<span class="token punctuation">,</span> platform_timer_t <span class="token operator">*</span>timer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>反序列化报文</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTDeserialize_unsuback</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>packet_id<span class="token punctuation">,</span> c<span class="token operator">-></span>read_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>read_buf_size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>取消对应的ack记录，并且获取到已经订阅的消息处理节点</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_ack_list_unrecord</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> UNSUBACK<span class="token punctuation">,</span> packet_id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg_handler<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>销毁对应的订阅消息处理函数</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_msg_handler_destory</span><span class="token punctuation">(</span>msg_handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="来自服务器的发布报文的处理"><a href="#来自服务器的发布报文的处理" class="headerlink" title="来自服务器的发布报文的处理"></a>来自服务器的发布报文的处理</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">mqtt_publish_packet_handle</span><span class="token punctuation">(</span>mqtt_client_t <span class="token operator">*</span>c<span class="token punctuation">,</span> platform_timer_t <span class="token operator">*</span>timer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>反序列化报文</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTDeserialize_publish</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg<span class="token punctuation">.</span>dup<span class="token punctuation">,</span> <span class="token operator">&amp;</span>qos<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">.</span>retained<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">.</span>id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>topic_name<span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>msg<span class="token punctuation">.</span>payload<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>msg<span class="token punctuation">.</span>payloadlen<span class="token punctuation">,</span> c<span class="token operator">-></span>read_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>read_buf_size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>对于QOS0、QOS1的报文，直接去处理消息</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_deliver_message</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token operator">&amp;</span>topic_name<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>对于QOS1的报文，还需要发送一个<code>PUBACK</code>应答报文给服务器</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTSerialize_ack</span><span class="token punctuation">(</span>c<span class="token operator">-></span>write_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>write_buf_size<span class="token punctuation">,</span> PUBACK<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> msg<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>而对于QOS2的报文则需要发送<code>PUBREC</code>报文给服务器，除此之外还需要记录<code>PUBREL</code>到ack链表上，等待服务器的发布释放报文，最后再去处理这个消息</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTSerialize_ack</span><span class="token punctuation">(</span>c<span class="token operator">-></span>write_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>write_buf_size<span class="token punctuation">,</span> PUBREC<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> msg<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">mqtt_ack_list_record</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> PUBREL<span class="token punctuation">,</span> msg<span class="token punctuation">.</span>id <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token function">mqtt_deliver_message</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token operator">&amp;</span>topic_name<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>说明：一旦注册到ack列表上的报文，当具有重复的报文是不会重新被注册的，它会通过<code>mqtt_ack_list_node_is_exist</code>函数判断这个节点是否存在，主要是依赖等待响应的消息类型与msgid。</p></blockquote><h3 id="发布收到与发布释放报文的处理"><a href="#发布收到与发布释放报文的处理" class="headerlink" title="发布收到与发布释放报文的处理"></a>发布收到与发布释放报文的处理</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">mqtt_pubrec_and_pubrel_packet_handle</span><span class="token punctuation">(</span>mqtt_client_t <span class="token operator">*</span>c<span class="token punctuation">,</span> platform_timer_t <span class="token operator">*</span>timer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>反序列化报文</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">MQTTDeserialize_ack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>packet_type<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dup<span class="token punctuation">,</span> <span class="token operator">&amp;</span>packet_id<span class="token punctuation">,</span> c<span class="token operator">-></span>read_buf<span class="token punctuation">,</span> c<span class="token operator">-></span>read_buf_size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>产生一个对应的应答报文</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_publish_ack_packet</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> packet_id<span class="token punctuation">,</span> packet_type<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>取消对应的ack记录</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token function">mqtt_ack_list_unrecord</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> UNSUBACK<span class="token punctuation">,</span> packet_id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg_handler<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> mqtt </tag>
            
            <tag> mqttclient </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake实战教程（三）</title>
      <link href="/cmake-3/"/>
      <url>/cmake-3/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从本小节开始，后面所有的构建我们都将采用 <code>out-of-source build</code> 外部构建的方式去编写构建工程代码，构建目录是工程目录下的 <code>build</code> 目录。</p><p>从上一篇文章我们就知道，通过<code>aux_source_directory</code>命令可以扫描某个目录下的所有源码，但是更深一层的目录源码就找不到了，因此不满足我们真正工程项目的需要，毕竟真的工程会有很多个目录的，这些目录在的地方还不一样，现在就来解决这个问题…</p><h1 id="定个小目标"><a href="#定个小目标" class="headerlink" title="定个小目标"></a>定个小目标</h1><ul><li><strong>CMake自动构建多个源码目录下的工程</strong></li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>首先，起码工程中得有多个目录对吧，按照编程习惯，我喜欢把源码放到 <code>src</code> 目录下，把头文件放到 <code>inc</code> 目录下，那么把上一篇文章的代码分离放开，具体如下：</p><pre class="line-numbers language-js"><code class="language-js">jie@pc<span class="token punctuation">:</span><span class="token operator">~</span><span class="token operator">/</span>github<span class="token operator">/</span>cmake<span class="token operator">/</span>section4$ tree<span class="token punctuation">.</span>├── build<span class="token punctuation">.</span>sh├── CMakeLists<span class="token punctuation">.</span>txt├── inc│   └── power<span class="token punctuation">.</span>h├── main<span class="token punctuation">.</span>c└── power    ├── CMakeLists<span class="token punctuation">.</span>txt    └── power<span class="token punctuation">.</span>c<span class="token number">2</span> directories<span class="token punctuation">,</span> <span class="token number">6</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很显然，从上面的目录结构中可以看出，有两个<code>CMakeLists.txt</code>文件，一个是在根目录下，一个是在src目录下：</p><pre class="line-numbers language-bash"><code class="language-bash">./CMakeLists.txt./src/CMakeLists.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其实无论在何处，<code>CMakeLists.txt</code>文件都可以被 <code>CMake</code> 命令识别并且自动构建，但是，我们自动构建的时候，都会有一个顶层目录<code>CMakeLists.txt</code>文件，它就是cmake的入口文件，而在顶层目录下，如果某些子目录中存在<code>CMakeLists.txt</code>文件，那么 <code>CMake</code> 可以将顶层的环境变量传递到子目录下，就好比，你在某个文件中定义了个全局变量，你在那个文件中的子函数都可以使用这个全局变量，有点类似的道理，说白了就是作用域。。。</p><h2 id="添加子目录"><a href="#添加子目录" class="headerlink" title="添加子目录"></a>添加子目录</h2><p>那么为了能人 <code>CMake</code> 去识别到<code>src</code>目录下的<code>./src/CMakeLists.txt</code>文件，我们可以在顶层<code>./CMakeLists.txt</code>文件添加一个子目录，用以下这个命令：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">add_subdirectory</span><span class="token punctuation">(</span>source_dir <span class="token punctuation">[</span>binary_dir<span class="token punctuation">]</span>                <span class="token punctuation">[</span>EXCLUDE_FROM_ALL<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>add_subdirectory</code> 这条命令的作用是为构建添加一个子路径。</p><ul><li><code>source_dir</code> 选项指定了 <code>CMakeLists.txt</code> 源文件和代码文件的位置。如果 <code>source_dir</code> 是一个相对路径，那么 <code>source_dir</code> 选项会被解释为相对于当前的目录，不过它也可以是一个绝对路径。在 <code>source_dir</code> 指定路径下的 <code>CMakeLists.txt</code> 将会在当前输入文件的处理过程执行到该命令之前，立即被 <code>CMake</code> 处理。</li><li><code>binary_dir</code> 选项指定了输出文件的路径，同样的， <code>binary_dir</code> 可以相对路径，也可以是一个绝对路径。不过杰杰目前暂未使用到<code>binary_dir</code>，感兴趣的兄弟姐妹可以自己去了解它。</li><li>如果指定了 <code>EXCLUDE_FROM_ALL</code> 选项，在子路径下的目标默认不会被包含到父路径的 ALL 目标里，并且也会被排除在工程文件之外，用户必须显式构建在子路径下的目标。</li></ul><h2 id="添加路径"><a href="#添加路径" class="headerlink" title="添加路径"></a>添加路径</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token function">include_directories</span><span class="token punctuation">(</span><span class="token punctuation">[</span>AFTER<span class="token operator">|</span>BEFORE<span class="token punctuation">]</span> <span class="token punctuation">[</span>SYSTEM<span class="token punctuation">]</span> dir1 dir2 <span class="token operator">...</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同理可以使用<code>include_directories</code>命令将给定的路径添加到编译器搜索包含文件（.h 文件）的路径列表中，这是为了让编译器找到合适的头文件。如果指定了 <code>SYSTEM</code> 选项，编译器将会认为该路径是某种平台上的系统包含路径。</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>在cmake中，很多变量都是以列表的形式存在，比如上面的两个命令，添加头文件与添加子目录，我们可以用列表的形式添加进去，比如<code>include_directories(dir1 dir2 dir3)</code>，那么这些dir，那么<code>CMake</code>也提供了遍历这些列表的方法，这与C语言中的for循环都差不多，可以使用以下命令去遍历它：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">foreach</span><span class="token punctuation">(</span>loop_var arg1 arg2 <span class="token operator">...</span><span class="token punctuation">)</span><span class="token function">COMMAND1</span><span class="token punctuation">(</span>ARGS <span class="token operator">...</span><span class="token punctuation">)</span><span class="token function">COMMAND2</span><span class="token punctuation">(</span>ARGS <span class="token operator">...</span><span class="token punctuation">)</span><span class="token operator">...</span><span class="token function">endforeach</span><span class="token punctuation">(</span>loop_var<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意，这个命令需要配合 endforeach 命令使用，endforeach 表示结束遍历</strong><br>所有的 <code>foreach</code> 和与之匹配的 <code>endforeach</code> 命令之间的命令，会根据list的每个变量都执行一遍，在每次迭代中，循环变量${loop_var}将会被设置为 list 中的当前变量值。</p><p>为了演示，我就将<code>foreach</code>命令去变量指定的<code>INCDIRS</code>（虽然只有一个变量，不过不影响演示），把<code>INCDIRS</code>列表的内容一个个添加到路径中：</p><pre class="line-numbers language-js"><code class="language-js"># 头文件<span class="token keyword">set</span><span class="token punctuation">(</span>INCDIRS <span class="token string">"inc"</span><span class="token punctuation">)</span># 添加头文件目录<span class="token function">foreach</span><span class="token punctuation">(</span>incdir $<span class="token punctuation">{</span>INCDIRS<span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token function">include_directories</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span>incdir<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">endforeach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，我在这提到遍历并不是因为必须要使用这个命令，而是为后续的文章做铺垫。</p><h2 id="构建库"><a href="#构建库" class="headerlink" title="构建库"></a>构建库</h2><p>如果一个工程中有非常多的源码，那么总不能将所有的源码都使用<code>add_executable</code>命令去生成可执行文件是不是，我们可以让这个可执行文件去依赖库，静态库，动态库都可以，那么在这里就简单说说<code>add_executable</code>命令依赖静态库生成可执行文件，那么问题来了，静态库从哪来？</p><p>很显然，静态库是我们的一些源码文件生成的，在生成静态库后，再通过静态库去构建可执行文件，那么就用到了CMake中的<code>add_library</code>命令：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">add_library</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>name<span class="token operator">></span> <span class="token punctuation">[</span>STATIC <span class="token operator">|</span> SHARED <span class="token operator">|</span> MODULE<span class="token punctuation">]</span>            <span class="token punctuation">[</span>EXCLUDE_FROM_ALL<span class="token punctuation">]</span>            source1 source2 <span class="token operator">...</span> sourceN<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>它的作用就是使用指定的源文件向工程中添加一个库。添加一个名为<code>&lt;name&gt;</code>的库文件，<code>&lt;name&gt;</code>在一个工程的全局域内必须是唯一的，这个库文件将会根据命令里列出的源文件（<code>source1 source2 ... sourceN</code>）来创建。待构建的库文件的实际文件名根据对应平台的命名约定来构造（比如 可以是<code>lib&lt;name&gt;.a</code> 或者<code>&lt;name&gt;.lib</code>）。通过指定<code>STATIC</code>，<code>SHARED</code>，或者 <code>MODULE</code> 参数用来指定要创建的库的类型。</p><ul><li><code>STATIC</code> 库是目标文件的归档文件，在链接其它目标的时候使用。</li><li><code>SHARED</code> 库会被动态链接，在运行时被加载。</li><li><code>MODULE</code> 库是不会被链接到其它目标中的插件，但是可能会在运行时使用 dlopen-系列的函数动态链接。如果没有类型被显式指定，这个选项将会根据变量 <code>BUILD_SHARED_LIBS</code> 的当前值是否为真决定是 <code>STATIC</code> 还是 <code>SHARED</code>。</li></ul><pre class="line-numbers language-js"><code class="language-js"># 查找当前目录下的所有源文件# 并将名称保存到 DIR_LIB_SRCS 变量<span class="token function">file</span><span class="token punctuation">(</span>GLOB_RECURSE DIR_LIB_SRCS <span class="token operator">*</span><span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token function">file</span><span class="token punctuation">(</span>GLOB_RECURSE DIR_LIB_HDRS <span class="token operator">*</span><span class="token punctuation">.</span>h<span class="token punctuation">)</span># 生成链接库<span class="token function">add_library</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span>LIB_NAME<span class="token punctuation">}</span> $<span class="token punctuation">{</span>DIR_LIB_SRCS<span class="token punctuation">}</span> $<span class="token punctuation">{</span>DIR_LIB_HDRS<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，为了我们的<code>CMakeLists.txt</code>文件有更好的兼容性，也不必每次都去写对应的库文件名字<code>&lt;name&gt;</code>，杰杰自己会使用正则表达式去解析当前目录的名字，并以这个目录名字去作为库的命名，正则表达式如下：</p><pre class="line-numbers language-js"><code class="language-js"># 正则表达式得到当前目录名字作为提供给上一层的库名字<span class="token function">string</span><span class="token punctuation">(</span>REGEX REPLACE <span class="token string">".*/(.*)"</span> <span class="token string">"\\1"</span> LIB_NAME $<span class="token punctuation">{</span>CMAKE_CURRENT_SOURCE_DIR<span class="token punctuation">}</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="工程demo"><a href="#工程demo" class="headerlink" title="工程demo"></a>工程demo</h1><p>顶层<code>./CMakeLists.txt</code>文件内容：</p><pre class="line-numbers language-js"><code class="language-js"># CMake 最低版本号要求<span class="token function">cmake_minimum_required</span><span class="token punctuation">(</span>VERSION <span class="token number">2.8</span><span class="token punctuation">)</span># 项目信息<span class="token function">project</span><span class="token punctuation">(</span>targets<span class="token punctuation">)</span># 设置可执行文件目标<span class="token keyword">set</span><span class="token punctuation">(</span>TARGETS <span class="token string">"targets"</span><span class="token punctuation">)</span># 子目录<span class="token keyword">set</span><span class="token punctuation">(</span>SUBDIRS <span class="token string">"power"</span><span class="token punctuation">)</span># 头文件<span class="token keyword">set</span><span class="token punctuation">(</span>INCDIRS <span class="token string">"inc"</span><span class="token punctuation">)</span># 指定编译器<span class="token keyword">set</span><span class="token punctuation">(</span>CMAKE_C_COMPILER <span class="token string">"gcc"</span><span class="token punctuation">)</span>#判断编译器类型<span class="token punctuation">,</span>如果是gcc编译器<span class="token punctuation">,</span>则在编译选项中加入c<span class="token operator">++</span><span class="token number">11</span>支持<span class="token keyword">if</span><span class="token punctuation">(</span>CMAKE_COMPILER_IS_GNUCXX<span class="token punctuation">)</span>    <span class="token keyword">set</span><span class="token punctuation">(</span>CMAKE_CXX_FLAGS <span class="token string">"-std=c++11 ${CMAKE_CXX_FLAGS}"</span><span class="token punctuation">)</span><span class="token function">endif</span><span class="token punctuation">(</span>CMAKE_COMPILER_IS_GNUCXX<span class="token punctuation">)</span>#指定编译类型<span class="token function">SET</span><span class="token punctuation">(</span>CMAKE_BUILE_TYPE <span class="token string">"RELEASE"</span><span class="token punctuation">)</span># 查找当前目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量<span class="token function">aux_source_directory</span><span class="token punctuation">(</span><span class="token punctuation">.</span> DIR_SRCS<span class="token punctuation">)</span># 指定生成目标<span class="token function">add_executable</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span>TARGETS<span class="token punctuation">}</span> $<span class="token punctuation">{</span>DIR_SRCS<span class="token punctuation">}</span><span class="token punctuation">)</span># 添加头文件目录<span class="token function">foreach</span><span class="token punctuation">(</span>incdir $<span class="token punctuation">{</span>INCDIRS<span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token function">include_directories</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span>incdir<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">endforeach</span><span class="token punctuation">(</span><span class="token punctuation">)</span># 添加子目录<span class="token function">foreach</span><span class="token punctuation">(</span>subdir $<span class="token punctuation">{</span>SUBDIRS<span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token function">add_subdirectory</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span>subdir<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">endforeach</span><span class="token punctuation">(</span><span class="token punctuation">)</span># 添加链接库<span class="token function">target_link_libraries</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span>TARGETS<span class="token punctuation">}</span> $<span class="token punctuation">{</span>SUBDIRS<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>src</code>目录下的<code>./src/CMakeLists.txt</code>文件内容：</p><pre class="line-numbers language-js"><code class="language-js"># 查找当前目录下的所有源文件# 并将名称保存到 DIR_LIB_SRCS 变量<span class="token function">file</span><span class="token punctuation">(</span>GLOB_RECURSE DIR_LIB_SRCS <span class="token operator">*</span><span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token function">file</span><span class="token punctuation">(</span>GLOB_RECURSE DIR_LIB_HDRS <span class="token operator">*</span><span class="token punctuation">.</span>h<span class="token punctuation">)</span># 正则表达式得到当前目录名字作为提供给上一层的库名字<span class="token function">string</span><span class="token punctuation">(</span>REGEX REPLACE <span class="token string">".*/(.*)"</span> <span class="token string">"\\1"</span> LIB_NAME $<span class="token punctuation">{</span>CMAKE_CURRENT_SOURCE_DIR<span class="token punctuation">}</span><span class="token punctuation">)</span> # 生成链接库<span class="token function">add_library</span><span class="token punctuation">(</span>$<span class="token punctuation">{</span>LIB_NAME<span class="token punctuation">}</span> $<span class="token punctuation">{</span>DIR_LIB_SRCS<span class="token punctuation">}</span> $<span class="token punctuation">{</span>DIR_LIB_HDRS<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后直接运行<code>./build</code>去构建工程与编译工程即可</p><h1 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h1><p><a href="https://github.com/jiejieTop/cmake" target="_blank" rel="noopener">https://github.com/jiejieTop/cmake</a></p><p>未完待续….</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> cmake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake实战教程（二）</title>
      <link href="/cmake-2/"/>
      <url>/cmake-2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从上一篇的文章中，相信大家也了解了<code>CMake</code>这个东西，但是呢它不是只是看一下就能会的，这种东西还是要实践才能学会，那么如果你已经实践过了，就会体会到上一篇文章在实际中使用到底是多么的难搞，比如：</p><ul><li>生成很多垃圾文件，这是我的第一个体会….</li><li>需要手动去指定编译的文件</li><li>无法指定编译器，编译选项等等很多东西….</li><li>如果有子目录也不能完全适用….</li><li>以及一些其他的问题….</li></ul><p>总的来说就是在真正项目中压根就没法适用的工程，那为什么我要写呢，因为那是我学习的过程，总不能一口吞下一个大胖子是不是，接下来的一系列文章我就会让<code>CMake</code>变得能在实际中使用，越来越自动化，更方便构建。。。</p><h1 id="外部构建"><a href="#外部构建" class="headerlink" title="外部构建"></a>外部构建</h1><p>第一个问题，在运行<code>cmake .</code>后会产生很多垃圾文件，那么我们可以让它在一个build目录下去编译，生成的垃圾文件放在这个目录下就好了，不需要的时候直接清除即可。</p><p>可能有人会问，它不能像Makefile一样直接<code>make clean</code> 或者<code>make distclean</code>清除编译的垃圾文件吗，我当时学的时候也谷歌过，但是，很遗憾没有，使用我才让它产生的垃圾文件放在build目录下，其实不能说是垃圾文件，只不过是一些中间文件，记录某些东西的，我用不上它，所以认为是垃圾…仅此而已。</p><p>对此官方的解释是：</p><blockquote><p>CMakeLists.txt 可以执行脚本并通过脚本生成一些临时文件，但是却没有办法来跟踪这些临时文件到底是哪些，因此，没有办法提供一个可靠的 clean 方案。</p></blockquote><p>那怎么办呢？很简单，从<code>CMake</code>的语法我们就知道，它在构建的时候指定了<code>PATH</code>，也就是顶层<code>CMakeLists.txt</code> 入口的路径。</p><pre class="line-numbers language-js"><code class="language-js">cmake PATH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么很显然，它可以是相对路径而不是绝对路径，毕竟<strong>点<code>‘.’</code></strong>  表示当前路径， <strong>点点<code>‘..’</code></strong> 表示上一级路径，那么我们可以新建一个build目录，然后在build目录下去运行：</p><pre class="line-numbers language-bash"><code class="language-bash">cmake <span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这在<code>CMake</code>中称之为外部构建（out-of-source build），而 <code>CMake</code> 强烈推荐的就是外部构建！</p><p>我自己也写了个build的脚本，内容非常简单，主要做两件事：</p><ol><li>创建一个build目录（存在就不会重新创建的）</li><li>进入build目录</li><li>然后外部构建cmake</li><li>生成Makefile文件后运行make命令编译</li></ol><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token function">mkdir</span> -p build<span class="token function">cd</span> buildcmake <span class="token punctuation">..</span><span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此在编译的时候直接运行这个脚本即可，生成的内容全部都在build目录下。</p><ul><li>这是原始目录</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">.</span>├── build.sh├── CMakeLists.txt└── main.c0 directories, 3 files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译后在build目录下生成很多文件，包括 <code>Makefile、section2(可执行程序)</code>等</p><pre class="line-numbers language-bash"><code class="language-bash">CMakeCache.txt  CMakeFiles  cmake_install.cmake  Makefile  section2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>补充一点，如果你想看到cmake生成的垃圾文件比你源码还多的时候，你就会爱死外部构建这种骚操作了~</strong></p><h1 id="自动查找源码"><a href="#自动查找源码" class="headerlink" title="自动查找源码"></a>自动查找源码</h1><p>不得不说，cmake是个很好的自动化构建工具，既然是自动化，那么很的东西都是自动的，比如查找源码，cmake就提供查找源码的命令：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">aux_source_directory</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>dir<span class="token operator">></span> <span class="token operator">&lt;</span>variable<span class="token operator">></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它的主要作用就是：<strong>查找在某个路径下的所有源文件</strong>，注意，是所有源码文件，当你的目录下有很多个源码文件的时候，他就主动去查找了，哦，当然，它也只会查找源码文件，比如<code>*.c 、 *.cpp 、*.cc</code>啦，反正只要是源码就可以了，但是什么<code>txt  、 *.h</code>文件这些它是不会记录下来的。</p><ul><li><code>dir</code> ： 指定的目录（可以是绝对路径也可以是相对路径）</li><li><code>variable</code>：将输出结果列表储存在指定的<code>&lt;variable&gt;</code>变量中。</li></ul><p>反正这个命令就很方便，我在某个目录下有啥源码文件，我都会被记录到<code>&lt;variable&gt;</code>变量，然后在<code>CMake</code>直接使用即可。当然后续也有其他的命令去找源码文件，一口吃不了一个大胖子，先了解这个先，后续慢慢学习~</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>在<code>CMake</code>中，变量是十分常见的，我正在就简单讲解下基本的语法吧：</p><p>定义变量常用的函数是：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">set</span><span class="token punctuation">(</span>VARIABLE_NAME VARIABLE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>取消定义变量是</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">unset</span><span class="token punctuation">(</span>VARIABLE_NAME <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>VARIABLE_NAME</code> ： 变量名字</li><li><code>VARIABLE</code>：变量的值</li></ul><p>变量的的值始终是<code>string（字符串）</code>类型，变量名字是区分大小写的，一般变量命名还是正常点比较好，别搞太多乱七八糟的特殊符号，只要数字、字母，下划线<code>"_"</code> 、横线<code>"-"</code>就差不多了，变量的作用域也是有全局与局部之分，与C语言、Java都差不多，我也不多说了。我的例程中<code>全局变量是全部大写，局部变量是全小写</code>的，也是比较好区分。</p><p>变量引用的形式为<code>${variable_name}</code>，变量引用被变量的值替换，或者如果变量没有被设置，则由空字符串替换。变量引用可以嵌套，例如<code>${outer_${inner_variable}veriable}</code>；环境变量引用的形式为<code>$ENV{VARIABLE}</code>，并在相同的上下文中作为正常变量引用。</p><h1 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h1><p>在<code>CMake</code>构建的时候，你可能不知道某些变量是啥内容，那么就在终端打印出来看看就好了，这根我们写代码中的printf函数差不多，给直接打一串字符串出来瞧瞧….</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">message</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&lt;</span>mode<span class="token operator">></span><span class="token punctuation">]</span> <span class="token string">"message to display"</span> <span class="token operator">...</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首先呢，<code>&lt;mode&gt;</code>是指定消息的类型：</p><ul><li><code>(无)</code> = 重要消息；</li><li><code>STATUS</code> = 非重要消息；</li><li><code>WARNING</code> = CMake 警告, 会继续执行；</li><li><code>AUTHOR_WARNING</code> = CMake 警告 (dev), 会继续执行；</li><li><code>SEND_ERROR</code> = CMake 错误, 继续执行，但是会跳过生成的步骤；</li><li><code>FATAL_ERROR</code> = CMake 错误, 终止所有处理过程；</li></ul><p>正常情况下我都是输出一些状态信息——<code>STATUS</code>，打印个变量啦，打印下代码的执行顺序啦等等….</p><p>后面就是有些字符串信息了，变量在这里直接引用就好，毕竟变量本身就是字符串….</p><h1 id="section3"><a href="#section3" class="headerlink" title="section3"></a>section3</h1><p>给出个实例代码：<br>当前目录存在2个c文件，分别是<code>main.c</code>、<code>power.c</code>就是简单计算x的y次方，纯粹是个demo，我自己也懒得写，并不是因为代码有多高深，所以这代码我是从网上找的，来自<a href="https://github.com/wzpan" target="_blank" rel="noopener">潘伟洲</a>大神的cmake测试代码：<a href="https://github.com/wzpan/cmake-demo" target="_blank" rel="noopener">https://github.com/wzpan/cmake-demo</a>。</p><ul><li>main.c</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"power.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Usage: %s base exponent \n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">double</span> base <span class="token operator">=</span> <span class="token function">atof</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> exponent <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> result <span class="token operator">=</span> <span class="token function">power</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> exponent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%g ^ %d is %g\n"</span><span class="token punctuation">,</span> base<span class="token punctuation">,</span> exponent<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>power.c</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">double</span> <span class="token function">power</span><span class="token punctuation">(</span><span class="token keyword">double</span> base<span class="token punctuation">,</span> <span class="token keyword">int</span> exponent<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> base<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>exponent <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> exponent<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        result <span class="token operator">=</span> result <span class="token operator">*</span> base<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就是<code>CMakeLists.txt</code>文件：</p><pre class="line-numbers language-js"><code class="language-js"># CMake 最低版本号要求cmake_minimum_required <span class="token punctuation">(</span>VERSION <span class="token number">2.8</span><span class="token punctuation">)</span># 项目信息project <span class="token punctuation">(</span>section3<span class="token punctuation">)</span># 查找当前目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量<span class="token function">aux_source_directory</span><span class="token punctuation">(</span><span class="token punctuation">.</span> DIR_SRCS<span class="token punctuation">)</span># 指定生成目标<span class="token function">add_executable</span><span class="token punctuation">(</span>section3 $<span class="token punctuation">{</span>DIR_SRCS<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相比于上一篇文章，我这个<code>CMakeLists.txt</code>文件只是添加了<code>aux_source_directory</code>命令去自动扫描当前目录下的源码文件，并且保存到<code>DIR_SRCS</code> 变量中，仅此而已！！</p><p>然后在<code>add_executable</code>命令中，用<code>${DIR_SRCS}</code>变量代替指定的源码文件<code>source1 source2 ... sourceN</code>，当然你也可以打印一下<code>${DIR_SRCS}</code>变量到底保存了什么，如果不出意外的话，它保存的就是<code>./main.c;   ./power.c</code>，表示的是当前目录下的<code>main.c</code>、<code>power.c</code>这两个文件，而分号代表它是一个list，后续会讲解怎么去提取list的内容….</p><pre class="line-numbers language-bash"><code class="language-bash">message<span class="token punctuation">(</span>STATUS <span class="token string">"<span class="token variable">${DIR_SRCS}</span>"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后用外部构建的方式去编译代码：</p><pre class="line-numbers language-bash"><code class="language-bash">jie@pc:~/github/cmake/section3$ ./build.sh -- The C compiler identification is GNU 7.4.0-- The CXX compiler identification is GNU 7.4.0-- Check <span class="token keyword">for</span> working C compiler: /usr/bin/cc-- Check <span class="token keyword">for</span> working C compiler: /usr/bin/cc -- works-- Detecting C compiler ABI info-- Detecting C compiler ABI info - <span class="token keyword">done</span>-- Detecting C compile features-- Detecting C compile features - <span class="token keyword">done</span>-- Check <span class="token keyword">for</span> working CXX compiler: /usr/bin/c++-- Check <span class="token keyword">for</span> working CXX compiler: /usr/bin/c++ -- works-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - <span class="token keyword">done</span>-- Detecting CXX compile features-- Detecting CXX compile features - <span class="token keyword">done</span>-- Configuring <span class="token keyword">done</span>-- Generating <span class="token keyword">done</span>-- Build files have been written to: /home/jie/github/cmake/section3/buildScanning dependencies of target section3<span class="token punctuation">[</span> 33%<span class="token punctuation">]</span> Building C object CMakeFiles/section3.dir/main.c.o<span class="token punctuation">[</span> 66%<span class="token punctuation">]</span> Building C object CMakeFiles/section3.dir/power.c.o<span class="token punctuation">[</span>100%<span class="token punctuation">]</span> Linking C executable section3<span class="token punctuation">[</span>100%<span class="token punctuation">]</span> Built target section3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显生成了正确可执行文件~</p><h1 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h1><p><a href="https://github.com/jiejieTop/cmake" target="_blank" rel="noopener">https://github.com/jiejieTop/cmake</a></p><p>未完待续….</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> cmake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake实战教程（一）</title>
      <link href="/cmake-1/"/>
      <url>/cmake-1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在学习<code>CMake</code>之前，一直都是自己在手敲<code>Makefile</code>文件，当项目的文件一旦多了起来，自己手动写<code>Makefile</code>就不是那么好玩了，也曾经了解了一下<code>autotools</code>，但是seeed的柱哥说有<code>CMake</code>这个东西，所以我就去学习了，也在网上搜过对比，下面的一句话让我放弃了<code>autotools</code>：</p><blockquote><p>CMake产生的晚，解决了很多autotools工具的问题</p></blockquote><p>其实吧，简单来说<code>CMake</code>就是生产Makefile的自动化构建工具，引用一句官方的描述就是：</p><blockquote><p>CMake 是一个跨平台的构建系统生成工具。它使用平台无关的 CMake 清单文件CMakeLists.txt，指定工程的构建过程；源码树的每个路径下都有这个文件。CMake 产生一个适用于具体平台的构建系统，用户使用这个系统构建自己的工程。</p></blockquote><h1 id="安装CMake"><a href="#安装CMake" class="headerlink" title="安装CMake"></a>安装CMake</h1><ul><li>开发环境：<code>Ubuntu</code></li></ul><p>一句代码的事安装<code>CMake</code>：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> cmake<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检测安装是否成功：</p><pre class="line-numbers language-js"><code class="language-js">cmake <span class="token operator">--</span>version # 输出cmake version <span class="token number">3.10</span><span class="token punctuation">.</span><span class="token number">2</span>CMake suite maintained and supported by Kitware <span class="token punctuation">(</span>kitware<span class="token punctuation">.</span>com<span class="token operator">/</span>cmake<span class="token punctuation">)</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你用的是<code>vscode</code>写代码的话，最好还是装一个<code>CMake</code>插件，更加方便：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/cmake-1.png" alt="cmake插件"></p><p>关于其他的一些注意事项，你需要编译c代码，起码Ubuntu得有个gcc编译器啥的吧~如果没有就直接安装得了….</p><h1 id="初步了解CMake"><a href="#初步了解CMake" class="headerlink" title="初步了解CMake"></a>初步了解CMake</h1><p>其实呢，<code>CMake</code>是非常简单易用的，我们写代码无非就是将写好的代码进行编译生成可执行文件，那么就可以用<code>CMake</code> 生成 Makefile 文件并编译源代码！</p><p>它的流程基本如下：</p><ol><li>编写 <code>CMake</code>配置文件 <code>CMakeLists.txt</code> 。</li><li>执行<code>cmake PATH</code>命令生成 <code>Makefile</code>。其中， <code>PATH</code> 是 <code>CMakeLists.txt</code> 所在的目录。</li><li>使用 <code>make</code> 命令进行编译。（既然步骤2的时候就生成<code>Makefile</code>文件了，那么肯定是可以直接<code>make</code>编译啦）</li></ol><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p>一个最基本的<code>CmakeLists.txt</code>文件最少需要包含以下3行代码：</p><pre class="line-numbers language-js"><code class="language-js"># CMake 最低版本号要求cmake_minimum_required <span class="token punctuation">(</span>VERSION <span class="token number">2.8</span><span class="token punctuation">)</span># 项目信息project <span class="token punctuation">(</span>section1<span class="token punctuation">)</span># 指定生成目标<span class="token function">add_executable</span><span class="token punctuation">(</span>section1 main<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：<code>CMake</code>的语法支持大写、小写甚至是大小写混合的，实在是太变态了，不过呢，在杰杰的例程中使用的<code>CMake</code>语法是小写的，全局变量是大写的，局部变量是小写！</p><h1 id="section1"><a href="#section1" class="headerlink" title="section1"></a>section1</h1><p>废话不多说，直接入门实战吧，写代码这东西还是要亲自动手去写采用意义~</p><ul><li>文件夹目录结构如下：</li></ul><pre class="line-numbers language-bash"><code class="language-bash">jie@pc:~/github/cmake/section1$ tree<span class="token keyword">.</span>├── CMakeLists.txt└── main.c0 directories, 2 files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非常简单，也就是一个<code>main.c</code>文件与一个<code>CMakeLists.txt</code>文件，内容更是简单，<code>main.c</code>就只是打印个<code>"Hello World!"</code>：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>CMakeLists.txt</code>就是<code>CMake</code>最基础的3行代码：</p><pre class="line-numbers language-js"><code class="language-js"># CMake 最低版本号要求cmake_minimum_required <span class="token punctuation">(</span>VERSION <span class="token number">2.8</span><span class="token punctuation">)</span># 项目信息project <span class="token punctuation">(</span>section1<span class="token punctuation">)</span># 指定生成目标<span class="token function">add_executable</span><span class="token punctuation">(</span>section1 main<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样子可以在该目录下直接运行以下命令去编译（注意有一个 <strong>点<code>.</code></strong>，表示<code>CMakeLists.txt</code> 所在的目录）：</p><pre class="line-numbers language-bash"><code class="language-bash">cmake <span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编译输出信息如下：</p><pre class="line-numbers language-bash"><code class="language-bash">jie@pc:~/github/cmake/section1$ cmake <span class="token keyword">.</span>-- The C compiler identification is GNU 7.4.0-- The CXX compiler identification is GNU 7.4.0-- Check <span class="token keyword">for</span> working C compiler: /usr/bin/cc-- Check <span class="token keyword">for</span> working C compiler: /usr/bin/cc -- works-- Detecting C compiler ABI info-- Detecting C compiler ABI info - <span class="token keyword">done</span>-- Detecting C compile features-- Detecting C compile features - <span class="token keyword">done</span>-- Check <span class="token keyword">for</span> working CXX compiler: /usr/bin/c++-- Check <span class="token keyword">for</span> working CXX compiler: /usr/bin/c++ -- works-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - <span class="token keyword">done</span>-- Detecting CXX compile features-- Detecting CXX compile features - <span class="token keyword">done</span>-- Configuring <span class="token keyword">done</span>-- Generating <span class="token keyword">done</span>-- Build files have been written to: /home/jie/github/cmake/section1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后你就会看到生成了一些其他文件文件以及一个<code>Makefile</code>文件：</p><pre class="line-numbers language-bash"><code class="language-bash">jie@pc:~/github/cmake/section1$ <span class="token function">ls</span>CMakeCache.txt  CMakeFiles  cmake_install.cmake  CMakeLists.txt  main.c  Makefile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>既然有<code>Makefile</code>文件那么就可以直接运行<code>make</code>命令去编译源码文件了，最后输出<code>“Built target section1”</code>表示编译成功！最终目录下会多出一个<code>section1</code>可执行文件，然后你运行它就能看到代码的执行效果了，直接打印输出<code>"Hello World!"</code>。</p><pre class="line-numbers language-bash"><code class="language-bash">jie@pc:~/github/cmake/section1$ <span class="token function">make</span>Scanning dependencies of target section1<span class="token punctuation">[</span> 50%<span class="token punctuation">]</span> Building C object CMakeFiles/section1.dir/main.c.o<span class="token punctuation">[</span>100%<span class="token punctuation">]</span> Linking C executable section1<span class="token punctuation">[</span>100%<span class="token punctuation">]</span> Built target section1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="CMakeLists-txt分析"><a href="#CMakeLists-txt分析" class="headerlink" title="CMakeLists.txt分析"></a>CMakeLists.txt分析</h1><pre class="line-numbers language-js"><code class="language-js"># CMake 最低版本号要求cmake_minimum_required <span class="token punctuation">(</span>VERSION <span class="token number">2.8</span><span class="token punctuation">)</span># 项目信息project <span class="token punctuation">(</span>section1<span class="token punctuation">)</span># 指定生成目标<span class="token function">add_executable</span><span class="token punctuation">(</span>section1 main<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实上面的三句代码看起来像是函数，但并不是函数而是命令，它跟我们的在<code>linux</code>的命令差不多，反正就是指定<code>CMake</code>要怎么做的一系列命令。比如：</p><ul><li><code>cmake_minimum_required</code>：设置一个工程所需要的最低 <code>CMake</code>版本，如果 <code>CMake</code>的当前版本低于指定的版本，它会停止处理工程文件，并报告错误。</li><li><code>project</code>：为整个工程设置一个工程名。</li><li><code>add_executable</code>：使用给定的源文件，为工程引入一个可执行文件。<pre class="line-numbers language-js"><code class="language-js"><span class="token function">add_executable</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>name<span class="token operator">></span> <span class="token punctuation">[</span>WIN32<span class="token punctuation">]</span> <span class="token punctuation">[</span>MACOSX_BUNDLE<span class="token punctuation">]</span>              <span class="token punctuation">[</span>EXCLUDE_FROM_ALL<span class="token punctuation">]</span>              source1 <span class="token punctuation">[</span>source2 <span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>引入一个名字为<code>&lt;name&gt;</code>的可执行目标，这个可执行目标会由调用该命令时在源文件列表中指定的源文件来构建，比如<code>main.c</code>就是一个源码文件。<code>&lt;name&gt;</code>在工程范围内必须是全局唯一的，它实际上就是make编译后生成的可执行文件。</li></ul><p>顺便再提一下语法，上面的代码呢，<code>&lt;name&gt;</code>是必须填写的，然后也必须有一个源码文件<code>source1</code>，当然有可以有多个源码文件<code>[source2 ...]</code>。<br>| 格式     | 注释 |<br>|–|–|<br>| &lt; command &gt; | 必须填写的 |<br>| [ command ] | 可写也可不写的 |<br>| a|b | a或者b都可以 |</p><p>对了，<code>#</code> 后面的是注释，这根C语言中<code>//</code>表示注释是一样的！</p><h1 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h1><p><a href="https://github.com/jiejieTop/cmake" target="_blank" rel="noopener">https://github.com/jiejieTop/cmake</a></p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>暂且到这吧，未完待续….</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> cmake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARP协议原理</title>
      <link href="/tcpip-3/"/>
      <url>/tcpip-3/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>从前一篇文章中，我们知道计算机中会维护一个ARP缓存表，这个表记录着IP地址与MAC地址的映射关系，我们可以通过在电脑的控制台通过arp -a指令查看一下我们自己计算机的ARP缓存表：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-6.png" alt="tcpip-6"></p><p>那么什么是<code>ARP</code>协议呢？</p><h1 id="初识ARP"><a href="#初识ARP" class="headerlink" title="初识ARP"></a>初识ARP</h1><p>ARP协议是地址解析协议（<code>Address Resolution Protocol</code>）是通过解析<code>IP地址</code>得到<code>MAC地址</code>的，是一个在网络协议包中极其重要的网络传输协议，它与网卡有着极其密切的关系，在<code>TCP/IP</code>分层结构中，把<code>ARP</code>划分为<code>网络层</code>，为什么呢，因为在<code>网络层</code>看来，源主机与目标主机是通过<code>IP地址</code>进行识别的，而所有的数据传输又依赖网卡底层硬件，即<code>链路层</code>，那么就需要将这些<code>IP地址</code>转换为链路层可以识别的东西，在所有的链路中都有着自己的一套寻址机制，如在以太网中使用<code>MAC地址</code>进行寻址，以标识不同的主机，那么就需要有一个协议将<code>IP地址转换为MAC地址</code>，由此就出现了<code>ARP协议</code>，所有<code>ARP协议</code>在网络层被应用，它是网络层与链路层连接的重要枢纽，每当有一个数据要发送的时候都需要在通过<code>ARP协议</code>将<code>IP地址转换成MAC地址</code>，在IP层及其以上的层次看来，他们只标识IP地址，从不跟硬件打交道，就像我一样，我做应用层的工作，而不会去写底层驱动，得专门有个同事将驱动写完给我，我只需要知道他提供的API接口就行了，而我就专心处理我的工作，我相信他能把驱动写好，我只需要直接调用即可。</p><h1 id="ARP缓存表"><a href="#ARP缓存表" class="headerlink" title="ARP缓存表"></a>ARP缓存表</h1><p>既然已经解释了<code>ARP协议</code>的用途及重要性，那么它是如何工作的？为了实现<code>IP地址</code>与<code>MAC地址</code>的<code>查询与转换</code>，<code>ARP协议</code>引入了<code>ARP缓存表</code>的概念，每台主机或路由器在<code>维护</code>着一个<code>ARP缓存表（ARP table）</code>，这个表包含<code>IP地址到MAC地址的映射关系</code>，表中记录了<code>&lt;IP地址，MAC地址&gt;</code>对，我称之为<code>ARP表项</code>，如我们前面那张<code>图</code>所展示的一样，他们是主机<code>最近</code>运行时获得关于其他主机的<code>IP地址</code>到<code>MAC地址</code>的映射，当需要发送数据的时候，主机就会根据数据报中的<code>目标IP地址</code>信息，然后在ARP缓存表中进行查找对应的<code>MAC地址</code>，最后通过网卡将数据发送出去。<code>ARP缓存表</code>包含一个<code>寿命值（TTL，也称作生存时间）</code>，它将记录每个<code>ARP表项</code>的生存时间，生存时间到了就会从缓存表中删除。从一个表项放置到<code>ARP缓存表</code>中开始，一个表项通常的生存时间一般是<code>10</code>分钟吗，当然，这些生存时间是可以任意设置的，我们一般使用默认即可。</p><h1 id="一句话总结ARP协议的工作"><a href="#一句话总结ARP协议的工作" class="headerlink" title="一句话总结ARP协议的工作"></a>一句话总结ARP协议的工作</h1><p><strong>ARP协议的主要工作就是建立、查询、更新、删除ARP表项。</strong></p><h1 id="ARP表项的建立"><a href="#ARP表项的建立" class="headerlink" title="ARP表项的建立"></a>ARP表项的建立</h1><p>当主机开机的时候，<code>ARP缓存</code>表肯定是空的，那么怎么一步步<code>建立 ARP表项</code>呢？如果此时想发送数据怎么办呢？因为没有<code>ARP表项</code>，说明就找不到<code>IP地址</code>到<code>MAC地址</code>的<code>映射关系</code>，这样子也就无法发送数据了。<br>其实协议栈的实现还是很强大的，如果没有<code>ARP表项</code>，那么主机就会去建立<code>ARP表项</code>。<br>以我们的电脑为例，在开机的时候，我们的电脑肯定是没有<code>ARP表项</code>的（或者应该说只有路由器的<code>ARP表项</code>，因为可能是动态获取IP地址）：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-8.png" alt="tcpip-8"></p><h2 id="对于局域网"><a href="#对于局域网" class="headerlink" title="对于局域网"></a>对于局域网</h2><p>如果我想向局域网中的某个电脑发送一个数据，那么我的电脑就会从已有的<code>ARP缓存表</code>中寻找这个IP地址对应的物理地址的<code>ARP表项</code>，然后直接将数据写入以太网数据帧中让网卡进行发送即可，而如果没有找到这个<code>IP地址</code>，那么这个数据就没法立即发送，电脑会先在局域网上广播一个<code>ARP请求</code>（目标MAC地址为<code>FF-FF-FF-FF-FF-FF</code>），广播的ARP请求发出后，处于同一局域网内的所有主机都会接收到这个请求，如果<code>目标IP地址</code>与接收到ARP请求的主机<code>自身IP地址</code>吻合就会<code>返回</code>一个<code>ARP应答</code>，告诉请求者（即我的电脑）自身的<code>MAC地址</code>，当我的电脑收到这个<code>ARP应答</code>后，就去建立一个<code>ARP表项</code>，并且重新将数据发送出去。<br>ARP协议的核心就是对缓存表的操作，发送数据包的时候，查找<code>ARP缓存表</code>以得到对应的<code>MAC地址</code>，在ARP缓存表中的<code>TTL</code>即将过期的时候<code>更新</code>缓存表以保证<code>ARP表项</code>有效，此外ARP协议还需要不断处理来自局域网中其他主机的<code>ARP请求</code>。</p><h2 id="对于公网"><a href="#对于公网" class="headerlink" title="对于公网"></a>对于公网</h2><p>比如我的电脑向访问我的博客：<a href="https://jiejietop.cn" target="_blank" rel="noopener">https://jiejietop.cn</a><br>因为我的博客主机是处于外网的，那么我的电脑在访问的时候，也是找不到缓存表的，那它只能通过网关，让网关将数据转发到我的博客主机上，即：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-9.png" alt="tcpip-9"></p><p>因为我的电脑与博客主机不在一个网段，电脑查询自己的<code>路由表</code>，知道如果想和<code>博客主机</code>通信则必须通过<code>网关（gateway）</code>来中转，所以会在与<code>网关</code>直连的网卡上请求网关的<code>MAC地址</code>，因为电脑要把发给博客主机的数据先发给网关，当合法以太帧到达网关并且顺利接收，网关会将数据递交给<code>IP层</code>，IP层查询路由表，找到与博客主机直连的接口（假设是直连的，实际上肯定不是直连的），网关会发一个<code>ARP请求</code>到博客主机上，请求它的<code>MAC地址</code>，网关收到应答后将建立新的<code>ARP表项</code>并将开始维护<code>ARP缓存表</code>，然后完成最终的通信。</p><h1 id="ARP缓存表的超时处理"><a href="#ARP缓存表的超时处理" class="headerlink" title="ARP缓存表的超时处理"></a>ARP缓存表的超时处理</h1><p>ARP是<code>动态</code>处理的，现在总结一下：<code>ARP表项</code>的生存时间是一般为<code>5-10</code>分钟（<code>LwIP</code>中默认是<code>5</code>分钟），而<code>ARP请求</code>的等待时间是<code>5秒钟</code>，当这些时间到达后，就会<code>更新ARP表项</code>，如果在物理链路层无法连通则会删除表项。<br>因此每个协议栈的实现都必须维护着一个<code>定时器（超时机制）</code>来管理<code>ARP缓存表</code>，在必要的时候更新及删除<code>ARP表项</code>，关于怎么处理的我们就不多追究，有兴趣的可以看LwIP的<code>etharp_tmr()</code>源码。</p><blockquote><p>说点题外话：因为<code>ARP协议</code>是一个动态的协议，很多网络攻击都是利用<code>ARP协议</code>进行的，如<code>ARP欺骗，ARP洪水攻击</code>等等，而且这种攻击是很难防御的，当然也有办法，直接将动态的<code>ARP缓存表</code>设置为静态就行了，但是这就违背了<code>ARP协议</code>的<code>动态地址解析</code>特性。</p></blockquote><h1 id="ARP报文"><a href="#ARP报文" class="headerlink" title="ARP报文"></a>ARP报文</h1><p>ARP的请求与应答都是依赖<code>ARP报文</code>结构进行的，<code>ARP报文</code>是放在以太网数据帧中进行发送的，下面是<code>ARP报文</code>的格式：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-10.png" alt="tcpip-10"></p><p>当它封装在以太网帧中的格式：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-11.png" alt="tcpip-11"></p><p>在ARP表建立前，主机并不知道目标<code>MAC地址</code>，所以在一开始的时候只能通过广播的方式将<code>ARP请求包</code>发送出去，处于同一局域网的主机都能接收到广播的数据包。所以一开始目标<code>MAC地址</code>是<code>FF-FF-FF-FF-FF-FF</code>，而以太网首部的帧类型是有多种，对于<code>ARP数据包</code>来说，其值为<code>0x0806</code>，对于<code>IP数据报</code>来说，其值为<code>0x0800</code>。<br>在ARP首部一开始的2个字节存储的是硬件类型，表示要知道目标网卡的硬件类型，其中，值为<code>1</code>表示以太网地址；接下来还有<code>2</code>字节的协议类型，其中，<code>0x0800</code>表示<code>IP协议</code>，其他还可能是<code>ICMP/IGMP协议</code>等；接下来有1个字节表示硬件地址长度，指出该报文中硬件地址的长度，对于以太网硬件类型，它的值为<code>6</code>；还有1字节的协议地址长度，如果是<code>ARP协议、IP协议</code>等，该值为<code>4</code>；ARP首部最后的<code>op</code>字段用于记录ARP操作的类型，分别是：</p><ul><li>ARP请求，其值为1。</li><li>ARP应答，其值为2。</li><li>RARP请求，其值为3。</li><li>RARP应答，其值为4。</li></ul><p>我们只关心ARP的请求与应答即可，RARP是逆地址解析协议，在这里我们就不用去了解，它在网络中基本已经被淘汰，用于主机在启动的时候获得自己的IP地址。<br>对于ARP首部后面的四个字段分别是源MAC地址、源IP地址、目标MAC地址、目标IP地址，这些就是比较简单的了。<br>为了加深理解，我们使用<code>wireshark</code>网络抓包工具形象地讲解报文格式与内容，关于<code>wireshark</code>网络抓包工具的使用方式我就不做过多讲解，网上教程一大把，打开工具，然后抓取电脑网络中的数据包。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-12.png" alt="tcpip-12"></p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-13.png" alt="tcpip-13"></p><p>未完待续…<br>下一篇<code>LwIP中ARP协议的实现</code></p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> TCP/IP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> 网络 </tag>
            
            <tag> LwIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络底层知识</title>
      <link href="/tcpip-2/"/>
      <url>/tcpip-2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从前一篇文章，我们也知道大概的网络相关知识，网络这个系列文章就从底层往顶层讲解，本篇文章就来接触一下<code>网络底层的相关知识</code>。</p><h1 id="概述网络中的数据递交"><a href="#概述网络中的数据递交" class="headerlink" title="概述网络中的数据递交"></a>概述网络中的数据递交</h1><p>当用户发送数据时，将数据向下交给传输层，这是处于应用层的操作，<code>应用层</code>可以通过调用传输层的接口来编写特定的应用程序，并且<code>TCP/IP</code>协议栈一般也会包含一些简单的应用协议如 <code>Telnet</code> 远程登录、<code>FTP</code>文件传输、<code>SMTP</code> 邮件传输协议等，这些协议有自己的首部——<code>APP首部</code>。<code>传输层</code>会在接收到上层协议的数据前面加上<code>传输层</code>首部（此处以<code>TCP</code>协议为例，图的<code>传输层</code>首部为<code>TCP首部</code>。当然<code>传输层</code>协议还有<code>UDP</code>协议），传输层会向下交给<code>网络层</code>。同样地，<code>网络层</code>会在数据前面加上网络层首部（如<code>IP</code>首部），然后<code>网络层</code>再将数据向下交给<code>链路层</code>，<code>数据链路层</code>会对数据进行最后一次封装，即在数据前面加上<code>数据链路层</code>首部（此处使用以太网接口为例），然后将数据交给<code>网卡</code>。最后，<code>网卡</code>将数据转换成物理链路上的电平信号，数据就这样被发送到了网络中。数据的发送过程，可以概括为TCP/IP的各层协议对数据进行封装的过程;<br>当设备的网卡接收到某个数据包后，它会将其放置在网卡的接收缓存中，并告知<code>TCP/IP</code>协议栈内核。然后<code>TCP/IP</code>协议栈内核就开始工作了，它会将数据包从接收缓存中取出，并逐层解析数据包中的协议首部信息，并最终将<code>数据</code>交给某个应用程序。数据的接收过程与发送过程正好相反，可以概括为TCP/IP的各层协议对数据进行解析的过程。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-5.png" alt="tcpip-5"></p><h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>关于以太网的理论我就不介绍了，因为这些理论太多了，有兴趣可以自己去网上查看。</p><h2 id="链路与数据链路"><a href="#链路与数据链路" class="headerlink" title="链路与数据链路"></a>链路与数据链路</h2><p>我们在这里要明确一下， “链路”和“数据链路”并不是一回事。<br>所谓<code>链路</code>就是从一个结点到相邻结点的一段物理线路（有线或无线）这是实实在在看得见的，比如我们的网线，而中间没有任何其他的交换结点。 在进行数据通信时， 两台计算机之间的通信路径往往要经过许多段这样的链路。 </p><p><code>数据链路</code>则是另一个概念。 这是因为当需要在一条线路上传送数据时， 除了<code>必须</code>有一条物理线路外，还必须有一些必要的协议来控制这些数据的传输，这就是我们<code>TCP/IP</code>协议栈要做的事情。 把这些<code>TCP/IP</code>协议栈加到链路上，就构成了数据链路。<br>一般我们所说的<code>链路层</code>指的都是<code>数据链路</code>。下文均采用<code>链路层</code>表示。</p><h2 id="LwIP中的“链路层”"><a href="#LwIP中的“链路层”" class="headerlink" title="LwIP中的“链路层”"></a>LwIP中的“链路层”</h2><p>我们知道，网络接口（如以太网接口）是硬件接口，（提示：网络接口又可以称之为网卡，为了统一，下文均采用网卡表示网络接口），LwIP是软件，<code>那么怎么让硬件与软件无缝连接起来呢？</code>而且，网卡又有多种多样，怎么能让<code>LwIP</code>使用同样的软件程序能兼容不同的硬件呢？</p><p>因此<code>LwIP</code>使用一个数据结构——<code>netif</code>来描述一个网卡，由于网卡是直接与硬件打交道的，硬件不同则处理基本是不同的，比如网卡的有各种各样的芯片，所以必须由<code>我们自己</code>提供最底层接口函数，<code>LwIP</code>提供统一的接口，比如网卡的初始化，网卡的收发数据，当<code>LwIP</code>底层得到了网络的数据之后，才会经过层层传入内核中去处理；同理，当应用层需要发送一个数据包的时候，也是讲数据包层层往下递交，然后也需要调用网卡的<code>发送函数</code>，将数据发送到网络中，这样子才能把数据从硬件接口到软件内核无缝连接起来。因此LwIP移植的关键是底层的移植，而很多人就卡在这里，如果底层的处理不好，那么就会导致各种各样的问题，比如网卡无缝接收太多数据，导致网速过慢，出现挂掉的现象，时常丢包，或者运行一段时间就导致内存泄漏等等等等乱七八糟的问题。</p><p>简单来说，<code>netif</code>是<code>LwIP</code>抽象出来的网卡描述符，它拥有描述设备中的不同网卡，一个设备至少与一个网卡，才能与网络进行通讯，<code>LwIP</code>协议栈可以使用多个不同的接口，而源码中的<code>ethernetif.c</code>文件则提供了<code>netif</code>访问各种不同的网卡，每个网卡有不同的实现方式，我们呢一般只需要修改<code>ethernetif.c</code>文件就行了，但是本篇文章不讲移植。（此处用LwIP协议栈讲解，本系列教程均基于<code>LwIP</code>）</p><p>举个例子：我们可以理解将整个网络的数据传输理解为物流，那么网卡就是不同的运输工具，我们可以选择汽车、飞机、轮船等运输工具，不同的运输工具速度是不一样的，但是对于一个物流公司而言，可能同时存在很多种运输的工具，这就需要物流公司去记录这些运输工具，当有一个包裹需要通过飞机运输出去，那么物流公司就会将这个包裹通过飞机发送出去，这就好比我们的网卡，需要哪个网卡发送或者接收网络数据的时候，就会让对应的网卡去工作。（可能不太贴切）</p><h2 id="MAC地址简介"><a href="#MAC地址简介" class="headerlink" title="MAC地址简介"></a>MAC地址简介</h2><blockquote><p>MAC地址（英语：Media Access Control Address），直译为媒体访问控制地址，也称为局域网地址（LAN Address），以太网地址（Ethernet Address）或物理地址（Physical Address），它是一个用来确认网络设备位置的地址。在OSI模型中，第三层网络层负责IP地址，第二层数据链接层则负责MAC地址。MAC地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址。（引用来自维基百科）</p></blockquote><p>可能我们做计算机相关专业的人，多多少少都会知道<code>IP地址</code>、<code>MAC地址</code>（也称之为链路层地址）。在前一篇文章说了，想要不同主机之间进行通讯，那么就必须有IP地址，<code>那现在为什么我们在链路层都需要地址呢？</code>事实上，并不是主机或路由器具有链路层地址，而是它们的<code>网卡</code>具有链路层地址。因此，一个主机拥有多少个网卡，那么它就有多少个<code>MAC地址</code>。MAC地址实际上就是网卡地址或网卡标识符。当某台计算机使用某块网卡后，网卡上的标识符就成为该计算机的MAC地址。MAC地址长度为<code>6</code>字节（<code>48bit</code>），其前<code>3</code>个字节表示组织唯一标志符（Organizationally Unique Identifier，即<code>OUI</code>），由<code>IEEE</code>的注册管理机构给不同厂家分配的代码，以区分不同的厂家，后3个字节由厂家自行分配，称为扩展标识符。同一个厂家生产的网卡中MAC地址后<code>24</code>位是不同的。</p><h2 id="IP地址与MAC地址的关系"><a href="#IP地址与MAC地址的关系" class="headerlink" title="IP地址与MAC地址的关系"></a>IP地址与MAC地址的关系</h2><p><code>TCP/IP</code>协议有自己的IP地址，IP地址（IPv4）是一个<code>32</code>位的IP地址，网络层发送数据包只需要知道目标主机IP地址即可，而以网卡发送数据则必须知道对方的硬件<code>MAC</code>地址，同时<code>IP</code>地址的分配与硬件<code>MAC</code>地址是没有关系的，为了让网络层只需要知道<code>IP地址</code>就可以完成通信工作，那就需要有一个协议将<code>IP</code>地址映射成为对应的<code>MAC</code>地址，此外还需要考虑<code>IP</code>地址可能是动态的，非常灵活，使用静态的映射方法是行不通的，所以<code>ARP</code>协议就提供优质的地址动态解析服务，让<code>32</code>位的<code>IP</code>地址能<code>映射</code>成为48位的<code>MAC地址</code>，让上层应用与底层完全分离开，这样子在上层应用就能灵活使用<code>IP</code>地址作为标识，进行通信。</p><p>简单来说，就是计算机中会维护一个ARP缓存表，这个表记录着IP地址与MAC地址的映射关系，我们可以通过在电脑的控制台通过arp -a指令查看一下我们自己计算机的ARP缓存表：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-6.png" alt="tcpip-6"></p><p>我给大家举个例子，IP地址就相当于你家的地址，MAC就是你的身份证，你的身份证是全国唯一的，这没疑问吧，但你的地址是可以跟别人重叠的（你家人也是住在你家）。当你寄快递的时候，快递员要确认这个快递是从你家寄出去的，是你本人亲自寄出去的，同样的，当你收快递的时候，快递员也是先电话找到你，然后必须是你本人才能拿到快递，再拿回家。（可能也不贴切，将就理解一下）</p><h2 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h2><p>链路层的主体部分是网卡中实现的，在发送的数据帧的时候，协议栈取得由高层传递过来的数据报（注意，数据帧与数据报不是一个东西，数据报是形容网络层及其以上的报文，而数据帧一般形容链路层的数据，是一帧一帧的，也是链路层的服务——数据成帧），在链路层中封装该数据报，也就是填写数据帧的各个字段，然后遵循链路接入协议将该帧数据进行传输；在接收端，控制器接收了整个数据帧，抽取出网络层的数据报，往上层传递。<br>下面来看看以太网帧：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-7.png" alt="tcpip-7"></p><p>一看这个以太网帧结构，就觉得它有7个字段，但是事实上，前同步码与帧开始符字段不能算是真正的以太网帧数据结构，他们是在网卡发送的时候自动添加进去的，为了数据的准确传输。</p><p>以太网帧以一个7字节的前同步码开始。该前同步码的值都是规定为<code>10101010</code>；而后紧接着一个字节的帧开始符，其值是<code>10101011</code>。前同步码字段的作用是实现物理层帧输入输出的同步，而帧开始符表示着以太网数据帧的开始，剩下的5个字段才是真正的以太网数据帧结构。 </p><p><strong>目标MAC地址（6字节）</strong>：这个字段包含目标网卡的MAC地址，当一个网卡收到一个以太网数据帧，如果该数据帧的目标地址是网卡自身的MAC地址或者是MAC广播地址，它都将该帧的数据字段的内容传递给网络层；如果它收到了具有任何其他MAC地址的帧，则将该数据帧丢弃。<br><strong>源MAC地址（6字节）</strong>：自身的MAC地址。<br><strong>类型字段（2字节）</strong>：类型字段允许以太网复用多种网络层协议。我们只需要记住主机能够使用除了<code>IP协议</code>以外的其他网络层协议。事实上，一台给定的主机可以支持多种网络层协议，以对不同的应用采用不同的协议。因此，当以太网帧到达网卡中，网卡需要知道它应该将数据字段的内容传递给哪个网络层协议。比如如有<code>IP</code>协议、<code>ARP</code>协议等。</p><p><code>注意了：当这个字段的值小于1518时，它表示后面数据字段的数据长度，当大于1518的时候才表示递交给哪个协议。</code></p><p><strong>数据字段（46~1500字节）</strong>：这个字段承载了IP数据报。以太网的最大传输单元（MTU）是1500字节。这意味着如果IP数据报超过了<code>1500</code>字节，则主机必须将该数据报分片（<code>IPv4</code>支持数据报分片，而<code>IPv6</code>不支持）。数据字段的最小长度是46字节，这意味着如果IP数据报小于<code>46</code>字节，数据报必须被填充到<code>46</code>字节。当采用填充时，传递到网络层的数据包括IP数据报和填充部分，网络层使用<code>IP</code>数据报首部中的长度字段来去除填充部分。<br><strong>CRC（4字节）</strong>：CRC字段包含了以太网的差错校验信息。<br><strong>补充</strong>：所有的以太网都向网络层提供不可靠的无连接服务，在接收到不对的以太网帧时，或者<code>CRC</code>校验不通过时，主机将直接丢弃以太网帧，并不会告知发送的一方。</p><p>未完待续…..<br>下一篇进入<code>协议篇</code></p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> TCP/IP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> 网络 </tag>
            
            <tag> LwIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP协议栈扫盲班</title>
      <link href="/tcpip-1/"/>
      <url>/tcpip-1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文的东西是基础理论知识，因此不必记住，前面的操作系统的文章我不想更新了，现在想写一写网络相关的文章，本篇文章是第一篇，仅传递网络相关知识的概念，不必牢记~</p><h1 id="什么是TCP-IP协议"><a href="#什么是TCP-IP协议" class="headerlink" title="什么是TCP/IP协议"></a>什么是TCP/IP协议</h1><p>简单来说TCP/IP协议是网络中所有相关协议簇的简称，它是众多网络协议的集合，这一类协议簇是有非常多的协议，如常见的:<code>ARP/TCP/UDP/IP/ICMP/IGMP/HTTP/DNS/DHCP/TFP/MQTT</code>等等</p><h1 id="分层思想"><a href="#分层思想" class="headerlink" title="分层思想"></a>分层思想</h1><p><code>TCP/IP</code>模型是一个抽象的分层模型，这个模型中，所有的<code>TCP/IP</code>系列网络协议都被归类到4个抽象的”层”中。每一抽象层创建在低一层提供的服务上，并且为高一层提供服务。 完成一些特定的任务需要众多的协议协同工作，这些协议分布在参考模型的不同层中的，因此有时称它们为一个协议栈。<br>网络协议通常分不同层次进行开发，每一层分别负责不同的通信功能。一个协议族，比如<code>TCP/IP</code>，是一组不同层次上的多个协议的组合。<code>TCP/IP</code>通常被认为是一个四层协议系统，其分层模型如下：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-1.png" alt="tcpip-1"></p><p>每一层都负责不同的功能。</p><h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><p>也称作数据链路层或网络接口层，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>有时也称作互联网层，处理数据报在网络中的活动，例如数据报路由。其中网络层协议包括<code>IP</code>协议（网际协议）， <code>ICMP</code>协议（互联网控制报文协议），以及<code>IGMP</code>协议（英特网组管理协议）。</p><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>运输层主要为两台主机上的应用程序提供端到端的通信。在<code>TCP/IP</code>协议族中，有两个传输层协议： TCP（传输控制协议）和UDP（用户数据报协议）。TCP为两台主机提供<code>高可靠性</code>的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的<code>网络层</code>，同时还要确认接收到的数据是正确的，并且将其组装成有序的数据递交到应用层，同时还要处理超时重传、流量控制等。由于运输层提供了高可靠性的端到端的通信，因此应用层可以更加方便来处理数据。<br>而另一方面，<code>UDP</code>则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端，因此数据的可靠性必须由应用层来提供，这就导致应用层处理程序的困难，但是对于数据要求不可靠的传输通常使用UDP协议，如视频的播放等。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层就是用户程序，不同的应用会有不一样的操作</p><h3 id="运行在TCP协议上的应用程序协议："><a href="#运行在TCP协议上的应用程序协议：" class="headerlink" title="运行在TCP协议上的应用程序协议："></a>运行在TCP协议上的应用程序协议：</h3><p><strong>HTTP</strong>（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。<br><strong>HTTPS</strong>（Hypertext Transfer Protocol over Secure Socket Layer, or HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。<br><strong>FTP</strong>（File Transfer Protocol，文件传输协议），由名知义，用于文件传输。<br><strong>POP3</strong>（Post Office Protocol, version 3，邮局协议），收邮件用。<br><strong>SMTP</strong>（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。<br><strong>SSH</strong>（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。</p><h3 id="运行在UDP协议上的应用程序协议："><a href="#运行在UDP协议上的应用程序协议：" class="headerlink" title="运行在UDP协议上的应用程序协议："></a>运行在UDP协议上的应用程序协议：</h3><p><strong>BOOTP</strong>（Boot Protocol，启动协议），应用于无盘设备。<br><strong>NTP</strong>（Network Time Protocol，网络时间协议），用于网络同步。<br><strong>DHCP</strong>（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。</p><h3 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h3><p><strong>DNS</strong>（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作（运行在TCP和UDP协议上）。<br><strong>ECHO</strong>（Echo Protocol，回绕协议），用于查错及测量应答时间（运行在TCP和UDP协议上）。<br><strong>SNMP</strong>（Simple Network Management Protocol，简单网络管理协议），用于网络信息的收集和网络管理。<br><strong>ARP</strong>（Address Resolution Protocol，地址解析协议），用于动态解析以太网硬件的地址。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-2.png" alt="tcpip-2"></p><p>提示：图中的RARP是基本不怎么使用的协议</p><h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><p>为了标识互联网中的每台主机的身份，设计人员为每个接入网络中的主机都分配一个<code>IP</code>地址（<code>Internet Protocol Address</code>），是一个<code>32</code>位的整数地址，只有合法的<code>IP</code>地址才能接入互联网中并且与其他主机进行通信。注意了：<code>IP</code>地址是软件地址，是协议栈中识别主机身份的唯一标识。如果IP地址是不合法的，那么无法连接上公网（或者称为广域网）。</p><h2 id="IP分类编址"><a href="#IP分类编址" class="headerlink" title="IP分类编址"></a>IP分类编址</h2><p>互联网上的每个接口必须有一个唯一的IP地址, IP地址长 32bit,IP地址并不采用平面形式的地址空间，如 1、2、3等。 IP地址具有一定的结构，有五类不同的互联网地址格式:</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-3.png" alt="tcpip-3"></p><p><strong>A</strong> 类网络地址的第一个字节的第一位必须为0 ，因此， A 类网络地址第一个字节的取值范围<code>为0~127</code>（注意：但0 和127 不是有效的A 类网络地址号）<br><strong>B</strong> 类网络地址的第一个字节的第一位必须为1 ，且第二位必须为0，因此， B 类网络地址第一个字节的取值范围为<code>128~191</code><br><strong>C</strong> 类网络地址的第一个字节的第一位必须为1，第二位必须为1，第三位必须为0，因此C类网络第一个字节的取值范围为<code>192~223</code><br><strong>D</strong> 类IP地址的第一个字节前四位为<code>1110</code>，那么它第一个字节的取值范围为<code>224~239</code>，约占据了所有IP地址的十六分之一，它是一个专门保留的地址，它并不指向特定的网络，目前这一类地址被用于多播。<br><strong>E</strong> 类IP地址的第一个字节前四位必须为<code>1111</code>，那么它第一个字节的取值范围为<code>240~255</code>，约占据了所有IP地址的十六分之一，是为将来使用而保留的，其中32bit全为1的IP地址（255.255.255.255）用作广播地址。</p><p>IP地址特点<br>|类别|第一字节(二进制)|第一字节取值范围|网络号个数|主机号个数|适用范围|<br>|—|—|—|—|—|—|<br>|A类 |0XXX XXXX    |0<del>127     |125      |16777214    |大型网络|<br>|B类    |10XX XXXX    |128</del>191 |16368      |65534    |中型网络|<br>|C类    |110X XXXX    |192<del>223 |2097152 |254        |小型网络|<br>|D类    |1110 XXXX    |224</del>239 |—          |—        |多播|<br>|E类    |1111 XXXX    |240~255 |—          |—        |保留|</p><h2 id="局域网的概念"><a href="#局域网的概念" class="headerlink" title="局域网的概念"></a>局域网的概念</h2><p>局域网（<code>Local Area Network</code>，缩写为<code>LAN</code>），又称内网，指覆盖局部区域（如办公室或楼层）的计算机网络，局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能，是在一定区域内由多个计算机连接组成的网络，比如腾讯、阿里的内网，在内部的计算机上的数据可以互联互通、数据共享等。简单来说，当我们使用的开发板接入路由器的时候，电脑的网络也接入路由器，那么开发板与电脑就组成局域网，数据在链路层上是互联互通的。当然，板子也能通过网线直连电脑，这样子也是组成一个局域网络，数据可以在两个主机之间进行通信。</p><h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><p>广域网（<code>Wide Area Network</code>，缩写为<code>WAN</code>），又称广域网、外网（与翻墙的外网是不一样的概念）、公网。是连接不同地区计算机以进行通信的网络，这种网络通常会跨越很大的范围，覆盖的范围从几十公里到几千公里，它能连接多个地区、城市并能提供远距离通信服务，但是注意的是我们说的广域网并不等同于互联网。<br>简单来说（我使用比喻的方式表达），如果局域网是小溪，不同区域有很多的小溪，这些小溪汇聚成江河，那么这些江河就是广域网，然后这些江河再流入大海，这个大海就是互联网。互联网就是由无数个局域网，通过广域网线路汇聚互联起来，就形成了互联网。互联网的特点是开放、互联，如果一个公司的局域网没有连接到互联网，那这个局域网就不属于互联网，仅仅属于内部通信的网络。<br>举个例子，如果你家在某网络运营商办理了网络服务，可能他们将送你一个光猫，然后你拿着这个光猫就能上网了，你可能觉得需要多人使用网络，所以你又去买了一个无线路由器，让家人也能连接到网络上，那么这个家就是一个局域网，然后局域网的通信是通过运营商连接到广域网上的。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/tcpip-4.png" alt="tcpip-4"></p><p>这个示意图虽然简单，却把<code>LAN、WAN、Internet</code>三者全包含了。无线路由器把电脑、手机等设备连接到局域网<code>LAN</code>上，并分配IP地址，即局域网<code>IP</code>，我们可以称之为<code>LAN-IP</code>，<code>LAN-IP</code>所到之处，就是局域网的范围，像我们电脑的IP地址<code>（192.168.1.xxx）</code>就是一个局域网<code>IP</code>，而路由器的地址就是运营商给我们的一个<code>IP</code>地址，这个IP地址是绝对合法的，可以看做是<code>WAN-IP</code>（实际上这个<code>IP</code>地址也是运营商的局域网IP地址（相对运营商来说），这个地址在运营商中转换成一个真正的广域网<code>IP</code>地址，因为真正的IP地址是不够的，只能再细分下去，但是这些事情我们暂时<code>无需理会</code>，只要把路由器的IP地址看做是<code>WAN-IP</code>即可）。<br>而运营商是一个边界，国家与国家之间有边界，网络之间也有边界，运营商就是局域网<code>LAN</code>与广域网<code>WAN</code>的边界。局域网<code>LAN-IP</code>可以在局域网内部有效，但是无法跨越边界进入广域网中，LAN-IP是路由器分配给我们的IP，那么我们想要跨越边界进入广域网中，就需要将LAN-IP变成有效的的IP地址，也就是<code>WAN-IP</code>，那么在路由器中就需要将IP地址进行转换，完成<code>LAN-IP&lt;—&gt;WAN-IP</code>地址转换（<code>NAT</code>）。<br>当持有<code>WAN-IP</code>的IP包顺利到达下一个边界<code>Internet Gateway</code>，这是通往互联网<code>Internet</code>的最后一道关卡，即边界。左边是广域网，右边是互联网，也需要做<code>WAN-IP 与 Global-IP</code>（互联网公共IP）的转换才能进入互联网中，我们知道这种概念即可，无需过多深入。</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> TCP/IP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> 网络 </tag>
            
            <tag> LwIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TencentOS  tiny】深度源码分析（8）——软件定时器</title>
      <link href="/tencentos-tiny-10/"/>
      <url>/tencentos-tiny-10/</url>
      
        <content type="html"><![CDATA[<h1 id="软件定时器的基本概念"><a href="#软件定时器的基本概念" class="headerlink" title="软件定时器的基本概念"></a>软件定时器的基本概念</h1><p>TencentOS tiny 的软件定时器是由操作系统提供的一类<code>系统接口</code>，它构建在硬件定时器基础之上，使系统能够提供不受硬件定时器资源限制的定时器服务，本质上软件定时器的使用相当于扩展了定时器的数量，允许创建更多的定时业务，它实现的功能与硬件定时器也是类似的。</p><blockquote><p>硬件定时器是芯片本身提供的定时功能。一般是由外部晶振提供给芯片输入时钟，芯片向软件模块提供一组配置寄存器，接受控制输入，到达设定时间值后芯片中断控制器产生时钟中断。硬件定时器的精度一般很高，可以达到纳秒级别，并且是中断触发方式。</p></blockquote><p>软件定时器的超时处理是指：在定时时间到达之后就会自动触发一个超时，然后系统跳转到对应的函数去处理这个超时，此时，调用的函数也被称<code>回调函数</code>。</p><p>回调函数的执行环境可以是<code>中断</code>，也可以是<code>任务</code>，这就需要你自己在<code>tos_config.h</code>通过<code>TOS_CFG_TIMER_AS_PROC</code>宏定义选择回调函数的执行环境了。</p><ul><li><code>TOS_CFG_TIMER_AS_PROC  为 1</code> ：回调函数的执行环境是<code>中断</code></li><li><code>TOS_CFG_TIMER_AS_PROC  为 0</code> ：回调函数的执行环境是<code>任务</code></li></ul><p>这与硬件定时器的中断服务函数很类似，无论是在中断中还是在任务中，回调函数的处理尽可能<code>简短，快进快出</code>。</p><p>软件定时器在被创建之后，当经过设定的超时时间后会触发回调函数，定时精度与系统时钟的周期有关，一般可以采用SysTick作为软件定时器的时基（在<code>m核</code>单片机中几乎都是采用SysTick作为系统时基，而软件定时器又是基于系统时基之上）。</p><p><code>TencentOS tiny</code>提供的软件定时器支持单次模式和周期模式，单次模式和周期模式的定时时间到之后都会调用软件定时器的回调函数。</p><ul><li><p><code>单次模式</code>：当用户创建了定时器并启动了定时器后，指定超时时间到达，只执行<code>一次</code>回调函数之后就将该定时器停止，不再重新执行。</p></li><li><p><code>周期模式</code>：这个定时器会按照指定的定时时间循环执行回调函数，直到将定时器删除。</p></li></ul><blockquote><p>在很多应用中，可能需要一些定时器任务，硬件定时器受硬件的限制，数量上不足以满足用户的实际需求，无法提供更多的定时器，可以采用软件定时器，由软件定时器代替硬件定时器任务。但需要注意的是软件定时器的精度是无法和硬件定时器相比的，因为在软件定时器的定时过程中是极有可能被其他中断打断，因此软件定时器更适用于对时间精度要求不高的任务。</p></blockquote><p>软件定时器以<code>tick</code>为基本计时单位，当用户创建并<code>启动</code>一个软件定时器时， <code>TencentOS tiny</code>会根据当前系统<code>tick</code>与用户指定的超时时间计算出该定时器超时的时间expires，并将该定时器插入软件定时器列表。</p><h1 id="软件定时器的数据结构"><a href="#软件定时器的数据结构" class="headerlink" title="软件定时器的数据结构"></a>软件定时器的数据结构</h1><blockquote><p>以下软件定时器的相关数据结构都在<code>tos_global.c</code>中定义</p></blockquote><h2 id="软件定时器列表"><a href="#软件定时器列表" class="headerlink" title="软件定时器列表"></a>软件定时器列表</h2><p>软件定时器列表用于记录系统中所有的软件定时器，这些软件定时器将按照唤醒时间升序插入软件定时器列表<code>k_timer_ctl.list</code> 中，它的数据类型是<code>timer_ctl_t</code>。</p><pre class="line-numbers language-js"><code class="language-js">timer_ctl_t         k_timer_ctl <span class="token operator">=</span> <span class="token punctuation">{</span> TOS_TIME_FOREVER<span class="token punctuation">,</span> <span class="token function">TOS_LIST_NODE</span><span class="token punctuation">(</span>k_timer_ctl<span class="token punctuation">.</span>list<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>typedef struct timer_control_st <span class="token punctuation">{</span>    k_tick_t    next_expires<span class="token punctuation">;</span>    k_list_t    list<span class="token punctuation">;</span><span class="token punctuation">}</span> timer_ctl_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>next_expires</code>：记录下一个到期的软件定时器时间。</li><li><code>list</code>：软件定时器列表，所有的软件定时器都会被挂载到这个列表中。</li></ul><h2 id="软件定时器任务相关的数据结构"><a href="#软件定时器任务相关的数据结构" class="headerlink" title="软件定时器任务相关的数据结构"></a>软件定时器任务相关的数据结构</h2><p>如果 <code>TOS_CFG_TIMER_AS_PROC</code> 宏定义为0，则表示使用软件定时器任务处理软件定时器的回调函数，那么此时软件定时器的回调函数执行环境为任务；反之软件定时器回调函数的处理将在中断上下文环境中。</p><pre class="line-numbers language-js"><code class="language-js">k_task_t            k_timer_task<span class="token punctuation">;</span>k_stack_t           k_timer_task_stk<span class="token punctuation">[</span>TOS_CFG_TIMER_TASK_STK_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>k_prio_t            <span class="token keyword">const</span> k_timer_task_prio         <span class="token operator">=</span> TOS_CFG_TIMER_TASK_PRIO<span class="token punctuation">;</span>k_stack_t          <span class="token operator">*</span><span class="token keyword">const</span> k_timer_task_stk_addr     <span class="token operator">=</span> <span class="token operator">&amp;</span>k_timer_task_stk<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>size_t              <span class="token keyword">const</span> k_timer_task_stk_size     <span class="token operator">=</span> TOS_CFG_TIMER_TASK_STK_SIZE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>k_timer_task</code>：软件定时器任务控制块</li><li><code>k_timer_task_stk</code>：软件定时器任务栈，其大小为<code>TOS_CFG_TIMER_TASK_STK_SIZE</code></li><li><code>k_timer_task_prio</code>：软件定时器任务优先级，值为<code>TOS_CFG_TIMER_TASK_PRIO</code>，默认值是 <code>(k_prio_t)(K_TASK_PRIO_IDLE - (k_prio_t)1u)</code>，比空闲任务高<code>1</code>个数值优先级，杰杰认为这也是很低的优先级了，这样一来软件定时器的精度将更低，不过好在这个值是可以被用户自定义的，想让精度高一点就将这个软件定时器任务优先级设置得高一点就好。</li><li>k_timer_task_stk_addr：软件定时器任务栈起始地址。</li><li>k_timer_task_stk_size：软件定时器任务栈大小。</li></ul><blockquote><p>以下软件定时器的相关数据结构都在<code>tos_timer.h</code>中定义</p></blockquote><h2 id="软件定时器的回调函数"><a href="#软件定时器的回调函数" class="headerlink" title="软件定时器的回调函数"></a>软件定时器的回调函数</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 软件定时器的回调函数类型</span>typedef <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>k_timer_callback_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>软件定时器的回调函数是一个函数指针的形式，它支持传入一个<code>void指针</code>类型的数据。</p><h2 id="软件定时器控制块"><a href="#软件定时器控制块" class="headerlink" title="软件定时器控制块"></a>软件定时器控制块</h2><p>每个软件定时器都有对应的软件定时器控制块，每个软件定时器控制块都包含了软件定时器的基本信息，如软件定时器的状态、软件定时器工作模式、软件定时器的周期，剩余时间，以及软件定时器回调函数等信息。</p><pre class="line-numbers language-js"><code class="language-js">typedef struct k_timer_st <span class="token punctuation">{</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    knl_obj_t               knl_obj<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**&lt; 仅为了验证,测试当前内核对象是否真的是一个软件定时器 */</span>#endif    k_timer_callback_t      cb<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/**&lt; 时间到时回调函数 */</span>    <span class="token keyword">void</span>                   <span class="token operator">*</span>cb_arg<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/**&lt; 回调函数中传入的参数 */</span>    k_list_t                list<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/**&lt; 挂载到软件定时器列表的节点 */</span>    k_tick_t                expires<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**&lt; 距离软件定时器的到期时间到期还剩多少时间（单位为tick） */</span>    k_tick_t                delay<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/**&lt; 还剩多少时间运行第一个到期的软件定时器（的回调函数） */</span>    k_tick_t                period<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/**&lt; 软件定时器的周期 */</span>    k_opt_t                 opt<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**&lt; 软件定时器的工作模式选项，可以是单次模式TOS_OPT_TIMER_ONESHOT，也可以是周期模式TOS_OPT_TIMER_PERIODIC */</span>    timer_state_t           state<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/**&lt; 软件定时器的状态 */</span><span class="token punctuation">}</span> k_timer_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="软件定时器的工作模式"><a href="#软件定时器的工作模式" class="headerlink" title="软件定时器的工作模式"></a>软件定时器的工作模式</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// if we just want the timer to run only once, this option should be passed to tos_timer_create.</span>#define TOS_OPT_TIMER_ONESHOT                   <span class="token punctuation">(</span>k_opt_t<span class="token punctuation">)</span><span class="token punctuation">(</span>0x0001u<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// if we want the timer run periodically, this option should be passed to tos_timer_create.</span>#define TOS_OPT_TIMER_PERIODIC                  <span class="token punctuation">(</span>k_opt_t<span class="token punctuation">)</span><span class="token punctuation">(</span>0x0002u<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>TOS_OPT_TIMER_ONESHOT</code>：<strong>单次</strong>模式，软件定时器在超时后，只会执行一次回调函数，它的状态将被设置为<code>TIMER_STATE_COMPLETED</code>，不再重新执行它的回调函数，当然，用户还是可以重新启动这个单次模式的软件定时器，它并未被删除。</p><blockquote><p>如果只希望计时器运行一次，则应将此选项传递给<code>tos_timer_create()</code>。</p></blockquote></li><li><p>TOS_OPT_TIMER_PERIODIC ：<strong>周期</strong>模式 ，软件定时器在超时后，会执行对应的回调函数，同时根据软件定时器控制块中的<code>period</code>成员变量的值再重新插入软件定时器列表中，这个定时器会按照指定的定时时间循环执行（周期性执行）回调函数，直到用户将定时器删除。</p><blockquote><p>如果我们希望计时器周期运行，则应将此选项传递给<code>tos_timer_create()</code>。</p></blockquote></li></ul><h2 id="软件定时器的状态"><a href="#软件定时器的状态" class="headerlink" title="软件定时器的状态"></a>软件定时器的状态</h2><p>定时器状态有以下几种：</p><pre class="line-numbers language-js"><code class="language-js">typedef <span class="token keyword">enum</span> timer_state_en <span class="token punctuation">{</span>    TIMER_STATE_UNUSED<span class="token punctuation">,</span>     <span class="token comment" spellcheck="true">/**&lt; the timer has been destroyed */</span>    TIMER_STATE_STOPPED<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/**&lt; the timer has been created but not been started, or just be stopped(tos_timer_stop) */</span>    TIMER_STATE_RUNNING<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/**&lt; the timer has been created and been started */</span>    TIMER_STATE_COMPLETED   <span class="token comment" spellcheck="true">/**&lt; the timer has finished its expires, it can only happen when the timer's opt is TOS_OPT_TIMER_ONESHOT */</span><span class="token punctuation">}</span> timer_state_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>TIMER_STATE_UNUSED</code>：未使用状态。</p></li><li><p><code>TIMER_STATE_STOPPED</code>：<code>创建</code>了软件定时器，但此时软件定时器<code>未启动</code>或者处于<code>停止</code>状态，调用<code>tos_timer_create()</code>函数接口或者在软件定时器启动后调用<code>tos_timer_stop()</code>函数接口后，定时器将变成该状态。</p></li><li><p><code>TIMER_STATE_RUNNING</code>：软件定时器处于运行状态，在定时器被<code>创建</code>后调用<code>tos_timer_start()</code>函数接口，定时器将变成该状态，表示定时器运行时的状态。</p></li><li><p><code>TIMER_STATE_COMPLETED</code>：软件定时器已到期，只有在软件定时器的模式选择为<code>TOS_OPT_TIMER_ONESHOT</code>时才可能发生，表示软件定时器已经完成了。</p></li></ul><h1 id="创建软件定时器"><a href="#创建软件定时器" class="headerlink" title="创建软件定时器"></a>创建软件定时器</h1><p><strong>函数</strong></p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_timer_create</span><span class="token punctuation">(</span>k_timer_t <span class="token operator">*</span>tmr<span class="token punctuation">,</span>                                 k_tick_t delay<span class="token punctuation">,</span>                                 k_tick_t period<span class="token punctuation">,</span>                                 k_timer_callback_t callback<span class="token punctuation">,</span>                                 <span class="token keyword">void</span> <span class="token operator">*</span>cb_arg<span class="token punctuation">,</span>                                 k_opt_t opt<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参数</strong></p><table><thead><tr><th>参数</th><th>说明（杰杰）</th></tr></thead><tbody><tr><td>tmr</td><td>软件定时器控制块指针</td></tr><tr><td>delay</td><td>软件定时器第一次运行的延迟时间间隔</td></tr><tr><td>period</td><td>软件定时器的周期</td></tr><tr><td>callback</td><td>软件定时器的回调函数，在超时时调用（由用户自己定义）</td></tr><tr><td>cb_arg</td><td>用于回调函数传入的形参（void指针类型）</td></tr><tr><td>opt</td><td>软件定时器的工作模式（单次 / 周期）</td></tr></tbody></table><blockquote><p>杰杰觉得 <code>delay</code>与 <code>period</code> 比较有意思，就简单提一下 <code>delay</code> 参数与 <code>period</code> 参数的意义与区别：</p><ul><li><code>delay</code>参数其实是第一次运行的延迟时间间隔（即第一次调用回调函数的时间），如果软件定时器是单次模式，那么只用 <code>delay</code> 参数作为软件定时器的回调时间，因为软件定时器是单次工作模式的话，只会运行一次回调函数，那么就没有周期一说（<code>period</code> 参数将不起作用），只能是以第一次运行的延迟时间间隔作为它的回调时间。</li><li><code>period</code> 参数则是作为软件定时器的周期性回调的时间间隔，就好比你的闹钟，每天 7 点叫你起床，但是<code>delay</code>参数在周期工作模式下的软件定时器也是有作用的，它是对第一次回调函数的延迟时间，举个例子：今天晚上<code>9</code>点的时候，你设置了一个闹钟，闹钟时间是每天早上<code>7</code>点的，那么在<code>10</code>个小时后，闹钟将叫你起床，那么这10个小时就相当于<code>delay</code>参数的值，因为闹钟第一次叫你起床并不是在<code>24</code>小时后，而在明天7点后，闹钟响了，此时闹钟将在一天后才会再响，这24小时则相当于 <code>period</code> 参数的值。</li></ul></blockquote><p>系统中每个软件定时器都有对应的软件定时器控制块，软件定时器控制块中包含了软件定时器的所有信息，那么可以想象一下，创建软件定时器的本质是不是就是对软件定时器控制块进行初始化呢？很显然就是这样子的。因为在后续对软件定时器的操作都是通过软件定时器控制块来操作的，如果控制块没有信息，那怎么能操作嘛~</p><p>步骤如下：</p><ol><li><p>判断传入的参数是否正确：软件定时器控制块不为<code>null</code>，回调函数不为<code>null</code>，如果是创建周期模式的软件定时器，那么 <code>period</code> 参数则不可以为<code>0</code>，而如果是单次模式的软件定时器，参数<code>delay</code>则不可以为<code>0</code>，无论是何种模式的软件定时器，<code>delay</code> 参数与 <code>period</code> 参数都不可以为<code>K_ERR_TIMER_PERIOD_FOREVER</code>，因为这代表着软件定时器不需要运行，那还创建个锤子啊。</p></li><li><p>根据传入的参数将软件定时器控制块的成员变量赋初值，软件定时器状态<code>state</code>被设置为<code>TIMER_STATE_STOPPED</code>，<code>expires</code> 则被设置为<code>0</code>，因为还尚未启动软件定时器。</p></li><li><p>调用<code>tos_list_init()</code>函数将软件定时器控制块中可挂载到<code>k_tick_list</code>列表的节点初始化。</p></li></ol><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_timer_create</span><span class="token punctuation">(</span>k_timer_t <span class="token operator">*</span>tmr<span class="token punctuation">,</span>                                 k_tick_t delay<span class="token punctuation">,</span>                                 k_tick_t period<span class="token punctuation">,</span>                                 k_timer_callback_t callback<span class="token punctuation">,</span>                                 <span class="token keyword">void</span> <span class="token operator">*</span>cb_arg<span class="token punctuation">,</span>                                 k_opt_t opt<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>opt <span class="token operator">==</span> TOS_OPT_TIMER_PERIODIC <span class="token operator">&amp;&amp;</span> period <span class="token operator">==</span> <span class="token punctuation">(</span>k_tick_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TIMER_INVALID_PERIOD<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>opt <span class="token operator">==</span> TOS_OPT_TIMER_ONESHOT <span class="token operator">&amp;&amp;</span> delay <span class="token operator">==</span> <span class="token punctuation">(</span>k_tick_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TIMER_INVALID_DELAY<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>opt <span class="token operator">!=</span> TOS_OPT_TIMER_ONESHOT <span class="token operator">&amp;&amp;</span> opt <span class="token operator">!=</span> TOS_OPT_TIMER_PERIODIC<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TIMER_INVALID_OPT<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>delay <span class="token operator">==</span> TOS_TIME_FOREVER<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TIMER_DELAY_FOREVER<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>period <span class="token operator">==</span> TOS_TIME_FOREVER<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TIMER_PERIOD_FOREVER<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token function">knl_object_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tmr<span class="token operator">-</span><span class="token operator">></span>knl_obj<span class="token punctuation">,</span> KNL_OBJ_TYPE_TIMER<span class="token punctuation">)</span><span class="token punctuation">;</span>#endif    tmr<span class="token operator">-</span><span class="token operator">></span>state          <span class="token operator">=</span> TIMER_STATE_STOPPED<span class="token punctuation">;</span>    tmr<span class="token operator">-</span><span class="token operator">></span>delay          <span class="token operator">=</span> delay<span class="token punctuation">;</span>    tmr<span class="token operator">-</span><span class="token operator">></span>expires        <span class="token operator">=</span> <span class="token punctuation">(</span>k_tick_t<span class="token punctuation">)</span>0u<span class="token punctuation">;</span>    tmr<span class="token operator">-</span><span class="token operator">></span>period         <span class="token operator">=</span> period<span class="token punctuation">;</span>    tmr<span class="token operator">-</span><span class="token operator">></span>opt            <span class="token operator">=</span> opt<span class="token punctuation">;</span>    tmr<span class="token operator">-</span><span class="token operator">></span>cb             <span class="token operator">=</span> callback<span class="token punctuation">;</span>    tmr<span class="token operator">-</span><span class="token operator">></span>cb_arg         <span class="token operator">=</span> cb_arg<span class="token punctuation">;</span>    <span class="token function">tos_list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tmr<span class="token operator">-</span><span class="token operator">></span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="销毁软件定时器"><a href="#销毁软件定时器" class="headerlink" title="销毁软件定时器"></a>销毁软件定时器</h1><p>软件定时器销毁函数是根据软件定时器控制块直接销毁的，销毁之后软件定时器的所有信息都会被清除，而且不能再次使用这个软件定时器，如果软件定时器处于运行状态，那么就需要将被销毁的软件定时器停止，然后再进行销毁操作。<br>其过程如下：</p><ol><li><p>判断软件定时器是否有效，然后根据软件定时器状态判断软件定时器是否创建，如果是未使用状态<code>TIMER_STATE_UNUSED</code>，则直接返回错误代码<code>K_ERR_TIMER_INACTIVE</code>。</p></li><li><p>如果软件定时器状态是 <code>运行</code>状态 <code>TIMER_STATE_RUNNING</code>，那么调用<code>timer_takeoff()</code>函数将软件定时器停止。</p></li><li><p>最后调用<code>timer_reset()</code>函数将软件定时器控制块的内容重置，主要是将软件定时器的状态设置为未使用状态<code>TIMER_STATE_UNUSED</code>，将对应的回调函数设置为<code>null</code>。</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_timer_destroy</span><span class="token punctuation">(</span>k_timer_t <span class="token operator">*</span>tmr<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><p>#if TOS_CFG_OBJECT_VERIFY_EN &gt; 0u<br>    if (!knl_object_verify(&amp;tmr-&gt;knl_obj, KNL_OBJ_TYPE_TIMER)) {<br>        return K_ERR_OBJ_INVALID;<br>    }<br>#endif</p><pre><code>if (tmr-&gt;state == TIMER_STATE_UNUSED) {    return K_ERR_TIMER_INACTIVE;}if (tmr-&gt;state == TIMER_STATE_RUNNING) {    timer_takeoff(tmr);}timer_reset(tmr);return K_ERR_NONE;</code></pre><p>}</p><pre><code># 停止软件定时器（内部函数）在销毁软件定时器的时候提到了`timer_takeoff()`函数，那么就来看看这个函数具体是怎么样停止软件定时器的，其实本质上就是将软件定时器从软件定时器列表中移除。&gt; 注意，这个函数是内部静态函数，不是给用户使用的，它与`tos_timer_stop()`不同。 1. 首先通过`TOS_LIST_FIRST_ENTRY`宏定义将软件定时器列表`k_timer_ctl.list`中的第一个软件定时器取出，因为防止软件定时器列表中的第一个软件定时器被移除了，而没有重置软件定时器列表中的相关的信息，因此此时要记录一下第一个软件定时器。 2. 调用`tos_list_del()`将软件定时器从软件定时器列表中移除，表示中国软件定时器就被停止了，因为不知软件定时器列表中，中国软件定时器也就不会被处理。 3. 判断一下移除的软件定时器是不是第一个软件定时器，如果是，则重置相关信息。如果软件定时器列表中不存在其他软件定时器，则将软件定时器列表的下一个到期时间设置为`TOS_TIME_FOREVER`，反正则让软件定时器列表的下一个到期时间为第二个软件定时器。```js__STATIC__ void timer_takeoff(k_timer_t *tmr){    TOS_CPU_CPSR_ALLOC();    k_timer_t *first, *next;    TOS_CPU_INT_DISABLE();    first = TOS_LIST_FIRST_ENTRY(&amp;k_timer_ctl.list, k_timer_t, list);    tos_list_del(&amp;tmr-&gt;list);    if (first == tmr) {        // if the first guy removed, we need to refresh k_timer_ctl.next_expires        next = TOS_LIST_FIRST_ENTRY_OR_NULL(&amp;tmr-&gt;list, k_timer_t, list);        if (!next) {            // the only guy removed            k_timer_ctl.next_expires = TOS_TIME_FOREVER;        } else {            k_timer_ctl.next_expires = next-&gt;expires;        }    }    TOS_CPU_INT_ENABLE();}</code></pre><h1 id="启动软件定时器"><a href="#启动软件定时器" class="headerlink" title="启动软件定时器"></a>启动软件定时器</h1><p>在创建成功软件定时器的时候，软件定时器的状态从<code>TIMER_STATE_UNUSED</code>（未使用状态）变成<code>TIMER_STATE_STOPPED</code>（创建但未启动 / 停止状态），创建完成的软件定时器是未运行的，用户在需要的时候可以启动它，TencentOS tiny提供了软件定时器启动函数<code>tos_timer_start()</code>。启动软件定时器的本质就是将软件定时器插入软件定时器列表<code>k_timer_ctl.list</code> 中，既然是这样子，那么很显然需要根据软件定时器的不同状态进行不同的处理。</p><p><strong>其实现过程如下</strong>：判断软件定时器控制块是否为<code>null</code>，然后判断软件定时器状态，如果为未使用状态<code>TIMER_STATE_UNUSED</code>则直接返回错误代码<code>K_ERR_TIMER_INACTIVE</code>；如果为已经运行状态<code>TIMER_STATE_RUNNING</code>，那么将软件定时器停止，然重新插入软件定时器列表<code>k_timer_ctl.list</code>中；如果是<code>TIMER_STATE_STOPPED</code>或者<code>TIMER_STATE_COMPLETED</code>状态，则将软件定时器的状态重新设置为运行状态<code>TIMER_STATE_RUNNING</code>，并且插入软件定时器列表<code>k_timer_ctl.list</code>中。</p><blockquote><p>注意：插入软件定时器列表的函数是<code>timer_place()</code>。</p></blockquote><blockquote><p><code>tos_timer_start()</code>函数将软件定时器控制块的<code>period</code>或者<code>delay</code>成员变量的值赋值给<code>expires</code>，但这个值是相对的到期时间，而不是绝对值，因此在<code>timer_place()</code>函数中将重新计算得出绝对的到期时间。</p></blockquote><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_timer_start</span><span class="token punctuation">(</span>k_timer_t <span class="token operator">*</span>tmr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">knl_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tmr<span class="token operator">-</span><span class="token operator">></span>knl_obj<span class="token punctuation">,</span> KNL_OBJ_TYPE_TIMER<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">==</span> TIMER_STATE_UNUSED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TIMER_INACTIVE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">==</span> TIMER_STATE_RUNNING<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">timer_takeoff</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span>        tmr<span class="token operator">-</span><span class="token operator">></span>expires <span class="token operator">=</span> tmr<span class="token operator">-</span><span class="token operator">></span>delay<span class="token punctuation">;</span>        <span class="token function">timer_place</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">==</span> TIMER_STATE_STOPPED <span class="token operator">||</span>        tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">==</span> TIMER_STATE_COMPLETED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">=</span> TIMER_STATE_RUNNING<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>delay <span class="token operator">==</span> <span class="token punctuation">(</span>k_tick_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>            tmr<span class="token operator">-</span><span class="token operator">></span>expires <span class="token operator">=</span> tmr<span class="token operator">-</span><span class="token operator">></span>period<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            tmr<span class="token operator">-</span><span class="token operator">></span>expires <span class="token operator">=</span> tmr<span class="token operator">-</span><span class="token operator">></span>delay<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">timer_place</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> K_ERR_TIMER_INVALID_STATE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="插入软件定时器列表"><a href="#插入软件定时器列表" class="headerlink" title="插入软件定时器列表"></a>插入软件定时器列表</h1><p>插入软件定时器列表的函数是<code>timer_place()</code>，这个函数会根据软件定时器的到期时间升序排序，然后再插入。</p><blockquote><p>该函数是一个内部实现的静态函数</p></blockquote><p>实现过程如下：</p><ol><li>根据软件定时器的到期时间<code>expires</code>（相对值） 与系统当前时间<code>k_tick_count</code>计算得出到期时间<code>expires</code>（绝对值）。<blockquote><p>举个例子，闹钟将在10分钟后叫我起床（这是一个<code>相对值</code>）。闹钟将在当前时间（7:00）的10分钟后叫我起床，那么闹钟响的时间是7:10分，此时的时间就是<code>绝对值</code>。</p></blockquote></li></ol><ol start="2"><li><p>通过for循环<code>TOS_LIST_FOR_EACH</code>找到合适的位置插入软件定时器列表，此时插入软件定时器列表安装到期时间升序插入。</p></li><li><p>找到合适的位置后，调用<code>tos_list_add_tail()</code>函数将软件定时器插入软件定时器列表。</p></li><li><p>如果插入的软件定时器是唯一定时器列表中的第一个，那么相应的，下一个到期时间就是这个软件定时器的到期时间，将到期时间更新： <code>k_timer_ctl.next_expires = tmr-&gt;expires</code>。如果<code>TOS_CFG_TIMER_AS_PROC</code> 宏定义为0，则判断一下软件定时器任务是否处于睡眠状态，如果是则调用<code>tos_task_delay_abort()</code>函数恢复软件定时器任务运行，以便于更新它休眠的时间，因为此时是需要更新软件定时器任务睡眠的时间的，毕竟第一个软件定时器到期时间已经改变了。</p></li><li><p>如果软件定时器任务处于挂起状态，表示并没有软件定时器在工作，现在插入了软件定时器，需要调用<code>tos_task_resume()</code>函数将软件定时器任务唤醒。</p></li></ol><blockquote><p>关于唤醒软件定时器任务是为了什么，我们在后续讲解</p></blockquote><pre class="line-numbers language-js"><code class="language-js">__STATIC__ <span class="token keyword">void</span> <span class="token function">timer_place</span><span class="token punctuation">(</span>k_timer_t <span class="token operator">*</span>tmr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_list_t <span class="token operator">*</span>curr<span class="token punctuation">;</span>    k_timer_t <span class="token operator">*</span>iter <span class="token operator">=</span> K_NULL<span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    tmr<span class="token operator">-</span><span class="token operator">></span>expires <span class="token operator">+</span><span class="token operator">=</span> k_tick_count<span class="token punctuation">;</span>    <span class="token function">TOS_LIST_FOR_EACH</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>k_timer_ctl<span class="token punctuation">.</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        iter <span class="token operator">=</span> <span class="token function">TOS_LIST_ENTRY</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> k_timer_t<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>expires <span class="token operator">&lt;</span> iter<span class="token operator">-</span><span class="token operator">></span>expires<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">tos_list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tmr<span class="token operator">-</span><span class="token operator">></span>list<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k_timer_ctl<span class="token punctuation">.</span>list<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token operator">&amp;</span>tmr<span class="token operator">-</span><span class="token operator">></span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// we are the first guy now</span>        k_timer_ctl<span class="token punctuation">.</span>next_expires <span class="token operator">=</span> tmr<span class="token operator">-</span><span class="token operator">></span>expires<span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_TIMER_AS_PROC <span class="token operator">==</span> 0u        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">task_state_is_sleeping</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>k_timer_task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">tos_task_delay_abort</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>k_timer_task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>#endif    <span class="token punctuation">}</span>#<span class="token keyword">if</span> TOS_CFG_TIMER_AS_PROC <span class="token operator">==</span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">task_state_is_suspended</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>k_timer_task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">tos_task_resume</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>k_timer_task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="停止软件定时器（外部函数）"><a href="#停止软件定时器（外部函数）" class="headerlink" title="停止软件定时器（外部函数）"></a>停止软件定时器（外部函数）</h1><blockquote><p>在前文也提及停止软件定时器，但是那个<code>timer_takeoff()</code>函数是内部函数，而<code>tos_timer_stop()</code>函数是外部函数，可以被用户使用。</p></blockquote><p>停止软件定时器的本质也是调用<code>timer_takeoff()</code>函数将软件定时器从软件定时器列表中移除，但是在调用这个函数之前还好做一些相关的判断，这样能保证系统的稳定性。</p><ol><li><p>对软件定时器控制块检测，如果软件定时器控制块为null，则直接返回错误代码。</p></li><li><p>如果软件定时器状态为未使用状态<code>TIMER_STATE_UNUSED</code>，则直接返回错误代码<code>K_ERR_TIMER_INACTIVE</code>。</p></li><li><p>如果软件定时器状态为<code>TIMER_STATE_COMPLETED</code> 或者是<code>TIMER_STATE_STOPPED</code>，则不需要停止软件定时器，因为这个软件定时器是未启动的。则直接返回错误代码<code>K_ERR_TIMER_STOPPED</code>。</p></li><li><p>如果软件定时器状态为<code>TIMER_STATE_RUNNING</code> ，就将软件定时器状态设置为停止状态<code>TIMER_STATE_STOPPED</code>，并且调用<code>timer_takeoff()</code>函数将软件定时器从软件定时器列表中移除。</p></li></ol><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_timer_stop</span><span class="token punctuation">(</span>k_timer_t <span class="token operator">*</span>tmr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">knl_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tmr<span class="token operator">-</span><span class="token operator">></span>knl_obj<span class="token punctuation">,</span> KNL_OBJ_TYPE_TIMER<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">==</span> TIMER_STATE_UNUSED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TIMER_INACTIVE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">==</span> TIMER_STATE_COMPLETED <span class="token operator">||</span>        tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">==</span> TIMER_STATE_STOPPED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TIMER_STOPPED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">==</span> TIMER_STATE_RUNNING<span class="token punctuation">)</span> <span class="token punctuation">{</span>        tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">=</span> TIMER_STATE_STOPPED<span class="token punctuation">;</span>        <span class="token function">timer_takeoff</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="软件定时器的处理（在中断上下文环境）"><a href="#软件定时器的处理（在中断上下文环境）" class="headerlink" title="软件定时器的处理（在中断上下文环境）"></a>软件定时器的处理（在中断上下文环境）</h1><p>我们知道，TencentOS tiny的软件定时器是可以在中断上下文环境来处理回调函数的，因此当软件定时器到期后，会在<code>tos_tick_handler()</code>函数中调用<code>timer_update()</code>来处理软件定时器。这个函数在每次tick中断到来的时候都会判断一下是否有软件定时器到期，如果有则去处理它。<br>过程如下：</p><ol><li><p>判断软件定时器的下一个到期时间<code>k_timer_ctl.next_expires</code>是否小于<code>k_tick_count</code>，如果是小于则表示还未到期，直接退出。</p></li><li><p>反之则表示到期，此时要<code>遍历</code>软件定时器列表，找到<code>所有</code>到期的软件定时器，并处理他们。</p></li></ol><blockquote><p>因为有可能不只是一个软件定时器到期，很可能有多个定时器到期。当然啦，当软件定时器没到期的时候就会退出遍历。</p></blockquote><ol start="3"><li><p>到期后的处理就是：调用<code>timer_takeoff()</code>函数将到期的软件定时器停止，如果是周期工作的定时器就调用<code>timer_place()</code>函数将它重新插入软件定时器列表中（它到期的相对时间就是软件定时器的周期值：<code>tmr-&gt;expires = tmr-&gt;period</code>）；如果是单次工作模式的软件定时器，就仅将软件定时器状态设置为<code>TIMER_STATE_COMPLETED</code>。</p></li><li><p>调用软件定时器的回调函数处理相关的工作：<code>(*tmr-&gt;cb)(tmr-&gt;cb_arg)</code></p></li></ol><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ <span class="token keyword">void</span> <span class="token function">timer_update</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    k_timer_t <span class="token operator">*</span>tmr<span class="token punctuation">;</span>    k_list_t <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k_timer_ctl<span class="token punctuation">.</span>next_expires <span class="token operator">&lt;</span> k_tick_count<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">tos_knl_sched_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_LIST_FOR_EACH_SAFE</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>k_timer_ctl<span class="token punctuation">.</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        tmr <span class="token operator">=</span> <span class="token function">TOS_LIST_ENTRY</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> k_timer_t<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>expires <span class="token operator">></span> k_tick_count<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// time's up</span>        <span class="token function">timer_takeoff</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>opt <span class="token operator">==</span> TOS_OPT_TIMER_PERIODIC<span class="token punctuation">)</span> <span class="token punctuation">{</span>            tmr<span class="token operator">-</span><span class="token operator">></span>expires <span class="token operator">=</span> tmr<span class="token operator">-</span><span class="token operator">></span>period<span class="token punctuation">;</span>            <span class="token function">timer_place</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">=</span> TIMER_STATE_COMPLETED<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">(</span><span class="token operator">*</span>tmr<span class="token operator">-</span><span class="token operator">></span>cb<span class="token punctuation">)</span><span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>cb_arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">tos_knl_sched_unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="软件定时器的处理（在任务上下文环境）"><a href="#软件定时器的处理（在任务上下文环境）" class="headerlink" title="软件定时器的处理（在任务上下文环境）"></a>软件定时器的处理（在任务上下文环境）</h1><blockquote><p>关于使用软件定时器任务处理回调函数（即回调函数执行的上下文环境是<code>任务</code>），则必须打开<code>TOS_CFG_TIMER_AS_PROC</code> 宏定义。</p></blockquote><h2 id="创建软件定时器任务"><a href="#创建软件定时器任务" class="headerlink" title="创建软件定时器任务"></a>创建软件定时器任务</h2><p>既然是软件定时器任务，那么就必须创建软件定时器任务，那么这个任务将在<code>timer_init()</code>函数中被创建，它是一个内核调用的函数，在内核初始化时就被调用（在<code>tos_knl_init()</code>函数中调用）。</p><blockquote><p>创建软件定时器任务也是跟创建其他任务没啥差别，都是通过<code>tos_task_create()</code>函数创建，软件定时器任务控制块、任务主体、优先级、任务栈起始地址与大小等都在<code>前面</code>的数据结构中指定了，任务的名字为”timer”。</p></blockquote><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ k_err_t <span class="token function">timer_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>#<span class="token keyword">if</span> TOS_CFG_TIMER_AS_PROC <span class="token operator">></span> 0u    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>#<span class="token keyword">else</span>    <span class="token keyword">return</span> <span class="token function">tos_task_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>k_timer_task<span class="token punctuation">,</span>                            <span class="token string">"timer"</span><span class="token punctuation">,</span>                            timer_task_entry<span class="token punctuation">,</span>                            K_NULL<span class="token punctuation">,</span>                            k_timer_task_prio<span class="token punctuation">,</span>                            k_timer_task_stk_addr<span class="token punctuation">,</span>                            k_timer_task_stk_size<span class="token punctuation">,</span>                            <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>#endif<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="软件定时器任务主体"><a href="#软件定时器任务主体" class="headerlink" title="软件定时器任务主体"></a>软件定时器任务主体</h2><p>软件定时器任务的主体也是一个<code>while (K_TRUE)</code>循环，在循环中处理对应的事情。</p><ol><li>调用<code>timer_next_expires_get()</code>函数获取软件定时器列表中的下一个到期时间，并且更新<code>next_expires</code> 的值。</li></ol><blockquote><p><code>注意</code>：这里的时间已经在函数内部转换为<code>相对</code>到期时间，比如10分钟后闹钟叫我起床，而不是7:10分闹钟叫我起床）</p></blockquote><ol start="2"><li>根据<code>next_expires</code>的值，判断一下软件定时器任务应该休眠多久，在多久后到期时才唤醒软件定时器任务并且处理回调函数。也就是说，软件定时器任务在软件定时器没有到期的时候是不会被唤醒的，都是处于休眠状态，调用<code>tos_task_delay()</code>函数将任务进入休眠状态，此时任务会被挂载到系统的<code>延时（时基）列表</code>中。</li></ol><blockquote><p><code>注意</code>：如果<code>next_expires</code>的值为<code>TOS_TIME_FOREVER</code>，则不是休眠而是直接挂起，因为挂起状态的任务对调度器而言是不可见的，这样子的处理效率更高~挂起任务的函数是<code>tos_task_suspend()</code>。</p></blockquote><ol start="3"><li><p>任务如果被唤醒了，或者被恢复运行了，则表明软件定时器到期了或者有新的软件定时器插入列表了，那么在唤醒之后就要判断一下是哪种情况，如果是到期了则处理对应的回调函数：首先调用<code>timer_takeoff()</code>函数将到期的软件定时器停止，如果是周期工作的定时器就调用<code>timer_place()</code>函数将它重新插入软件定时器列表中（它到期的相对时间就是软件定时器的周期值：<code>tmr-&gt;expires = tmr-&gt;period</code>）；如果是单次工作模式的软件定时器，就仅将软件定时器状态设置为<code>TIMER_STATE_COMPLETED</code>。（这里也是会<code>遍历</code>软件定时器列表以处理<code>所有</code>到期的软件定时器）</p></li><li><p>最后将调用软件定时器的回调函数处理相关的工作：<code>(*tmr-&gt;cb)(tmr-&gt;cb_arg)</code>。</p></li><li><p>如果定时器还未到期，并且软件定时器任务被唤醒了，那么就表示有新的软件定时器插入列表了，此时要更新一下任务的睡眠时间，因为软件定时器任务主体是一个<code>while</code>循环，还是会回到 <code>timer_next_expires_get()</code>函数中重新获取下一个唤醒任务的时间的。</p></li></ol><blockquote><p>注意：软件定时器的处理都是在锁调度器中处理的，就是为了避免其他任务打扰回调函数的执行。</p></blockquote><pre class="line-numbers language-js"><code class="language-js">__STATIC__ <span class="token keyword">void</span> <span class="token function">timer_task_entry</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">{</span>    k_timer_t <span class="token operator">*</span>tmr<span class="token punctuation">;</span>    k_list_t <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    k_tick_t next_expires<span class="token punctuation">;</span>    arg <span class="token operator">=</span> arg<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// make compiler happy</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>K_TRUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        next_expires <span class="token operator">=</span> <span class="token function">timer_next_expires_get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>next_expires <span class="token operator">==</span> TOS_TIME_FOREVER<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">tos_task_suspend</span><span class="token punctuation">(</span>K_NULL<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>next_expires <span class="token operator">></span> <span class="token punctuation">(</span>k_tick_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">tos_task_delay</span><span class="token punctuation">(</span>next_expires<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">tos_knl_sched_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">TOS_LIST_FOR_EACH_SAFE</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>k_timer_ctl<span class="token punctuation">.</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            tmr <span class="token operator">=</span> <span class="token function">TOS_LIST_ENTRY</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> k_timer_t<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>expires <span class="token operator">></span> k_tick_count<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// not yet</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// time's up</span>            <span class="token function">timer_takeoff</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>opt <span class="token operator">==</span> TOS_OPT_TIMER_PERIODIC<span class="token punctuation">)</span> <span class="token punctuation">{</span>                tmr<span class="token operator">-</span><span class="token operator">></span>expires <span class="token operator">=</span> tmr<span class="token operator">-</span><span class="token operator">></span>period<span class="token punctuation">;</span>                <span class="token function">timer_place</span><span class="token punctuation">(</span>tmr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                tmr<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">=</span> TIMER_STATE_COMPLETED<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token punctuation">(</span><span class="token operator">*</span>tmr<span class="token operator">-</span><span class="token operator">></span>cb<span class="token punctuation">)</span><span class="token punctuation">(</span>tmr<span class="token operator">-</span><span class="token operator">></span>cb_arg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">tos_knl_sched_unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="获取软件定时器下一个到期时间"><a href="#获取软件定时器下一个到期时间" class="headerlink" title="获取软件定时器下一个到期时间"></a>获取软件定时器下一个到期时间</h1><p><code>timer_next_expires_get()</code>就是用于获取软件定时器下一个到期时间，如果软件定时器到期时间是<code>TOS_TIME_FOREVER</code>，就返回<code>TOS_TIME_FOREVER</code>，如果下一个到期时间小于<code>k_tick_count</code>则直接返回0，表示已经到期了，可以直接处理它，而如果是其他值，则需要减去<code>k_tick_count</code>，将其转变为相对值，因为调用这个函数就是为了知道任务能休眠多少时间。</p><blockquote><p>打个比方，我7点醒来了，而7:10分的闹钟才会响，那么我就能再睡10分钟，就是这个道理。</p></blockquote><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ k_tick_t <span class="token function">timer_next_expires_get</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_tick_t next_expires<span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k_timer_ctl<span class="token punctuation">.</span>next_expires <span class="token operator">==</span> TOS_TIME_FOREVER<span class="token punctuation">)</span> <span class="token punctuation">{</span>        next_expires <span class="token operator">=</span> TOS_TIME_FOREVER<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k_timer_ctl<span class="token punctuation">.</span>next_expires <span class="token operator">&lt;=</span> k_tick_count<span class="token punctuation">)</span> <span class="token punctuation">{</span>        next_expires <span class="token operator">=</span> <span class="token punctuation">(</span>k_tick_t<span class="token punctuation">)</span>0u<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        next_expires <span class="token operator">=</span> k_timer_ctl<span class="token punctuation">.</span>next_expires <span class="token operator">-</span> k_tick_count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> next_expires<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台回复 “ 19 ” 获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> TencentOS tiny </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TencentOS tiny </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TencentOS  tiny】深度源码分析（7）——事件</title>
      <link href="/tencentos-tiny-9/"/>
      <url>/tencentos-tiny-9/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>大家在裸机编程中很可能经常用到<code>flag</code>这种变量，用来标志一下某个事件的发生，然后在循环中判断这些标志是否发生，如果是等待多个事件的话，还可能会<code>if((xxx_flag)&amp;&amp;(xxx_flag))</code>这样子做判断。当然，如果聪明一点的同学就会拿<code>flag</code>的<code>某些位</code>做标志，比如这个变量的第一位表示<code>A</code>事件，第二位表示<code>B</code>事件，当这两个事件都发生的时候，就判断<code>flag&amp;0x03</code>的值是多少，从而判断出哪个事件发生了。</p><p>但在操作系统中又将如何实现呢？</p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p><strong>在操作系统中，<code>事件</code>是一种内核资源，主要用于<code>任务与任务间、中断与任务间</code>的<code>同步</code>，<code>不提供</code>数据传输功能！</strong></p><p>与使用<code>信号量</code>同步有细微的差别：事件它可以实现一对多，多对多的同步。即一个任务可以等待多个事件的发生：可以是任意一个事件发生时唤醒任务进行事件处理；也可以是几个事件都发生后才唤醒任务进行事件处理。同样，也可以是多个任务同步多个事件。</p><p>每一个事件组只需要极少的<code>RAM</code>空间来保存事件旗标，一个<code>事件（控制块）</code>中包含了一个<code>旗标</code>，这个<code>旗标</code>的每一位表示一个“<code>事件</code>”，旗标存储在一个<code>k_event_flag_t</code>类型的变量中（名字叫<code>flag</code>，旗标简单理解就是<code>事件标记变量</code>），该变量在事件控制块中被定义，每一位代表一个事件，任务通过<code>“逻辑与”</code>或<code>“逻辑或”</code>与一个或多个事件建立关联，在事件发生时任务将被唤醒。</p><ul><li><p>事件“逻辑或”是<code>独立型同步</code>，指的是任务所等待的若干事件中任意一个事件发生即可被唤醒；</p><ul><li>事件“逻辑与”则是<code>关联型同步</code>，指的是任务所等待的若干事件中全部<code>都</code>发生时才被唤醒。</li></ul></li></ul><p>事件是一种实现任务间通信的机制，可用于实现任务间的同步，但事件无数据传输。多任务环境下，任务、中断之间往往需要同步操作，一个事件发生会告知等待中的任务，即形成一个任务与任务、中断与任务间的同步。</p><p>事件<code>无排队性</code>，即多次向任务设置同一事件(如果任务还未来得及读走)，等效于只设置一次。</p><p>此外事件可以提供一对多、多对多的同步操作。</p><ul><li><p><code>一对多</code>同步模型：一个任务等待多个事件的触发，这种情况是比较常见的；</p></li><li><p><code>多对多</code>同步模型：多个任务等待多个事件的触发，任务可以通过设置事件位来实现事件的触发和等待操作。</p></li></ul><h1 id="事件数据结构"><a href="#事件数据结构" class="headerlink" title="事件数据结构"></a>事件数据结构</h1><h2 id="事件控制块"><a href="#事件控制块" class="headerlink" title="事件控制块"></a>事件控制块</h2><p><code>TencentOS tiny</code> 通过事件控制块操作事件，其数据类型为<code>k_event_t</code>，事件控制块由多个元素组成。</p><ul><li><code>pend_obj</code>有点类似于面向对象的继承，继承一些属性，里面有描述内核资源的类型（如互斥锁、队列、互斥量等，同时还有一个等待列表<code>list</code>）。</li><li><code>flag</code>是旗标，一个32位的变量，因此每个事件控制块最多只能标识32个事件发生！<pre class="line-numbers language-js"><code class="language-js">typedef struct k_event_st <span class="token punctuation">{</span> pend_obj_t      pend_obj<span class="token punctuation">;</span> k_event_flag_t  flag<span class="token punctuation">;</span><span class="token punctuation">}</span> k_event_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="任务控制块与事件相关的数据结构"><a href="#任务控制块与事件相关的数据结构" class="headerlink" title="任务控制块与事件相关的数据结构"></a>任务控制块与事件相关的数据结构</h2><pre class="line-numbers language-js"><code class="language-js">typedef struct k_task_st <span class="token punctuation">{</span>    ···    k_opt_t             opt_event_pend<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/**&lt; 等待事件的的操作类型：TOS_OPT_EVENT_PEND_ANY 、 TOS_OPT_EVENT_PEND_ALL */</span>    k_event_flag_t      flag_expect<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**&lt; 期待发生的事件 */</span>    k_event_flag_t     <span class="token operator">*</span>flag_match<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/**&lt; 等待到的事件（匹配的事件） */</span>    ···<span class="token punctuation">}</span> k_task_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="与事件相关的宏定义"><a href="#与事件相关的宏定义" class="headerlink" title="与事件相关的宏定义"></a>与事件相关的宏定义</h2><p>在<code>tos_config.h</code>中，配置事件开关的宏定义是<code>TOS_CFG_EVENT_EN</code></p><pre class="line-numbers language-js"><code class="language-js">#define TOS_CFG_EVENT_EN            1u<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在<code>tos_event.h</code>中，存在一些宏定义是用于操作事件的（<code>opt选项</code>）：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// if we are pending an event, for any flag we expect is set is ok, this flag should be passed to tos_event_pend </span>#define TOS_OPT_EVENT_PEND_ANY          <span class="token punctuation">(</span>k_opt_t<span class="token punctuation">)</span><span class="token number">0x0001</span><span class="token comment" spellcheck="true">// if we are pending an event, must all the flag we expect is set is ok, this flag should be passed to tos_event_pend </span>#define TOS_OPT_EVENT_PEND_ALL          <span class="token punctuation">(</span>k_opt_t<span class="token punctuation">)</span><span class="token number">0x0002</span>#define TOS_OPT_EVENT_PEND_CLR          <span class="token punctuation">(</span>k_opt_t<span class="token punctuation">)</span><span class="token number">0x0004</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>TOS_OPT_EVENT_PEND_ANY</code>：任务在等待任意一个事件发生，即“逻辑或”！</li><li><code>TOS_OPT_EVENT_PEND_ALL</code>：任务在等待所有事件发生，即“逻辑与”！</li><li><code>TOS_OPT_EVENT_PEND_CLR</code>：清除等待到的事件旗标，可以与<code>TOS_OPT_EVENT_PEND_ANY</code>、<code>TOS_OPT_EVENT_PEND_ALL</code>混合使用（通过<code>“|”</code>运算符）。</li></ul><p>除此之外还有一个枚举类型的数据结构，用于发送事件时的选项操作，可以在发送事件时清除事件旗标的其他位（即覆盖，影响其他事件），也可以保持原本旗标中的其他位（不覆盖，不影响其他事件）。</p><pre class="line-numbers language-js"><code class="language-js">typedef <span class="token keyword">enum</span> opt_event_post_en <span class="token punctuation">{</span>    OPT_EVENT_POST_KEP<span class="token punctuation">,</span>    OPT_EVENT_POST_CLR<span class="token punctuation">,</span><span class="token punctuation">}</span> opt_event_post_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="创建事件"><a href="#创建事件" class="headerlink" title="创建事件"></a>创建事件</h1><p>系统中每个事件都有对应的事件控制块，事件控制块中包含了事件的所有信息，比如它的等待列表、它的资源类型，以及它的事件旗标值，那么可以想象一下，创建事件的本质是不是就是对事件控制块进行初始化呢？很显然就是这样子的。因为在后续对事件的操作都是通过事件控制块来操作的，如果控制块没有信息，那怎么能操作嘛~</p><p>创建事件函数是<code>tos_event_create()</code>，传入一个事件控制块的指针<code>*event</code>，除此之外还可以指定事件初始值<code>init_flag</code>。</p><p>事件的创建实际上就是调用<code>pend_object_init()</code>函数将事件控制块中的<code>event-&gt;pend_obj</code>成员变量进行初始化，它的资源类型被标识为<code>PEND_TYPE_EVENT</code>。然后将<code>event-&gt;flag</code>成员变量设置为事件旗标初始值<code>init_flag</code>。</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_event_create</span><span class="token punctuation">(</span>k_event_t <span class="token operator">*</span>event<span class="token punctuation">,</span> k_event_flag_t init_flag<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pend_object_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>event<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_EVENT<span class="token punctuation">)</span><span class="token punctuation">;</span>    event<span class="token operator">-</span><span class="token operator">></span>flag <span class="token operator">=</span> init_flag<span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="销毁事件"><a href="#销毁事件" class="headerlink" title="销毁事件"></a>销毁事件</h1><p>事件销毁函数是根据事件控制块直接销毁的，销毁之后事件的所有信息都会被清除，而且不能再次使用这个事件，当事件被销毁时，其等待列表中存在任务，系统有必要将这些等待这些任务唤醒，并告知任务事件已经被销毁了<code>PEND_STATE_DESTROY</code>。然后产生一次任务调度以切换到最高优先级任务执行。</p><p><code>TencentOS tiny</code> 对事件销毁的处理流程如下：</p><ol><li>调用<code>pend_is_nopending()</code>函数判断一下是否有任务在等待事件</li><li>如果有任务在等待事件则调用<code>pend_wakeup_all()</code>函数将这些任务唤醒，并且告知等待任务事件已经被销毁了（即设置任务控制块中的等待状态成员变量<code>pend_state</code>为<code>PEND_STATE_DESTROY</code>）。</li><li>调用<code>pend_object_deinit()</code>函数将事件控制块中的内容清除，最主要的是将控制块中的资源类型设置为<code>PEND_TYPE_NONE</code>，这样子就无法使用这个事件了。</li><li>将<code>event-&gt;flag</code>成员变量恢复为默认值<code>0</code>。</li><li>进行任务调度<code>knl_sched()</code></li></ol><p>注意：如果事件控制块的RAM是由<code>编译器静态分配</code>的，所以即使是销毁了事件，这个内存也是没办法释放的。当然你也可以使用动态内存为事件控制块分配内存，只不过在销毁后要将这个内存释放掉，避免内存泄漏。</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_event_destroy</span><span class="token punctuation">(</span>k_event_t <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>event<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_EVENT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_is_nopending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>event<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">pend_wakeup_all</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>event<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_STATE_DESTROY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pend_object_deinit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>event<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    event<span class="token operator">-</span><span class="token operator">></span>flag <span class="token operator">=</span> <span class="token punctuation">(</span>k_event_flag_t<span class="token punctuation">)</span>0u<span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="等待事件"><a href="#等待事件" class="headerlink" title="等待事件"></a>等待事件</h1><p><code>tos_event_pend()</code>函数用于获取事件，通过这个函数，就可以知道<code>事件旗标</code>中的哪一<code>位</code>被<code>置1</code>，即哪一个事件发生了，然后任务可以对等待的事件指定<code>“逻辑与”、“逻辑或”</code>进行等待操作（<code>opt_pend选项</code>）。</p><p>并且这个函数实现了<code>等待超时</code>机制，且仅当任务等待的事件发生时，任务才能等待到事件。当事件未发生的时候，等待事件的任务会进入阻塞态，阻塞时间<code>timeout</code>由用户指定，在这段时间中，如果事件一直没发生，该任务将保持阻塞状态以等待事件发生。当其它任务或中断服务程序往其等待的事件旗标设置对应的标志位，该任务将自动由阻塞态转为就绪态。当任务等待的时间超过了指定的阻塞时间，即使事件还未发生，任务也会自动从阻塞态转移为就绪态。这样子很有效的体现了操作系统的实时性。</p><p>任务获取了某个事件时，可以选择清除事件操作。</p><p><strong>等待事件的操作不允许在中断上下文环境运行！</strong></p><p>等待事件的过程如下：</p><ol><li>首先检测传入的参数是否正确。，注意<code>opt_pend</code>的选项必须存在<code>TOS_OPT_EVENT_PEND_ALL</code> 或者 <code>TOS_OPT_EVENT_PEND_ANY</code> 之一，且二者不允许同时存在（<code>互斥</code>）。</li><li>调用<code>event_is_match()</code>函数判断等待的事件是否已发生（即任务等待的事件与事件控制块中的旗标是否<code>匹配</code>）。</li><li>在<code>event_is_match()</code>函数中会根据等待选项<code>opt_pend</code>是等待任意一个事件（<code>TOS_OPT_EVENT_PEND_ANY</code>）还是等待所有事件（<code>TOS_OPT_EVENT_PEND_ANY</code>）做出是否匹配的判断，如果是匹配了则返回<code>K_TRUE</code>，反之返回<code>K_FALSE</code>，同时等待到的事件通过<code>flag_match</code>变量返回（已发生匹配）。对于等待所有时间的选项，当且仅当所有事件都发生是才算匹配：<code>(event &amp; flag_expect) == flag_expect)</code>，对于等待任意一个事件的选项，有其中一个事件发生都算匹配：<code>(event &amp; flag_expect)</code>。</li><li>如果事件未发生则可能会阻塞当前获取的任务，看一下用户指定的阻塞时间<code>timeout</code>是否为不阻塞<code>TOS_TIME_NOWAIT</code>，如果不阻塞则直接返回<code>K_ERR_PEND_NOWAIT</code>错误代码。</li><li>如果调度器被锁了<code>knl_is_sched_locked()</code>，则无法进行等待操作，返回错误代码<code>K_ERR_PEND_SCHED_LOCKED</code>，毕竟需要切换任务，调度器被锁则无法切换任务。</li><li>将任务控制块中关于事件的变量设置一下，即设置任务期望等待的事件<code>k_curr_task-&gt;flag_expect</code>，任务匹配的事件<code>k_curr_task-&gt;flag_match</code>，以及任务等待事件的选项<code>k_curr_task-&gt;opt_event_pend</code>。</li><li>调用<code>pend_task_block()</code>函数将任务阻塞，该函数实际上就是将任务从就绪列表中移除<code>k_rdyq.task_list_head[task_prio]</code>，并且插入到等待列表中<code>object-&gt;list</code>，如果等待的时间不是永久等待<code>TOS_TIME_FOREVER</code>，还会将任务插入时间列表中<code>k_tick_list</code>，阻塞时间为<code>timeout</code>，然后进行一次任务调度<code>knl_sched()</code>。</li><li>当程序能继续往下执行时，则表示<code>任务等待到事件</code>，又或者<code>等待发生了超时</code>，任务就不需要等待事件了，此时将任务控制块中的内容清空，即清空任务期望等待的事件<code>k_curr_task-&gt;flag_expect</code>，任务匹配的事件<code>k_curr_task-&gt;flag_match</code>，以及任务等待事件的选项<code>k_curr_task-&gt;opt_event_pend</code>，同时还调用<code>pend_state2errno()</code>函数获取一下任务的等待状态，看一下是哪种情况导致任务恢复运行，并且将结果返回给调用等待事件函数的任务。</li></ol><p>注意：当等待事件的任务能从阻塞中恢复运行，也不一定是等待到事件发生，也有可能是发生了超时，因此在写程序的时候必须要判断一下等待的事件状态，如果是<code>K_ERR_NONE</code>则表示获取成功！</p><p>代码如下：</p><pre class="line-numbers language-js"><code class="language-js">__STATIC__ int <span class="token function">event_is_match</span><span class="token punctuation">(</span>k_event_flag_t event<span class="token punctuation">,</span> k_event_flag_t flag_expect<span class="token punctuation">,</span> k_event_flag_t <span class="token operator">*</span>flag_match<span class="token punctuation">,</span> k_opt_t opt_pend<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>opt_pend <span class="token operator">&amp;</span> TOS_OPT_EVENT_PEND_ALL<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>event <span class="token operator">&amp;</span> flag_expect<span class="token punctuation">)</span> <span class="token operator">==</span> flag_expect<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token operator">*</span>flag_match <span class="token operator">=</span> flag_expect<span class="token punctuation">;</span>            <span class="token keyword">return</span> K_TRUE<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>opt_pend <span class="token operator">&amp;</span> TOS_OPT_EVENT_PEND_ANY<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>event <span class="token operator">&amp;</span> flag_expect<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token operator">*</span>flag_match <span class="token operator">=</span> event <span class="token operator">&amp;</span> flag_expect<span class="token punctuation">;</span>            <span class="token keyword">return</span> K_TRUE<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> K_FALSE<span class="token punctuation">;</span><span class="token punctuation">}</span>__API__ k_err_t <span class="token function">tos_event_pend</span><span class="token punctuation">(</span>k_event_t <span class="token operator">*</span>event<span class="token punctuation">,</span> k_event_flag_t flag_expect<span class="token punctuation">,</span> k_event_flag_t <span class="token operator">*</span>flag_match<span class="token punctuation">,</span> k_tick_t timeout<span class="token punctuation">,</span> k_opt_t opt_pend<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>flag_match<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_IN_IRQ_CHECK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>event<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_EVENT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>opt_pend <span class="token operator">&amp;</span> TOS_OPT_EVENT_PEND_ALL<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>opt_pend <span class="token operator">&amp;</span> TOS_OPT_EVENT_PEND_ANY<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_EVENT_PEND_OPT_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>opt_pend <span class="token operator">&amp;</span> TOS_OPT_EVENT_PEND_ALL<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>opt_pend <span class="token operator">&amp;</span> TOS_OPT_EVENT_PEND_ANY<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_EVENT_PEND_OPT_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">event_is_match</span><span class="token punctuation">(</span>event<span class="token operator">-</span><span class="token operator">></span>flag<span class="token punctuation">,</span> flag_expect<span class="token punctuation">,</span> flag_match<span class="token punctuation">,</span> opt_pend<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>opt_pend <span class="token operator">&amp;</span> TOS_OPT_EVENT_PEND_CLR<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// destroy the bridge after get across the river</span>            event<span class="token operator">-</span><span class="token operator">></span>flag <span class="token operator">=</span> <span class="token punctuation">(</span>k_event_flag_t<span class="token punctuation">)</span>0u<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout <span class="token operator">==</span> TOS_TIME_NOWAIT<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_PEND_NOWAIT<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">knl_is_sched_locked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_PEND_SCHED_LOCKED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    k_curr_task<span class="token operator">-</span><span class="token operator">></span>flag_expect      <span class="token operator">=</span> flag_expect<span class="token punctuation">;</span>    k_curr_task<span class="token operator">-</span><span class="token operator">></span>flag_match       <span class="token operator">=</span> flag_match<span class="token punctuation">;</span>    k_curr_task<span class="token operator">-</span><span class="token operator">></span>opt_event_pend   <span class="token operator">=</span> opt_pend<span class="token punctuation">;</span>    <span class="token function">pend_task_block</span><span class="token punctuation">(</span>k_curr_task<span class="token punctuation">,</span> <span class="token operator">&amp;</span>event<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_curr_task<span class="token operator">-</span><span class="token operator">></span>flag_expect      <span class="token operator">=</span> <span class="token punctuation">(</span>k_event_flag_t<span class="token punctuation">)</span>0u<span class="token punctuation">;</span>    k_curr_task<span class="token operator">-</span><span class="token operator">></span>flag_match       <span class="token operator">=</span> <span class="token punctuation">(</span>k_event_flag_t <span class="token operator">*</span><span class="token punctuation">)</span>K_NULL<span class="token punctuation">;</span>    k_curr_task<span class="token operator">-</span><span class="token operator">></span>opt_event_pend   <span class="token operator">=</span> <span class="token punctuation">(</span>k_opt_t<span class="token punctuation">)</span>0u<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">pend_state2errno</span><span class="token punctuation">(</span>k_curr_task<span class="token operator">-</span><span class="token operator">></span>pend_state<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="发送事件"><a href="#发送事件" class="headerlink" title="发送事件"></a>发送事件</h1><p><code>TencentOS tiny</code> 提供两个函数发送事件，分别是：<code>tos_event_post()</code>与<code>tos_event_post_keep()</code>，两个函数本质上都是调用同一个函数<code>event_do_post()</code>去实现发送事件的操作的，只不过选项是不同而已，使用<code>tos_event_post()</code>函数会覆盖写入指定的事件，可能影响其他已发生的事件，而<code>tos_event_post_keep()</code>函数则可以保持其他事件位不改变的同时发生事件，在实际情况中后者更常用。</p><p>此函数用于将已发生的事件写入事件旗标中指定的位，当对应的位被置1之后，等待事件的任务将可能被恢复，此时需要遍历等待在事件对象上的事件等待列表，判断是否有任务<code>期望的事件</code>与当前<code>事件旗标</code>的值匹配，如果有，则唤醒该任务。</p><p>简单来说，就是设置自己定义的事件标志位为1，并且看看有没有任务在等待这个事件，有的话就唤醒它。</p><p><code>TencentOS tiny</code> 中设计的很好的地方就是简单与低耦合，这两个api接口本质上都是调用<code>event_do_post()</code>函数去发生事件，只是通过<code>opt_post</code>参数不同选择不同的处理方法。</p><p>在<code>event_do_post()</code>函数中的处理也是非常简单明了的，其执行思路如下：</p><ol><li>首先判断一下发生事件的方式<code>opt_post</code>，如果是<code>OPT_EVENT_POST_KEP</code>则采用或运算<code>“|”</code>写入事件旗标，否则直接赋值。</li><li>使用<code>TOS_LIST_FOR_EACH_SAFE</code>遍历等待在事件对象上的事件等待列表，通过<code>event_is_match()</code>函数判断是否有任务<code>期望的事件</code>与当前<code>事件旗标</code>的值匹配，如果有则调用<code>pend_task_wakeup()</code>函数唤醒对应的任务。</li><li>如果唤醒的等待任务指定了清除对应的事件，那么将清除事件的旗标值。</li><li>最后进行一次任务调度<code>knl_sched()</code>。<pre class="line-numbers language-js"><code class="language-js">__STATIC__ k_err_t <span class="token function">event_do_post</span><span class="token punctuation">(</span>k_event_t <span class="token operator">*</span>event<span class="token punctuation">,</span> k_event_flag_t flag<span class="token punctuation">,</span> opt_event_post_t opt_post<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>k_task_t <span class="token operator">*</span>task<span class="token punctuation">;</span>k_list_t <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>#if TOS_CFG_OBJECT_VERIFY_EN &gt; 0u<br>    if (!pend_object_verify(&amp;event-&gt;pend_obj, PEND_TYPE_EVENT)) {<br>        return K_ERR_OBJ_INVALID;<br>    }<br>#endif</p><pre><code>if (opt_post == OPT_EVENT_POST_KEP) {    event-&gt;flag |= flag;} else {    event-&gt;flag = flag;}TOS_CPU_INT_DISABLE();TOS_LIST_FOR_EACH_SAFE(curr, next, &amp;event-&gt;pend_obj.list) {    task = TOS_LIST_ENTRY(curr, k_task_t, pend_list);    if (event_is_match(event-&gt;flag, task-&gt;flag_expect, task-&gt;flag_match, task-&gt;opt_event_pend)) {        pend_task_wakeup(TOS_LIST_ENTRY(curr, k_task_t, pend_list), PEND_STATE_POST);        // if anyone pending the event has set the TOS_OPT_EVENT_PEND_CLR, then no wakeup for the others pendig for the event.        if (task-&gt;opt_event_pend &amp; TOS_OPT_EVENT_PEND_CLR) {            event-&gt;flag = (k_event_flag_t)0u;            break;        }    }}TOS_CPU_INT_ENABLE();knl_sched();return K_ERR_NONE;</code></pre><p>}</p><p><strong>API</strong> k_err_t tos_event_post(k_event_t *event, k_event_flag_t flag)<br>{<br>    TOS_PTR_SANITY_CHECK(event);</p><pre><code>return event_do_post(event, flag, OPT_EVENT_POST_CLR);</code></pre><p>}</p><p><strong>API</strong> k_err_t tos_event_post_keep(k_event_t *event, k_event_flag_t flag)<br>{<br>    TOS_PTR_SANITY_CHECK(event);</p><pre><code>return event_do_post(event, flag, OPT_EVENT_POST_KEP);</code></pre><p>}</p><p>```</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台回复 “ 19 ” 获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> TencentOS tiny </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TencentOS tiny </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TencentOS  tiny】深度源码分析（6）——互斥锁</title>
      <link href="/tencentos-tiny-8/"/>
      <url>/tencentos-tiny-8/</url>
      
        <content type="html"><![CDATA[<h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><p>互斥锁又称互斥互斥锁，是一种特殊的信号量，它和信号量不同的是，它具有<code>互斥锁所有权、递归访问以及优先级继承</code>等特性，在操作系统中常用于对临界资源的<code>独占式</code>处理。在任意时刻互斥锁的状态只有两种，<code>开锁或闭锁</code>，当互斥锁被任务持有时，该互斥锁处于闭锁状态，当该任务释放互斥锁时，该互斥锁处于开锁状态。</p><ul><li>一个任务持有互斥锁就表示它拥有互斥锁的所有权，只有该任务才能释放互斥锁，同时其他任务将不能持有该互斥锁，这就是互斥锁的<code>所有权</code>特性。</li><li>当持有互斥锁的任务再次获取互斥锁时不会被挂起，而是能递归获取，这就是互斥锁的<code>递归访问</code>特性。这个特性与一般的信号量有很大的不同，在信号量中，由于已经不存在可用的信号量，任务递归获取信号量时会发生挂起任务最终形成<code>死锁</code>。</li><li>互斥锁还拥有<code>优先级继承</code>机制，它可以将<code>低</code>优先级任务的优先级<code>临时提升</code>到与获取互斥锁的<code>高</code>优先级任务的优先级<code>相同</code>，尽可能<code>降低</code>优先级翻转的危害。</li></ul><p>在实际应用中，如果想要实现同步功能，可以使用信号量，虽然互斥锁也可以用于任务与任务间的同步，但互斥锁更多的是用于临界资源的互斥访问。</p><p>使用互斥锁对临界资源保护时，任务必须先获取互斥锁以获得访问该资源的所有权，当任务使用资源后，必须释放互斥锁以便其他任务可以访问该资源（而使用信号量保护临界资源时则可能发生优先级翻转，且<code>危害</code>是不可控的）。</p><h1 id="优先级翻转"><a href="#优先级翻转" class="headerlink" title="优先级翻转"></a>优先级翻转</h1><p>简单来说就是高优先级任务在等待低优先级任务执行完毕，这已经违背了操作系统的设计初衷（抢占式调度）。</p><p>为什么会发生优先级翻转？</p><p>当系统中某个临界资源受到一个互斥锁保护时，任务访问该资源时需要获得互斥锁，如果这个资源正在被一个<code>低优先级</code>任务使用，此时互斥锁处于闭锁状态；如果此时一个<code>高优先级</code>任务想要访问该资源，那么高优先级任务会因为获取不到互斥锁而进入阻塞态，此时就形成高优先级任务在等待低优先级任务运行（等待它释放互斥锁）。</p><p>优先级翻转是会产生<code>危害</code>的，在一开始设计系统的时候，就已经指定任务的优先级，越重要的任务优先级越高，但是发生优先级翻转后，高优先级任务在等待低优先级任务，这就有可能让高优先级任务得不到有效的处理，严重时可能导致系统崩溃。</p><p>优先级翻转的危害是不可控的，因为低优先级任务很可能会被系统中其他<code>中间优先级</code>任务（低优先级与高优先级任务之间的优先级任务）抢占，这就有可能导致高优先级任务将等待所有中间优先级任务运行完毕的情况，这种情况对高优先级任务来说是不可接受的，也是违背了操作系统设计的原则。</p><h1 id="优先级继承"><a href="#优先级继承" class="headerlink" title="优先级继承"></a>优先级继承</h1><p>在<code>TencentOS tiny</code> 中为了<code>降低</code>优先级翻转产生的危害使用了<code>优先级继承算法</code>：暂时提高占有某种临界资源的低优先级任务的优先级，使之与在所有等待该资源的任务中，优先级最高的任务优先级相等，而当这个低优先级任务执行完毕释放该资源时，优先级恢复初始设定值（此处可以看作是低优先级任务临时继承了高优先级任务的优先级）。因此，继承优先级的任务避免了系统资源被任何中间优先级任务抢占。互斥锁的优先级继承机制，它确保高优先级任务进入阻塞状态的时间尽可能短，以及将已经出现的“优先级翻转”危害<code>降低到最小</code>，<code>但不能消除</code>优先级翻转带来的危害。</p><p>值得一提的是<code>TencentOS tiny</code> 在持有互斥锁时还允许调用修改任务优先级的API接口。</p><h1 id="互斥锁的数据结构"><a href="#互斥锁的数据结构" class="headerlink" title="互斥锁的数据结构"></a>互斥锁的数据结构</h1><h2 id="互斥锁控制块"><a href="#互斥锁控制块" class="headerlink" title="互斥锁控制块"></a>互斥锁控制块</h2><p><code>TencentOS tiny</code> 通过互斥锁控制块操作互斥锁，其数据类型为<code>k_mutex_t</code>，互斥锁控制块由多个元素组成。</p><ul><li><code>pend_obj</code>有点类似于面向对象的继承，继承一些属性，里面有描述内核资源的类型（如互斥锁、队列、互斥量等，同时还有一个等待列表<code>list</code>）。</li><li><code>pend_nesting</code>实际上是一个<code>uint8_t</code>类型的变量，记录互斥锁被获取的次数，如果<code>pend_nesting</code>为0则表示开锁状态，不为0则表示闭锁状态，且它的值记录了互斥量被获取的次数（拥有递归访问特性）</li><li><code>*owner</code>是任务控制块指针，记录当前互斥锁被哪个任务持有。</li><li><code>owner_orig_prio</code>变量记录了持有互斥锁任务的优先级，因为有可能发生优先级继承机制而临时改变任务的优先级。（拥有优先级继承机制）。</li><li><code>owner_list</code>是一个列表节点，当互斥锁被任务获取时，该节点会被添加到任务控制块的<code>task-&gt;mutex_own_list</code>列表中，表示任务自己获取到的互斥锁有哪些。当互斥锁被<code>完全</code>释放时（<code>pend_nesting等于0</code>），该节点将从任务控制块的<code>task-&gt;mutex_own_list</code>列表中移除。</li><li><code>prio_pending</code>变量比较有意思：在一般的操作系统中，任务在持有互斥锁时不允许修改优先级，但在<code>TencentOS tiny</code> 中是允许的，就是因为这个变量，当一个任务处于互斥锁优先级反转的时候，我假设他因为优先级反转优先级得到了提升，此时有用户企图改变这个任务的优先级，但这个更改后的优先级会使此任务违背其优先级必须比所有等待他所持有的互斥锁的任务还高的原则时，此时需要将用户的这次优先级更改请求记录到<code>prio_pending</code>里，待其释放其所持有的互斥锁后再更改，相当于将任务优先级的更改延后了。<blockquote><p>举个例子：好比一个任务优先级是10，且持有一把锁，此时一个优先级为6的任务尝试获取这把锁，那么此任务优先级会被提升为6，如果此时用户试图更改他的优先级为7，那么不能立刻响应这次请求，必须要等这把锁放掉的时候才能做真正的优先级修改</p></blockquote></li></ul><pre class="line-numbers language-js"><code class="language-js">typedef struct k_mutex_st <span class="token punctuation">{</span>    pend_obj_t      pend_obj<span class="token punctuation">;</span>    k_nesting_t     pend_nesting<span class="token punctuation">;</span>    k_task_t       <span class="token operator">*</span>owner<span class="token punctuation">;</span>    k_prio_t        owner_orig_prio<span class="token punctuation">;</span>    k_list_t        owner_list<span class="token punctuation">;</span><span class="token punctuation">}</span> k_mutex_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">typedef struct k_task_st <span class="token punctuation">{</span>#<span class="token keyword">if</span> TOS_CFG_MUTEX_EN <span class="token operator">></span> 0u    k_list_t            mutex_own_list<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/**&lt; 任务拥有的互斥量 */</span>    k_prio_t            prio_pending<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/*&lt; 在持有互斥锁时修改任务优先级将被记录到这个变量中，在释放持有的互斥锁时再更改 */</span>#endif<span class="token punctuation">}</span> k_task_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="与互斥锁相关的宏定义"><a href="#与互斥锁相关的宏定义" class="headerlink" title="与互斥锁相关的宏定义"></a>与互斥锁相关的宏定义</h2><p>在<code>tos_config.h</code>中，使能互斥锁的宏定义是<code>TOS_CFG_MUTEX_EN</code></p><pre class="line-numbers language-js"><code class="language-js">#define TOS_CFG_MUTEX_EN            1u<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="创建互斥锁"><a href="#创建互斥锁" class="headerlink" title="创建互斥锁"></a>创建互斥锁</h1><p>系统中每个互斥锁都有对应的互斥锁控制块，互斥锁控制块中包含了互斥锁的所有信息，比如它的等待列表、它的资源类型，以及它的互斥锁值，那么可以想象一下，创建互斥锁的本质是不是就是对互斥锁控制块进行初始化呢？很显然就是这样子的。因为在后续对互斥锁的操作都是通过互斥锁控制块来操作的，如果控制块没有信息，那怎么能操作嘛~</p><p>创建互斥锁函数是<code>tos_mutex_create()</code>，传入一个互斥锁控制块的指针<code>*mutex</code>即可。</p><p>互斥锁的创建实际上就是调用<code>pend_object_init()</code>函数将互斥锁控制块中的<code>mutex-&gt;pend_obj</code>成员变量进行初始化，它的资源类型被标识为<code>PEND_TYPE_MUTEX</code>。然后将<code>mutex-&gt;pend_nesting</code>成员变量设置为<code>0</code>，表示互斥锁处于开锁状态；将<code>mutex-&gt;owner</code>成员变量设置为<code>K_NULL</code>，表示此事并无任务持有互斥锁；将<code>mutex-&gt;owner_orig_prio</code>成员变量设置为默认值<code>K_TASK_PRIO_INVALID</code>，毕竟此事没有任务持有互斥锁，也无需记录持有互斥锁任务的优先级。最终调用<code>tos_list_init()</code>函数将互斥锁的持有互斥锁任务的列表节点<code>owner_list</code>。</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_mutex_create</span><span class="token punctuation">(</span>k_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pend_object_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_MUTEX<span class="token punctuation">)</span><span class="token punctuation">;</span>    mutex<span class="token operator">-</span><span class="token operator">></span>pend_nesting     <span class="token operator">=</span> <span class="token punctuation">(</span>k_nesting_t<span class="token punctuation">)</span>0u<span class="token punctuation">;</span>    mutex<span class="token operator">-</span><span class="token operator">></span>owner            <span class="token operator">=</span> K_NULL<span class="token punctuation">;</span>    mutex<span class="token operator">-</span><span class="token operator">></span>owner_orig_prio  <span class="token operator">=</span> K_TASK_PRIO_INVALID<span class="token punctuation">;</span>    <span class="token function">tos_list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>owner_list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="销毁互斥锁"><a href="#销毁互斥锁" class="headerlink" title="销毁互斥锁"></a>销毁互斥锁</h1><p>互斥锁销毁函数是根据互斥锁控制块直接销毁的，销毁之后互斥锁的所有信息都会被清除，而且不能再次使用这个互斥锁，当互斥锁被销毁时，其等待列表中存在任务，系统有必要将这些等待这些任务唤醒，并告知任务互斥锁已经被销毁了<code>PEND_STATE_DESTROY</code>。然后产生一次任务调度以切换到最高优先级任务执行。</p><p><code>TencentOS tiny</code> 对互斥锁销毁的处理流程如下：</p><ol><li>调用<code>pend_is_nopending()</code>函数判断一下是否有任务在等待互斥锁</li><li>如果有则调用<code>pend_wakeup_all()</code>函数将这些任务唤醒，并且告知等待任务互斥锁已经被销毁了（即设置任务控制块中的等待状态成员变量<code>pend_state</code>为<code>PEND_STATE_DESTROY</code>）。</li><li>调用<code>pend_object_deinit()</code>函数将互斥锁控制块中的内容清除，最主要的是将控制块中的资源类型设置为<code>PEND_TYPE_NONE</code>，这样子就无法使用这个互斥锁了。</li><li>将<code>mutex-&gt;pend_nesting</code>成员变量恢复为默认值<code>0</code>。</li><li>如果删除的时候有任务持有互斥锁，那么调用<code>mutex_old_owner_release()</code>函数将互斥锁释放。</li><li>进行任务调度<code>knl_sched()</code></li></ol><p>注意：如果互斥锁控制块的RAM是由<code>编译器静态分配</code>的，所以即使是销毁了互斥锁，这个内存也是没办法释放的。当然你也可以使用动态内存为互斥锁控制块分配内存，只不过在销毁后要将这个内存释放掉，避免内存泄漏。</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_mutex_destroy</span><span class="token punctuation">(</span>k_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_MUTEX<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_is_nopending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">pend_wakeup_all</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_STATE_DESTROY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pend_object_deinit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    mutex<span class="token operator">-</span><span class="token operator">></span>pend_nesting <span class="token operator">=</span> <span class="token punctuation">(</span>k_nesting_t<span class="token punctuation">)</span>0u<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mutex<span class="token operator">-</span><span class="token operator">></span>owner<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">mutex_old_owner_release</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="获取互斥锁"><a href="#获取互斥锁" class="headerlink" title="获取互斥锁"></a>获取互斥锁</h1><p><code>tos_mutex_pend_timed()</code>函数用于获取互斥锁，互斥锁就像是临界资源的令牌，任务只有获取到互斥锁时才能访问临界资源。当且仅当互斥锁处于开锁的状态，任务才能获取互斥锁成功，当任务持有了某个互斥锁的时候，其它任务就无法获取这个互斥锁，需要等到持有互斥锁的任务进行释放后，其他任务才能获取成功，任务通过互斥锁获取函数来获取互斥锁的所有权，任务对互斥锁的所有权是独占的，任意时刻互斥锁只能被一个任务持有，如果互斥锁处于开锁状态，那么获取该互斥锁的任务将成功获得该互斥锁，并拥有互斥锁的使用权；如果互斥锁处于闭锁状态，获取该互斥锁的任务将无法获得互斥锁，任务将可能被阻塞，也可能立即返回，阻塞时间<code>timeout</code>由用户指定，在指定时间还无法获取到互斥锁时，将发送超时，等待任务将自动恢复为就绪态。在任务被阻塞之前，会进行优先级继承，如果当前任务优先级比持有互斥锁的任务优先级高，那么将会临时提升持有互斥锁任务的优先级。</p><p><code>TencentOS tiny</code> 提供两组API接口用于获取互斥锁，分别是<code>tos_mutex_pend_timed()</code>和<code>tos_mutex_pend()</code>，主要的差别是参数不同：可选阻塞与永久阻塞获取互斥锁，实际获取的过程都是一样的。获取互斥锁的过程如下：</p><ol><li>首先检测传入的参数是否正确，此处不仅会检查互斥锁控制块的信息，还会调用<code>TOS_IN_IRQ_CHECK()</code>检查上下文是否处于中断中，因为互斥锁的操作是不允许在中断中进行的。</li><li>判断互斥锁控制块中的<code>mutex-&gt;pend_nesting</code>成员变量是否为<code>0</code>，为0表示互斥锁处于开锁状态，调用<code>mutex_fresh_owner_mark()</code>函数将获取互斥锁任务的相关信息保存到互斥锁控制块中，如<code>mutex-&gt;pend_nesting</code>成员变量的值变为<code>1</code>表示互斥锁处于闭锁状态，其他任务无法获取，<code>mutex-&gt;owner</code>成员变量指向当前获取互斥锁的任务控制块，<code>mutex-&gt;owner_orig_prio</code>成员变量则是记录当前任务的优先级，最终使用<code>tos_list_add()</code>函数将互斥锁控制块的<code>mutex-&gt;owner_list</code>节点挂载到任务控制块的<code>task-&gt;mutex_own_list</code>列表中，任务获取成功后返回<code>K_ERR_NONE</code>。</li><li>如果互斥锁控制块中的<code>mutex-&gt;pend_nesting</code>成员变量不为<code>0</code>，则表示互斥锁处于闭锁状态，那么由于互斥锁具有递归访问特性，那么会判断一下是不是已经持有互斥锁的任务再次获取互斥锁（<code>knl_is_self()</code>），因为这也是允许的，判断一下<code>mutex-&gt;pend_nesting</code>成员变量的值是否为<code>(k_nesting_t)-1</code>，如果是则表示递归访问次数达到最大值，互斥锁已经溢出了，返回错误代码<code>K_ERR_MUTEX_NESTING_OVERFLOW</code>。否则就将<code>mutex-&gt;pend_nesting</code>成员变量的值加1，返回<code>K_ERR_MUTEX_NESTING</code>表示递归获取成功。</li><li>如果互斥锁处于闭锁状态，且当前任务并未持有互斥锁，看一下用户指定的阻塞时间<code>timeout</code>是否为不阻塞<code>TOS_TIME_NOWAIT</code>，如果不阻塞则直接返回<code>K_ERR_PEND_NOWAIT</code>错误代码。</li><li>如果调度器被锁了<code>knl_is_sched_locked()</code>，则无法进行等待操作，返回错误代码<code>K_ERR_PEND_SCHED_LOCKED</code>，毕竟需要切换任务，调度器被锁则无法切换任务。</li><li>最最最最重要的特性来了，在阻塞当前任务之前，需要判断一下当前任务与持有互斥锁的任务优先级大小情况，如果当前任务优先级比持有互斥锁任务优先级大，则需要进行优先级继承，临时将持有互斥锁任务的优先级提升到当前优先级，通过<code>tos_task_prio_change()</code>函数进行改变优先级。</li><li>调用<code>pend_task_block()</code>函数将任务阻塞，该函数实际上就是将任务从就绪列表中移除<code>k_rdyq.task_list_head[task_prio]</code>，并且插入到等待列表中<code>object-&gt;list</code>，如果等待的时间不是永久等待<code>TOS_TIME_FOREVER</code>，还会将任务插入时间列表中<code>k_tick_list</code>，阻塞时间为<code>timeout</code>，然后进行一次任务调度<code>knl_sched()</code>。</li><li>当程序能行到<code>pend_state2errno()</code>时，则表示<code>任务等获取到互斥锁</code>，又或者<code>等待发生了超时</code>，那么就调用<code>pend_state2errno()</code>函数获取一下任务的等待状态，看一下是哪种情况导致任务恢复运行，如果任务已经获取到互斥锁，那么需要调用<code>mutex_new_owner_mark()</code>函数标记一下获取任务的信息，将获取互斥锁任务的相关信息保存到互斥锁控制块中。</li></ol><p>注意：当获取互斥锁的任务能从阻塞中恢复运行，也不一定是获取到互斥锁，也可能是发生了超时，因此在写程序的时候必须要判断一下获取的互斥锁状态，如果返回值是<code>K_ERR_NONE</code>与<code>K_ERR_MUTEX_NESTING</code>则表示获取成功！</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_mutex_pend_timed</span><span class="token punctuation">(</span>k_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">,</span> k_tick_t timeout<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_err_t err<span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_IN_IRQ_CHECK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_MUTEX<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_nesting <span class="token operator">==</span> <span class="token punctuation">(</span>k_nesting_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// first come</span>        <span class="token function">mutex_fresh_owner_mark</span><span class="token punctuation">(</span>mutex<span class="token punctuation">,</span> k_curr_task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">knl_is_self</span><span class="token punctuation">(</span>mutex<span class="token operator">-</span><span class="token operator">></span>owner<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// come again</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_nesting <span class="token operator">==</span> <span class="token punctuation">(</span>k_nesting_t<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> K_ERR_MUTEX_NESTING_OVERFLOW<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token operator">++</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_nesting<span class="token punctuation">;</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_MUTEX_NESTING<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout <span class="token operator">==</span> TOS_TIME_NOWAIT<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// no wait, return immediately</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_PEND_NOWAIT<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">knl_is_sched_locked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_PEND_SCHED_LOCKED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mutex<span class="token operator">-</span><span class="token operator">></span>owner<span class="token operator">-</span><span class="token operator">></span>prio <span class="token operator">></span> k_curr_task<span class="token operator">-</span><span class="token operator">></span>prio<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// PRIORITY INVERSION:</span>        <span class="token comment" spellcheck="true">// we are declaring a mutex, which's owner has a lower(numerically bigger) priority.</span>        <span class="token comment" spellcheck="true">// make owner the same priority with us.</span>        <span class="token function">tos_task_prio_change</span><span class="token punctuation">(</span>mutex<span class="token operator">-</span><span class="token operator">></span>owner<span class="token punctuation">,</span> k_curr_task<span class="token operator">-</span><span class="token operator">></span>prio<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pend_task_block</span><span class="token punctuation">(</span>k_curr_task<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    err <span class="token operator">=</span> <span class="token function">pend_state2errno</span><span class="token punctuation">(</span>k_curr_task<span class="token operator">-</span><span class="token operator">></span>pend_state<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">==</span> K_ERR_NONE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// good, we are the owner now.</span>        <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mutex_new_owner_mark</span><span class="token punctuation">(</span>mutex<span class="token punctuation">,</span> k_curr_task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> err<span class="token punctuation">;</span><span class="token punctuation">}</span>__API__ k_err_t <span class="token function">tos_mutex_pend</span><span class="token punctuation">(</span>k_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">tos_mutex_pend_timed</span><span class="token punctuation">(</span>mutex<span class="token punctuation">,</span> TOS_TIME_FOREVER<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>mutex_fresh_owner_mark</code>与<code>mutex_new_owner_mark()</code>函数的实现：</p><pre class="line-numbers language-js"><code class="language-js">__STATIC_INLINE__ <span class="token keyword">void</span> <span class="token function">mutex_fresh_owner_mark</span><span class="token punctuation">(</span>k_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">,</span> k_task_t <span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">{</span>    mutex<span class="token operator">-</span><span class="token operator">></span>pend_nesting     <span class="token operator">=</span> <span class="token punctuation">(</span>k_nesting_t<span class="token punctuation">)</span>1u<span class="token punctuation">;</span>    mutex<span class="token operator">-</span><span class="token operator">></span>owner            <span class="token operator">=</span> task<span class="token punctuation">;</span>    mutex<span class="token operator">-</span><span class="token operator">></span>owner_orig_prio  <span class="token operator">=</span> task<span class="token operator">-</span><span class="token operator">></span>prio<span class="token punctuation">;</span>    <span class="token function">tos_list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>owner_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>task<span class="token operator">-</span><span class="token operator">></span>mutex_own_list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>__STATIC_INLINE__ <span class="token keyword">void</span> <span class="token function">mutex_new_owner_mark</span><span class="token punctuation">(</span>k_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">,</span> k_task_t <span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">{</span>    k_prio_t highest_pending_prio<span class="token punctuation">;</span>    <span class="token function">mutex_fresh_owner_mark</span><span class="token punctuation">(</span>mutex<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// we own the mutex now, make sure our priority is higher than any one in the pend list.</span>    highest_pending_prio <span class="token operator">=</span> <span class="token function">pend_highest_prio_get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token operator">-</span><span class="token operator">></span>prio <span class="token operator">></span> highest_pending_prio<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">tos_task_prio_change</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> highest_pending_prio<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="释放互斥锁"><a href="#释放互斥锁" class="headerlink" title="释放互斥锁"></a>释放互斥锁</h1><p>互斥锁的释放是不允许在中断中释放的，主要的原因是因为中断中没有上下文的概念，所以中断上下文不能持有，也不能释放互斥锁；互斥锁有<code>所属</code>关系，只有持有互斥锁的任务才能将互斥锁释放，而持有者是任务。</p><p>任务想要访问某个资源的时候，需要先获取互斥锁，然后进行资源访问，在任务使用完该资源的时候，必须要<code>及时</code>释放互斥锁，这样别的任务才能访问临界资源。任务可以调用<code>tos_mutex_post()</code>函数进行释放互斥锁，当互斥锁处于开锁状态时就表示我已经用完了，别人可以获取互斥锁以访问临界资源。</p><p>使用<code>tos_mutex_post()</code>函数接口时，只有已持有互斥锁所有权的任务才能释放它，当任务调用<code>tos_mutex_post()</code>函数时会将互斥锁释放一次，当互斥锁完全释放完毕（<code>mutex-&gt;pend_nesting</code>成员变量的值为<code>0</code>）就变为开锁状态，等待获取该互斥锁的任务将被唤醒。如果任务的优先级被互斥锁的优先级翻转机制临时提升，那么当互斥锁被释放后，任务的优先级将恢复为原本设定的优先级。</p><p><code>TencentOS tiny</code> 中可以只让等待中的一个任务获取到互斥锁（在等待的任务中具有最高优先级）。</p><p>在<code>tos_mutex_post()</code>函数中的处理也是非常简单明了的，其执行思路如下：</p><ol><li>首先进行传入的互斥锁控制块相关的参数检测，然后判断一下是否是持有互斥锁的任务来释放互斥锁，如果是则进行释放操作，如果不是则返回错误代码<code>K_ERR_MUTEX_NOT_OWNER</code>。</li><li>将<code>mutex-&gt;pend_nesting</code>成员变量的值减1，然后判断它的值是否为0，如果不为0则表示当前任务还是持有互斥锁的，也无需进行后续的操作，直接返回<code>K_ERR_MUTEX_NESTING</code>。</li><li>如果<code>mutex-&gt;pend_nesting</code>成员变量的值为0，则表示互斥锁处于开锁状态，则需要调用<code>mutex_old_owner_release()</code>函数完全释放掉互斥锁，在这个函数中会将互斥锁控制块的成员变量（如<code>owner_list、owner、owner_orig_prio</code>等都设置为初始值），此外还有最重要的就是判断一下任务是否发生过优先级继承，如果是则需要将任务恢复为原本的优先级，否则就无效理会。</li><li>调用<code>pend_is_nopending()</code>函数判断一下是否有任务在等待互斥锁，如果没有则返回<code>K_ERR_NONE</code>表示释放互斥锁成功，因为此时没有唤醒任务也就无需任务调度，直接返回即可。</li><li>如果有任务在等待互斥锁，则直接调用<code>pend_wakeup_one()</code>函数唤醒一个等待任务，这个任务在等待任务中是处于最高优先级的，因为<code>TencentOS tiny</code> 的等待任务是按照优先级进行排序。</li><li>进行一次任务调度<code>knl_sched()</code>。</li></ol><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_mutex_post</span><span class="token punctuation">(</span>k_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_MUTEX<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">knl_is_self</span><span class="token punctuation">(</span>mutex<span class="token operator">-</span><span class="token operator">></span>owner<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_MUTEX_NOT_OWNER<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_nesting <span class="token operator">==</span> <span class="token punctuation">(</span>k_nesting_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_MUTEX_NESTING_OVERFLOW<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">--</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_nesting<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_nesting <span class="token operator">></span> <span class="token punctuation">(</span>k_nesting_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_MUTEX_NESTING<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">mutex_old_owner_release</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pend_is_nopending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pend_wakeup_one</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_STATE_POST<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>持有互斥锁的任务释放互斥锁<code>mutex_old_owner_release()</code>。</p><pre class="line-numbers language-js"><code class="language-js">__STATIC_INLINE__ <span class="token keyword">void</span> <span class="token function">mutex_old_owner_release</span><span class="token punctuation">(</span>k_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">{</span>    k_task_t <span class="token operator">*</span>owner<span class="token punctuation">;</span>    owner <span class="token operator">=</span> mutex<span class="token operator">-</span><span class="token operator">></span>owner<span class="token punctuation">;</span>    <span class="token function">tos_list_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token operator">-</span><span class="token operator">></span>owner_list<span class="token punctuation">)</span><span class="token punctuation">;</span>    mutex<span class="token operator">-</span><span class="token operator">></span>owner <span class="token operator">=</span> K_NULL<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// the right time comes! let's do it!</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>owner<span class="token operator">-</span><span class="token operator">></span>prio_pending <span class="token operator">!=</span> K_TASK_PRIO_INVALID<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">tos_task_prio_change</span><span class="token punctuation">(</span>owner<span class="token punctuation">,</span> owner<span class="token operator">-</span><span class="token operator">></span>prio_pending<span class="token punctuation">)</span><span class="token punctuation">;</span>        owner<span class="token operator">-</span><span class="token operator">></span>prio_pending <span class="token operator">=</span> K_TASK_PRIO_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>owner<span class="token operator">-</span><span class="token operator">></span>prio <span class="token operator">!=</span> mutex<span class="token operator">-</span><span class="token operator">></span>owner_orig_prio<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">tos_task_prio_change</span><span class="token punctuation">(</span>owner<span class="token punctuation">,</span> mutex<span class="token operator">-</span><span class="token operator">></span>owner_orig_prio<span class="token punctuation">)</span><span class="token punctuation">;</span>        mutex<span class="token operator">-</span><span class="token operator">></span>owner_orig_prio <span class="token operator">=</span> K_TASK_PRIO_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台回复 “ 19 ” 获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> TencentOS tiny </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TencentOS tiny </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TencentOS  tiny】深度源码分析（5）——信号量</title>
      <link href="/tencentos-tiny-7/"/>
      <url>/tencentos-tiny-7/</url>
      
        <content type="html"><![CDATA[<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>信号量（<code>sem</code>）在操作系统中是一种实现系统中任务与任务、任务与中断间同步或者临界资源互斥保护的机制。在多任务系统中，各任务之间常需要同步或互斥，信号量就可以为用户提供这方面的支持。</p><p>抽象来说，信号量是一个非负整数，每当信号量被获取（<code>pend</code>）时，该整数会减一，当该整数的值为 <code>0</code> 时，表示信号量处于无效状态，将无法被再次获取，所有试图获取它的任务将进入阻塞态。通常一个信号量是有计数值的，它的计数值可以用于系统资源计数（统计）。</p><p>一般来说信号量的值有两种：</p><ul><li>0：表示没有积累下来的<code>post</code>信号量操作，且可能有任务阻塞在此信号量上。</li><li>正值：表示有一个或多个<code>post</code>信号量操作。</li></ul><p>一般来说信号量多用于同步而非互斥，因为操作系统中会提供另一种互斥机制（互斥锁），互斥量的互斥作用更完善：互斥锁有优先级继承机制，而信号量则没有这个机制，此外互斥量还拥有所有者属性，我们会在后续讲解。</p><p>信号量也如队列一样，拥有<code>阻塞机制</code>。任务需要等待某个中断发生后，再去执行对应的处理，那么任务可以处于阻塞态等待信号量，直到中断发生后释放信号量后，该任务才被唤醒去执行对应的处理。在释放（<code>post</code>）信号量的时候能立即将等待的任务转变为就绪态，如果任务的优先级在就绪任务中是最高的，任务就能立即被运行，这就是操作系统中的“<code>实时响应，实时处理</code>”。在操作系统中使用信号量可以提高处理的效率。</p><h1 id="信号量的数据结构"><a href="#信号量的数据结构" class="headerlink" title="信号量的数据结构"></a>信号量的数据结构</h1><h2 id="信号量控制块"><a href="#信号量控制块" class="headerlink" title="信号量控制块"></a>信号量控制块</h2><p><code>TencentOS tiny</code> 通过信号量控制块操作信号量，其数据类型为<code>k_sem_t</code>，信号量控制块由多个元素组成，主要有 <code>pend_obj_t</code> 类型的<code>pend_obj</code>以及<code>k_sem_cnt_t</code>类型的<code>count</code>。而<code>pend_obj</code>有点类似于面向对象的继承，继承一些属性，里面有描述内核资源的类型（如信号量、队列、互斥量等，同时还有一个等待列表<code>list</code>）。而<code>count</code>则是一个简单的变量（它是16位的无符号整数），表示信号量的值。</p><pre class="line-numbers language-js"><code class="language-js">typedef struct k_sem_st <span class="token punctuation">{</span>    pend_obj_t      pend_obj<span class="token punctuation">;</span>    k_sem_cnt_t     count<span class="token punctuation">;</span><span class="token punctuation">}</span> k_sem_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="与信号量相关的宏定义"><a href="#与信号量相关的宏定义" class="headerlink" title="与信号量相关的宏定义"></a>与信号量相关的宏定义</h2><p>在<code>tos_config.h</code>中，使能信号量的宏定义是<code>TOS_CFG_SEM_EN</code></p><pre class="line-numbers language-js"><code class="language-js">#define TOS_CFG_SEM_EN              1u<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="信号量实现"><a href="#信号量实现" class="headerlink" title="信号量实现"></a>信号量实现</h1><p><code>TencentOS tiny</code> 中实现信号量非常简单，核心代码仅仅只有<code>125</code>行，可以说是非常少了。</p><h1 id="创建信号量"><a href="#创建信号量" class="headerlink" title="创建信号量"></a>创建信号量</h1><p>系统中每个信号量都有对应的信号量控制块，信号量控制块中包含了信号量的所有信息，比如它的等待列表、它的资源类型，以及它的信号量值，那么可以想象一下，创建信号量的本质是不是就是对信号量控制块进行初始化呢？很显然就是这样子的。因为在后续对信号量的操作都是通过信号量控制块来操作的，如果控制块没有信息，那怎么能操作嘛~</p><p>创建信号量函数是<code>tos_sem_create()</code>，传入两个参数，一个是信号量控制块的指针<code>*sem</code>，另一个是信号量的初始值<code>init_count</code>，该值是非负整数即可，但主要不能超过<code>65535</code>。</p><p>实际上就是调用<code>pend_object_init()</code>函数将信号量控制块中的<code>sem-&gt;pend_obj</code>成员变量进行初始化，它的资源类型被标识为<code>PEND_TYPE_SEM</code>。然后将<code>sem-&gt;count</code>成员变量设置为传递进来的信号量的初始值<code>init_count</code>。</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_sem_create</span><span class="token punctuation">(</span>k_sem_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> k_sem_cnt_t init_count<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pend_object_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_SEM<span class="token punctuation">)</span><span class="token punctuation">;</span>    sem<span class="token operator">-</span><span class="token operator">></span>count <span class="token operator">=</span> init_count<span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="销毁信号量"><a href="#销毁信号量" class="headerlink" title="销毁信号量"></a>销毁信号量</h1><p>信号量销毁函数是根据信号量控制块直接销毁的，销毁之后信号量的所有信息都会被清除，而且不能再次使用这个信号量，当信号量被销毁时，其等待列表中存在任务，系统有必要将这些等待这些任务唤醒，并告知任务信号量已经被销毁了<code>PEND_STATE_DESTROY</code>。然后产生一次任务调度以切换到最高优先级任务执行。</p><p><code>TencentOS tiny</code> 对信号量销毁的处理流程如下：</p><ol><li>调用<code>pend_is_nopending()</code>函数判断一下是否有任务在等待信号量</li><li>如果有则调用<code>pend_wakeup_all()</code>函数将这些任务唤醒，并且告知等待任务信号量已经被销毁了（即设置任务控制块中的等待状态成员变量<code>pend_state</code>为<code>PEND_STATE_DESTROY</code>）。</li><li>调用<code>pend_object_deinit()</code>函数将信号量控制块中的内容清除，最主要的是将控制块中的资源类型设置为<code>PEND_TYPE_NONE</code>，这样子就无法使用这个信号量了。</li><li>进行任务调度<code>knl_sched()</code></li></ol><p>注意：如果信号量控制块的RAM是由<code>编译器静态分配</code>的，所以即使是销毁了信号量，这个内存也是没办法释放的。当然你也可以使用动态内存为信号量控制块分配内存，只不过在销毁后要将这个内存释放掉，避免内存泄漏。</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_sem_destroy</span><span class="token punctuation">(</span>k_sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_SEM<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_is_nopending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">pend_wakeup_all</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_STATE_DESTROY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pend_object_deinit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="获取信号量"><a href="#获取信号量" class="headerlink" title="获取信号量"></a>获取信号量</h1><p><code>tos_sem_pend()</code>函数用于获取信号量，当信号量有效的时候，任务才能获取信号量。任务获取了某个信号量时，该信号量的可用个数减一，当它为0的时候，获取信号量的任务会进入阻塞态，阻塞时间<code>timeout</code>由用户指定，在指定时间还无法获取到信号量时，将发送超时，等待任务将自动恢复为就绪态。</p><p>获取信号量的过程如下：</p><ol><li>首先检测传入的参数是否正确。</li><li>判断信号量控制块中的<code>count</code>成员变量是否大于<code>0</code>，大于0表示存在可用信号量，将<code>count</code>成员变量的值<code>减1</code>，任务获取成功后返回<code>K_ERR_NONE</code>。</li><li>如果不存在信号量则可能会阻塞当前获取的任务，看一下用户指定的阻塞时间<code>timeout</code>是否为不阻塞<code>TOS_TIME_NOWAIT</code>，如果不阻塞则直接返回<code>K_ERR_PEND_NOWAIT</code>错误代码。</li><li>如果调度器被锁了<code>knl_is_sched_locked()</code>，则无法进行等待操作，返回错误代码<code>K_ERR_PEND_SCHED_LOCKED</code>，毕竟需要切换任务，调度器被锁则无法切换任务。</li><li>调用<code>pend_task_block()</code>函数将任务阻塞，该函数实际上就是将任务从就绪列表中移除<code>k_rdyq.task_list_head[task_prio]</code>，并且插入到等待列表中<code>object-&gt;list</code>，如果等待的时间不是永久等待<code>TOS_TIME_FOREVER</code>，还会将任务插入时间列表中<code>k_tick_list</code>，阻塞时间为<code>timeout</code>，然后进行一次任务调度<code>knl_sched()</code>。</li><li>当程序能行到<code>pend_state2errno()</code>时，则表示<code>任务等获取到信号量</code>，又或者<code>等待发生了超时</code>，那么就调用<code>pend_state2errno()</code>函数获取一下任务的等待状态，看一下是哪种情况导致任务恢复运行，并且将结果返回给调用获取信号量的任务。</li></ol><p>注意：当获取信号量的任务能从阻塞中恢复运行，也不一定是获取到信号量，也可能是发生了超时，因此在写程序的时候必须要判断一下获取的信号量状态，如果是<code>K_ERR_NONE</code>则表示获取成功！</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_sem_pend</span><span class="token punctuation">(</span>k_sem_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> k_tick_t timeout<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_IN_IRQ_CHECK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_SEM<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sem<span class="token operator">-</span><span class="token operator">></span>count <span class="token operator">></span> <span class="token punctuation">(</span>k_sem_cnt_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">--</span>sem<span class="token operator">-</span><span class="token operator">></span>count<span class="token punctuation">;</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout <span class="token operator">==</span> TOS_TIME_NOWAIT<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// no wait, return immediately</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_PEND_NOWAIT<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">knl_is_sched_locked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_PEND_SCHED_LOCKED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pend_task_block</span><span class="token punctuation">(</span>k_curr_task<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sem<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">pend_state2errno</span><span class="token punctuation">(</span>k_curr_task<span class="token operator">-</span><span class="token operator">></span>pend_state<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="释放信号量"><a href="#释放信号量" class="headerlink" title="释放信号量"></a>释放信号量</h1><p>任务或者中断服务程序都可以释放信号量（post），释放信号量的本质就是将信号量控制块的<code>count</code>成员变量的值<code>加1</code>，表示信号量有效，不过如果有任务在等待这个信号量时，信号量控制块的<code>count</code>成员变量的值是不会改变的，因为要唤醒等待任务，而唤醒等待任务的本质就是等待任务获取到信号量，信号量控制块的<code>count</code>成员变量的值要<code>减1</code>，这一来一回中，信号量控制块的<code>count</code>成员变量的值是不会改变的。</p><p><code>TencentOS tiny</code> 中可以只让等待中的一个任务获取到信号量，也可以让所有等待任务都获取到信号量。分别对应的API是<code>tos_sem_post()</code>与<code>tos_sem_post_all()</code>。顺便提一点，<code>tos_sem_post_all()</code>的设计模式其实是观察者模式，当一个观察的对象改变后，那么所有的观察者都会知道它改变了，具体可以看看《大话设计模式》这本书。</p><p><code>TencentOS tiny</code> 中设计的很好的地方就是简单与低耦合，这两个api接口本质上都是调用<code>sem_do_post()</code>函数去释放信号量，只是通过<code>opt</code>参数不同选择不同的处理方法。</p><p>在<code>sem_do_post()</code>函数中的处理也是非常简单明了的，其执行思路如下：</p><ol><li>首先判断一下信号量是否溢出了，因为一个整数始终都会溢出的，总不能一直释放信号量让<code>count</code>成员变量的值<code>加1</code>吧，因此必须要判断一下是否溢出，如果<code>sem-&gt;count</code>的值为 <code>(k_sem_cnt_t)-1</code>，则表示已经溢出，无法继续释放信号量，返回错误代码K_ERR_SEM_OVERFLOW。</li><li>调用<code>pend_is_nopending()</code>函数判断一下是否有任务在等待信号量，如果没有则将<code>count</code>成员变量的值<code>加1</code>，返回<code>K_ERR_NONE</code>表示释放信号量成功，因为此时没有唤醒任务也就无需任务调度，直接返回即可。</li><li>如果有任务在等待信号量，则<code>count</code>成员变量的值<code>无需加1</code>，直接调用<code>pend_wakeup</code>唤醒对应的任务即可，唤醒任务则是根据<code>opt</code>参数进行唤醒，可以唤醒等待中的一个任务或者是所有任务。</li><li>进行一次任务调度<code>knl_sched()</code>。</li></ol><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_sem_post</span><span class="token punctuation">(</span>k_sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">sem_do_post</span><span class="token punctuation">(</span>sem<span class="token punctuation">,</span> OPT_POST_ONE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>__API__ k_err_t <span class="token function">tos_sem_post_all</span><span class="token punctuation">(</span>k_sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">sem_do_post</span><span class="token punctuation">(</span>sem<span class="token punctuation">,</span> OPT_POST_ALL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>__STATIC__ k_err_t <span class="token function">sem_do_post</span><span class="token punctuation">(</span>k_sem_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> opt_post_t opt<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_SEM<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sem<span class="token operator">-</span><span class="token operator">></span>count <span class="token operator">==</span> <span class="token punctuation">(</span>k_sem_cnt_t<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_SEM_OVERFLOW<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pend_is_nopending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">++</span>sem<span class="token operator">-</span><span class="token operator">></span>count<span class="token punctuation">;</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pend_wakeup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_STATE_POST<span class="token punctuation">,</span> opt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于为什么判断<code>sem-&gt;count</code>是<code>(k_sem_cnt_t)-1</code>就代表溢出呢？我在C语言中举了个简单的例子：</p><pre class="line-numbers language-js"><code class="language-js">#include <span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token operator">></span>int <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    unsigned int a <span class="token operator">=</span> <span class="token operator">~</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token punctuation">(</span>unsigned int<span class="token punctuation">)</span>0XFFFFFFFF<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"OK\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token punctuation">(</span>unsigned int<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"OK\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"unsigned int a = %d \n"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>输出：OKOKunsigned int a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>代码精悍短小，思想清晰，非常建议深入学习~</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台回复 “ 19 ” 获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> TencentOS tiny </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TencentOS tiny </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TencentOS  tiny】深度源码分析（4）——消息队列</title>
      <link href="/tencentos-tiny-6/"/>
      <url>/tencentos-tiny-6/</url>
      
        <content type="html"><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>在前一篇文章中<a href="https://blog.csdn.net/jiejiemcu/article/details/99687678" target="_blank" rel="noopener">【TencentOS tiny学习】源码分析（3）——队列</a><br>我们描述了TencentOS tiny的队列实现，同时也点出了TencentOS tiny的队列是依赖于消息队列的，那么我们今天来看看消息队列的实现。</p><p>其实消息队列是TencentOS tiny的一个<strong>基础组件</strong>，作为队列的底层。<br>所以在<code>tos_config.h</code>中会用以下宏定义：</p><pre class="line-numbers language-js"><code class="language-js">#<span class="token keyword">if</span> <span class="token punctuation">(</span>TOS_CFG_QUEUE_EN <span class="token operator">></span> 0u<span class="token punctuation">)</span>#define TOS_CFG_MSG_EN     1u#<span class="token keyword">else</span>#define TOS_CFG_MSG_EN     0u#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="系统消息池初始化"><a href="#系统消息池初始化" class="headerlink" title="系统消息池初始化"></a>系统消息池初始化</h1><p>在系统初始化（<code>tos_knl_init()</code>）的时候，系统就会将消息池进行初始化，其中， <code>msgpool_init()</code>函数就是用来初始化消息池的，该函数的定义位于 tos_msg.c文件中，函数的实现主要是通过一个<code>for</code>循环，将消息池<code>k_msg_pool[TOS_CFG_MSG_POOL_SIZE]</code>的成员变量进行初始化，初始化对应的列表节点，并且将它挂载到空闲消息列表上<code>k_msg_freelist</code><br>初始化完成示意图：（假设只有3个消息）<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190820005010919.png" alt=""></p><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ <span class="token keyword">void</span> <span class="token function">msgpool_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    uint32_t i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> TOS_CFG_MSG_POOL_SIZE<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">tos_list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>k_msg_pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">tos_list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>k_msg_pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>k_msg_freelist<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_knl_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    ···    #<span class="token keyword">if</span> <span class="token punctuation">(</span>TOS_CFG_MSG_EN<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span>        <span class="token function">msgpool_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    #endif    ···<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="消息队列创建"><a href="#消息队列创建" class="headerlink" title="消息队列创建"></a>消息队列创建</h1><p>这个函数在队列创建中会被调用，当然他也可以自己作为用户API接口提供给用户使用，而非仅仅是内核API接口。<br>这个函数的本质上就是初始化消息队列中的消息列表<code>queue_head</code>。<br>初始化完成示意图：<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190820005606981.png" alt=""></p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_msg_queue_create</span><span class="token punctuation">(</span>k_msg_queue_t <span class="token operator">*</span>msg_queue<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>msg_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token function">knl_object_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg_queue<span class="token operator">-</span><span class="token operator">></span>knl_obj<span class="token punctuation">,</span> KNL_OBJ_TYPE_MSG_QUEUE<span class="token punctuation">)</span><span class="token punctuation">;</span>#endif    <span class="token function">tos_list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg_queue<span class="token operator">-</span><span class="token operator">></span>queue_head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="消息队列销毁"><a href="#消息队列销毁" class="headerlink" title="消息队列销毁"></a>消息队列销毁</h1><p><code>tos_msg_queue_destroy()</code>函数用于销毁一个消息队列，当消息队列不在使用是可以将其销毁，销毁的本质其实是将消息队列控制块的内容进行清除，首先判断一下消息队列控制块的类型是<code>KNL_OBJ_TYPE_MSG_QUEUE</code>，这个函数只能销毁队列类型的控制块。然后调用<code>tos_msg_queue_flush()</code>函数将队列的消息列表的消息全部“<code>清空</code>”，“清空”的意思是将挂载到队列上的消息释放回消息池（如果消息队列的消息列表存在消息，使用<code>msgpool_free()</code>函数释放消息）。并且通过<code>tos_list_init()</code>函数将消息队列的消息列表进行初始化，<code>knl_object_deinit()</code>函数是为了确保消息队列已经被销毁，此时消息队列控制块的<code>pend_obj</code>成员变量中的<code>type</code> 属性标识为<code>KNL_OBJ_TYPE_NONE</code>。</p><blockquote><p>但是有一点要注意，因为队列控制块的RAM是由编译器静态分配的，所以即使是销毁了队列，这个内存也是没办法释放的~</p></blockquote><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_msg_queue_destroy</span><span class="token punctuation">(</span>k_msg_queue_t <span class="token operator">*</span>msg_queue<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>msg_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">knl_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg_queue<span class="token operator">-</span><span class="token operator">></span>knl_obj<span class="token punctuation">,</span> KNL_OBJ_TYPE_MSG_QUEUE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">tos_msg_queue_flush</span><span class="token punctuation">(</span>msg_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg_queue<span class="token operator">-</span><span class="token operator">></span>queue_head<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token function">knl_object_deinit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg_queue<span class="token operator">-</span><span class="token operator">></span>knl_obj<span class="token punctuation">)</span><span class="token punctuation">;</span>#endif    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">__API__ <span class="token keyword">void</span> <span class="token function">tos_msg_queue_flush</span><span class="token punctuation">(</span>k_msg_queue_t <span class="token operator">*</span>msg_queue<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_list_t <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_LIST_FOR_EACH_SAFE</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg_queue<span class="token operator">-</span><span class="token operator">></span>queue_head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">msgpool_free</span><span class="token punctuation">(</span><span class="token function">TOS_LIST_ENTRY</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> k_msg_t<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="从消息队列获取消息"><a href="#从消息队列获取消息" class="headerlink" title="从消息队列获取消息"></a>从消息队列获取消息</h1><p><code>tos_msg_queue_get()</code>函数用于从消息队列中获取消息，获取到的消息通过<code>msg_addr</code>参数返回，获取到消息的大小通过<code>msg_size</code>参数返回给用户，当获取成功是返回<code>K_ERR_NONE</code>，否则返回对应的错误代码。<br>这个从消息队列中获取消息的函数是不会产生阻塞的，如果有消息则获取成功，否则就获取失败，它的实现过程如下：<br><code>TOS_CFG_OBJECT_VERIFY_EN</code> 宏定义使能了，就调用<code>knl_object_verify()</code>函数确保是从消息队列中获取消息，然后通过<code>TOS_LIST_FIRST_ENTRY_OR_NULL</code>判断一下是消息队列的消息列表否存在消息，如果不存在则返回<code>K_ERR_MSG_QUEUE_EMPTY</code>表示消息队列是空的，反正将获取成功，获取成功后需要使用<code>msgpool_free()</code>函数将消息释放回消息池。</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_msg_queue_get</span><span class="token punctuation">(</span>k_msg_queue_t <span class="token operator">*</span>msg_queue<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">**</span>msg_addr<span class="token punctuation">,</span> size_t <span class="token operator">*</span>msg_size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_msg_t <span class="token operator">*</span>msg<span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">knl_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg_queue<span class="token operator">-</span><span class="token operator">></span>knl_obj<span class="token punctuation">,</span> KNL_OBJ_TYPE_MSG_QUEUE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    msg <span class="token operator">=</span> <span class="token function">TOS_LIST_FIRST_ENTRY_OR_NULL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg_queue<span class="token operator">-</span><span class="token operator">></span>queue_head<span class="token punctuation">,</span> k_msg_t<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_MSG_QUEUE_EMPTY<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">*</span>msg_addr <span class="token operator">=</span> msg<span class="token operator">-</span><span class="token operator">></span>msg_addr<span class="token punctuation">;</span>    <span class="token operator">*</span>msg_size <span class="token operator">=</span> msg<span class="token operator">-</span><span class="token operator">></span>msg_size<span class="token punctuation">;</span>    <span class="token function">msgpool_free</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="向消息队列写入消息"><a href="#向消息队列写入消息" class="headerlink" title="向消息队列写入消息"></a>向消息队列写入消息</h1><p>当发送消息时，<code>TencentOS tiny</code>会从消息池（空闲消息列表）中取出一个空闲消息，挂载到消息队列的消息列表中，可以通过<code>opt</code>参数选择挂载到消息列表的末尾或者是头部，因此消息队列的写入是支持<code>FIFO</code>与<code>LIFO</code>方式的，<code>msg_queue</code>是要写入消息的消息队列控制块，<code>msg_addr</code>、<code>msg_size</code>则是要写入消息的地址与大小。</p><p>写入消息的过程非常简单，直接通过<code>msgpool_alloc()</code>函数从消息池取出一个空闲消息，如果系统不存在空闲的消息，则直接返回错误代码<code>K_ERR_MSG_QUEUE_FULL</code>表示系统可用的消息已经被使用完。如果取出空闲消息成功则将要写入的消息地址与大小记录到消息池的<code>msg_addr</code> 与 <code>msg_size</code> 成员变量中，然后通过<code>opt</code>参数选择将消息挂载到消息列表的位置（头部或者是尾部）。</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_msg_queue_put</span><span class="token punctuation">(</span>k_msg_queue_t <span class="token operator">*</span>msg_queue<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>msg_addr<span class="token punctuation">,</span> size_t msg_size<span class="token punctuation">,</span> k_opt_t opt<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_msg_t <span class="token operator">*</span>msg<span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">knl_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg_queue<span class="token operator">-</span><span class="token operator">></span>knl_obj<span class="token punctuation">,</span> KNL_OBJ_TYPE_MSG_QUEUE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    msg <span class="token operator">=</span> <span class="token function">msgpool_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_MSG_QUEUE_FULL<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    msg<span class="token operator">-</span><span class="token operator">></span>msg_addr <span class="token operator">=</span> msg_addr<span class="token punctuation">;</span>    msg<span class="token operator">-</span><span class="token operator">></span>msg_size <span class="token operator">=</span> msg_size<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>opt <span class="token operator">&amp;</span> TOS_OPT_MSG_PUT_LIFO<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">tos_list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg<span class="token operator">-</span><span class="token operator">></span>list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg_queue<span class="token operator">-</span><span class="token operator">></span>queue_head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">tos_list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg<span class="token operator">-</span><span class="token operator">></span>list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg_queue<span class="token operator">-</span><span class="token operator">></span>queue_head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="实验测试代码"><a href="#实验测试代码" class="headerlink" title="实验测试代码"></a>实验测试代码</h1><pre class="line-numbers language-js"><code class="language-js">#include <span class="token string">"stm32f10x.h"</span>#include <span class="token string">"bsp_usart.h"</span>#include <span class="token string">"tos.h"</span>k_msg_queue_t test_msg_queue_00<span class="token punctuation">;</span>k_task_t task1<span class="token punctuation">;</span>k_task_t task2<span class="token punctuation">;</span>k_stack_t task_stack1<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>k_stack_t task_stack2<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test_task1</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>Parameter<span class="token punctuation">)</span><span class="token punctuation">{</span>    k_err_t err<span class="token punctuation">;</span>    int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    int msg_received<span class="token punctuation">;</span>    size_t msg_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"queue pend\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>         <span class="token punctuation">{</span>            err <span class="token operator">=</span> <span class="token function">tos_msg_queue_get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>test_msg_queue_00<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">**</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>msg_received<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg_size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">==</span> K_ERR_NONE<span class="token punctuation">)</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"msg queue get is %d \r\n"</span><span class="token punctuation">,</span>msg_received<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">==</span> K_ERR_PEND_DESTROY<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"queue is destroy\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">tos_task_delay</span><span class="token punctuation">(</span>TOS_TIME_FOREVER <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">tos_task_delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">test_task2</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>Parameter<span class="token punctuation">)</span><span class="token punctuation">{</span>    k_err_t err<span class="token punctuation">;</span>    int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    uint32_t msgs<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"task2 running\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>         <span class="token punctuation">{</span>            err <span class="token operator">=</span> <span class="token function">tos_msg_queue_put</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>test_msg_queue_00<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>msgs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sizeof</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span><span class="token punctuation">,</span> TOS_OPT_MSG_PUT_FIFO<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">!=</span> K_ERR_NONE<span class="token punctuation">)</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"msg queue put fail! code : %d \r\n"</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">tos_task_delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * @brief  主函数  * @param  无  * @retval 无  */</span>int <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    k_err_t err<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*初始化USART 配置模式为 115200 8-N-1，中断接收*/</span>    <span class="token function">USART_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Welcome to TencentOS tiny\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_knl_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// TOS Tiny kernel initialize</span>    <span class="token function">tos_robin_config</span><span class="token punctuation">(</span>TOS_ROBIN_STATE_ENABLED<span class="token punctuation">,</span> <span class="token punctuation">(</span>k_timeslice_t<span class="token punctuation">)</span>500u<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"create test_queue_00\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    err <span class="token operator">=</span> <span class="token function">tos_msg_queue_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>test_msg_queue_00<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> K_ERR_NONE<span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"TencentOS Create test_msg_queue_00 fail! code : %d \r\n"</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"create task1\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    err <span class="token operator">=</span> <span class="token function">tos_task_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>task1<span class="token punctuation">,</span>                           <span class="token string">"task1"</span><span class="token punctuation">,</span>                           test_task1<span class="token punctuation">,</span>                          NULL<span class="token punctuation">,</span>                           <span class="token number">3</span><span class="token punctuation">,</span>                           task_stack1<span class="token punctuation">,</span>                          <span class="token number">1024</span><span class="token punctuation">,</span>                          <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> K_ERR_NONE<span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"TencentOS Create task1 fail! code : %d \r\n"</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"create task2\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    err <span class="token operator">=</span> <span class="token function">tos_task_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>task2<span class="token punctuation">,</span>                           <span class="token string">"task2"</span><span class="token punctuation">,</span>                           test_task2<span class="token punctuation">,</span>                          NULL<span class="token punctuation">,</span>                           <span class="token number">4</span><span class="token punctuation">,</span>                           task_stack2<span class="token punctuation">,</span>                          <span class="token number">1024</span><span class="token punctuation">,</span>                          <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> K_ERR_NONE<span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"TencentOS Create task2 fail! code : %d \r\n"</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_knl_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Start TOS Tiny</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190925193400985.png?" alt="现象"></p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台回复 “ 19 ” 获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> TencentOS tiny </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TencentOS tiny </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TencentOS  tiny】深度源码分析（3）——队列</title>
      <link href="/tencentos-tiny-5/"/>
      <url>/tencentos-tiny-5/</url>
      
        <content type="html"><![CDATA[<h1 id="队列基本概念"><a href="#队列基本概念" class="headerlink" title="队列基本概念"></a>队列基本概念</h1><p>队列是一种常用于任务间通信的数据结构，队列可以在<code>任务与任务间、中断和任务间</code>传递消息，实现了任务接收来自其他任务或中断的不固定长度的消息，任务能够从队列里面读取消息，当队列中的消息是空时，读取消息的任务将被阻塞，用户还可以指定任务等待消息的时间<code>timeout</code>，在这段时间中，如果队列为空，该任务将<code>保持阻塞</code>状态以等待队列数据有效。当队列中有新消息时，被阻塞的任务会被唤醒并处理新消息；当等待的时间超过了指定的阻塞时间，即使队列中尚无有效数据，任务也会自动从阻塞态转为就绪态，消息队列是一种<code>异步</code>的通信方式。</p><p>通过队列服务，任务或中断服务例程可以将一条或多条消息放入队列中。同样，一个或多个任务可以从队列中获得消息。当有多个消息发送到队列时，通常是将先进入队列的消息先传给任务，也就是说，任务先得到的是最先进入队列的消息，即先进先出原则（<code>FIFO</code>），其实<code>TencentOS tiny</code>暂时不支持后进先出原则<code>LIFO</code>操作队列，但是支持后进先出操作<code>消息队列</code>。</p><blockquote><p>提示：<code>TencentOS tiny</code> 的队列不等同于消息队列，虽然<code>队列</code>的底层实现是<strong>依赖</strong><code>消息队列</code>，但在<code>TencentOS tiny</code>中将它们分离开，这是两个概念，毕竟操作是不一样的。</p></blockquote><h1 id="队列的阻塞机制"><a href="#队列的阻塞机制" class="headerlink" title="队列的阻塞机制"></a>队列的阻塞机制</h1><p>举个简单的例子来理解操作系统中的阻塞机制：</p><blockquote><p>假设你某天去餐厅吃饭，但是餐厅没菜了，那么你可能会有3个选择，你扭头就走，既然都没菜了，肯定换一家餐厅啊是吧。或者你会选择等一下，说不定老板去买菜了，一会就有菜了呢，就能吃饭。又或者，你觉得这家餐厅非常好吃，吃不到饭你就不走了，在这死等~</p></blockquote><p>同样的：假设有一个任务A对某个队列进行读操作的时候（<code>出队</code>），发现它此时是没有消息的，那么此时任务A有3个选择：第一个选择，任务A扭头就走，既然队列没有消息，那我也不等了，干其它事情去，这样子任务A<code>不会进入阻塞态</code>；第二个选择，任务A还是在这里等等吧，可能过一会队列就有消息，此时任务A会进入阻塞状态，在等待着消息的到来，而任务A的等待时间就<code>由我们自己指定</code>，当阻塞的这段时间中任务A等到了队列的消息，那么任务A就会从阻塞态变成就绪态；假如等待超时了，队列还没消息，那任务A就不等了，从阻塞态中唤醒；第三个选择，任务A死等，不等到消息就不走了，这样子任务A就会进入阻塞态，直到完成读取队列的消息。</p><h1 id="队列实现的数据结构"><a href="#队列实现的数据结构" class="headerlink" title="队列实现的数据结构"></a>队列实现的数据结构</h1><h2 id="队列控制块"><a href="#队列控制块" class="headerlink" title="队列控制块"></a>队列控制块</h2><p><code>TencentOS tiny</code> 通过队列控制块操作队列，其数据类型为<code>k_queue_t</code>，队列控制块由多个元素组成，主要有 <code>pend_obj_t</code> 类型的<code>pend_obj</code>以及<code>k_msg_queue_t</code>类型的<code>msg_queue</code><strong>消息列表</strong>。其实整个队列的实现非常简单，主要靠<code>msg_queue</code>中的<code>queue_head</code>成员变量（这其实是一个消息列表（消息链表）），所有的消息都会被记录在这个消息列表中，当读取消息的时候，会从消息列表读取消息。</p><blockquote><p><strong>继承自内核对象的数据结构 在 \kernel\core\include\tos_pend.h 的 35 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">typedef struct pend_object_st <span class="token punctuation">{</span>    pend_type_t     type<span class="token punctuation">;</span>    k_list_t        list<span class="token punctuation">;</span><span class="token punctuation">}</span> pend_obj_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>消息列表的数据类型（消息队列控制块），在 \kernel\core\include\tos_msg.h 文件的第 13 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">typedef struct k_msg_queue_st <span class="token punctuation">{</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    knl_obj_t       knl_obj<span class="token punctuation">;</span>#endif    k_list_t        queue_head<span class="token punctuation">;</span><span class="token punctuation">}</span> k_msg_queue_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>队列控制块，在 \kernel\core\include\tos_queue.h 文件的第 6 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">typedef struct k_queue_st <span class="token punctuation">{</span>    pend_obj_t      pend_obj<span class="token punctuation">;</span>    k_msg_queue_t msg_queue<span class="token punctuation">;</span><span class="token punctuation">}</span> k_queue_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>队列控制块示意图如下：</p><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190817012709177.png?" alt=""></p><h2 id="消息控制块"><a href="#消息控制块" class="headerlink" title="消息控制块"></a>消息控制块</h2><p>除了上述的队列控制块外，还有消息队列控制块，这是因为<code>TencentOS tiny</code>中实现队列是依赖消息队列的，既然队列可以传递数据（消息），则必须存在一种可以存储消息的数据结构，我称之为消息控制块，消息控制块中记录了消息的存储地址<code>msg_addr</code>，以及消息的大小<code>msg_size</code>，此外还存在一个<code>list</code>成员变量，可以将消息挂载到队列的消息列表中。</p><blockquote><p><strong>消息控制块数据结构， 在 \kernel\core\include\tos_msg.h 文件的第 7 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">typedef struct k_message_st <span class="token punctuation">{</span>    k_list_t        list<span class="token punctuation">;</span>    <span class="token keyword">void</span>           <span class="token operator">*</span>msg_addr<span class="token punctuation">;</span>    size_t          msg_size<span class="token punctuation">;</span><span class="token punctuation">}</span> k_msg_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190817013938740.png?" alt=""></p><blockquote><p><strong>其实队列的实现依赖于消息队列，他们的关系如下：</strong></p></blockquote><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190923202021286.png?" alt=""></p><h2 id="任务控制块中的消息成员变量"><a href="#任务控制块中的消息成员变量" class="headerlink" title="任务控制块中的消息成员变量"></a>任务控制块中的消息成员变量</h2><p>假设任务A在队列中等待消息，而中断或其他任务往任务A等待的队列写入（发送）一个消息，那么这个消息不会被挂载到队列的消息列表中，而是会直接被记录在任务A的任务控制块中，表示任务A从队列中等待到这个消息，因此任务控制块必须存在一些成员变量用于记录消息相关信息（如消息地址、消息大小等）：</p><blockquote><p><strong>任务控制块数据结构 在\kernel\core\include\tos_task.h文件的第 90 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">typedef struct k_task_st <span class="token punctuation">{</span>···#<span class="token keyword">if</span> TOS_CFG_MSG_EN <span class="token operator">></span> 0u    <span class="token keyword">void</span>               <span class="token operator">*</span>msg_addr<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">/**&lt; 保存接收到的消息地址 */</span>    size_t              msg_size<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/**&lt; 保存接收到的消息大小 */</span>#endif···<span class="token punctuation">}</span> k_task_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="与消息相关的宏定义"><a href="#与消息相关的宏定义" class="headerlink" title="与消息相关的宏定义"></a>与消息相关的宏定义</h2><p>在<code>tos_config.h</code>文件中，使能队列组件的宏定义<code>TOS_CFG_QUEUE_EN</code>，使能消息队列组件宏定义<code>TOS_CFG_MSG_EN</code>，系统支持的消息池中消息个数宏定义<code>TOS_CFG_MSG_POOL_SIZE</code>。</p><pre class="line-numbers language-js"><code class="language-js">#define TOS_CFG_QUEUE_EN                1u#define TOS_CFG_MSG_EN                    1u#define TOS_CFG_MSG_POOL_SIZE           3u<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="消息池"><a href="#消息池" class="headerlink" title="消息池"></a>消息池</h2><p>在<code>TencentOS tiny</code>中定义了一个数组<code>k_msg_pool[TOS_CFG_MSG_POOL_SIZE]</code>作为消息池，它的数据类型是消息控制块类型<code>k_msg_t</code>，因为在使用消息队列的时候存取消息比较频繁，而在系统初始化的时候就将这个大数组的各个元素串初始化，并挂载到空闲消息列表中<code>k_msg_freelist</code>，组成我们说的消息池<code>k_msg_pool</code>，而池中的成员变量就是我们所说的消息。</p><blockquote><p>为什么使用池化的方式处理消息呢，因为高效，复用率高，就像我们在池塘中去一勺水，在使用完毕再将其归还到池塘，这种操作是非常高效的，并且在有限资源的嵌入式中能将资源重复有效地利用起来。</p></blockquote><blockquote><p><strong>消息池相关的定义 在\kernel\core\tos_global.c文件 第 51 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">#<span class="token keyword">if</span> TOS_CFG_MSG_EN <span class="token operator">></span> 0u<span class="token function">TOS_LIST_DEFINE</span><span class="token punctuation">(</span>k_msg_freelist<span class="token punctuation">)</span><span class="token punctuation">;</span>k_msg_t             k_msg_pool<span class="token punctuation">[</span>TOS_CFG_MSG_POOL_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="队列创建"><a href="#队列创建" class="headerlink" title="队列创建"></a>队列创建</h1><p><code>tos_queue_create()</code>函数用于创建一个队列，队列就是一个数据结构，用于任务间的数据的传递。每创建一个新的队列都需要为其分配RAM，在创建的时候我们需要自己定义一个队列控制块，其内存是由编译器自动分配的。在创建的过程中实际上就是将队列控制块的内容进行初始化，将队列控制块的 <code>pend_obj</code>成员变量中的<code>type</code> 属性标识为<code>PEND_TYPE_QUEUE</code>，表示这是一个队列，然后调用消息队列中的API函数<code>tos_msg_queue_create()</code>将队列的消息成员变量<code>msg_queue</code>初始化，实际上就是初始化消息列表。</p><blockquote><p><strong>创建队列函数，在\kernel\core\tos_queue.c 第 5 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_queue_create</span><span class="token punctuation">(</span>k_queue_t <span class="token operator">*</span>queue<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pend_object_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_QUEUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_msg_queue_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>msg_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="销毁队列"><a href="#销毁队列" class="headerlink" title="销毁队列"></a>销毁队列</h1><p><code>tos_queue_destroy()</code>函数用于销毁一个队列，当队列不在使用是可以将其销毁，销毁的本质其实是将队列控制块的内容进行清除，首先判断一下队列控制块的类型是<code>PEND_TYPE_QUEUE</code>，这个函数只能销毁队列类型的控制块。然后判断是否有任务在等待队列中的消息，如果有则调用<code>pend_wakeup_all()</code>函数将这项任务唤醒，然后调用<code>tos_msg_queue_flush()</code>函数将队列的消息列表的消息全部“<code>清空</code>”，“清空”的意思是将挂载到队列上的消息释放回消息池（如果队列的消息列表存在消息，使用<code>msgpool_free()</code>函数释放消息），<code>knl_object_deinit()</code>函数是为了确保队列已经被销毁，此时队列控制块的<code>pend_obj</code>成员变量中的<code>type</code> 属性标识为<code>KNL_OBJ_TYPE_NONE</code>。最后在销毁队列后进行一次任务调度，以切换任务（毕竟刚刚<strong>很可能</strong>唤醒了任务）。</p><blockquote><p>但是有一点要注意，因为队列控制块的RAM是由编译器静态分配的，所以即使是销毁了队列，这个内存也是没办法释放的~</p></blockquote><blockquote><p><strong>销毁队列函数，在\kernel\core\tos_queue.c 第 14 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_queue_destroy</span><span class="token punctuation">(</span>k_queue_t <span class="token operator">*</span>queue<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_QUEUE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_is_nopending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">pend_wakeup_all</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_STATE_DESTROY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pend_object_deinit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_msg_queue_flush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>msg_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="清空队列"><a href="#清空队列" class="headerlink" title="清空队列"></a>清空队列</h1><p>清空队列实际上就是将消息释放回消息池中，本质上还是调用<code>tos_msg_queue_flush()</code>函数。它是依赖于消息队列实现的。</p><blockquote><p><strong>清空队列函数，在\kernel\core\tos_queue.c 第 41 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_queue_flush</span><span class="token punctuation">(</span>k_queue_t <span class="token operator">*</span>queue<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_QUEUE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_msg_queue_flush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>msg_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="等待队列（消息）"><a href="#等待队列（消息）" class="headerlink" title="等待队列（消息）"></a>等待队列（消息）</h1><p>当任务试图从队列中的获取消息时，用户可以指定一个等待时间，当且仅当队列存在消息的时候，任务才能获取到消息。在等待的这段时间中，如果队列为空，该任务将保持阻塞状态以等待队列消息有效。当其他任务或中断服务程序往其等待的队列中写入了数据，该任务将自动由阻塞态转为就绪态。当任务等待发生超时，即使队列中尚无有效消息，任务也会自动从阻塞态转为就绪态。<br>等待队列的过程也是非常简单的，先来看看参数吧（其中<code>msg_addr</code>与<code>msg_size</code>参数是用于保存函数返回的内容，即输出）：<br>| 参数 | 说明 |<br>|–|–|<br>| queue | 队列控制块指针 |<br>| msg_addr| 用于保存获取到的消息（这是输出的） |<br>| msg_size| 用于保存获取到消息的大小（这是输出的） |<br>| timeout| 等待时间（以k_tick_t为单位） |</p><p>等待队列消息的过程如下：</p><ol><li><p>首先检测传入的参数是否正确</p></li><li><p>尝试调用<code>tos_msg_queue_get()</code>函数获取消息，如果队列存在消息则会获取成功（返回<code>K_ERR_NONE</code>），否则获取失败。（关于该函数在下一章讲解）</p></li><li><p>当获取成功则可以直接退出函数，而当获取消息失败的时候，则可以根据指定的等待时间<code>timeout</code>进行阻塞，如果不等待（<code>timeout =TOS_TIME_NOWAIT</code>），则直接返回错误代码<code>K_ERR_PEND_NOWAIT</code>。</p></li><li><p>如果调度器被锁了<code>knl_is_sched_locked()</code>，则无法进行等待操作，返回错误代码<code>K_ERR_PEND_SCHED_LOCKED</code>，毕竟需要切换任务，调度器被锁则无法切换任务。</p></li><li><p>调用<code>pend_task_block()</code>函数将任务阻塞，该函数实际上就是将任务从就绪列表中移除<code>k_rdyq.task_list_head[task_prio]</code>，并且插入到等待列表中<code>object-&gt;list</code>，如果等待的时间不是永久等待<code>TOS_TIME_FOREVER</code>，还会将任务插入时间列表中<code>k_tick_list</code>，阻塞时间为<code>timeout</code>，然后进行一次任务调度<code>knl_sched()</code>。</p></li><li><p>当程序能执行到<code>pend_state2errno()</code>时，则表示<code>任务等待到消息</code>，又或者<code>发生超时</code>，那么就调用<code>pend_state2errno()</code>函数获取一下任务的等待状态，看一下是哪种情况导致任务恢复运行。</p></li><li><p>如果是正常情况（等待获取到消息），则将消息从任务控制块的<code>k_curr_task-&gt;msg_addr</code>读取出来，并且写入<code>msg_addr</code> 中用于返回。同样的消息的大小也是会通过<code>msg_size</code>返回。</p></li></ol><blockquote><p><strong>获取（等待）队列消息函数，在\kernel\core\tos_queue.c 第 60 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_queue_pend</span><span class="token punctuation">(</span>k_queue_t <span class="token operator">*</span>queue<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">**</span>msg_addr<span class="token punctuation">,</span> size_t <span class="token operator">*</span>msg_size<span class="token punctuation">,</span> k_tick_t timeout<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_err_t err<span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>msg_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>msg_size<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_QUEUE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tos_msg_queue_get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>msg_queue<span class="token punctuation">,</span> msg_addr<span class="token punctuation">,</span> msg_size<span class="token punctuation">)</span> <span class="token operator">==</span> K_ERR_NONE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout <span class="token operator">==</span> TOS_TIME_NOWAIT<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>msg_addr <span class="token operator">=</span> K_NULL<span class="token punctuation">;</span>        <span class="token operator">*</span>msg_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_PEND_NOWAIT<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">knl_is_sched_locked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_PEND_SCHED_LOCKED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pend_task_block</span><span class="token punctuation">(</span>k_curr_task<span class="token punctuation">,</span> <span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    err <span class="token operator">=</span> <span class="token function">pend_state2errno</span><span class="token punctuation">(</span>k_curr_task<span class="token operator">-</span><span class="token operator">></span>pend_state<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">==</span> K_ERR_NONE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>msg_addr <span class="token operator">=</span> k_curr_task<span class="token operator">-</span><span class="token operator">></span>msg_addr<span class="token punctuation">;</span>        <span class="token operator">*</span>msg_size <span class="token operator">=</span> k_curr_task<span class="token operator">-</span><span class="token operator">></span>msg_size<span class="token punctuation">;</span>        k_curr_task<span class="token operator">-</span><span class="token operator">></span>msg_addr <span class="token operator">=</span> K_NULL<span class="token punctuation">;</span>        k_curr_task<span class="token operator">-</span><span class="token operator">></span>msg_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> err<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>将等待消息的任务添加到对应等待列表函数，在\kernel\core\tos_pend.c文件的 第 106 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ <span class="token keyword">void</span> <span class="token function">pend_task_block</span><span class="token punctuation">(</span>k_task_t <span class="token operator">*</span>task<span class="token punctuation">,</span> pend_obj_t <span class="token operator">*</span>object<span class="token punctuation">,</span> k_tick_t timeout<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">readyqueue_remove</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pend_list_add</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> object<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout <span class="token operator">!=</span> TOS_TIME_FOREVER<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">tick_list_add</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>获取任务等待状态的函数，在\kernel\core\tos_pend.c文件的 第 72 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ k_err_t <span class="token function">pend_state2errno</span><span class="token punctuation">(</span>pend_state_t state<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> PEND_STATE_POST<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> PEND_STATE_TIMEOUT<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_PEND_TIMEOUT<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> PEND_STATE_DESTROY<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_PEND_DESTROY<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> PEND_STATE_OWNER_DIE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_PEND_OWNER_DIE<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_PEND_ABNORMAL<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="（消息）写入队列"><a href="#（消息）写入队列" class="headerlink" title="（消息）写入队列"></a>（消息）写入队列</h1><p>任务或者中断服务程序都可以给消息队列发送消息，当发送消息时，<code>TencentOS tiny</code>会从消息池中取出一个消息，挂载到队列的消息列表末尾（FIFO发送方式）。<code>tos_queue_post()</code>是唤醒一个等待队列消息任务，<code>tos_queue_post_all()</code>则会唤醒所有等待队列消息的任务，无论何种情况，都是调用<code>queue_do_post</code>将消息写入队列中。<br>消息的写入队列过程：</p><ol><li><p>首先检测传入的参数是否正确</p></li><li><p>判断一下是否有任务在等待消息，如果有则根据<code>opt</code>参数决定唤醒一个任务或者所有等待任务，否则直接将消息写入队列中。</p></li><li><p>当没有任务在等待消息时，调用<code>tos_msg_queue_put()</code>函数将消息写入队列，写入队列的方式遵循<code>FIFO</code>原则（<code>TOS_OPT_MSG_PUT_FIFO</code>），写入成功返回<code>K_ERR_NONE</code>。而如果消息池已经没有消息了（消息最大个数由<code>TOS_CFG_MSG_POOL_SIZE</code>宏定义决定），则写入失败，返回<code>K_ERR_QUEUE_FULL</code>错误代码。（关于该函数将在下一章讲解）</p></li><li><p>如果有任务在等待消息，则调用<code>queue_task_msg_recv()</code>函数将消息内容与大小写入任务控制块的<code>msg_addr</code>与<code>msg_size</code>成员变量中，此外还需要唤醒任务，就通过调用<code>pend_task_wakeup()</code>函数将对应的等待任务唤醒，核心处理思想就是通过<code>TOS_LIST_FIRST_ENTRY</code>获取到等待在队列上的任务，然后唤醒它。</p></li><li><p>对于唤醒所有等待任务的处理其实也是一样的，只不过是多了个循环处理，把等待列表中的所有任务依次唤醒，仅此而已~</p></li></ol><blockquote><p><strong>写入队列消息函数，在\kernel\core\tos_queue.c 第 159 、164 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_queue_post</span><span class="token punctuation">(</span>k_queue_t <span class="token operator">*</span>queue<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>msg_addr<span class="token punctuation">,</span> size_t msg_size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>msg_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">queue_do_post</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> msg_addr<span class="token punctuation">,</span> msg_size<span class="token punctuation">,</span> OPT_POST_ONE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>__API__ k_err_t <span class="token function">tos_queue_post_all</span><span class="token punctuation">(</span>k_queue_t <span class="token operator">*</span>queue<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>msg_addr<span class="token punctuation">,</span> size_t msg_size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>msg_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">queue_do_post</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> msg_addr<span class="token punctuation">,</span> msg_size<span class="token punctuation">,</span> OPT_POST_ALL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>写入队列消息函数实际调用的函数，通过<code>opt</code>参数进行不一样的处理，在\kernel\core\tos_queue.c 第 118 行</strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js">__STATIC__ k_err_t <span class="token function">queue_do_post</span><span class="token punctuation">(</span>k_queue_t <span class="token operator">*</span>queue<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>msg_addr<span class="token punctuation">,</span> size_t msg_size<span class="token punctuation">,</span> opt_post_t opt<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_list_t <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pend_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">,</span> PEND_TYPE_QUEUE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pend_is_nopending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tos_msg_queue_put</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>msg_queue<span class="token punctuation">,</span> msg_addr<span class="token punctuation">,</span> msg_size<span class="token punctuation">,</span> TOS_OPT_MSG_PUT_FIFO<span class="token punctuation">)</span> <span class="token operator">!=</span> K_ERR_NONE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> K_ERR_QUEUE_FULL<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>opt <span class="token operator">==</span> OPT_POST_ONE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">queue_task_msg_recv</span><span class="token punctuation">(</span><span class="token function">TOS_LIST_FIRST_ENTRY</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">.</span>list<span class="token punctuation">,</span> k_task_t<span class="token punctuation">,</span> pend_list<span class="token punctuation">)</span><span class="token punctuation">,</span>                                msg_addr<span class="token punctuation">,</span> msg_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// OPT_QUEUE_POST_ALL</span>        <span class="token function">TOS_LIST_FOR_EACH_SAFE</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>queue<span class="token operator">-</span><span class="token operator">></span>pend_obj<span class="token punctuation">.</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">queue_task_msg_recv</span><span class="token punctuation">(</span><span class="token function">TOS_LIST_ENTRY</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> k_task_t<span class="token punctuation">,</span> pend_list<span class="token punctuation">)</span><span class="token punctuation">,</span>                                msg_addr<span class="token punctuation">,</span> msg_size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>唤醒等待的任务函数，在\kernel\core\tos_pend.c文件 的第 87 行</strong></p></blockquote><p>唤醒等待任务的思想就是将任务从对应的等待列表移除，然后添加到就绪列表中。</p><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ <span class="token keyword">void</span> <span class="token function">pend_task_wakeup</span><span class="token punctuation">(</span>k_task_t <span class="token operator">*</span>task<span class="token punctuation">,</span> pend_state_t state<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">task_state_is_pending</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// mark why we wakeup</span>        task<span class="token operator">-</span><span class="token operator">></span>pend_state <span class="token operator">=</span> state<span class="token punctuation">;</span>        <span class="token function">pend_list_remove</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">task_state_is_sleeping</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">tick_list_remove</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">task_state_is_suspended</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">readyqueue_add</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>代码精悍短小，思想清晰，非常建议深入学习~</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> TencentOS tiny </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TencentOS tiny </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TencentOS  tiny】深度源码分析（2）——调度器</title>
      <link href="/tencentos-tiny-4/"/>
      <url>/tencentos-tiny-4/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>温馨提示：本文不描述与浮点相关的寄存器的内容，如需了解自行查阅（毕竟我自己也不懂）</strong></p></blockquote><h1 id="调度器的基本概念"><a href="#调度器的基本概念" class="headerlink" title="调度器的基本概念"></a>调度器的基本概念</h1><p><code>TencentOS tiny</code>中提供的任务调度器是基于优先级的全抢占式调度，在系统运行过程中，当有比当前任务优先级更高的任务就绪时，当前任务将立刻被<code>切出</code>，高优先级任务<code>抢占</code>处理器运行。</p><p><code>TencentOS tiny</code>内核中也允许创建相同优先级的任务。相同优先级的任务采用时间片轮转方式进行调度（也就是通常说的分时调度器），时间片轮转调度仅在当前系统中<strong>无更高优先级就绪任务</strong>的情况下才有效。</p><p>为了保证系统的实时性，系统尽最大可能地保证高优先级的任务得以运行。任务调度的原则是一旦任务状态发生了改变，并且当前运行的任务优先级小于优先级队列中任务最高优先级时，立刻进行任务切换（除非当前系统处于中断处理程序中或禁止任务切换的状态）。</p><p>调度器是操作系统的<code>核心</code>，其主要功能就是<code>实现任务的切换</code>，即从就绪列表里面<code>找到</code>优先级最高的任务，然后去<code>执行</code>该任务。</p><h1 id="启动调度器"><a href="#启动调度器" class="headerlink" title="启动调度器"></a>启动调度器</h1><p>调度器的启动由<code>cpu_sched_start</code>函数来完成，它会被<code>tos_knl_start</code>函数调用，这个函数中主要做两件事，首先通过<code>readyqueue_highest_ready_task_get</code>函数获取当前系统中处于最高优先级的就绪任务，并且将它赋值给指向当前任务控制块的指针<code>k_curr_task</code>，然后设置一下系统的状态为运行态<code>KNL_STATE_RUNNING</code>。</p><p>当然最重要的是调用汇编代码写的函数<code>cpu_sched_start</code>启动调度器，该函数在源码的<code>arch\arm\arm-v7m</code>目录下的<code>port_s.S</code>汇编文件下，<code>TencentOS tiny</code>支持多种内核的芯片，如<code>M3/M4/M7</code>等，不同的芯片该函数的实现方式不同，<code>port_s.S</code>也是<code>TencentOS tiny</code>作为软件与CPU硬件连接的<code>桥梁</code>。以M4的<code>cpu_sched_start</code>举个例子：</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_knl_start</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tos_knl_is_running</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_KNL_RUNNING<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    k_next_task <span class="token operator">=</span> <span class="token function">readyqueue_highest_ready_task_get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_curr_task <span class="token operator">=</span> k_next_task<span class="token punctuation">;</span>    k_knl_state <span class="token operator">=</span> KNL_STATE_RUNNING<span class="token punctuation">;</span>    <span class="token function">cpu_sched_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">port_sched_start    CPSID   I        <span class="token punctuation">;</span> <span class="token keyword">set</span> pendsv priority lowest    <span class="token punctuation">;</span> otherwise trigger pendsv <span class="token keyword">in</span> port_irq_context_switch will cause a context swich <span class="token keyword">in</span> irq    <span class="token punctuation">;</span> that would be a disaster    MOV32   R0<span class="token punctuation">,</span> NVIC_SYSPRI14    MOV32   R1<span class="token punctuation">,</span> NVIC_PENDSV_PRI    STRB    R1<span class="token punctuation">,</span> <span class="token punctuation">[</span>R0<span class="token punctuation">]</span>    LDR     R0<span class="token punctuation">,</span> <span class="token operator">=</span>SCB_VTOR    LDR     R0<span class="token punctuation">,</span> <span class="token punctuation">[</span>R0<span class="token punctuation">]</span>    LDR     R0<span class="token punctuation">,</span> <span class="token punctuation">[</span>R0<span class="token punctuation">]</span>    MSR     MSP<span class="token punctuation">,</span> R0    <span class="token punctuation">;</span> k_curr_task <span class="token operator">=</span> k_next_task    MOV32   R0<span class="token punctuation">,</span> k_curr_task    MOV32   R1<span class="token punctuation">,</span> k_next_task    LDR     R2<span class="token punctuation">,</span> <span class="token punctuation">[</span>R1<span class="token punctuation">]</span>    STR     R2<span class="token punctuation">,</span> <span class="token punctuation">[</span>R0<span class="token punctuation">]</span>    <span class="token punctuation">;</span> sp <span class="token operator">=</span> k_next_task<span class="token operator">-</span><span class="token operator">></span>sp    LDR     R0<span class="token punctuation">,</span> <span class="token punctuation">[</span>R2<span class="token punctuation">]</span>    <span class="token punctuation">;</span> PSP <span class="token operator">=</span> sp    MSR     PSP<span class="token punctuation">,</span> R0    <span class="token punctuation">;</span> using PSP    MRS     R0<span class="token punctuation">,</span> CONTROL    ORR     R0<span class="token punctuation">,</span> R0<span class="token punctuation">,</span> #<span class="token number">2</span>    MSR     CONTROL<span class="token punctuation">,</span> R0    ISB    <span class="token punctuation">;</span> restore r4<span class="token number">-11</span> <span class="token keyword">from</span> <span class="token keyword">new</span> <span class="token class-name">process</span> stack    LDMFD   SP<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>R4 <span class="token operator">-</span> R11<span class="token punctuation">}</span>    IF <span class="token punctuation">{</span>FPU<span class="token punctuation">}</span> <span class="token operator">!=</span> <span class="token string">"SoftVFP"</span>    <span class="token punctuation">;</span> ignore EXC_RETURN the first <span class="token keyword">switch</span>    LDMFD   SP<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>R0<span class="token punctuation">}</span>    ENDIF    <span class="token punctuation">;</span> restore r0<span class="token punctuation">,</span> r3    LDMFD    SP<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>R0 <span class="token operator">-</span> R3<span class="token punctuation">}</span>    <span class="token punctuation">;</span> load R12 and LR    LDMFD    SP<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>R12<span class="token punctuation">,</span> LR<span class="token punctuation">}</span>    <span class="token punctuation">;</span> load PC and discard xPSR    LDMFD    SP<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>R1<span class="token punctuation">,</span> R2<span class="token punctuation">}</span>    CPSIE    I    BX       R1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Cortex-M内核关中断指令"><a href="#Cortex-M内核关中断指令" class="headerlink" title="Cortex-M内核关中断指令"></a>Cortex-M内核关中断指令</h2><p>从上面的汇编代码，我又想介绍一下<code>Cortex-M</code>内核关中断指令，唉~感觉还是有点麻烦！<br>为了快速地开关中断， Cortex-M内核专门设置了一条 <code>CPS 指令</code>，用于操作<code>PRIMASK</code>寄存器跟<code>FAULTMASK</code>寄存器的，这两个寄存器是与屏蔽中断有关的，除此之外<code>Cortex-M</code>内核还存在<code>BASEPRI</code>寄存器也是与中断有关的，也顺带介绍一下吧。</p><pre class="line-numbers language-js"><code class="language-js">CPSID I     <span class="token punctuation">;</span>PRIMASK<span class="token operator">=</span><span class="token number">1</span>     <span class="token punctuation">;</span>关中断CPSIE I     <span class="token punctuation">;</span>PRIMASK<span class="token operator">=</span><span class="token number">0</span>     <span class="token punctuation">;</span>开中断CPSID F     <span class="token punctuation">;</span>FAULTMASK<span class="token operator">=</span><span class="token number">1</span>   <span class="token punctuation">;</span>关异常CPSIE F     <span class="token punctuation">;</span>FAULTMASK<span class="token operator">=</span><span class="token number">0</span>   <span class="token punctuation">;</span>开异常<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>寄存器</th><th>功能</th></tr></thead><tbody><tr><td>PRIMASK</td><td>它被置 1 后，就关掉所有可屏蔽的异常，只剩下 NMI 和HardFault FAULT可以响应</td></tr><tr><td>FAULTMASK</td><td>当它置 1 时，只有 NMI 才能响应，所有其它的异常都无法响应（包括HardFault FAULT）</td></tr><tr><td>BASEPRI</td><td>这个寄存器最多有 9 位（由表达优先级的位数决定）。它定义了被屏蔽优先级的阈值。当它被设成某个值后，所有优先级号大于等于此值的中断都被关（优先级号越大，优先级越低）。但若被设成 0，则不关闭任何中断</td></tr></tbody></table><p>更多具体的描述看我以前的文章：<a href="https://blog.csdn.net/jiejiemcu/article/details/82534974" target="_blank" rel="noopener">RTOS临界段知识：https://blog.csdn.net/jiejiemcu/article/details/82534974</a></p><h2 id="回归正题"><a href="#回归正题" class="headerlink" title="回归正题"></a>回归正题</h2><p>在启动内核调度器过程中需要配置<code>PendSV</code> 的中断优先级为最低，就是往<code>NVIC_SYSPRI14（0xE000ED22）</code>地址写入<code>NVIC_PENDSV_PRI（0xFF）</code>。因为<code>PendSV</code>都会涉及到系统调度，系统调度的优先级要<code>低于</code>系统的其它硬件中断优先级，即优先响应系统中的外部硬件中断，所以PendSV的中断优先级要配置为最低，不然很可能在中断上下文中产生任务调度。</p><p><code>PendSV</code> 异常会自动延迟上下文切换的请求，直到其它的 <code>ISR</code> 都完成了处理后才放行。为实现这个机制，需要把 <code>PendSV</code> 编程为最低优先级的异常。如果 <code>OS</code> 检测到某 <code>ISR</code> 正在活动，它将悬起一个 <code>PendSV</code> 异常，以便缓期执行上下文切换。也就是说，只要将<code>PendSV</code>的优先级设为最低的，systick即使是打断了IRQ，它也不会马上进行上下文切换，而是等到<code>ISR</code>执行完，<code>PendSV</code> 服务例程才开始执行，并且在里面执行上下文切换。过程如图所示：<br><img src="./images/loading.png" data-original="https://img-blog.csdn.net/20180714005652198?" alt=""><br>然后获取<code>MSP</code>主栈指针的地址，在<code>Cortex-M</code>中，<code>0xE000ED08</code>是<code>SCB_VTOR</code>寄存器的地址，里面存放的是向量表的起始地址。</p><p>加载<code>k_next_task</code>指向的任务控制块到 <code>R2</code>，从上一篇文章可知任务控制块的第一个成员就是栈顶指针，所以此时<code>R2</code>等于栈顶指针。</p><blockquote><p>ps : 在调度器启动时，<code>k_next_task</code>与<code>k_curr_task</code>是一样的（<code>k_curr_task = k_next_task</code>）</p></blockquote><p>加载<code>R2</code>到<code>R0</code>，然后将栈顶指针<code>R0</code>更新到<code>psp</code>，任务执行的时候使用的栈指针是<code>psp</code>。</p><blockquote><p>ps：<code>sp</code>指针有两个，分别为<code>psp</code>和<code>msp</code>。（可以简单理解为：在任务上下文环境中使用<code>psp</code>，在中断上下文环境使用<code>msp</code>，也不一定是正确的，这是我个人的理解）</p></blockquote><p>以<code>R0</code>为基地址，将栈中向上增长的<code>8</code>个字的内容加载到CPU寄存器<code>R4~R11</code>，同时<code>R0</code>也会跟着自增</p><p>接着需要加载<code>R0 ~ R3、R12以及LR、 PC、xPSR</code>到CPU寄存器组，PC指针指向的是即将要运行的线程，而LR寄存器则指向任务的退出。<code>因为这是第一次启动任务，要全部手动把任务栈上的寄存器弹到硬件里，才能进入第一个任务的上下文，因为一开始并没有第一个任务运行的上下文环境，而在进入PendSV的时候需要上文保存，所以需要手动创造任务上下文环境（将这些寄存器加载到CPU寄存器组中）</code>，第一次的时候此汇编入口函数，sp是指向一个选好的任务的栈顶（<code>k_curr_task</code>）。</p><h2 id="看看任务栈的初始化"><a href="#看看任务栈的初始化" class="headerlink" title="看看任务栈的初始化"></a>看看任务栈的初始化</h2><p>从上面的了解，再来看看任务栈的初始化，可能会有更深一点的印象。主要了解以下几点即可：</p><ul><li><p>获取栈顶指针为<code>stk_base[stk_size]</code>高地址，<code>Cortex-M</code>内核的栈是<code>向下增长</code>的。</p></li><li><p><code>R0、R1、R2、R3、R12、R14、R15和xPSR的位24</code>是会被CPU<code>自动</code>加载与保存的。</p></li><li><p>xPSR的<code>bit24必须置1</code>，即0x01000000。</p></li><li><p>entry是任务的入口地址，即<code>PC</code></p></li><li><p>R14 (<code>LR</code>)是任务的退出地址，所以任务一般是死循环而不会<code>return</code></p></li><li><p>R0: arg是任务主体的形参</p></li><li><p>初始化栈时sp指针会自减</p><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ k_stack_t <span class="token operator">*</span><span class="token function">cpu_task_stk_init</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>entry<span class="token punctuation">,</span>                                           <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span>                                           <span class="token keyword">void</span> <span class="token operator">*</span>exit<span class="token punctuation">,</span>                                           k_stack_t <span class="token operator">*</span>stk_base<span class="token punctuation">,</span>                                           size_t stk_size<span class="token punctuation">)</span><span class="token punctuation">{</span> cpu_data_t <span class="token operator">*</span>sp<span class="token punctuation">;</span> sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>stk_base<span class="token punctuation">[</span>stk_size<span class="token punctuation">]</span><span class="token punctuation">;</span> sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cpu_addr_t<span class="token punctuation">)</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFFFFFFF8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* auto-saved on exception(pendSV) by hardware */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x01000000u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* xPSR     */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>entry<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* entry    */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>exit<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">/* R14 (LR) */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x12121212u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R12      */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x03030303u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R3       */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x02020202u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R2       */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x01010101u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R1       */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>arg<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* R0: arg  */</span> <span class="token comment" spellcheck="true">/* Remaining registers saved on process stack */</span> <span class="token comment" spellcheck="true">/* EXC_RETURN = 0xFFFFFFFDL    Initial state: Thread mode +  non-floating-point state + PSP    31 - 28 : EXC_RETURN flag, 0xF    27 -  5 : reserved, 0xFFFFFE    4       : 1, basic stack frame; 0, extended stack frame    3       : 1, return to Thread mode; 0, return to Handler mode    2       : 1, return to PSP; 0, return to MSP    1       : reserved, 0    0       : reserved, 1  */</span>#<span class="token keyword">if</span> defined <span class="token punctuation">(</span>TOS_CFG_CPU_ARM_FPU_EN<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>TOS_CFG_CPU_ARM_FPU_EN <span class="token operator">==</span> 1U<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0xFFFFFFFDL<span class="token punctuation">;</span>#endif <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x11111111u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R11      */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x10101010u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R10      */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x09090909u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R9       */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x08080808u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R8       */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x07070707u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R7       */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x06060606u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R6       */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x05050505u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R5       */</span> <span class="token operator">*</span><span class="token operator">--</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>cpu_data_t<span class="token punctuation">)</span>0x04040404u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* R4       */</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>k_stack_t <span class="token operator">*</span><span class="token punctuation">)</span>sp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="查找最高优先级任务"><a href="#查找最高优先级任务" class="headerlink" title="查找最高优先级任务"></a>查找最高优先级任务</h1><p>一个操作系统如果只是具备了高优先级任务能够<code>立即</code>获得处理器并得到执行的特点，那么它仍然不算是实时操作系统。因为这个查找最高优先级任务的过程决定了调度时间是否具有确定性，可以简单来说可以使用<code>时间复杂度</code>来描述一下吧，如果系统查找最高优先级任务的时间是<code>O(N)</code>，那么这个时间会随着任务个数的增加而增大，这是不可取的，<code>TencentOS tiny</code>的时间复杂度是<code>O(1)</code>，它提供两种方法查找最高优先级任务，通过<code>TOS_CFG_CPU_LEAD_ZEROS_ASM_PRESENT</code>宏定义决定。</p></li></ul><ol><li>第一种是使用普通方法，根据就绪列表中<code>k_rdyq.prio_mask[]</code>的变量判断对应的位是否被置1。</li><li>第二种方法则是特殊方法，利用计算前导零指令<code>CLZ</code>，直接在<code>k_rdyq.prio_mask[]</code>这个<code>32</code>位的变量中直接得出最高优先级所处的位置，这种方法比普通方法更快捷，<code>但受限于平台</code>（需要硬件前导零指令，在STM32中我们就可以使用这种方法）。</li></ol><p>实现过程如下，建议看一看<code>readyqueue_prio_highest_get</code>函数，他的实现还是非常精妙的~</p><pre class="line-numbers language-js"><code class="language-js">__STATIC__ k_prio_t <span class="token function">readyqueue_prio_highest_get</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    uint32_t <span class="token operator">*</span>tbl<span class="token punctuation">;</span>    k_prio_t prio<span class="token punctuation">;</span>    prio    <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    tbl     <span class="token operator">=</span> <span class="token operator">&amp;</span>k_rdyq<span class="token punctuation">.</span>prio_mask<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>tbl <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        prio <span class="token operator">+</span><span class="token operator">=</span> K_PRIO_TBL_SLOT_SIZE<span class="token punctuation">;</span>        <span class="token operator">++</span>tbl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    prio <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">tos_cpu_clz</span><span class="token punctuation">(</span><span class="token operator">*</span>tbl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> prio<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">__API__ uint32_t <span class="token function">tos_cpu_clz</span><span class="token punctuation">(</span>uint32_t val<span class="token punctuation">)</span><span class="token punctuation">{</span>#<span class="token keyword">if</span> <span class="token function">defined</span><span class="token punctuation">(</span>TOS_CFG_CPU_LEAD_ZEROS_ASM_PRESENT<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>TOS_CFG_CPU_LEAD_ZEROS_ASM_PRESENT <span class="token operator">==</span> 0u<span class="token punctuation">)</span>    uint32_t nbr_lead_zeros <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>val <span class="token operator">&amp;</span> 0XFFFF0000<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">&lt;</span><span class="token operator">&lt;=</span> <span class="token number">16</span><span class="token punctuation">;</span>        nbr_lead_zeros <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>val <span class="token operator">&amp;</span> 0XFF000000<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">&lt;</span><span class="token operator">&lt;=</span> <span class="token number">8</span><span class="token punctuation">;</span>        nbr_lead_zeros <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>val <span class="token operator">&amp;</span> 0XF0000000<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">&lt;</span><span class="token operator">&lt;=</span> <span class="token number">4</span><span class="token punctuation">;</span>        nbr_lead_zeros <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>val <span class="token operator">&amp;</span> 0XC0000000<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">&lt;</span><span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">;</span>        nbr_lead_zeros <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>val <span class="token operator">&amp;</span> 0X80000000<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        nbr_lead_zeros <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        nbr_lead_zeros <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>nbr_lead_zeros<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">else</span>    <span class="token keyword">return</span> <span class="token function">port_clz</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>#endif<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="任务切换的实现"><a href="#任务切换的实现" class="headerlink" title="任务切换的实现"></a>任务切换的实现</h1><p>从前面我们也知道，任务切换是在<code>PendSV</code>中断中进行的，这个中断中实现的内容总结成一句精髓的话就是 <strong>上文保存，下文切换</strong>，直接看源代码：</p><pre class="line-numbers language-js"><code class="language-js">PendSV_Handler    CPSID   I    MRS     R0<span class="token punctuation">,</span> PSP_context_save    <span class="token punctuation">;</span> R0<span class="token operator">-</span>R3<span class="token punctuation">,</span> R12<span class="token punctuation">,</span> LR<span class="token punctuation">,</span> PC<span class="token punctuation">,</span> xPSR is saved automatically here    IF <span class="token punctuation">{</span>FPU<span class="token punctuation">}</span> <span class="token operator">!=</span> <span class="token string">"SoftVFP"</span>    <span class="token punctuation">;</span> is it extended frame<span class="token operator">?</span>    TST     LR<span class="token punctuation">,</span> #<span class="token number">0x10</span>    IT      EQ    VSTMDBEQ  R0<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>S16 <span class="token operator">-</span> S31<span class="token punctuation">}</span>    <span class="token punctuation">;</span> S0 <span class="token operator">-</span> S16<span class="token punctuation">,</span> FPSCR saved automatically here    <span class="token punctuation">;</span> save EXC_RETURN    STMFD   R0<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>LR<span class="token punctuation">}</span>    ENDIF    <span class="token punctuation">;</span> save remaining regs r4<span class="token number">-11</span> on process stack    STMFD   R0<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>R4 <span class="token operator">-</span> R11<span class="token punctuation">}</span>    <span class="token punctuation">;</span> k_curr_task<span class="token operator">-</span><span class="token operator">></span>sp <span class="token operator">=</span> PSP    MOV32   R5<span class="token punctuation">,</span> k_curr_task    LDR     R6<span class="token punctuation">,</span> <span class="token punctuation">[</span>R5<span class="token punctuation">]</span>    <span class="token punctuation">;</span> R0 is SP <span class="token keyword">of</span> process being switched out    STR     R0<span class="token punctuation">,</span> <span class="token punctuation">[</span>R6<span class="token punctuation">]</span>_context_restore    <span class="token punctuation">;</span> k_curr_task <span class="token operator">=</span> k_next_task    MOV32   R1<span class="token punctuation">,</span> k_next_task    LDR     R2<span class="token punctuation">,</span> <span class="token punctuation">[</span>R1<span class="token punctuation">]</span>    STR     R2<span class="token punctuation">,</span> <span class="token punctuation">[</span>R5<span class="token punctuation">]</span>    <span class="token punctuation">;</span> R0 <span class="token operator">=</span> k_next_task<span class="token operator">-</span><span class="token operator">></span>sp    LDR     R0<span class="token punctuation">,</span> <span class="token punctuation">[</span>R2<span class="token punctuation">]</span>    <span class="token punctuation">;</span> restore R4 <span class="token operator">-</span> R11    LDMFD   R0<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>R4 <span class="token operator">-</span> R11<span class="token punctuation">}</span>    IF <span class="token punctuation">{</span>FPU<span class="token punctuation">}</span> <span class="token operator">!=</span> <span class="token string">"SoftVFP"</span>    <span class="token punctuation">;</span> restore EXC_RETURN    LDMFD   R0<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>LR<span class="token punctuation">}</span>    <span class="token punctuation">;</span> is it extended frame<span class="token operator">?</span>    TST     LR<span class="token punctuation">,</span> #<span class="token number">0x10</span>    IT      EQ    VLDMIAEQ    R0<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>S16 <span class="token operator">-</span> S31<span class="token punctuation">}</span>    ENDIF    <span class="token punctuation">;</span> Load PSP <span class="token keyword">with</span> <span class="token keyword">new</span> <span class="token class-name">process</span> SP    MSR     PSP<span class="token punctuation">,</span> R0    CPSIE   I    <span class="token punctuation">;</span> R0<span class="token operator">-</span>R3<span class="token punctuation">,</span> R12<span class="token punctuation">,</span> LR<span class="token punctuation">,</span> PC<span class="token punctuation">,</span> xPSR restored automatically here    <span class="token punctuation">;</span> S0 <span class="token operator">-</span> S16<span class="token punctuation">,</span> FPSCR restored automatically here <span class="token keyword">if</span> FPCA <span class="token operator">=</span> <span class="token number">1</span>    BX      LR    ALIGN    END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将<code>PSP</code>的值存储到<code>R0</code>。当进入<code>PendSVC_Handler</code>时，上一个任务运行的环境即： <code>xPSR，PC（任务入口地址），R14，R12，R3，R2，R1，R0</code>这些CPU寄存器的值会<code>自动</code>存储到任务的栈中，此时psp指针已经被自动更新。而剩下的<code>r4~r11</code>需要<code>手动</code>保存，这也是为啥要在<code>PendSVC_Handler</code>中保存上文（<code>_context_save</code>）的原因，主要是加载CPU中不能自动保存的寄存器，将其压入任务栈中。</p><p>接着找到下一个要运行的任务<code>k_next_task</code>，将它的任务栈顶加载到<code>R0</code>，然后手动将新任务栈中的内容（此处是指<code>R4~R11</code>）加载到<code>CPU</code>寄存器组中，这就是下文切换，当然还有一些其他没法自动保存的内容也是需要手动加载到<code>CPU</code>寄存器组的。手动加载完后，此时<code>R0</code>已经被更新了，更新psp的值，在退出<code>PendSVC_Handler</code>中断时，会以<code>psp</code>作为基地址，将任务栈中剩下的内容（<code>xPSR，PC（任务入口地址），R14，R12，R3，R2，R1，R0</code>）自动加载到CPU寄存器。</p><p>其实在异常发生时，R14中保存异常返回标志，包括返回后进入任务模式还是处理器模式、使用PSP堆栈指针还是MSP堆栈指针。此时的r14等于0xfffffffd，最表示异常返回后进入任务模式（毕竟<code>PendSVC_Handler</code>优先级是最低的，会返回到任务中），SP以PSP作为堆栈指针出栈，出栈完毕后<code>PSP</code>指向任务栈的栈顶。当调用 BX R14指令后，系统以<code>PSP</code>作为<code>SP</code>指针出栈，把接下来要运行的新任务的任务栈中剩下的内容加载到CPU寄存器：<code>R0、R1、R2、R3、R12、R14（LR）、R15（PC）和xPSR</code>，从而切换到新的任务。</p><h1 id="SysTick"><a href="#SysTick" class="headerlink" title="SysTick"></a>SysTick</h1><h2 id="SysTick初始化"><a href="#SysTick初始化" class="headerlink" title="SysTick初始化"></a>SysTick初始化</h2><p>systick是系统的时基，而且它是内核时钟，只要是<code>M0/M3/M4/M7</code>内核它都会存在<code>systick</code>时钟，并且它是可以被编程配置的，这就对操作系统的移植提供极大的方便。<br><code>TencentOS tiny</code>会在<code>cpu_init</code>函数中将<code>systick</code>进行初始化，即调用<code>cpu_systick_init</code>函数，这样子就不需要用户自行去编写<code>systick</code>初始化相关的代码。</p><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ <span class="token keyword">void</span> <span class="token function">cpu_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    k_cpu_cycle_per_tick <span class="token operator">=</span> TOS_CFG_CPU_CLOCK <span class="token operator">/</span> k_cpu_tick_per_second<span class="token punctuation">;</span>    <span class="token function">cpu_systick_init</span><span class="token punctuation">(</span>k_cpu_cycle_per_tick<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> <span class="token punctuation">(</span>TOS_CFG_CPU_HRTIMER_EN <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">tos_cpu_hrtimer_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>#endif<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ <span class="token keyword">void</span> <span class="token function">cpu_systick_init</span><span class="token punctuation">(</span>k_cycle_t cycle_per_tick<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">port_systick_priority_set</span><span class="token punctuation">(</span>TOS_CFG_CPU_SYSTICK_PRIO<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">port_systick_config</span><span class="token punctuation">(</span>cycle_per_tick<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="SysTick中断"><a href="#SysTick中断" class="headerlink" title="SysTick中断"></a>SysTick中断</h2><p><code>SysTick</code>中断服务函数是需要我们自己编写的，要在里面调用一下<code>TencentOS tiny</code>相关的函数，更新系统时基以驱动系统的运行，<code>SysTick_Handler</code>函数的移植如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">SysTick_Handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">HAL_IncTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tos_knl_is_running</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">tos_knl_irq_enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_tick_handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_knl_irq_leave</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要是需要调用<code>tos_tick_handler</code>函数将系统时基更新，具体见：</p><pre class="line-numbers language-js"><code class="language-js">__API__ <span class="token keyword">void</span> <span class="token function">tos_tick_handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tos_knl_is_running</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">tick_update</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k_tick_t<span class="token punctuation">)</span>1u<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_TIMER_EN <span class="token operator">></span> 0u <span class="token operator">&amp;&amp;</span> TOS_CFG_TIMER_AS_PROC <span class="token operator">></span> 0u    <span class="token function">timer_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>#endif#<span class="token keyword">if</span> TOS_CFG_ROUND_ROBIN_EN <span class="token operator">></span> 0u    <span class="token function">robin_sched</span><span class="token punctuation">(</span>k_curr_task<span class="token operator">-</span><span class="token operator">></span>prio<span class="token punctuation">)</span><span class="token punctuation">;</span>#endif<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不得不说<code>TencentOS tiny</code>源码的实现非常简单，<code>我非常喜欢</code>，在<code>tos_tick_handler</code>中，首先判断一下系统是否已经开始运行，如果没有运行将直接返回，如果已经运行了，那就调用<code>tick_update</code>函数更新系统时基，如果使能了<code>TOS_CFG_TIMER_EN</code> 宏定义表示使用软件定时器，则需要更新相应的处理，此处暂且不提及。如果使能了<code>TOS_CFG_ROUND_ROBIN_EN</code>宏定义，还需要更新时间片相关变量，稍后讲解。</p><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ <span class="token keyword">void</span> <span class="token function">tick_update</span><span class="token punctuation">(</span>k_tick_t tick<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_task_t <span class="token operator">*</span>first<span class="token punctuation">,</span> <span class="token operator">*</span>task<span class="token punctuation">;</span>    k_list_t <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_tick_count <span class="token operator">+</span><span class="token operator">=</span> tick<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tos_list_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>k_tick_list<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    first <span class="token operator">=</span> <span class="token function">TOS_LIST_FIRST_ENTRY</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>k_tick_list<span class="token punctuation">,</span> k_task_t<span class="token punctuation">,</span> tick_list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token operator">-</span><span class="token operator">></span>tick_expires <span class="token operator">&lt;=</span> tick<span class="token punctuation">)</span> <span class="token punctuation">{</span>        first<span class="token operator">-</span><span class="token operator">></span>tick_expires <span class="token operator">=</span> <span class="token punctuation">(</span>k_tick_t<span class="token punctuation">)</span>0u<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        first<span class="token operator">-</span><span class="token operator">></span>tick_expires <span class="token operator">-</span><span class="token operator">=</span> tick<span class="token punctuation">;</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_LIST_FOR_EACH_SAFE</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>k_tick_list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        task <span class="token operator">=</span> <span class="token function">TOS_LIST_ENTRY</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> k_task_t<span class="token punctuation">,</span> tick_list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token operator">-</span><span class="token operator">></span>tick_expires <span class="token operator">></span> <span class="token punctuation">(</span>k_tick_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// we are pending on something, but tick's up, no longer waitting</span>        <span class="token function">pend_task_wakeup</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> PEND_STATE_TIMEOUT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>tick_update</code>函数的主要功能就是将<code>k_tick_count +1</code>，并且判断一下时基列表<code>k_tick_list</code>（也可以成为延时列表吧）的任务是否超时，如果超时则唤醒该任务，否则就直接退出即可。关于时间片的调度也是非常简单，将任务的剩余时间片变量<code>timeslice</code>减一，然后当变量减到0时，将该变量进行重装载<code>timeslice_reload</code>，然后切换任务<code>knl_sched()</code>，其实现过程如下：</p><pre class="line-numbers language-js"><code class="language-js">__KERNEL__ <span class="token keyword">void</span> <span class="token function">robin_sched</span><span class="token punctuation">(</span>k_prio_t prio<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k_task_t <span class="token operator">*</span>task<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k_robin_state <span class="token operator">!=</span> TOS_ROBIN_STATE_ENABLED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    task <span class="token operator">=</span> <span class="token function">readyqueue_first_task_get</span><span class="token punctuation">(</span>prio<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>task <span class="token operator">||</span> <span class="token function">knl_is_idle</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">readyqueue_is_prio_onlyone</span><span class="token punctuation">(</span>prio<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">knl_is_sched_locked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token operator">-</span><span class="token operator">></span>timeslice <span class="token operator">></span> <span class="token punctuation">(</span>k_timeslice_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">--</span>task<span class="token operator">-</span><span class="token operator">></span>timeslice<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token operator">-</span><span class="token operator">></span>timeslice <span class="token operator">></span> <span class="token punctuation">(</span>k_timeslice_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">readyqueue_move_head_to_tail</span><span class="token punctuation">(</span>k_curr_task<span class="token operator">-</span><span class="token operator">></span>prio<span class="token punctuation">)</span><span class="token punctuation">;</span>    task <span class="token operator">=</span> <span class="token function">readyqueue_first_task_get</span><span class="token punctuation">(</span>prio<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token operator">-</span><span class="token operator">></span>timeslice_reload <span class="token operator">==</span> <span class="token punctuation">(</span>k_timeslice_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>        task<span class="token operator">-</span><span class="token operator">></span>timeslice <span class="token operator">=</span> k_robin_default_timeslice<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        task<span class="token operator">-</span><span class="token operator">></span>timeslice <span class="token operator">=</span> task<span class="token operator">-</span><span class="token operator">></span>timeslice_reload<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> TencentOS tiny </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TencentOS tiny </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TencentOS  tiny】深度源码分析（1）——task</title>
      <link href="/tencentos-tiny-3/"/>
      <url>/tencentos-tiny-3/</url>
      
        <content type="html"><![CDATA[<h1 id="任务的基本概念"><a href="#任务的基本概念" class="headerlink" title="任务的基本概念"></a>任务的基本概念</h1><p>从系统的角度看，任务是竞争系统资源的最小运行单元。TencentOS  tiny是一个支持多任务的操作系统，任务可以使用或等待CPU、使用内存空间等系统资源，并独立于其它任务运行，理论上任何数量的任务都可以共享同一个优先级，这样子处于就绪态的多个相同优先级任务将会以时间片切换的方式共享处理器。</p><blockquote><p>不过<strong>要注意</strong>的是：在TencentOS  tiny中，不能创建与空闲任务相同优先级的任务<code>K_TASK_PRIO_IDLE</code>，相同优先级下的任务需要允许使用时间片调度，打开<code>TOS_CFG_ROUND_ROBIN_EN</code>。</p></blockquote><p>简而言之： TencentOS  tiny的任务可认为是一系列独立任务的集合。每个任务在自己的环境中运行。在任何时刻，只有一个任务得到运行，由TencentOS  tiny调度器决定运行哪个任务。从<code>宏观</code>看上去所有的任务都在同时在执行。</p><p>TencentOS中的任务是抢占式调度机制，高优先级的任务可打断低优先级任务，低优先级任务必须在高优先级任务阻塞或结束后才能得到调度。同时TencentOS也支持时间片轮转调度方式。</p><p>系统默认可以支持10个优先级，<code>0～TOS_CFG_TASK_PRIO_MAX</code>，这个宏定义是可以修改的，优先级数值越大的任务优先级越低，<code>(TOS_CFG_TASK_PRIO_MAX - (k_prio_t)1u)</code>为最低优先级，分配给空闲任务使用。</p><pre class="line-numbers language-js"><code class="language-js">#define K_TASK_PRIO_IDLE         <span class="token punctuation">(</span>k_prio_t<span class="token punctuation">)</span><span class="token punctuation">(</span>TOS_CFG_TASK_PRIO_MAX <span class="token operator">-</span> <span class="token punctuation">(</span>k_prio_t<span class="token punctuation">)</span>1u<span class="token punctuation">)</span>#define K_TASK_PRIO_INVALID      <span class="token punctuation">(</span>k_prio_t<span class="token punctuation">)</span><span class="token punctuation">(</span>TOS_CFG_TASK_PRIO_MAX<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h1><p>TencentOS  tiny任务状态有以下几种。</p><ul><li>就绪态（K_TASK_STATE_READY）：该任务在就绪列表中，就绪的任务已经具备执行的能力，只等待调度器进行调度，新创建的任务会初始化为就绪态。</li><li>运行态（K_TASK_STATE_READY）：该状态表明任务正在执行，此时它占用处理器，<strong>其实此时的任务还是处于就绪列表中的</strong>，TencentOS调度器选择运行的永远是处于最高优先级的就绪态任务，当任务被运行的一刻，它的任务状态就变成了运行态。</li><li>睡眠态（K_TASK_STATE_SLEEP）：如果任务当前正在休眠让出CPU使用权，那么就可以说这个任务处于休眠状态，该任务不在就绪列表中，此时任务处于睡眠列表中（或者叫延时列表）。</li><li>等待态（K_TASK_STATE_PEND）：任务正在等待信号量、队列或者等待事件等状态。</li><li>挂起态（K_TASK_STATE_SUSPENDED）：任务被挂起，此时任务对调度器而言是不可见的。</li><li>退出态（K_TASK_STATE_DELETED）：该任务运行结束，并且被删除。</li><li>等待超时状态（K_TASK_STATE_PENDTIMEOUT）：任务正在等待信号量、队列或者等待事件发生超时的状态。</li><li>睡眠挂起态（K_TASK_STATE_SLEEP_SUSPENDED）：任务在睡眠中被挂起时的状态。</li><li>等待挂起态（K_TASK_STATE_PEND_SUSPENDED）：任务正在等待信号量、队列或者等待事件时被挂起的状态。</li><li>等待超时挂起态（K_TASK_STATE_PENDTIMEOUT_SUSPENDED）：任务正在等待信号量、队列或者等待事件发生超时，但此时任务已经被挂起的状态。</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// ready to schedule</span><span class="token comment" spellcheck="true">// a task's pend_list is in readyqueue</span>#define K_TASK_STATE_READY                <span class="token punctuation">(</span>k_task_state_t<span class="token punctuation">)</span><span class="token number">0x0000</span><span class="token comment" spellcheck="true">// delayed, or pend for a timeout</span><span class="token comment" spellcheck="true">// a task's tick_list is in k_tick_list</span>#define K_TASK_STATE_SLEEP                <span class="token punctuation">(</span>k_task_state_t<span class="token punctuation">)</span><span class="token number">0x0001</span><span class="token comment" spellcheck="true">// pend for something</span><span class="token comment" spellcheck="true">// a task's pend_list is in some pend object's list</span>#define K_TASK_STATE_PEND                 <span class="token punctuation">(</span>k_task_state_t<span class="token punctuation">)</span><span class="token number">0x0002</span><span class="token comment" spellcheck="true">// suspended</span>#define K_TASK_STATE_SUSPENDED            <span class="token punctuation">(</span>k_task_state_t<span class="token punctuation">)</span><span class="token number">0x0004</span><span class="token comment" spellcheck="true">// deleted</span>#define K_TASK_STATE_DELETED              <span class="token punctuation">(</span>k_task_state_t<span class="token punctuation">)</span><span class="token number">0x0008</span><span class="token comment" spellcheck="true">// actually we don't really need those TASK_STATE below, if you understand the task state deeply, the code can be much more elegant. </span><span class="token comment" spellcheck="true">// we are pending, also we are waitting for a timeout(eg. tos_sem_pend with a valid timeout, not TOS_TIME_FOREVER)</span><span class="token comment" spellcheck="true">// both a task's tick_list and pend_list is not empty</span>#define K_TASK_STATE_PENDTIMEOUT                      <span class="token punctuation">(</span>k_task_state_t<span class="token punctuation">)</span><span class="token punctuation">(</span>K_TASK_STATE_PEND <span class="token operator">|</span> K_TASK_STATE_SLEEP<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// suspended when sleeping</span>#define K_TASK_STATE_SLEEP_SUSPENDED                  <span class="token punctuation">(</span>k_task_state_t<span class="token punctuation">)</span><span class="token punctuation">(</span>K_TASK_STATE_SLEEP <span class="token operator">|</span> K_TASK_STATE_SUSPENDED<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// suspened when pending</span>#define K_TASK_STATE_PEND_SUSPENDED                   <span class="token punctuation">(</span>k_task_state_t<span class="token punctuation">)</span><span class="token punctuation">(</span>K_TASK_STATE_PEND <span class="token operator">|</span> K_TASK_STATE_SUSPENDED<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// suspended when pendtimeout</span>#define K_TASK_STATE_PENDTIMEOUT_SUSPENDED            <span class="token punctuation">(</span>k_task_state_t<span class="token punctuation">)</span><span class="token punctuation">(</span>K_TASK_STATE_PENDTIMEOUT <span class="token operator">|</span> K_TASK_STATE_SUSPENDED<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="TencentOS中维护任务的数据结构"><a href="#TencentOS中维护任务的数据结构" class="headerlink" title="TencentOS中维护任务的数据结构"></a>TencentOS中维护任务的数据结构</h1><h2 id="就绪列表"><a href="#就绪列表" class="headerlink" title="就绪列表"></a>就绪列表</h2><p>TencentOS  tiny维护一条就绪列表，用于挂载系统中的所有处于就绪态的任务，他是<code>readyqueue_t</code>类型的列表，其成员变量如下：</p><pre class="line-numbers language-js"><code class="language-js">readyqueue_t        k_rdyq<span class="token punctuation">;</span>typedef struct readyqueue_st <span class="token punctuation">{</span>    k_list_t    task_list_head<span class="token punctuation">[</span>TOS_CFG_TASK_PRIO_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>    uint32_t    prio_mask<span class="token punctuation">[</span>K_PRIO_TBL_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    k_prio_t    highest_prio<span class="token punctuation">;</span><span class="token punctuation">}</span> readyqueue_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>task_list_head</code>是列表类型<code>k_list_t</code>的数组，TencentOS  tiny为每个优先级的任务都分配一个列表，系统支持最大优先级为<code>TOS_CFG_TASK_PRIO_MAX</code><br><code>prio_mask</code>则是优先级掩码数组，它是一个类型为32位变量的数组，数组成员个数由<code>TOS_CFG_TASK_PRIO_MAX</code>决定：</p><pre class="line-numbers language-js"><code class="language-js">#define K_PRIO_TBL_SIZE         <span class="token punctuation">(</span><span class="token punctuation">(</span>TOS_CFG_TASK_PRIO_MAX <span class="token operator">+</span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">32</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当<code>TOS_CFG_TASK_PRIO_MAX</code>不超过32时数组成员变量只有一个，就是32位的变量数值，那么该变量的每一位代表一个优先级。比如当<code>TOS_CFG_TASK_PRIO_MAX</code>为64时，<code>prio_mask[0]</code>变量的每一位（bit）代表<code>0-31</code>优先级，而<code>prio_mask[1]</code>变量的每一位代表<code>32-63</code>优先级。</p><p><code>highest_prio</code>则是记录当前优先级列表的最高优先级，方便索引<code>task_list_head</code>。</p><h2 id="延时列表"><a href="#延时列表" class="headerlink" title="延时列表"></a>延时列表</h2><p>与系统时间相关的任务都会被挂载到这个列表中，可能是睡眠、有期限地等待信号量、事件、消息队列等情况~</p><pre><code>k_list_t             k_tick_list;</code></pre><h2 id="任务控制块"><a href="#任务控制块" class="headerlink" title="任务控制块"></a>任务控制块</h2><p>在多任务系统中，任务的执行是由系统调度的。系统为了顺利的调度任务，为每个任务都额外定义了一个任务控制块，这个任务控制块就相当于任务的身份证，里面存有任务的所有信息，比如任务的栈指针，任务名称，任务的形参等。有了这个任务控制块之后，以后系统对任务的全部操作都可以通过这个任务控制块来实现。<br>TencentOS 任务控制块如下：</p><pre class="line-numbers language-js"><code class="language-js">typedef struct k_task_st <span class="token punctuation">{</span>    k_stack_t          <span class="token operator">*</span>sp<span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">/**&lt; 任务栈指针,用于切换上下文*/</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    knl_obj_t           knl_obj<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/**&lt; 只是为了验证，测试当前对象是否真的是一项任务。*/</span>#endif    char               <span class="token operator">*</span>name<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">/**&lt; 任务名称 */</span>    k_task_entry_t      entry<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">/**&lt; 任务主体 */</span>    <span class="token keyword">void</span>               <span class="token operator">*</span>arg<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/**&lt; 任务主体形参 */</span>    k_task_state_t      state<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">/**&lt; 任务状态 */</span>    k_prio_t            prio<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">/**&lt; 任务优先级 */</span>    k_stack_t          <span class="token operator">*</span>stk_base<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">/**&lt; 任务栈基地址 */</span>    size_t              stk_size<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">/**&lt; 任务栈大小 */</span>    k_tick_t            tick_expires<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/**&lt; 任务阻塞的时间 */</span>    k_list_t            tick_list<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/**&lt; 延时列表 */</span>    k_list_t            pend_list<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/**&lt; 就绪、等待列表 */</span>#<span class="token keyword">if</span> TOS_CFG_MUTEX_EN <span class="token operator">></span> 0u    k_list_t            mutex_own_list<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/**&lt; 任务拥有的互斥量 */</span>    k_prio_t            prio_pending<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/*&lt; 用于记录持有互斥量的任务初始优先级，在优先级继承中使用 */</span>#endif    pend_obj_t         <span class="token operator">*</span>pending_obj<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/**&lt; 记录任务此时挂载到的列表 */</span>    pend_state_t        pend_state<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/**&lt; 等待被唤醒的原因（状态） */</span>#<span class="token keyword">if</span> TOS_CFG_ROUND_ROBIN_EN <span class="token operator">></span> 0u    k_timeslice_t       timeslice_reload<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/**&lt; 时间片初始值（重装载值） */</span>    k_timeslice_t       timeslice<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/**&lt; 剩余时间片 */</span>#endif#<span class="token keyword">if</span> TOS_CFG_MSG_EN <span class="token operator">></span> 0u    <span class="token keyword">void</span>               <span class="token operator">*</span>msg_addr<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">/**&lt; 保存接收到的消息 */</span>    size_t              msg_size<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/**&lt; 保存接收到的消息大小 */</span>#endif#<span class="token keyword">if</span> TOS_CFG_EVENT_EN <span class="token operator">></span> 0u    k_opt_t             opt_event_pend<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/**&lt; 等待事件的的操作类型：TOS_OPT_EVENT_PEND_ANY 、 TOS_OPT_EVENT_PEND_ALL */</span>    k_event_flag_t      flag_expect<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**&lt; 期待发生的事件 */</span>    k_event_flag_t     <span class="token operator">*</span>flag_match<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/**&lt; 等待到的事件 */</span>#endif<span class="token punctuation">}</span> k_task_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h1><p>在TencentOS  tiny中，凡是使用<code>__API__</code>修饰的函数都是提供给用户使用的，而使用<code>__KERNEL__</code>修饰的代码则是给内核使用的。<br>TencentOS的创建任务函数有好几个参数：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>entry</td><td>任务主体</td></tr><tr><td>name</td><td>任务名字</td></tr><tr><td>arg</td><td>任务形参</td></tr><tr><td>task</td><td>任务控制块</td></tr><tr><td>stk_base</td><td>任务栈基地址</td></tr><tr><td>stk_size</td><td>任务栈大小</td></tr><tr><td>prio</td><td>优先级</td></tr><tr><td>timeslice</td><td>时间片</td></tr></tbody></table><p>参数详解（来源TencentOS  tiny开发指南）：</p><ul><li><p>task</p><p>这是一个k_task_t类型的指针，k_task_t是内核的任务结构体类型。注意：task指针，应该指向生命周期大于待创建任务体生命周期的k_task_t类型变量，如果该指针指向的变量生命周期比待创建的任务体生命周期短，譬如可能是一个生命周期极端的函数栈上变量，可能会出现任务体还在运行而k_task_t变量已被销毁，会导致系统调度出现不可预知问题。</p></li><li><p>name</p><p>指向任务名字符串的指针。注意：同task，该指针指向的字符串生命周期应该大于待创建的任务体生命周期，一般来说，传入字符串常量指针即可。</p></li><li><p>entry</p><p>任务体运行的函数入口。当任务创建完毕进入运行状态后，entry是任务执行的入口，用户可以在此函数中编写业务逻辑。</p></li><li><p>arg</p><p>传递给任务入口函数的参数。</p></li><li><p>prio</p><p>任务优先级。prio的数值越小，优先级越高。用户可以在tos_config.h中，通过TOS_CFG_TASK_PRIO_MAX来配置任务优先级的最大数值，在内核的实现中，idle任务的优先级会被分配为TOS_CFG_TASK_PRIO_MAX - 1,此优先级只能被idle任务使用。因此对于一个用户创建的任务来说，合理的优先级范围应该为[0, TOS_CFG_TASK_PRIO_MAX - 2]。另外TOS_CFG_TASK_PRIO_MAX的配置值必需大于等于8。</p></li><li><p>stk_base</p><p>任务在运行时使用的栈空间的起始地址。注意：同task，该指针指向的内存空间的生命周期应该大于待创建的任务体生命周期。stk_base是k_stack_t类型的数组起始地址。</p></li><li><p>stk_size</p><p>任务的栈空间大小。注意：因为stk_base是k_stack_t类型的数组指针，因此实际栈空间所占内存大小为stk_size * sizeof(k_stack_t)。</p></li><li><p>timeslice</p><p>时间片轮转机制下当前任务的时间片大小。当timeslice为0时，任务调度时间片会被设置为默认大小（TOS_CFG_CPU_TICK_PER_SECOND / 10），系统时钟滴答（systick）数 / 10。</p></li></ul><p>创建任务的实现如下：首先对参数进行检查，还要再提一下：<strong>在TencentOS中，不能创建与空闲任务相同优先级的任务<code>K_TASK_PRIO_IDLE</code></strong>。然后调用<code>cpu_task_stk_init</code>函数将任务栈进行初始化，并且将传入的参数记录到任务控制块中。如果打开了<code>TOS_CFG_ROUND_ROBIN_EN</code>宏定义，则表示支持时间片调度，则需要配置时间片相关的信息<code>timeslice</code>到任务控制块中。然后调用<code>task_state_set_ready</code>函数将新创建的任务设置为就绪态<code>K_TASK_STATE_READY</code>，再调用<code>readyqueue_add_tail</code>函数将任务插入就绪列表<code>k_rdyq</code>中。如果调度器运行起来了，则进行一次任务调度。</p><blockquote><p>个人感觉吧，没有从堆中动态分配还是有点小小的遗憾，我更喜欢简单的函数接口~！</p></blockquote><p>代码如下：</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_task_create</span><span class="token punctuation">(</span>k_task_t <span class="token operator">*</span>task<span class="token punctuation">,</span>                                char <span class="token operator">*</span>name<span class="token punctuation">,</span>                                k_task_entry_t entry<span class="token punctuation">,</span>                                <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span>                                k_prio_t prio<span class="token punctuation">,</span>                                k_stack_t <span class="token operator">*</span>stk_base<span class="token punctuation">,</span>                                size_t stk_size<span class="token punctuation">,</span>                                k_timeslice_t timeslice<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_IN_IRQ_CHECK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_PTR_SANITY_CHECK</span><span class="token punctuation">(</span>stk_base<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>stk_size <span class="token operator">&lt;</span> <span class="token function">sizeof</span><span class="token punctuation">(</span>cpu_context_t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TASK_STK_SIZE_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>prio <span class="token operator">==</span> K_TASK_PRIO_IDLE <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">knl_is_idle</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TASK_PRIO_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>prio <span class="token operator">></span> K_TASK_PRIO_IDLE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TASK_PRIO_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">task_reset</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token function">knl_object_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>task<span class="token operator">-</span><span class="token operator">></span>knl_obj<span class="token punctuation">,</span> KNL_OBJ_TYPE_TASK<span class="token punctuation">)</span><span class="token punctuation">;</span>#endif    task<span class="token operator">-</span><span class="token operator">></span>sp        <span class="token operator">=</span> <span class="token function">cpu_task_stk_init</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>entry<span class="token punctuation">,</span> arg<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>task_exit<span class="token punctuation">,</span> stk_base<span class="token punctuation">,</span> stk_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    task<span class="token operator">-</span><span class="token operator">></span>entry     <span class="token operator">=</span> entry<span class="token punctuation">;</span>    task<span class="token operator">-</span><span class="token operator">></span>arg       <span class="token operator">=</span> arg<span class="token punctuation">;</span>    task<span class="token operator">-</span><span class="token operator">></span>name      <span class="token operator">=</span> name<span class="token punctuation">;</span>    task<span class="token operator">-</span><span class="token operator">></span>prio      <span class="token operator">=</span> prio<span class="token punctuation">;</span>    task<span class="token operator">-</span><span class="token operator">></span>stk_base  <span class="token operator">=</span> stk_base<span class="token punctuation">;</span>    task<span class="token operator">-</span><span class="token operator">></span>stk_size  <span class="token operator">=</span> stk_size<span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_ROUND_ROBIN_EN <span class="token operator">></span> 0u    task<span class="token operator">-</span><span class="token operator">></span>timeslice_reload <span class="token operator">=</span> timeslice<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeslice <span class="token operator">==</span> <span class="token punctuation">(</span>k_timeslice_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span> <span class="token punctuation">{</span>        task<span class="token operator">-</span><span class="token operator">></span>timeslice <span class="token operator">=</span> k_robin_default_timeslice<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        task<span class="token operator">-</span><span class="token operator">></span>timeslice <span class="token operator">=</span> timeslice<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">task_state_set_ready</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">readyqueue_add_tail</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tos_knl_is_running</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="任务销毁"><a href="#任务销毁" class="headerlink" title="任务销毁"></a>任务销毁</h1><p>这个函数十分简单，根据传递进来的任务控制块销毁任务，也可以传递进NULL表示销毁当前运行的任务。但是不允许销毁空闲任务<code>k_idle_task</code>，当调度器被锁住时不能销毁自身，会返回<code>K_ERR_SCHED_LOCKED</code>错误代码。如果使用了互斥量，当任务被销毁时会释放掉互斥量，并且根据任务所处的状态进行销毁，比如任务处于就绪态、延时态、等待态，则会从<code>对应的状态列表</code>中移除。<br>代码实现如下：</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_task_destroy</span><span class="token punctuation">(</span>k_task_t <span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_IN_IRQ_CHECK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        task <span class="token operator">=</span> k_curr_task<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#<span class="token keyword">if</span> TOS_CFG_OBJECT_VERIFY_EN <span class="token operator">></span> 0u    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">knl_object_verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>task<span class="token operator">-</span><span class="token operator">></span>knl_obj<span class="token punctuation">,</span> KNL_OBJ_TYPE_TASK<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_OBJ_INVALID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">knl_is_idle</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_TASK_DESTROY_IDLE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">knl_is_self</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">knl_is_sched_locked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_SCHED_LOCKED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>#<span class="token keyword">if</span> TOS_CFG_MUTEX_EN <span class="token operator">></span> 0u    <span class="token comment" spellcheck="true">// when we die, wakeup all the people in this land.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tos_list_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>task<span class="token operator">-</span><span class="token operator">></span>mutex_own_list<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">task_mutex_release</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>#endif    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">task_state_is_ready</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// that's simple, good kid</span>        <span class="token function">readyqueue_remove</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">task_state_is_sleeping</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">tick_list_remove</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">task_state_is_pending</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">pend_list_remove</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">task_reset</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">task_state_set_deleted</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="任务睡眠"><a href="#任务睡眠" class="headerlink" title="任务睡眠"></a>任务睡眠</h1><p>任务睡眠非常简单，主要的思路就是将任务从就绪列表移除，然后添加到延时列表中<code>k_tick_list</code>，如果调度器被锁，直接返回错误代码<code>K_ERR_SCHED_LOCKED</code>，如果睡眠时间为0，则调用<code>tos_task_yield</code>函数发起一次任务调度；调用<code>tick_list_add</code>函数将任务<code>插入延时列表</code>中，睡眠的时间<code>delay</code>是由用户指定的。不过<strong>需要注意</strong>的是<strong>如果任务睡眠的时间是永久睡眠<code>TOS_TIME_FOREVER</code></strong>，将返回错误代码<code>K_ERR_DELAY_FOREVER</code>，这是因为任务睡眠是<code>主动行为</code>，如果永久睡眠了，将没法主动唤醒，而任务等待事件、信号量、消息队列等行为是被动行为，可以是永久等待，一旦事件发生了、信号量呗释放、消息队列不为空时任务就会被唤醒，这是<code>被动行为</code>，这两点需要区分开来。最后调用<code>readyqueue_remove</code>函数将任务从就绪列表中移除，然后调用<code>knl_sched</code>函数发起一次任务调度，就能切换另一个任务。<br>任务睡眠的代码如下：</p><pre class="line-numbers language-js"><code class="language-js">__API__ k_err_t <span class="token function">tos_task_delay</span><span class="token punctuation">(</span>k_tick_t delay<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">TOS_CPU_CPSR_ALLOC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_IN_IRQ_CHECK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">knl_is_sched_locked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> K_ERR_SCHED_LOCKED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>delay <span class="token operator">==</span> <span class="token punctuation">(</span>k_tick_t<span class="token punctuation">)</span>0u<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">tos_task_yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">TOS_CPU_INT_DISABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tick_list_add</span><span class="token punctuation">(</span>k_curr_task<span class="token punctuation">,</span> delay<span class="token punctuation">)</span> <span class="token operator">!=</span> K_ERR_NONE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> K_ERR_DELAY_FOREVER<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">readyqueue_remove</span><span class="token punctuation">(</span>k_curr_task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">TOS_CPU_INT_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">knl_sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> K_ERR_NONE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> TencentOS tiny </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TencentOS tiny </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TencentOS tiny】 移植到STM32F103全教程</title>
      <link href="/tencentos-tiny-2/"/>
      <url>/tencentos-tiny-2/</url>
      
        <content type="html"><![CDATA[<h1 id="移植前的准备工作"><a href="#移植前的准备工作" class="headerlink" title="移植前的准备工作"></a>移植前的准备工作</h1><h2 id="1-获取STM32的裸机工程模板"><a href="#1-获取STM32的裸机工程模板" class="headerlink" title="1. 获取STM32的裸机工程模板"></a>1. 获取STM32的裸机工程模板</h2><p>STM32的裸机工程模板直接使用野火STM32开发板配套的固件库例程即可。可以从我<code>github</code>上获取<a href="https://github.com/jiejieTop/TencentOS-Demo" target="_blank" rel="noopener">https://github.com/jiejieTop/TencentOS-Demo</a></p><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919200430213.png?" alt=""></p><h1 id="下载TencentOS-tiny-源码"><a href="#下载TencentOS-tiny-源码" class="headerlink" title="下载TencentOS tiny 源码"></a>下载TencentOS tiny 源码</h1><p>TencentOS tiny的源码可从<code>TencentOS tiny</code> <strong>GitHub</strong>仓库地址<a href="https://github.com/Tencent/TencentOS-tiny" target="_blank" rel="noopener">https://github.com/Tencent/TencentOS-tiny</a>下载，如果GitHub下载慢，也可以通过腾讯工蜂开源仓下载，地址：<a href="https://git.code.tencent.com/Tencent_Open_Source/TencentOS-tiny" target="_blank" rel="noopener">https://git.code.tencent.com/Tencent_Open_Source/TencentOS-tiny</a> ，大家在移植时并不需要把整个<code>TencentOS tiny</code> 源码放进工程文件中，否则工程的代码量太大。杰杰将在下文讲解如何将<code>TencentOS tiny</code>移植到工程中去，以及如何把<code>TencentOS tiny</code>源码中的核心部分单独提取出来，方便以后在不同的平台上移植。目前使用的是<code>TencentOS tiny</code>最新版本，由于<code>TencentOS tiny</code>在不断更新，如果以后<code>TencentOS tiny</code>更新到更高的版本，则以最新的版本为准。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919200841964.png?" alt="TencentOS tiny源码"></p><h1 id="TencentOS-tiny源码核心文件夹分析"><a href="#TencentOS-tiny源码核心文件夹分析" class="headerlink" title="TencentOS tiny源码核心文件夹分析"></a>TencentOS tiny源码核心文件夹分析</h1><p>打开<code>TencentOS tiny</code>源码文件，可以看见里面有<code>12</code>个文件夹，下面先来了解主要文件夹及其子文件夹的作用，然后将<code>TencentOS tiny</code>源码的核心文件提取出来，添加到工程根目录下的文件夹中，因为工程只需要有用的源码文件，而不是全部的<code>TencentOS tiny</code>源码，所以可以避免工程过于庞大。</p><table><thead><tr><th>一级目录</th><th>二 / 三级目录</th><th>说明（杰杰）</th></tr></thead><tbody><tr><td><strong><code>arch</code></strong></td><td><strong><code>arm</code></strong></td><td><strong><code>TencentOS tiny适配的IP核架构（含M核中断、调度、tick相关代码），对我们的移植很重要</code></strong></td></tr><tr><td>arch</td><td>risc-v</td><td>TencentOS tiny适配的risc-v架构</td></tr><tr><td>board</td><td>TencentOS_tiny_EVB_MX</td><td>TencentOS tiny 定制开发板demo，包含AT适配框架、MQTT协议、安全组件等</td></tr><tr><td>component</td><td>connectivity / loraWAN</td><td>loRaWAN协议栈实现源码及适配层</td></tr><tr><td></td><td>connectivity / Eclipse-Paho-MQTT</td><td>MQTT协议栈实现源码及适配层</td></tr><tr><td></td><td>connectivity / TencentCloud_SDK</td><td>腾讯云C-SDK实现源码及适配层</td></tr><tr><td></td><td>fs</td><td>文件系统实现源码</td></tr><tr><td></td><td>security</td><td>mbedtls 安全协议源码</td></tr><tr><td></td><td>utils</td><td>包含json相关源码</td></tr><tr><td>devices</td><td></td><td>TencentOS tiny适配的一些外设驱动（如串口wifi gprs 驱动等）</td></tr><tr><td>doc</td><td></td><td>TencentOS tiny相关技术文档及开发指南（<code>建议多看这部分</code>）</td></tr><tr><td>examples</td><td></td><td>TencentOS tiny提供的功能示例</td></tr><tr><td><strong><code>kernel</code></strong></td><td><strong><code>core</code></strong></td><td><strong><code>TencentOS tiny内核源码（这部分是最重要的）</code></strong></td></tr><tr><td></td><td><strong><code>hal</code></strong></td><td><strong><code>TencentOS tiny驱动抽象层</code></strong></td></tr><tr><td></td><td><strong>pm</strong></td><td><strong>TencentOS tiny低功耗模块源码</strong></td></tr><tr><td>net</td><td>at</td><td>TencentOS tiny为串口类通信模组提供的AT框架实现层</td></tr><tr><td></td><td>lora_module_wrapper</td><td>TencentOS tiny为串口类LoraWAN模块提供的移植框架</td></tr><tr><td></td><td>lwip</td><td>Lwip协议实现源码及适配层</td></tr><tr><td></td><td>sal_module_wrapper</td><td>TencentOS tiny为串口类网络模块（wifi gprs）提供的socket移植框架</td></tr><tr><td></td><td>tencent_firmware_module_wrapper</td><td>TencentOS tiny提供的腾讯定制模组移植框架</td></tr><tr><td>osal</td><td>cmsis_os</td><td>TencentOS tiny提供的cmsis os 适配</td></tr><tr><td>platform</td><td>hal</td><td>TencentOS tiny适配的部分芯片的驱动实现源码</td></tr><tr><td></td><td>vendor_bsp</td><td>芯片厂家提供的原厂bsp固件库，如STM32的HAL库</td></tr><tr><td>test</td><td></td><td>存放TencentOS tiny提供的一些测试代码，含内核及上层模块示例及测试代码</td></tr><tr><td>tools</td><td></td><td>存放TencentOS tiny提供的工具，小程序，配置工具等</td></tr></tbody></table><p>简单提一下我们的重点文件夹：</p><ul><li><p><strong>arch</strong>: <code>TencentOS tiny</code>是软件，单片机是硬件，为了使<code>TencentOS tiny</code>运行在单片机上面，<code>TencentOS tiny</code>和单片机必须关联在一起，那么如何关联呢？还是要通过代码来关联，这部分关联的文件叫接口文件，通常由汇编语言和C语言联合编写。这些接口文件都是跟硬件密切相关的，不同的硬件接口文件是不一样的，但都大同小异。<code>TencentOS tiny</code>在<code>arch\arm\arm-v6m</code>目录中存放了<code>cortex m0</code>内核的单片机的接口文件，在<code>arch\arm\arm-v7m</code>目录中存放了<code>cortex m3、m4</code>和<code>m7</code>内核的单片机的接口文件，以及一些通用的接口文件，基于这些内核的mcu都可以使用里面的接口文件。</p></li><li><p><strong>kernel</strong>：<code>kernel</code>是<code>TencentOS tiny</code>内核核心源码，它的重要性我也不用多说，毕竟整个内核就是由这里面的文件组成，而其他文件夹都是基于内核的组件。</p></li></ul><h1 id="提取TencentOS-tiny内核源码"><a href="#提取TencentOS-tiny内核源码" class="headerlink" title="提取TencentOS tiny内核源码"></a>提取TencentOS tiny内核源码</h1><p>将裸机工程源码重命名为hello-world，然后在裸机工程中新建一个<code>TencentOS</code>文件夹，接着将<code>kernel</code>文件夹、<code>arch</code>文件夹、添加到<code>TencentOS</code>文件夹下：</p><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919203814911.png?" alt=""></p><p>除了<code>TencentOS tiny</code>的核心文件外，还需要移植一下其他文件，如关于<code>TencentOS tiny</code>系统的配置文件。这是一些可以被用户修改的文件，所以会放在具体的工程文件中。<code>board</code>就是<code>TencentOS tiny</code>为一些常用开发板开发的<code>demo</code>文件夹，其内有各个工程的配置文件，选一个与移植芯片最相机的开发板，找到它的配置文件<code>tos_config.h</code>，比如我们可以选择：<code>TencentOS-tiny\board\STM32F103_SIM800A\TOS-CONFIG</code>路径下的配置文件，把它拷贝到我们工程中的<code>TencentOS</code>文件夹下，当然你也可以把整个<code>TOS-CONFIG</code>目录拷贝过去，把其他无关的配置删掉就好了。</p><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919204033306.png" alt=""></p><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919204358500.png" alt=""></p><p>这个配置文件<strong>很重要</strong>，后续在移植工程时，我们需要对这个配置文件进行修改，这样子可以裁剪<code>TencentOS tiny</code>的功能，得到最适合的工程配置。</p><h1 id="开始移植"><a href="#开始移植" class="headerlink" title="开始移植"></a>开始移植</h1><p>打开<code>TencentOS-Demo\hello-world\Project\RVMDK（uv5）</code>路径下的<code>TencentOS.uvprojx</code>文件。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919205248405.png?" alt=""></p><ol><li>根据下图的提示，新建<code>3</code>个工程分组，分别为<code>tos/kernel、tos/arch、tos/config</code>，这样可以<strong>见其名知其意</strong>，这些工程分组分别保存<code>TencentOS tiny</code>的<strong>内核源码、接口文件、以及配置文件</strong>。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919205631749.png?" alt=""></li><li>根据下图将<code>TencentOS-Demo\hello-world\TencentOS\kernel\core</code>路径下的所有<code>.c文件</code>添加到<code>tos/kernel</code>工程分组中，也将<code>\TencentOS-Demo\hello-world\TencentOS\kernel\pm</code>目录下的所有<code>.c文件</code>添加到<code>tos/kernel</code>工程分组中:<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919211038774.png?" alt=""></li><li>同理将<code>TencentOS-Demo\hello-world\TencentOS\arch\arm\arm-v7m\common</code>路径下的 <code>tos_cpu.c、tos_fault.c</code>添加到<code>tos/arch</code>工程分组下，也将<code>TencentOS-Demo\hello-world\TencentOS\arch\arm\arm-v7m\cortex-m3\armcc</code>路径下的 <code>port_s.S、port_c.c</code>文件添加到<code>tos/arch</code>工程分组下<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919210818240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppZWppZW1jdQ==,size_16,color_FFFFFF,t_70" alt=""></li><li>最后再将<code>TencentOS-Demo\hello-world\TencentOS\TOS-CONFIG</code>路径下的<code>tos_config.h</code>文件添加到<code>tos/config</code>工程分组中。</li></ol><p><strong>需要注意的是</strong>，在<code>tos/arch</code>分组中添加的<code>port_s.S</code>文件，需要在添加时选择文件类型为<code>“All files (*.*)”</code>，添加(<em>.h)文件类型的时候也需要选择文件类型为`“All files (</em>.*)”`</p><p>添加完成后的文件：<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919211133584.png" alt=""></p><h1 id="指定头文件路径"><a href="#指定头文件路径" class="headerlink" title="指定头文件路径"></a>指定头文件路径</h1><p>编译时需要为这些源文件指定头文件的路径，否则编译会报错。<code>TencentOS tiny</code>的源码中有很多头文件，必须将对应的路径添加到开发环境里。在添加<code>TencentOS tiny</code>源码时，一些其他的头文件夹也被复制到了工程目录中，所以这些文件夹的路径也要加到开发环境中。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919211444152.png?" alt=""><br>这些头文件的路径分别是：</p><pre><code>..\..\TencentOS\arch\arm\arm-v7m\common\include..\..\TencentOS\arch\arm\arm-v7m\cortex-m3\armcc..\..\TencentOS\kernel\core\include..\..\TencentOS\kernel\pm\include..\..\TencentOS\TOS-CONFIG</code></pre><p>同时还要在配置中勾选支持<code>C99</code>模式：<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919213556464.png?" alt=""></p><h1 id="尝试编译"><a href="#尝试编译" class="headerlink" title="尝试编译"></a>尝试编译</h1><p>如果你走到这一步，那么可以尝试编译一下，不过我测试时编译是没通过的，原因是缺少了部分头文件：<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919213852458.png?" alt=""><br>不过这不影响，我们在配置文件<code>tos_config.h</code>中修改一下就好，添加两句话</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span> </span><span class="token comment" spellcheck="true">// 或者 #include &lt;stddef.h></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如下图：<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919214203165.png?" alt=""></p><h1 id="修改中断函数"><a href="#修改中断函数" class="headerlink" title="修改中断函数"></a>修改中断函数</h1><h2 id="注释PendSV-Handler-函数"><a href="#注释PendSV-Handler-函数" class="headerlink" title="注释PendSV_Handler()函数"></a>注释PendSV_Handler()函数</h2><p>鉴于<code>TencentOS tiny</code>已经处理好<code>PendSV与SysTick</code>中断了，就不需要用户自己去处理，所以要在中断相关的源文件（<code>stm32f10x_it.c文件</code>）中<strong>注释</strong>（或者<strong>删除</strong>）<code>PendSV_Handler()</code>函数。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919214321770.png?" alt=""></p><h2 id="编写SysTick-Handler-函数"><a href="#编写SysTick-Handler-函数" class="headerlink" title="编写SysTick_Handler()函数"></a>编写SysTick_Handler()函数</h2><p><code>SysTick</code>中断服务函数是一个非常重要的函数，<code>TencentOS tiny</code>所有跟时间相关的事情都在里面处理，<code>SysTick</code>就是<code>TencentOS tiny</code>的一个心跳时钟，驱动着<code>TencentOS tiny</code>的运行，就像人的心跳一样，假如没有心跳，我们就相当于<code>“挂掉”</code>，同样的，<code>TencentOS tiny</code>没有了心跳，那么它就会卡死在某个地方，不能进行任务调度，不能运行任何的东西，因此我们需要实现一个<code>TencentOS tiny</code>的心跳时钟。代码如下：</p><p><strong>注意</strong>：<code>SysTick_Handler()</code>中调用的都是<code>TencentOS tiny</code>中的函数，所以需要在<code>stm32f10x_it.c</code>文件中包含<code>tos.h</code>头文件。</p><pre class="line-numbers language-js"><code class="language-js">#include <span class="token string">"tos.h"</span><span class="token comment" spellcheck="true">// SysTick_Handler()函数</span><span class="token keyword">void</span> <span class="token function">SysTick_Handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tos_knl_is_running</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">tos_knl_irq_enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_tick_handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_knl_irq_leave</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="编写main函数"><a href="#编写main函数" class="headerlink" title="编写main函数"></a>编写main函数</h1><p>当你走到这一步，编译是不会出错了，此时我们已经完全移植好操作系统了，那么可以编写代码了，现在编写一个测试代码，在<code>main.c</code>文件中：</p><pre class="line-numbers language-js"><code class="language-js">#include <span class="token string">"stm32f10x.h"</span>#include <span class="token string">"bsp_usart.h"</span>#include <span class="token string">"tos.h"</span>k_task_t task<span class="token punctuation">;</span>k_stack_t task_stack<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test_task</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>Parameter<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world!\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">tos_task_delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * @brief  主函数  * @author 杰杰  * @retval 无  */</span>int <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    k_err_t err<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*初始化USART 配置模式为 115200 8-N-1，中断接收*/</span>    <span class="token function">USART_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Welcome to TencentOS tiny\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_knl_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// TOS Tiny kernel initialize</span>    err <span class="token operator">=</span> <span class="token function">tos_task_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>task<span class="token punctuation">,</span>                           <span class="token string">"task1"</span><span class="token punctuation">,</span>                           test_task<span class="token punctuation">,</span>                          NULL<span class="token punctuation">,</span>                           <span class="token number">2</span><span class="token punctuation">,</span>                           task_stack<span class="token punctuation">,</span>                          <span class="token number">1024</span><span class="token punctuation">,</span>                          <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>err <span class="token operator">!=</span> K_ERR_NONE<span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"TencentOS Create task fail! code : %d \r\n"</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tos_knl_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Start TOS Tiny</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>然后编译，下载到开发板上，就通过串口可以看到程序已经跑起来了：<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190919215529345.png?" alt=""></p><h1 id="end"><a href="#end" class="headerlink" title="end"></a>end</h1><p>至此，<code>TencentOS tiny</code>移植到<code>stm32f1</code>的过程全部完成！</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> TencentOS tiny </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TencentOS tiny </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TencentOS tiny】又有一个操作系统开源</title>
      <link href="/tencentos-tiny-1/"/>
      <url>/tencentos-tiny-1/</url>
      
        <content type="html"><![CDATA[<h1 id="新闻"><a href="#新闻" class="headerlink" title="新闻"></a>新闻</h1><p>2019年9月18日，腾讯宣布将<code>开源</code> <code>自主研发</code>的<code>轻量级</code>物联网实时操作系统<strong>TencentOS tiny</strong>。相比市场上其它系统，腾讯TencentOS tiny在资源占用、设备成本、功耗管理以及安全稳定等层面极具竞争力。该系统的开源可大幅降低物联网应用开发成本，提升开发效率，同时支持一键上云，对接云端海量资源。</p><p><strong>源码已在github上开源：<a href="https://github.com/Tencent/TencentOS-tiny" target="_blank" rel="noopener">https://github.com/Tencent/TencentOS-tiny</a></strong></p><h1 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h1><p>很荣幸，能亲眼见证TencentOS tiny的开源，也很荣幸能在一个多月前内测使用过它~</p><p>不得不说，TencentOS tiny的内核确实是非常非常小巧，最少资源占用为RAM <strong><code>0.6KB</code></strong>，ROM <strong><code>1.8 KB</code></strong>。这是他们团队自主研发的RTOS，源码非常简单易懂，源码作者以非常清晰的逻辑实现了整个内核（还是非常佩服戴大神的，膜拜一下）。</p><p><strong>了解一下TencentOS tiny的框架</strong><br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190918190421629.png?" alt="TencentOS tiny的主体架构图"><br>TencentOS tiny主要由<strong>一个轻量级RTOS内核<code>+</code>多个物联网组件</strong>构成，，从下到上主要包括：</p><p> <strong>CPU库</strong> ：TencentOS tiny支持的CPU IP核架构，当前主要支持<code>ARM Cortex M0/3/4/7</code>，还有现在很火的<code>RISC-V</code>，当然，腾讯物联网团队肯定也会支持更多种类更多IP核与开发板。</p><p> <strong>驱动管理层</strong> ：包括<code>BSP</code>板级支持包，这些东西主要由MCU芯片厂家开发与维护，、<code>HAL</code>硬件抽象、Drivers设备驱动，这部分对于纯粹嵌入式开发者来说还是很重要的，肯定会越来越完善的！</p><p> <strong>内核</strong> ：<code>TencentOS tiny</code>实时内核包括任务管理、实时调度、时间管理、中断管理、内存管理、异常处理、软件定时器、链表、消息队列、信号量、互斥锁、事件标志等模块，接下来我也将写一系列<code>TencentOS tiny</code>内核<code>源码分析</code>的文章，敬请期待吧！</p><p> <strong>IoT协议栈</strong> ：<code>TencentOS tiny</code>提供<code>lwip、AT Adapter、SAL层</code>，支持不同的网络硬件，如<code>以太网、串口WIFI、GPRS、NB-IoT、4G</code>等通信模块。在<code>TCP/IP</code>网络协议栈上提供常用的物联网协议栈应用层，如<code>COAP、MQTT</code>，支撑终端业务快速接入腾讯云；</p><p> <strong>安全框架</strong> ：<code>TencentOS tiny</code>为了确保物联网终端数据传输安全以及设备认证安全，提供了比较完整的安全解决方案。安全框架提供的<code>DTLS</code>和<code>TLS</code>安全协议加固了<code>COAP</code>及<code>MQTT</code>的传输层，可确保物联网终端在对接腾讯云时实现安全认证和数据加密；另外针对低资源的终端硬件，安全框架还提供与<code>腾讯云IoTHub</code>配套的密钥认证方案，确保资源受限设备也能在一定程度上实现设备安全认证；物联网安全是非常重要的，这些框架也是必须存在的。</p><p> <strong>组件框架</strong> ：<code>TencentOS tiny</code>提供<code>文件系统、KV存储、自组网、JS引擎、低功耗框架、设备框架、OTA、调试工具</code>链等一系列组件，这部分我觉得还是很不错的，期待ing；</p><p> <strong>开放API</strong> (规划开发中)：<code>TencentOS tiny</code>将在协议中间件和框架层上提供开放<code>API</code>函数，这样子就能很方便使用中间组件的功能，我是最喜欢这种开发的，不造轮子，能直接使用。简单来说这个API能快速对接腾讯云，实现终端业务上云的需求，最大程度减少终端物联网产品开发周期，节省开发成本；</p><p> <strong>示例应用</strong> ：<code>TencentOS tiny</code>提供的示例代码，模块测试代码等，方便用户参考使用。</p><p>  <strong>腾讯云物联网平台</strong>（图中最上层的部分）：严格来说这部分不算<code>TencentOS tiny</code>的框架内容，这是接入平台层了，腾讯云的物联网平台都是提供多种语言的<code>SDK</code>包，当然在嵌入式设备上肯定使用<code>C SDK</code>的，不过总的来说都是很不错的。</p><p>总的来说<code>TencentOS tiny</code>还是非常不错的，该有的功能都有，可以考虑使用一下这个操作系统~</p><p>对于杰杰来说，作为嵌入式开发者，我是很看好物联网的，也一直在往这条路上缓缓前行，在万物互联的时代，说不定真的能在<code>赚钱</code>的同时还能<code>为世界做出一丢丢贡献</code>（如果没有那就算了）。</p><p>据我所知，<code>TencentOS tiny</code>后续也将推出基于事件驱动模型的调度，用于某些单片机上不支持基于上下文调度的多任务。</p><p>顺便再透露一下，我将接下来会写一系列<code>TencentOS tiny</code>内核分析的文章，全网首发哦！ps：<strong>得到源码作者的亲自指点，绝对干货！！！</strong></p><h1 id="图文教程："><a href="#图文教程：" class="headerlink" title="图文教程："></a>图文教程：</h1><h2 id="简单上手："><a href="#简单上手：" class="headerlink" title="简单上手："></a>简单上手：</h2><ul><li><a href="https://blog.csdn.net/jiejiemcu/article/details/101034426" target="_blank" rel="noopener">超详细的 TencentOS tiny 移植到STM32F103全教程</a></li></ul><h2 id="深度源码分析："><a href="#深度源码分析：" class="headerlink" title="深度源码分析："></a>深度源码分析：</h2><ul><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/99618912" target="_blank" rel="noopener">【TencentOS tiny学习】源码分析（1）——task</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/99665883" target="_blank" rel="noopener">【TencentOS tiny学习】源码分析（2）——调度器</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/99687678" target="_blank" rel="noopener">【TencentOS tiny学习】源码分析（3）——队列</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/99781093" target="_blank" rel="noopener">【TencentOS tiny学习】源码分析（4）——消息队列</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/100052643" target="_blank" rel="noopener">【TencentOS tiny学习】源码分析（5）——信号量</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/100056641" target="_blank" rel="noopener">【TencentOS tiny学习】源码分析（6）——互斥锁</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/100492219" target="_blank" rel="noopener">【TencentOS tiny学习】源码分析（7）——事件</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/101846089" target="_blank" rel="noopener">【TencentOS tiny学习】源码分析（8）——软件定时器</a></p></li></ul><h2 id="配套例程："><a href="#配套例程：" class="headerlink" title="配套例程："></a>配套例程：</h2><ul><li><p><a href="https://github.com/jiejieTop/TencentOS-Demo/tree/master/hello-world" target="_blank" rel="noopener">【TencentOS tiny学习】例程（0）——hello world</a></p></li><li><p><a href="https://github.com/jiejieTop/TencentOS-Demo/tree/master/01-task" target="_blank" rel="noopener">【TencentOS tiny学习】例程（1）——task</a></p></li><li><p><a href="https://github.com/jiejieTop/TencentOS-Demo/tree/master/02-queue" target="_blank" rel="noopener">【TencentOS tiny学习】例程（2）——队列</a></p></li><li><p><a href="https://github.com/jiejieTop/TencentOS-Demo/tree/master/03-msg_queue" target="_blank" rel="noopener">【TencentOS tiny学习】例程（3）——消息队列</a></p></li><li><p><a href="https://github.com/jiejieTop/TencentOS-Demo/tree/master/04-sem" target="_blank" rel="noopener">【TencentOS tiny学习】例程（4）——信号量</a></p></li><li><p><a href="https://github.com/jiejieTop/TencentOS-Demo/tree/master/05-mutex" target="_blank" rel="noopener">【TencentOS tiny学习】例程（5）——互斥锁</a></p></li><li><p><a href="https://github.com/jiejieTop/TencentOS-Demo/tree/master/07-event" target="_blank" rel="noopener">【TencentOS tiny学习】例程（6）——事件</a></p></li><li><p><a href="https://github.com/jiejieTop/TencentOS-Demo/tree/master/07-timer" target="_blank" rel="noopener">【TencentOS tiny学习】例程（7）——软件定时器</a></p></li><li><p><a href="https://github.com/jiejieTop/TencentOS-Demo/tree/master/08-mmblk" target="_blank" rel="noopener">【TencentOS tiny学习】例程（8）——内存池</a></p></li><li><p><a href="https://github.com/jiejieTop/TencentOS-Demo/tree/master/09-mmheap" target="_blank" rel="noopener">【TencentOS tiny学习】例程（9）——内存堆</a></p></li></ul><h2 id="视频教程："><a href="#视频教程：" class="headerlink" title="视频教程："></a>视频教程：</h2><ul><li><p><a href="https://www.bilibili.com/video/av70478596" target="_blank" rel="noopener">【TencentOS tiny学习】视频汇总</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=1" target="_blank" rel="noopener">【视频】01-初识TencentOS tiny</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=2" target="_blank" rel="noopener">【视频】02-TencentOS tiny基础知识</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=3" target="_blank" rel="noopener">【视频】03-TencentOS tiny移植</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=4" target="_blank" rel="noopener">【视频】04-TencentOS tiny任务-1</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=5" target="_blank" rel="noopener">【视频】05-TencentOS tiny任务-2</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=6" target="_blank" rel="noopener">【视频】06-TencentOS tiny队列-1</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=7" target="_blank" rel="noopener">【视频】07-TencentOS tiny队列-2</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=8" target="_blank" rel="noopener">【视频】08-TencentOS tiny消息队列</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=9" target="_blank" rel="noopener">【视频】09-TencentOS tiny信号量-1</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=10" target="_blank" rel="noopener">【视频】10-TencentOS tiny信号量-2</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=11" target="_blank" rel="noopener">【视频】11-TencentOS tiny互斥锁-1</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=12" target="_blank" rel="noopener">【视频】12-TencentOS tiny互斥锁-2</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=13" target="_blank" rel="noopener">【视频】13-TencentOS tiny互斥锁-3</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=14" target="_blank" rel="noopener">【视频】14-TencentOS tiny事件-1</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=15" target="_blank" rel="noopener">【视频】15-TencentOS tiny事件-2</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=16" target="_blank" rel="noopener">【视频】16-TencentOS tiny软件定时器-1</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=17" target="_blank" rel="noopener">【视频】17-TencentOS tiny软件定时器-2</a></p></li><li><p><a href="https://www.bilibili.com/video/av70478596/?p=18" target="_blank" rel="noopener">【视频】18-TencentOS tiny软件定时器-3</a></p></li></ul><div style="position: relative; width: 100%; height: 100%; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=70478596&amp;cid=122092611&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;">    </iframe></div><h2 id="相关PPT资料："><a href="#相关PPT资料：" class="headerlink" title="相关PPT资料："></a>相关PPT资料：</h2><ul><li><a href="https://github.com/jiejieTop/TencentOS-Demo/tree/master/PPT" target="_blank" rel="noopener">【TencentOS tiny学习】视频PPT</a></li></ul><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> TencentOS tiny </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TencentOS tiny </tag>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一种Cortex-M内核中的精确延时方法</title>
      <link href="/dwt/"/>
      <url>/dwt/</url>
      
        <content type="html"><![CDATA[<h3 id="本文介绍一种Cortex-M内核中的精确延时方法"><a href="#本文介绍一种Cortex-M内核中的精确延时方法" class="headerlink" title="本文介绍一种Cortex-M内核中的精确延时方法"></a>本文介绍一种Cortex-M内核中的精确延时方法</h3><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为什么要学习这种延时的方法？</p><ol><li>很多时候我们跑操作系统，就一般会占用一个硬件定时器——SysTick，而我们一般操作系统的时钟节拍一般是设置100-1000HZ，也就是1ms——10ms产生一次中断。很多裸机教程使用延时函数又是基于SysTick的，这样一来又难免产生冲突。</li><li>很多人会说，不是还有定时器吗，定时器的计时是超级精确的。这点我不否认，但是假设，如果一个系统，总是进入定时器中断（10us一次/1us一次/0.5us一次），那整个系统就会经常被打断，线程的进行就没办法很好运行啊。此外还消耗一个硬件定时器资源，一个硬件定时器可能做其他事情呢！</li><li>对应ST HAL库的修改，其实杰杰个人觉得吧，ST的东西什么都好，就是出的HAL库太恶心了，没办法，而HAL库中有一个HAL_Delay()，他也是采用SysTick延时的，在移植操作系统的时候，会有诸多不便，不过好在，HAL_Delay()是一个弱定义的，我们可以重写这个函数的实现，那么，采用内核延时当然是最好的办法啦（个人是这么觉得的）当然你有能力完全用for循环写个简单的延时还是可以的。</li><li>可能我说的话没啥权威，那我就引用Cortex-M3权威指南中的一句话——“DWT 中有剩余的计数器，它们典型地用于程序代码的“性能速写”（profiling）。通过编程它们，就可以让它们在计数器溢出时发出事件（以跟踪数据包的形式）。最典型地，就是使用 CYCCNT寄存器来测量执行某个任务所花的周期数，这也可以用作时间基准相关的目的（操作系统中统计 CPU使用率可以用到它）。”<h2 id="Cortex-M中的DWT"><a href="#Cortex-M中的DWT" class="headerlink" title="Cortex-M中的DWT"></a>Cortex-M中的DWT</h2>在Cortex-M里面有一个外设叫DWT(Data Watchpoint and Trace)，是用于系统调试及跟踪，<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181110191659860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppZWppZW1jdQ==,size_16,color_FFFFFF,t_70" alt="">它有一个32位的寄存器叫CYCCNT，它是一个向上的计数器，记录的是内核时钟运行的个数，内核时钟跳动一次，该计数器就加1，精度非常高，决定内核的频率是多少，如果是F103系列，内核时钟是72M，那精度就是1/72M = 14ns，而程序的运行时间都是微秒级别的，所以14ns的精度是远远够的。最长能记录的时间为：60s=2的32次方/72000000(假设内核频率为72M，内核跳一次的时间大概为1/72M=14ns)，而如果是H7这种400M主频的芯片，那它的计时精度高达2.5ns（1/400000000 = 2.5），而如果是 i.MX RT1052这种比较牛逼的处理器，最长能记录的时间为： 8.13s=2的32次方/528000000 (假设内核频率为528M，内核跳一次的时间大概为1/528M=1.9ns) 。当CYCCNT溢出之后，会清0重新开始向上计数。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181110193428964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppZWppZW1jdQ==,size_16,color_FFFFFF,t_70" alt=""></li></ol><blockquote><p>m3、m4、m7杰杰实测可用（m0不可用）。<br>精度：1/内核频率(s)。</p></blockquote><p>要实现延时的功能，总共涉及到三个寄存器：DEMCR 、DWT_CTRL、DWT_CYCCNT，分别用于开启DWT功能、开启CYCCNT及获得系统时钟计数值。</p><h4 id="DEMCR"><a href="#DEMCR" class="headerlink" title="DEMCR"></a>DEMCR</h4><p> 想要使能DWT外设，需要由另外的内核调试寄存器DEMCR的位24控制，写1使能（划重点啦，要考试！！）。<br> DEMCR的地址是<strong>0xE000 EDFC</strong><br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181110192323371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppZWppZW1jdQ==,size_16,color_FFFFFF,t_70" alt=""><br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181110201757887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppZWppZW1jdQ==,size_16,color_FFFFFF,t_70" alt=""></p><h4 id="关于DWT-CYCCNT"><a href="#关于DWT-CYCCNT" class="headerlink" title="关于DWT_CYCCNT"></a>关于DWT_CYCCNT</h4><p>使能DWT_CYCCNT寄存器之前，先清0。<br>让我们看看DWT_CYCCNT的基地址，从ARM-Cortex-M手册中可以看到其基地址是<strong>0xE000 1004</strong>，复位默认值是0，而且它的类型是可读可写的，我们往<strong>0xE000 1004</strong>这个地址写0就将DWT_CYCCNT清0了。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181110195939728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppZWppZW1jdQ==,size_16,color_FFFFFF,t_70" alt=""></p><h4 id="关于CYCCNTENA"><a href="#关于CYCCNTENA" class="headerlink" title="关于CYCCNTENA"></a>关于CYCCNTENA</h4><p>CYCCNTENA Enable the CYCCNT counter. If not enabled, the counter does not count and no event is<br>generated for PS sampling or CYCCNTENA. In normal use, the debugger must initialize<br>the CYCCNT counter to 0.<br>它是DWT控制寄存器的第一位，写1使能，则启用CYCCNT计数器，否则CYCCNT计数器将不会工作。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181110200343311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppZWppZW1jdQ==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="综上所述"><a href="#综上所述" class="headerlink" title="综上所述"></a>综上所述</h3><p><strong>想要使用DWT的CYCCNT步骤：</strong></p><blockquote><ol><li>先使能DWT外设，这个由另外内核调试寄存器DEMCR的位24控制，写1使能</li><li>使能CYCCNT寄存器之前，先清0。</li><li>使能CYCCNT寄存器，这个由DWT的CYCCNTENA 控制，也就是DWT控制寄存器的位0控制，写1使能</li></ol></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**  ******************************************************************  * @file    core_delay.c  * @author  fire  * @version V1.0  * @date    2018-xx-xx  * @brief   使用内核寄存器精确延时  ******************************************************************  * @attention  *  * 实验平台:野火 STM32开发板    * 论坛    :http://www.firebbs.cn  * 淘宝    :https://fire-stm32.taobao.com  *  ******************************************************************  */</span>#include <span class="token string">"./delay/core_delay.h"</span>   <span class="token comment" spellcheck="true">/************************************************************************         时间戳相关寄存器定义***********************************************************************/</span><span class="token comment" spellcheck="true">/* 在Cortex-M里面有一个外设叫DWT(Data Watchpoint and Trace)， 该外设有一个32位的寄存器叫CYCCNT，它是一个向上的计数器， 记录的是内核时钟运行的个数，最长能记录的时间为： 10.74s=2的32次方/400000000 (假设内核频率为400M，内核跳一次的时间大概为1/400M=2.5ns) 当CYCCNT溢出之后，会清0重新开始向上计数。 使能CYCCNT计数的操作步骤： 1、先使能DWT外设，这个由另外内核调试寄存器DEMCR的位24控制，写1使能 2、使能CYCCNT寄存器之前，先清0 3、使能CYCCNT寄存器，这个由DWT_CTRL(代码上宏定义为DWT_CR)的位0控制，写1使能 */</span>#define  DWT_CR      <span class="token operator">*</span><span class="token punctuation">(</span>__IO uint32_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0xE0001000</span>#define  DWT_CYCCNT  <span class="token operator">*</span><span class="token punctuation">(</span>__IO uint32_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0xE0001004</span>#define  DEM_CR      <span class="token operator">*</span><span class="token punctuation">(</span>__IO uint32_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0xE000EDFC</span>#define  DEM_CR_TRCENA                   <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">24</span><span class="token punctuation">)</span>#define  DWT_CR_CYCCNTENA                <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span>  <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">/**  * @brief  初始化时间戳  * @param  无  * @retval 无  * @note   使用延时函数前，必须调用本函数  */</span>HAL_StatusTypeDef <span class="token function">HAL_InitTick</span><span class="token punctuation">(</span>uint32_t TickPriority<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 使能DWT外设 */</span>    DEM_CR <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span>DEM_CR_TRCENA<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">/* DWT CYCCNT寄存器计数清0 */</span>    DWT_CYCCNT <span class="token operator">=</span> <span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span>0u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 使能Cortex-M DWT CYCCNT寄存器 */</span>    DWT_CR <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span>DWT_CR_CYCCNTENA<span class="token punctuation">;</span>    <span class="token keyword">return</span> HAL_OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * @brief  读取当前时间戳  * @param  无  * @retval 当前时间戳，即DWT_CYCCNT寄存器的值  */</span>uint32_t <span class="token function">CPU_TS_TmrRd</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span>DWT_CYCCNT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * @brief  读取当前时间戳  * @param  无  * @retval 当前时间戳，即DWT_CYCCNT寄存器的值  */</span>uint32_t <span class="token function">HAL_GetTick</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span>DWT_CYCCNT<span class="token operator">/</span>SysClockFreq<span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**  * @brief  采用CPU的内部计数实现精确延时，32位计数器  * @param  us : 延迟长度，单位1 us  * @retval 无  * @note   使用本函数前必须先调用CPU_TS_TmrInit函数使能计数器，            或使能宏CPU_TS_INIT_IN_DELAY_FUNCTION            最大延时值为8秒，即8*1000*1000  */</span><span class="token keyword">void</span> <span class="token function">CPU_TS_Tmr_Delay_US</span><span class="token punctuation">(</span>uint32_t us<span class="token punctuation">)</span><span class="token punctuation">{</span>  uint32_t ticks<span class="token punctuation">;</span>  uint32_t told<span class="token punctuation">,</span>tnow<span class="token punctuation">,</span>tcnt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 在函数内部初始化时间戳寄存器， */</span>  #<span class="token keyword">if</span> <span class="token punctuation">(</span>CPU_TS_INIT_IN_DELAY_FUNCTION<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">/* 初始化时间戳并清零 */</span>  <span class="token function">HAL_InitTick</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>#endif  ticks <span class="token operator">=</span> us <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token function">GET_CPU_ClkFreq</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 需要的节拍数 */</span>        tcnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  told <span class="token operator">=</span> <span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span><span class="token function">CPU_TS_TmrRd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* 刚进入时的计数器值 */</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    tnow <span class="token operator">=</span> <span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span><span class="token function">CPU_TS_TmrRd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>tnow <span class="token operator">!=</span> told<span class="token punctuation">)</span>    <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">/* 32位计数器是递增计数器 */</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>tnow <span class="token operator">></span> told<span class="token punctuation">)</span>      <span class="token punctuation">{</span>        tcnt <span class="token operator">+</span><span class="token operator">=</span> tnow <span class="token operator">-</span> told<span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">/* 重新装载 */</span>      <span class="token keyword">else</span>       <span class="token punctuation">{</span>        tcnt <span class="token operator">+</span><span class="token operator">=</span> UINT32_MAX <span class="token operator">-</span> told <span class="token operator">+</span> tnow<span class="token punctuation">;</span>       <span class="token punctuation">}</span>       told <span class="token operator">=</span> tnow<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*时间超过/等于要延迟的时间,则退出 */</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>tcnt <span class="token operator">>=</span> ticks<span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*********************************************END OF FILE**********************/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">#ifndef __CORE_DELAY_H#define __CORE_DELAY_H#include <span class="token string">"stm32h7xx.h"</span><span class="token comment" spellcheck="true">/* 获取内核时钟频率 */</span>#define <span class="token function">GET_CPU_ClkFreq</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token function">HAL_RCC_GetSysClockFreq</span><span class="token punctuation">(</span><span class="token punctuation">)</span>#define SysClockFreq            <span class="token punctuation">(</span><span class="token number">218000000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">/* 为方便使用，在延时函数内部调用CPU_TS_TmrInit函数初始化时间戳寄存器，   这样每次调用函数都会初始化一遍。   把本宏值设置为0，然后在main函数刚运行时调用CPU_TS_TmrInit可避免每次都初始化 */</span>  #define CPU_TS_INIT_IN_DELAY_FUNCTION   <span class="token number">0</span>  <span class="token comment" spellcheck="true">/******************************************************************************* * 函数声明 ******************************************************************************/</span>uint32_t <span class="token function">CPU_TS_TmrRd</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>HAL_StatusTypeDef <span class="token function">HAL_InitTick</span><span class="token punctuation">(</span>uint32_t TickPriority<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用以下函数前必须先调用CPU_TS_TmrInit函数使能计数器，或使能宏CPU_TS_INIT_IN_DELAY_FUNCTION</span><span class="token comment" spellcheck="true">//最大延时值为8秒</span><span class="token keyword">void</span> <span class="token function">CPU_TS_Tmr_Delay_US</span><span class="token punctuation">(</span>uint32_t us<span class="token punctuation">)</span><span class="token punctuation">;</span>#define <span class="token function">HAL_Delay</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span>     <span class="token function">CPU_TS_Tmr_Delay_US</span><span class="token punctuation">(</span>ms<span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span>#define <span class="token function">CPU_TS_Tmr_Delay_S</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>       <span class="token function">CPU_TS_Tmr_Delay_MS</span><span class="token punctuation">(</span>s<span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span>#endif <span class="token comment" spellcheck="true">/* __CORE_DELAY_H */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><p>使用者如果不是在HAL库中使用，注释掉：</p><pre class="line-numbers language-js"><code class="language-js">uint32_t <span class="token function">HAL_GetTick</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span>DWT_CYCCNT<span class="token operator">/</span>SysClockFreq<span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同时建议重新命名<code>HAL_InitTick()</code>函数。</p><p>按照自己的平台重写以下宏定义：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* 获取内核时钟频率 */</span>#define <span class="token function">GET_CPU_ClkFreq</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token function">HAL_RCC_GetSysClockFreq</span><span class="token punctuation">(</span><span class="token punctuation">)</span>#define SysClockFreq            <span class="token punctuation">(</span><span class="token number">218000000</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>其实在ucos-iii 源码中，有一个功能是测量关中断时间的功能，就是使用STM32的时间戳，即记录程序运行的某个时刻，如果记录下程序前后的两个时刻点，即可以算出这段程序的运行时间。<br>但是有关内核寄存器的描述的资料非常少，还好找到一个（arm手册），里面有这些内核寄存器的详细描述，其中时间戳相关的寄存器在第10章和11章有详细的描述。关于资料想看的可以后台找我拿。</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台回复 “ <strong>DWT</strong> ”获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> Cortex-M </tag>
            
            <tag> DWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Linux的kfifo移植到STM32（支持os的互斥访问）</title>
      <link href="/kfifo/"/>
      <url>/kfifo/</url>
      
        <content type="html"><![CDATA[<h2 id="基于Linux的kfifo移植到STM32（支持os的互斥访问）"><a href="#基于Linux的kfifo移植到STM32（支持os的互斥访问）" class="headerlink" title="基于Linux的kfifo移植到STM32（支持os的互斥访问）"></a>基于Linux的kfifo移植到STM32（支持os的互斥访问）</h2><h3 id="关于kfifo"><a href="#关于kfifo" class="headerlink" title="关于kfifo"></a>关于kfifo</h3><p>kfifo是内核里面的一个First In First Out数据结构，它采用环形循环队列的数据结构来实现；它提供一个无边界的字节流服务，最重要的一点是，它使用并行无锁编程技术，即当它用于只有一个入队线程和一个出队线程的场情时，两个线程可以并发操作，而不需要任何加锁行为，就可以保证kfifo的线程安全。</p><blockquote><p>具体什么是环形缓冲区，请看我以前的文章</p></blockquote><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><blockquote><p>关于kfifo的相关概念我不会介绍，有兴趣可以看他的相关文档，我只将其实现过程移植重写，移植到适用stm32开发板上，并且按照我个人习惯重新命名，<strong>RingBuff</strong>-&gt;意为环形缓冲区</p></blockquote><h3 id="RingBuff-t"><a href="#RingBuff-t" class="headerlink" title="RingBuff_t"></a>RingBuff_t</h3><p>环形缓冲区的结构体成员变量，具体含义看注释。<br>  buffer: 用于存放数据的缓存<br>  size: buffer空间的大小<br>  in, out: 和buffer一起构成一个循环队列。 in指向buffer中队头，而且out指向buffer中的队尾</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> ringbuff <span class="token punctuation">{</span>    uint8_t <span class="token operator">*</span>buffer<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* 数据区域 */</span>    uint32_t size<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* 环形缓冲区大小 */</span>    uint32_t in<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 数据入队指针 (in % size) */</span>    uint32_t out<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/* 数据出队指针 (out % size) */</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_MUTEX</span>    MUTEX_T <span class="token operator">*</span>mutex<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/* 支持rtos的互斥 */</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token punctuation">}</span>RingBuff_t <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Create-RingBuff"><a href="#Create-RingBuff" class="headerlink" title="Create_RingBuff"></a>Create_RingBuff</h3><p>创建一个环形缓冲区，为了适应后续对缓冲区入队出队的高效操作，环形缓冲区的大小应为2^n字节，<br>如果不是这个大小，则系统默认裁剪以对应缓冲区字节。<br>当然还可以优化，不过我目前并未做，思路如下：如果系统支持动态分配内存，则向上对齐，避免浪费内存空间，否则就按照我默认的向下对齐，当内存越大，对齐导致内存泄漏则会越多。对齐采用的函数是<code>roundup_pow_of_two</code>。如果系统支持互斥量，那么还将创建一个互斥量用来做互斥访问，防止多线程同时使用导致数据丢失。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/************************************************************  * @brief   Create_RingBuff  * @param   rb：环形缓冲区句柄  *          buffer：环形缓冲区的数据区域  *          size：环形缓冲区的大小，缓冲区大小要为2^n  * @return  err_t：ERR_OK表示创建成功，其他表示失败  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    用于创建一个环形缓冲区  ***********************************************************/</span>err_t <span class="token function">Create_RingBuff</span><span class="token punctuation">(</span>RingBuff_t<span class="token operator">*</span> rb<span class="token punctuation">,</span>                       uint8_t <span class="token operator">*</span>buffer<span class="token punctuation">,</span>                      uint32_t size                                <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>rb <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>buffer <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">PRINT_ERR</span><span class="token punctuation">(</span><span class="token string">"data is null!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ERR_NULL<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">PRINT_DEBUG</span><span class="token punctuation">(</span><span class="token string">"ringbuff size is %d!"</span><span class="token punctuation">,</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 缓冲区大小必须为2^n字节,系统会强制转换,         否则可能会导致指针访问非法地址。         空间大小越大,强转时丢失内存越多 */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>size<span class="token operator">&amp;</span><span class="token punctuation">(</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        size <span class="token operator">=</span> <span class="token function">roundup_pow_of_two</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PRINT_DEBUG</span><span class="token punctuation">(</span><span class="token string">"change ringbuff size is %d!"</span><span class="token punctuation">,</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    rb<span class="token operator">-></span>buffer <span class="token operator">=</span> buffer<span class="token punctuation">;</span>    rb<span class="token operator">-></span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>    rb<span class="token operator">-></span>in <span class="token operator">=</span> rb<span class="token operator">-></span>out <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_MUTEX    </span>  <span class="token comment" spellcheck="true">/* 创建信号量不成功 */</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">create_mutex</span><span class="token punctuation">(</span>rb<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">PRINT_ERR</span><span class="token punctuation">(</span><span class="token string">"create mutex fail!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>ASSERT_ERR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ERR_NOK<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    <span class="token function">PRINT_DEBUG</span><span class="token punctuation">(</span><span class="token string">"create ringBuff ok!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ERR_OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="roundup-pow-of-two"><a href="#roundup-pow-of-two" class="headerlink" title="roundup_pow_of_two"></a>roundup_pow_of_two</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/************************************************************  * @brief   roundup_pow_of_two  * @param   size：传递进来的数据长度  * @return  size：返回处理之后的数据长度  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    用于处理数据，使数据长度必须为 2^n    *                     如果不是，则转换，丢弃多余部分，如    *                     roundup_pow_of_two(66) -> 返回 64  ***********************************************************/</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">roundup_pow_of_two</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token function">fls</span><span class="token punctuation">(</span>x<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//向下对齐</span>  <span class="token comment" spellcheck="true">//return (1UL &lt;&lt; fls(x - 1));            //向上对齐，用动态内存可用使用</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Delete-RingBuff"><a href="#Delete-RingBuff" class="headerlink" title="Delete_RingBuff"></a>Delete_RingBuff</h3><p>删除一个环形缓冲区，删除之后，缓冲区真正存储地址是不会被改变的（目前我是使用自定义数组做缓冲区的），但是删除之后，就无法对缓冲区进行读写操作。并且如果支持os的话，创建的互斥量会被删除。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/************************************************************  * @brief   Delete_RingBuff  * @param   rb：环形缓冲区句柄  * @return  err_t：ERR_OK表示成功，其他表示失败  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    删除一个环形缓冲区  ***********************************************************/</span>err_t <span class="token function">Delete_RingBuff</span><span class="token punctuation">(</span>RingBuff_t <span class="token operator">*</span>rb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>rb <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">PRINT_ERR</span><span class="token punctuation">(</span><span class="token string">"ringbuff is null!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ERR_NULL<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    rb<span class="token operator">-></span>buffer <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    rb<span class="token operator">-></span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    rb<span class="token operator">-></span>in <span class="token operator">=</span> rb<span class="token operator">-></span>out <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_MUTEX    </span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">deleta_mutex</span><span class="token punctuation">(</span>rb<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">PRINT_DEBUG</span><span class="token punctuation">(</span><span class="token string">"deleta mutex is fail!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ERR_NOK<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    <span class="token keyword">return</span> ERR_OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Write-RingBuff"><a href="#Write-RingBuff" class="headerlink" title="Write_RingBuff"></a>Write_RingBuff</h3><p>向环形缓冲区写入指定数据，支持线程互斥访问。用户想要写入缓冲区的数据长度不一定是真正入队的长度，在完成的时候还要看看返回值是否与用户需要的长度一致~<br>这个函数很有意思，也是比较高效的入队操作，将指定区域的数据拷贝到指定的缓冲区中，过程看注释即可</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/************************************************************  * @brief   Write_RingBuff  * @param   rb:环形缓冲区句柄  * @param   wbuff:写入的数据起始地址  * @param   len:写入数据的长度(字节)  * @return  len:实际写入数据的长度(字节)  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    这个函数会从buff空间拷贝len字节长度的数据到             rb环形缓冲区中的空闲空间。  ***********************************************************/</span>uint32_t <span class="token function">Write_RingBuff</span><span class="token punctuation">(</span>RingBuff_t <span class="token operator">*</span>rb<span class="token punctuation">,</span>                        uint8_t <span class="token operator">*</span>wbuff<span class="token punctuation">,</span>                         uint32_t len<span class="token punctuation">)</span><span class="token punctuation">{</span>  uint32_t l<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_MUTEX</span>  <span class="token comment" spellcheck="true">/* 请求互斥量，成功才能进行ringbuff的访问 */</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">request_mutex</span><span class="token punctuation">(</span>rb<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">PRINT_DEBUG</span><span class="token punctuation">(</span><span class="token string">"request mutex fail!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span>  <span class="token comment" spellcheck="true">/* 获取互斥量成功 */</span>  <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    len <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> rb<span class="token operator">-></span>size <span class="token operator">-</span> rb<span class="token operator">-></span>in <span class="token operator">+</span> rb<span class="token operator">-></span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 第一部分的拷贝:从环形缓冲区写入数据直至缓冲区最后一个地址 */</span>    l <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> rb<span class="token operator">-></span>size <span class="token operator">-</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>in <span class="token operator">&amp;</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>rb<span class="token operator">-></span>buffer <span class="token operator">+</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>in <span class="token operator">&amp;</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> wbuff<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 如果溢出则在缓冲区头写入剩余的部分       如果没溢出这句代码相当于无效 */</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>rb<span class="token operator">-></span>buffer<span class="token punctuation">,</span> wbuff <span class="token operator">+</span> l<span class="token punctuation">,</span> len <span class="token operator">-</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>    rb<span class="token operator">-></span>in <span class="token operator">+</span><span class="token operator">=</span> len<span class="token punctuation">;</span>    <span class="token function">PRINT_DEBUG</span><span class="token punctuation">(</span><span class="token string">"write ringBuff len is %d!"</span><span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_MUTEX</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/* 释放互斥量 */</span>  <span class="token function">release_mutex</span><span class="token punctuation">(</span>rb<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>  <span class="token keyword">return</span> len<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Read-RingBuff"><a href="#Read-RingBuff" class="headerlink" title="Read_RingBuff"></a>Read_RingBuff</h3><p>读取缓冲区数据到指定区域，用户指定读取长度，用户想要读取的长度不一定是真正读取的长度，在读取完成的时候还要看看返回值是否与用户需要的长度一致~也支持多线程互斥访问。<br>也是缓冲区出队的高效操作。过程看代码注释即可</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/************************************************************  * @brief   Read_RingBuff  * @param   rb:环形缓冲区句柄  * @param   wbuff:读取数据保存的起始地址  * @param   len:想要读取数据的长度(字节)  * @return  len:实际读取数据的长度(字节)  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    这个函数会从rb环形缓冲区中的数据区域拷贝len字节             长度的数据到rbuff空间。  ***********************************************************/</span>uint32_t <span class="token function">Read_RingBuff</span><span class="token punctuation">(</span>RingBuff_t <span class="token operator">*</span>rb<span class="token punctuation">,</span>                       uint8_t <span class="token operator">*</span>rbuff<span class="token punctuation">,</span>                        uint32_t len<span class="token punctuation">)</span><span class="token punctuation">{</span>  uint32_t l<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_MUTEX</span>  <span class="token comment" spellcheck="true">/* 请求互斥量，成功才能进行ringbuff的访问 */</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">request_mutex</span><span class="token punctuation">(</span>rb<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">PRINT_DEBUG</span><span class="token punctuation">(</span><span class="token string">"request mutex fail!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span>  <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    len <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> rb<span class="token operator">-></span>in <span class="token operator">-</span> rb<span class="token operator">-></span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 第一部分的拷贝:从环形缓冲区读取数据直至缓冲区最后一个 */</span>    l <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> rb<span class="token operator">-></span>size <span class="token operator">-</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>out <span class="token operator">&amp;</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>rbuff<span class="token punctuation">,</span> rb<span class="token operator">-></span>buffer <span class="token operator">+</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>out <span class="token operator">&amp;</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 如果溢出则在缓冲区头读取剩余的部分       如果没溢出这句代码相当于无效 */</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>rbuff <span class="token operator">+</span> l<span class="token punctuation">,</span> rb<span class="token operator">-></span>buffer<span class="token punctuation">,</span> len <span class="token operator">-</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>    rb<span class="token operator">-></span>out <span class="token operator">+</span><span class="token operator">=</span> len<span class="token punctuation">;</span>    <span class="token function">PRINT_DEBUG</span><span class="token punctuation">(</span><span class="token string">"read ringBuff len is %d!"</span><span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_MUTEX</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/* 释放互斥量 */</span>  <span class="token function">release_mutex</span><span class="token punctuation">(</span>rb<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>  <span class="token keyword">return</span> len<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取缓冲区信息"><a href="#获取缓冲区信息" class="headerlink" title="获取缓冲区信息"></a>获取缓冲区信息</h3><p>这些就比较简单了，看看缓冲区可读可写的数据有多少</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/************************************************************  * @brief   CanRead_RingBuff    * @param   rb:环形缓冲区句柄    * @return  uint32:可读数据长度 0 / len  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    可读数据长度  ***********************************************************/</span>uint32_t <span class="token function">CanRead_RingBuff</span><span class="token punctuation">(</span>RingBuff_t <span class="token operator">*</span>rb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> rb<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">PRINT_ERR</span><span class="token punctuation">(</span><span class="token string">"ringbuff is null!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>rb<span class="token operator">-></span>in <span class="token operator">==</span> rb<span class="token operator">-></span>out<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>rb<span class="token operator">-></span>in <span class="token operator">></span> rb<span class="token operator">-></span>out<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>in <span class="token operator">-</span> rb<span class="token operator">-></span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>size <span class="token operator">-</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>out <span class="token operator">-</span> rb<span class="token operator">-></span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/************************************************************  * @brief   CanRead_RingBuff    * @param   rb:环形缓冲区句柄    * @return  uint32:可写数据长度 0 / len  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    可写数据长度  ***********************************************************/</span>uint32_t <span class="token function">CanWrite_RingBuff</span><span class="token punctuation">(</span>RingBuff_t <span class="token operator">*</span>rb<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> rb<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">PRINT_ERR</span><span class="token punctuation">(</span><span class="token string">"ringbuff is null!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>rb<span class="token operator">-></span>size <span class="token operator">-</span> <span class="token function">CanRead_RingBuff</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="附带"><a href="#附带" class="headerlink" title="附带"></a>附带</h3><p>这里的代码我是用于测试的，随便写的</p><pre><code>    RingBuff_t ringbuff_handle;    uint8_t rb[64];    uint8_t res[64];    Create_RingBuff(&amp;ringbuff_handle,                                 rb,                                sizeof(rb));            Write_RingBuff(&amp;ringbuff_handle,                     res,                      datapack.data_length);            PRINT_DEBUG("CanRead_RingBuff = %d!",CanRead_RingBuff(&amp;ringbuff_handle));            PRINT_DEBUG("CanWrite_RingBuff = %d!",CanWrite_RingBuff(&amp;ringbuff_handle));            Read_RingBuff(&amp;ringbuff_handle,                     res,                      datapack.data_length);</code></pre><h3 id="支持多个os的互斥量操作"><a href="#支持多个os的互斥量操作" class="headerlink" title="支持多个os的互斥量操作"></a>支持多个os的互斥量操作</h3><p>此处模仿了文件系统的互斥操作</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">if</span> USE_MUTEX</span><span class="token macro property">#<span class="token directive keyword">define</span>  MUTEX_TIMEOUT   1000     </span><span class="token comment" spellcheck="true">/* 超时时间 */</span><span class="token macro property">#<span class="token directive keyword">define</span>  MUTEX_T         mutex_t  </span><span class="token comment" spellcheck="true">/* 互斥量控制块 */</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token comment" spellcheck="true">/*********************************** mutex **************************************************/</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_MUTEX</span><span class="token comment" spellcheck="true">/************************************************************  * @brief   create_mutex  * @param   mutex:创建信号量句柄  * @return  创建成功为1，0为不成功。  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    创建一个互斥量,用户在os中互斥使用ringbuff，  *          支持的os有rtt、win32、ucos、FreeRTOS、LiteOS  ***********************************************************/</span><span class="token keyword">static</span> err_t <span class="token function">create_mutex</span><span class="token punctuation">(</span>MUTEX_T <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">{</span>  err_t ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    *mutex = rt_mutex_create("test_mux",RT_IPC_FLAG_PRIO); </span><span class="token comment" spellcheck="true">/* rtt */</span><span class="token comment" spellcheck="true">//    ret = (err_t)(*mutex != RT_NULL);</span><span class="token comment" spellcheck="true">//    *mutex = CreateMutex(NULL, FALSE, NULL);        </span><span class="token comment" spellcheck="true">/* Win32 */</span><span class="token comment" spellcheck="true">//    ret = (err_t)(*mutex != INVALID_HANDLE_VALUE);</span><span class="token comment" spellcheck="true">//    *mutex = OSMutexCreate(0, &amp;err);        </span><span class="token comment" spellcheck="true">/* uC/OS-II */</span><span class="token comment" spellcheck="true">//    ret = (err_t)(err == OS_NO_ERR);</span><span class="token comment" spellcheck="true">//    *mutex = xSemaphoreCreateMutex();    </span><span class="token comment" spellcheck="true">/* FreeRTOS */</span><span class="token comment" spellcheck="true">//    ret = (err_t)(*mutex != NULL);</span><span class="token comment" spellcheck="true">//  ret = LOS_MuxCreate(&amp;mutex);  </span><span class="token comment" spellcheck="true">/* LiteOS */</span><span class="token comment" spellcheck="true">//    ret = (err_t)(ret != LOS_OK);</span>  <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/************************************************************  * @brief   deleta_mutex  * @param   mutex:互斥量句柄  * @return  NULL  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    删除一个互斥量，支持的os有rtt、win32、ucos、FreeRTOS、LiteOS  ***********************************************************/</span><span class="token keyword">static</span> err_t <span class="token function">deleta_mutex</span><span class="token punctuation">(</span>MUTEX_T <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">{</span>    err_t ret<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    ret = rt_mutex_delete(mutex);    </span><span class="token comment" spellcheck="true">/* rtt */</span><span class="token comment" spellcheck="true">//    ret = CloseHandle(mutex);    </span><span class="token comment" spellcheck="true">/* Win32 */</span><span class="token comment" spellcheck="true">//    OSMutexDel(mutex, OS_DEL_ALWAYS, &amp;err);    </span><span class="token comment" spellcheck="true">/* uC/OS-II */</span><span class="token comment" spellcheck="true">//    ret = (err_t)(err == OS_NO_ERR);</span><span class="token comment" spellcheck="true">//  vSemaphoreDelete(mutex);        </span><span class="token comment" spellcheck="true">/* FreeRTOS */</span><span class="token comment" spellcheck="true">//    ret = 1;</span><span class="token comment" spellcheck="true">//  ret = LOS_MuxDelete(&amp;mutex);  </span><span class="token comment" spellcheck="true">/* LiteOS */</span><span class="token comment" spellcheck="true">//    ret = (err_t)(ret != LOS_OK);</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/************************************************************  * @brief   request_mutex  * @param   mutex:互斥量句柄  * @return  NULL  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    请求一个互斥量，得到互斥量的线程才允许进行访问缓冲区  *          支持的os有rtt、win32、ucos、FreeRTOS、LiteOS  ***********************************************************/</span><span class="token keyword">static</span> err_t <span class="token function">request_mutex</span><span class="token punctuation">(</span>MUTEX_T <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">{</span>    err_t ret<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    ret = (err_t)(rt_mutex_take(mutex, MUTEX_TIMEOUT) == RT_EOK);</span><span class="token comment" spellcheck="true">/* rtt */</span><span class="token comment" spellcheck="true">//    ret = (err_t)(WaitForSingleObject(mutex, MUTEX_TIMEOUT) == WAIT_OBJECT_0);    </span><span class="token comment" spellcheck="true">/* Win32 */</span><span class="token comment" spellcheck="true">//    OSMutexPend(mutex, MUTEX_TIMEOUT, &amp;err));        </span><span class="token comment" spellcheck="true">/* uC/OS-II */</span><span class="token comment" spellcheck="true">//    ret = (err_t)(err == OS_NO_ERR);</span><span class="token comment" spellcheck="true">//    ret = (err_t)(xSemaphoreTake(mutex, MUTEX_TIMEOUT) == pdTRUE);    </span><span class="token comment" spellcheck="true">/* FreeRTOS */</span><span class="token comment" spellcheck="true">//  ret = (err_t)(LOS_MuxPend(mutex,MUTEX_TIMEOUT) == LOS_OK);          </span><span class="token comment" spellcheck="true">/* LiteOS */</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/************************************************************  * @brief   release_mutex  * @param   mutex:互斥量句柄  * @return  NULL  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    释放互斥量，当线程使用完资源必须释放互斥量  *          支持的os有rtt、win32、ucos、FreeRTOS、LiteOS  ***********************************************************/</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">release_mutex</span><span class="token punctuation">(</span>MUTEX_T <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//    rt_mutex_release(mutex);</span><span class="token comment" spellcheck="true">/* rtt */</span><span class="token comment" spellcheck="true">//    ReleaseMutex(mutex);        </span><span class="token comment" spellcheck="true">/* Win32 */</span><span class="token comment" spellcheck="true">//    OSMutexPost(mutex);        </span><span class="token comment" spellcheck="true">/* uC/OS-II */</span><span class="token comment" spellcheck="true">//    xSemaphoreGive(mutex);    </span><span class="token comment" spellcheck="true">/* FreeRTOS */</span><span class="token comment" spellcheck="true">//  LOS_MuxPost(mutex);   </span><span class="token comment" spellcheck="true">/* LiteOS */</span><span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token comment" spellcheck="true">/*********************************** mutex **************************************************/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="debug-h"><a href="#debug-h" class="headerlink" title="debug.h"></a>debug.h</h3><p>最后送一份debug的简便操作源码，因为前文很多时候会调用<br><code>PRINT_ERR</code><br><code>PRINT_DEBUG</code></p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">ifndef</span> _DEBUG_H</span><span class="token macro property">#<span class="token directive keyword">define</span> _DEBUG_H</span><span class="token comment" spellcheck="true">/************************************************************  * @brief   debug.h  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    此文件用于打印日志信息  ***********************************************************/</span><span class="token comment" spellcheck="true">/*** @name Debug print * @{*/</span><span class="token macro property">#<span class="token directive keyword">define</span> PRINT_DEBUG_ENABLE        1        </span><span class="token comment" spellcheck="true">/* 打印调试信息 */</span><span class="token macro property">#<span class="token directive keyword">define</span> PRINT_ERR_ENABLE            1     </span><span class="token comment" spellcheck="true">/* 打印错误信息 */</span><span class="token macro property">#<span class="token directive keyword">define</span> PRINT_INFO_ENABLE            0        </span><span class="token comment" spellcheck="true">/* 打印个人信息 */</span><span class="token macro property">#<span class="token directive keyword">if</span> PRINT_DEBUG_ENABLE</span><span class="token macro property">#<span class="token directive keyword">define</span> PRINT_DEBUG(fmt, args...)      do{(printf("\n[DEBUG] >> "), printf(fmt, ##args));}while(0)     </span><span class="token macro property">#<span class="token directive keyword">else</span></span><span class="token macro property">#<span class="token directive keyword">define</span> PRINT_DEBUG(fmt, args...)         </span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">if</span> PRINT_ERR_ENABLE</span><span class="token macro property">#<span class="token directive keyword">define</span> PRINT_ERR(fmt, args...)      do{(printf("\n[ERR] >> "), printf(fmt, ##args));}while(0)     </span><span class="token macro property">#<span class="token directive keyword">else</span></span><span class="token macro property">#<span class="token directive keyword">define</span> PRINT_ERR(fmt, args...)           </span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">if</span> PRINT_INFO_ENABLE</span><span class="token macro property">#<span class="token directive keyword">define</span> PRINT_INFO(fmt, args...)      do{(printf("\n[INFO] >> "), printf(fmt, ##args));}while(0)     </span><span class="token macro property">#<span class="token directive keyword">else</span></span><span class="token macro property">#<span class="token directive keyword">define</span> PRINT_INFO(fmt, args...)           </span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token comment" spellcheck="true">/**@} */</span><span class="token comment" spellcheck="true">//针对不同的编译器调用不同的stdint.h文件</span><span class="token macro property">#<span class="token directive keyword">if</span> defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__)</span>    <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token comment" spellcheck="true">/* 断言 Assert */</span><span class="token macro property">#<span class="token directive keyword">define</span> AssertCalled(char,int)     printf("\nError:%s,%d\r\n",char,int)</span><span class="token macro property">#<span class="token directive keyword">define</span> ASSERT(x)   if((x)==0)  AssertCalled(__FILE__,__LINE__)</span><span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token punctuation">{</span>    ASSERT_ERR <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>                                <span class="token comment" spellcheck="true">/* 错误 */</span>    ASSERT_SUCCESS <span class="token operator">=</span> <span class="token operator">!</span>ASSERT_ERR    <span class="token comment" spellcheck="true">/* 正确 */</span><span class="token punctuation">}</span> Assert_ErrorStatus<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token punctuation">{</span>    FALSE <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">/* 假 */</span>    TRUE <span class="token operator">=</span> <span class="token operator">!</span>FALSE    <span class="token comment" spellcheck="true">/* 真 */</span><span class="token punctuation">}</span>ResultStatus<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">/* __DEBUG_H */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> Cortex-M </tag>
            
            <tag> kfifo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32进阶之串口环形缓冲区实现</title>
      <link href="/fifo/"/>
      <url>/fifo/</url>
      
        <content type="html"><![CDATA[<h1 id="队列的概念"><a href="#队列的概念" class="headerlink" title="队列的概念"></a>队列的概念</h1><p>在此之前，我们来回顾一下队列的基本概念：</p><p>队列 (Queue)：是一种先进先出(First In First Out ,简称 FIFO)的线性表，只允许在一端插入（入队），在另一端进行删除（出队）。<br><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/fifo-1.jpg" alt="fifo-1"></p><h1 id="队列的特点"><a href="#队列的特点" class="headerlink" title="队列的特点"></a>队列的特点</h1><p>类似售票排队窗口，先到的人看到能先买到票，然后先走，后来的人只能后买到票</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/fifo-2.jpg" alt="fifo-2"></p><h1 id="队列的常见两种形式"><a href="#队列的常见两种形式" class="headerlink" title="队列的常见两种形式"></a>队列的常见两种形式</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/fifo-3.jpg" alt="fifo-3"></p><h2 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h2><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/fifo-4.jpg" alt="fifo-4"></p><p>在计算机中，每个信息都是存储在存储单元中的，比喻一下吧，上图的一些小正方形格子就是一个个存储单元，你可以理解为常见的数组，存放我们一个个的信息。</p><p>当有大量数据的时候，我们不能存储所有的数据，那么计算机处理数据的时候，只能先处理先来的，那么处理完后呢，就会把数据释放掉，再处理下一个。那么，已经处理的数据的内存就会被浪费掉。因为后来的数据只能往后排队，如过要将剩余的数据都往前移动一次，那么效率就会低下了，肯定不现实，所以，环形队列就出现了。</p><h2 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h2><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/fifo-5.jpg" alt="fifo-5"></p><p>它的队列就是一个环，它避免了普通队列的缺点，就是有点难理解而已，其实它就是一个队列，一样有队列头，队列尾，一样是先进先出（FIFO）。我们采用顺时针的方式来对队列进行排序。</p><ul><li><p>队列头 (Head) : 允许进行删除的一端称为队首。</p></li><li><p>队列尾 (Tail) : 允许进行插入的一端称为队尾。</p></li></ul><p>环形队列的实现：在计算机中，也是没有环形的内存的，只不过是我们将顺序的内存处理过，让某一段内存形成环形，使他们首尾相连，简单来说，这其实就是一个数组，只不过有两个指针，一个指向列队头，一个指向列队尾。指向列队头的指针(Head)是缓冲区可读的数据，指向列队尾的指针(Tail)是缓冲区可写的数据，通过移动这两个指针(Head) &amp;(Tail)即可对缓冲区的数据进行读写操作了，直到缓冲区已满（头尾相接），将数据处理完，可以释放掉数据，又可以进行存储新的数据了。</p><p>实现的原理：初始化的时候，列队头与列队尾都指向0，当有数据存储的时候，数据存储在‘0’的地址空间，列队尾指向下一个可以存储数据的地方‘1’，再有数据来的时候，存储数据到地址‘1’，然后队列尾指向下一个地址‘2’。当数据要进行处理的时候，肯定是先处理‘0’空间的数据，也就是列队头的数据，处理完了数据，‘0’地址空间的数据进行释放掉，列队头指向下一个可以处理数据的地址‘1’。从而实现整个环形缓冲区的数据读写。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/fifo-6.jpg" alt="fifo-6"></p><p>看图，队列头就是指向已经存储的数据，并且这个数据是待处理的。下一个CPU处理的数据就是1；而队列尾则指向可以进行写数据的地址。当1处理了，就会把1释放掉。并且把队列头指向2。当写入了一个数据6，那么队列尾的指针就会指向下一个可以写的地址。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/fifo-7.jpg" alt="fifo-7"></p><h1 id="从队列到串口缓冲区的实现"><a href="#从队列到串口缓冲区的实现" class="headerlink" title="从队列到串口缓冲区的实现"></a>从队列到串口缓冲区的实现</h1><p>串口环形缓冲区收发：在很多入门级教程中，我们知道的串口收发都是：接收一个数据，触发中断，然后把数据发回来。这种处理方式是没有缓冲的，当数量太大的时候，亦或者当数据接收太快的时候，我们来不及处理已经收到的数据，那么，当再次收到数据的时候，就会将之前还未处理的数据覆盖掉。那么就会出现丢包的现象了，对我们的程序是一个致命的创伤。</p><p>那么如何避免这种情况的发生呢，很显然，上面说的一些队列的特性很容易帮我们实现我们需要的情况。将接受的数据缓存一下，让处理的速度有些许缓冲，使得处理的速度赶得上接收的速度，上面又已经分析了普通队列与环形队列的优劣了，那么我们肯定是用环形队列来进行实现了。下面就是代码的实现：</p><h2 id="定义一个结构体："><a href="#定义一个结构体：" class="headerlink" title="定义一个结构体："></a>定义一个结构体：</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    u16 Head<span class="token punctuation">;</span>               u16 Tail<span class="token punctuation">;</span>    u16 Lenght<span class="token punctuation">;</span>    u8 Ring_Buff<span class="token punctuation">[</span>RINGBUFF_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>RingBuff_t<span class="token punctuation">;</span>RingBuff_t ringBuff<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建一个ringBuff的缓冲区</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化结构体相关信息：使得我们的环形缓冲区是头尾相连的，并且里面没有数据，也就是空的队列。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief  RingBuff_Init * @param  void * @return void * @author 杰杰 * @date   2018 * @version v1.0 * @note   初始化环形缓冲区 */</span><span class="token keyword">void</span> <span class="token function">RingBuff_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//初始化相关信息</span>   ringBuff<span class="token punctuation">.</span>Head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   ringBuff<span class="token punctuation">.</span>Tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   ringBuff<span class="token punctuation">.</span>Lenght <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化效果如下：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/fifo-8.jpg" alt="fifo-8"></p><h2 id="写入环形缓冲区的代码实现："><a href="#写入环形缓冲区的代码实现：" class="headerlink" title="写入环形缓冲区的代码实现："></a>写入环形缓冲区的代码实现：</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief  Write_RingBuff * @param  u8 data * @return FLASE:环形缓冲区已满，写入失败;TRUE:写入成功 * @author 杰杰 * @date   2018 * @version v1.0 * @note   往环形缓冲区写入u8类型的数据 */</span>u8 <span class="token function">Write_RingBuff</span><span class="token punctuation">(</span>u8 data<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>ringBuff<span class="token punctuation">.</span>Lenght <span class="token operator">>=</span> RINGBUFF_LEN<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//判断缓冲区是否已满</span>    <span class="token punctuation">{</span>      <span class="token keyword">return</span> FLASE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ringBuff<span class="token punctuation">.</span>Ring_Buff<span class="token punctuation">[</span>ringBuff<span class="token punctuation">.</span>Tail<span class="token punctuation">]</span><span class="token operator">=</span>data<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    ringBuff.Tail++;</span>    ringBuff<span class="token punctuation">.</span>Tail <span class="token operator">=</span> <span class="token punctuation">(</span>ringBuff<span class="token punctuation">.</span>Tail<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>RINGBUFF_LEN<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//防止越界非法访问</span>    ringBuff<span class="token punctuation">.</span>Lenght<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> TRUE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="读取缓冲区的数据的代码实现："><a href="#读取缓冲区的数据的代码实现：" class="headerlink" title="读取缓冲区的数据的代码实现："></a>读取缓冲区的数据的代码实现：</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief  Read_RingBuff * @param  u8 *rData，用于保存读取的数据 * @return FLASE:环形缓冲区没有数据，读取失败;TRUE:读取成功 * @author 杰杰 * @date   2018 * @version v1.0 * @note   从环形缓冲区读取一个u8类型的数据 */</span>u8 <span class="token function">Read_RingBuff</span><span class="token punctuation">(</span>u8 <span class="token operator">*</span>rData<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>ringBuff<span class="token punctuation">.</span>Lenght <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//判断非空</span>    <span class="token punctuation">{</span>       <span class="token keyword">return</span> FLASE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token operator">*</span>rData <span class="token operator">=</span> ringBuff<span class="token punctuation">.</span>Ring_Buff<span class="token punctuation">[</span>ringBuff<span class="token punctuation">.</span>Head<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//先进先出FIFO，从缓冲区头出</span><span class="token comment" spellcheck="true">//   ringBuff.Head++;</span>   ringBuff<span class="token punctuation">.</span>Head <span class="token operator">=</span> <span class="token punctuation">(</span>ringBuff<span class="token punctuation">.</span>Head<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>RINGBUFF_LEN<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//防止越界非法访问</span>   ringBuff<span class="token punctuation">.</span>Lenght<span class="token operator">--</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> TRUE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于读写操作需要注意的地方有两个：</p><ol><li><p>判断队列是否为空或者满，如果空的话，是不允许读取数据的，返回FLASE。如果是满的话，也是不允许写入数据的，避免将已有数据覆盖掉。那么如果处理的速度赶不上接收的速度，可以适当增大缓冲区的大小，用空间换取时间。</p></li><li><p>防止指针越界非法访问，程序有说明，需要使用者对整个缓冲区的大小进行把握。</p></li></ol><p>那么在串口接收函数中：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">USART1_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">USART_GetITStatus</span><span class="token punctuation">(</span>USART1<span class="token punctuation">,</span> USART_IT_RXNE<span class="token punctuation">)</span> <span class="token operator">!=</span> RESET<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//接收中断</span>                   <span class="token punctuation">{</span>           <span class="token function">USART_ClearITPendingBit</span><span class="token punctuation">(</span>USART1<span class="token punctuation">,</span>USART_IT_RXNE<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//清楚标志位</span>           <span class="token function">Write_RingBuff</span><span class="token punctuation">(</span><span class="token function">USART_ReceiveData</span><span class="token punctuation">(</span>USART1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//读取接收到的数据</span>       <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/fifo-9.jpg" alt="fifo-9"></p><p>测试数据没有发生丢包现象</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>对于现在的阶段，杰杰我本人写代码也慢慢学会规范了。所有的代码片段均使用了可读性很强的，还有可移植性也很强的。我使用了宏定义来决定是否开启环形缓冲区的方式来收发数据，移植到大家的代码并不会有其他副作用，只需要开启宏定义即可使用了。</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token macro property">#<span class="token directive keyword">define</span> USER_RINGBUFF  1  </span><span class="token comment" spellcheck="true">//使用环形缓冲区形式接收数据</span> <span class="token macro property">#<span class="token directive keyword">if</span>  USER_RINGBUFF</span> <span class="token comment" spellcheck="true">/**如果使用环形缓冲形式接收串口数据***/</span> <span class="token macro property">#<span class="token directive keyword">define</span>  RINGBUFF_LEN          200     </span><span class="token comment" spellcheck="true">//定义最大接收字节数 200</span> <span class="token macro property">#<span class="token directive keyword">define</span>  FLASE   1 </span> <span class="token macro property">#<span class="token directive keyword">define</span>  TRUE    0 </span> <span class="token keyword">void</span> <span class="token function">RingBuff_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span> u8 <span class="token function">Write_RingBuff</span><span class="token punctuation">(</span>u8 data<span class="token punctuation">)</span><span class="token punctuation">;</span> u8 <span class="token function">Read_RingBuff</span><span class="token punctuation">(</span>u8 <span class="token operator">*</span>rData<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，我们完全可以用空闲中断与DMA传输，效率更高，但是某些单片机没有空闲中断与DMA，那么这种环形缓冲区的作用就很大了，并且移植简便。</p><blockquote><p>说明：文章部分截图来源慕课网james_yuan老师的课程</p></blockquote><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> Cortex-M </tag>
            
            <tag> fifo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32之串口DMA接收不定长数据</title>
      <link href="/dma/"/>
      <url>/dma/</url>
      
        <content type="html"><![CDATA[<h1 id="STM32之串口DMA接收不定长数据"><a href="#STM32之串口DMA接收不定长数据" class="headerlink" title="STM32之串口DMA接收不定长数据"></a>STM32之串口DMA接收不定长数据</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在使用stm32或者其他单片机的时候，会经常使用到串口通讯，那么如何有效地接收数据呢？假如这段数据是不定长的有如何高效接收呢？</p><blockquote><p>同学A：数据来了就会进入串口中断，在中断中读取数据就行了！</p></blockquote><blockquote><p><strong>中断就是打断程序正常运行，怎么能保证高效呢？经常把主程序打断，主程序还要不要运行了？</strong></p></blockquote><blockquote><p>同学B：串口可以配置成用DMA的方式接收数据，等接收完毕就可以去读取了！</p></blockquote><blockquote><p><strong>这个同学是对的，我们可以使用DMA去接收数据，不过DMA需要定长才能产生接收中断,如何接收不定长的数据呢？</strong></p></blockquote><h2 id="DMA简介"><a href="#DMA简介" class="headerlink" title="DMA简介"></a>DMA简介</h2><blockquote><p>题外话：其实，上面的问题是很有必要思考一下的，不断思考，才能进步。</p></blockquote><h3 id="什么是DMA"><a href="#什么是DMA" class="headerlink" title="什么是DMA"></a>什么是DMA</h3><p><strong>DMA</strong>：全称Direct Memory Access，即直接存储器访问</p><p>DMA 传输将数据从一个地址空间复制到另外一个地址空间。CPU只需初始化DMA即可，传输动作本身是由 DMA 控制器来实现和完成。典型的例子就是移动一个外部内存的区块到芯片内部更快的内存区。这样的操作并没有让处理器参与处理，CPU可以干其他事情，当DMA传输完成的时候产生一个中断，告诉CPU我已经完成了，然后CPU知道了就可以去处理数据了，这样子提高了CPU的利用率，因为CPU是大脑，主要做数据运算的工作，而不是去搬运数据。DMA 传输对于高效能嵌入式系统算法和网络是很重要的。</p><h3 id="在STM32的DMA资源"><a href="#在STM32的DMA资源" class="headerlink" title="在STM32的DMA资源"></a>在STM32的DMA资源</h3><p><strong>STM32F1系列</strong>的MCU有两个DMA控制器（DMA2只存在于大容量产品中），DMA1有7个通道，DMA2有5个通道，每个通道专门用来管理来自于一个或者多个外设对存储器的访问请求。还有一个仲裁器来协调各个DMA请求的优先权。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/f1-dam.png" alt="f1-dam"></p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/f1-dam2.png" alt="f1-dam2"></p><p><strong>而STM32F4/F7/H7系列</strong>的MCU有两个DMA控制器总共有16个数据流（每个DMA控制器8个），每一个DMA控制器都用于管理一个或多个外设的存储器访问请求。每个数据流总共可以有多达8个通道（或称请求）。每个通道都有一个仲裁器，用于处理 DMA 请求间的优先级。<br><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/f4-dam.png" alt="f4-dam"></p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/f4-dam2.png" alt="f4-dam2"></p><h3 id="DMA接收数据"><a href="#DMA接收数据" class="headerlink" title="DMA接收数据"></a>DMA接收数据</h3><p>DMA在接收数据的时候，串口接收DMA在初始化的时候就处于开启状态，一直等待数据的到来，在软件上无需做任何事情，只要在初始化配置的时候设置好配置就可以了。等到接收到数据的时候，告诉CPU去处理即可。</p><h3 id="判断数据接收完成"><a href="#判断数据接收完成" class="headerlink" title="判断数据接收完成"></a>判断数据接收完成</h3><blockquote><p>那么问题来了，怎么知道数据是否接收完成呢？</p></blockquote><p>其实，有很多方法：</p><ul><li>对于定长的数据，只需要判断一下数据的接收个数，就知道是否接收完成，这个很简单，暂不讨论。</li><li>对于不定长的数据，其实也有好几种方法，麻烦的我肯定不会介绍，有兴趣做复杂工作的同学可以在网上看看别人怎么做，下面这种方法是最简单的，充分利用了stm32的串口资源，效率也是非常之高。</li></ul><p><strong>DMA+串口空闲中断</strong></p><p>这两个资源配合，简直就是天衣无缝啊，无论接收什么不定长的数据，管你数据有多少，来一个我就收一个，就像广东人吃“山竹”，来一个吃一个~（最近风好大，我好怕）。</p><p>可能很多人在学习stm32的时候，都不知道idle是啥东西，先看看stm32串口的状态寄存器：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/idle.png" alt="idle"></p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/idle1.png" alt="idle1"></p><p>当我们检测到触发了串口总线空闲中断的时候，我们就知道这一波数据传输完成了，然后我们就能得到这些数据，去进行处理即可。这种方法是最简单的，根本不需要我们做多的处理，只需要配置好，串口就等着数据的到来，dma也是处于工作状态的，来一个数据就自动搬运一个数据。</p><h3 id="接收完数据时处理"><a href="#接收完数据时处理" class="headerlink" title="接收完数据时处理"></a>接收完数据时处理</h3><p>串口接收完数据是要处理的，那么处理的步骤是怎么样呢？</p><ul><li>暂时关闭串口接收DMA通道，有两个原因：1.防止后面又有数据接收到，产生干扰，因为此时的数据还未处理。2.DMA需要重新配置。</li><li>清DMA标志位。</li><li>从DMA寄存器中获取接收到的数据字节数（可有可无）。</li><li>重新设置DMA下次要接收的数据字节数，注意，数据传输数量范围为0至65535。这个寄存器只能在通道不工作(DMA_CCRx的EN=0)时写入。通道开启后该寄存器变为只读，指示剩余的待传输字节数目。寄存器内容在每次DMA传输后递减。数据传输结束后，寄存器的内容或者变为0；或者当该通道配置为自动重加载模式时，寄存器的内容将被自动重新加载为之前配置时的数值。当寄存器的内容为0时，无论通道是否开启，都不会发生任何数据传输。</li><li>给出信号量，发送接收到新数据标志，供前台程序查询。</li><li>开启DMA通道，等待下一次的数据接收，注意，对DMA的相关寄存器配置写入，如重置DMA接收数据长度，必须要在关闭DMA的条件进行，否则操作无效。</li></ul><p><strong>注意事项</strong></p><p>STM32的IDLE的中断在串口无数据接收的情况下，是不会一直产生的，产生的条件是这样的，当清除IDLE标志位后，必须有接收到第一个数据后，才开始触发，一断接收的数据断流，没有接收到数据，即产生IDLE中断。如果中断发送数据帧的速率很快，MCU来不及处理此次接收到的数据，中断又发来数据的话，这里不能开启，否则数据会被覆盖。有两种方式解决：</p><ol><li><p>在重新开启接收DMA通道之前，将Rx_Buf缓冲区里面的数据复制到另外一个数组中，然后再开启DMA，然后马上处理复制出来的数据。</p></li><li><p>建立双缓冲，重新配置DMA_MemoryBaseAddr的缓冲区地址，那么下次接收到的数据就会保存到新的缓冲区中，不至于被覆盖。</p></li></ol><h3 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h3><p>实验效果：<br>当外部给单片机发送数 据的时候，假设这帧数据长度是1000个字节，那么在单片机接收到一个字节的时候并不会产生串口中断，只是DMA在背后默默地把数据搬运到你指定的缓冲区里面。当整帧数据发送完毕之后串口才会产生一次中断，此时可以利用<code>DMA_GetCurrDataCounter()</code>函数计算出本次的数据接受长度，从而进行数据处理。</p><p><strong>串口的配置</strong><br>很简单，基本与使用串口的时候一致，只不过一般我们是打开接收缓冲区非空中断，而现在是打开空闲中断——<code>USART_ITConfig(DEBUG_USARTx, USART_IT_IDLE, ENABLE);</code>。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/**  * @brief  USART GPIO 配置,工作参数配置  * @param  无  * @retval 无  */</span><span class="token keyword">void</span> <span class="token function">USART_Config</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>    USART_InitTypeDef USART_InitStructure<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 打开串口GPIO的时钟</span>    <span class="token function">DEBUG_USART_GPIO_APBxClkCmd</span><span class="token punctuation">(</span>DEBUG_USART_GPIO_CLK<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 打开串口外设的时钟</span>    <span class="token function">DEBUG_USART_APBxClkCmd</span><span class="token punctuation">(</span>DEBUG_USART_CLK<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将USART Tx的GPIO配置为推挽复用模式</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> DEBUG_USART_TX_GPIO_PIN<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_AF_PP<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>    <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>DEBUG_USART_TX_GPIO_PORT<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 将USART Rx的GPIO配置为浮空输入模式</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> DEBUG_USART_RX_GPIO_PIN<span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_IN_FLOATING<span class="token punctuation">;</span>    <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>DEBUG_USART_RX_GPIO_PORT<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 配置串口的工作参数</span>    <span class="token comment" spellcheck="true">// 配置波特率</span>    USART_InitStructure<span class="token punctuation">.</span>USART_BaudRate <span class="token operator">=</span> DEBUG_USART_BAUDRATE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 配置 针数据字长</span>    USART_InitStructure<span class="token punctuation">.</span>USART_WordLength <span class="token operator">=</span> USART_WordLength_8b<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 配置停止位</span>    USART_InitStructure<span class="token punctuation">.</span>USART_StopBits <span class="token operator">=</span> USART_StopBits_1<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 配置校验位</span>    USART_InitStructure<span class="token punctuation">.</span>USART_Parity <span class="token operator">=</span> USART_Parity_No <span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 配置硬件流控制</span>    USART_InitStructure<span class="token punctuation">.</span>USART_HardwareFlowControl <span class="token operator">=</span>     USART_HardwareFlowControl_None<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 配置工作模式，收发一起</span>    USART_InitStructure<span class="token punctuation">.</span>USART_Mode <span class="token operator">=</span> USART_Mode_Rx <span class="token operator">|</span> USART_Mode_Tx<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 完成串口的初始化配置</span>    <span class="token function">USART_Init</span><span class="token punctuation">(</span>DEBUG_USARTx<span class="token punctuation">,</span> <span class="token operator">&amp;</span>USART_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 串口中断优先级配置</span>    <span class="token function">NVIC_Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_USART_DMA_RX </span>    <span class="token comment" spellcheck="true">// 开启 串口空闲IDEL 中断</span>    <span class="token function">USART_ITConfig</span><span class="token punctuation">(</span>DEBUG_USARTx<span class="token punctuation">,</span> USART_IT_IDLE<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 开启串口DMA接收</span>    <span class="token function">USART_DMACmd</span><span class="token punctuation">(</span>DEBUG_USARTx<span class="token punctuation">,</span> USART_DMAReq_Rx<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 使能串口DMA */</span>    <span class="token function">USARTx_DMA_Rx_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">else</span></span>    <span class="token comment" spellcheck="true">// 使能串口接收中断</span>    <span class="token function">USART_ITConfig</span><span class="token punctuation">(</span>DEBUG_USARTx<span class="token punctuation">,</span> USART_IT_RXNE<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">if</span> USE_USART_DMA_TX </span>    <span class="token comment" spellcheck="true">// 开启串口DMA发送</span><span class="token comment" spellcheck="true">//    USART_DMACmd(DEBUG_USARTx, USART_DMAReq_Tx, ENABLE); </span>    <span class="token function">USARTx_DMA_Tx_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    <span class="token comment" spellcheck="true">// 使能串口</span>    <span class="token function">USART_Cmd</span><span class="token punctuation">(</span>DEBUG_USARTx<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>串口DMA配置</strong></p><p>把DMA配置完成，就可以直接打开DMA了，让它处于工作状态，当有数据的时候就能直接搬运了。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">if</span> USE_USART_DMA_RX </span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">USARTx_DMA_Rx_Config</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    DMA_InitTypeDef DMA_InitStructure<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 开启DMA时钟</span>    <span class="token function">RCC_AHBPeriphClockCmd</span><span class="token punctuation">(</span>RCC_AHBPeriph_DMA1<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置DMA源地址：串口数据寄存器地址*/</span>    DMA_InitStructure<span class="token punctuation">.</span>DMA_PeripheralBaseAddr <span class="token operator">=</span> <span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span>USART_DR_ADDRESS<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 内存地址(要传输的变量的指针)</span>    DMA_InitStructure<span class="token punctuation">.</span>DMA_MemoryBaseAddr <span class="token operator">=</span> <span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span>Usart_Rx_Buf<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 方向：从内存到外设    </span>    DMA_InitStructure<span class="token punctuation">.</span>DMA_DIR <span class="token operator">=</span> DMA_DIR_PeripheralSRC<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 传输大小    </span>    DMA_InitStructure<span class="token punctuation">.</span>DMA_BufferSize <span class="token operator">=</span> USART_RX_BUFF_SIZE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 外设地址不增        </span>    DMA_InitStructure<span class="token punctuation">.</span>DMA_PeripheralInc <span class="token operator">=</span> DMA_PeripheralInc_Disable<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 内存地址自增</span>    DMA_InitStructure<span class="token punctuation">.</span>DMA_MemoryInc <span class="token operator">=</span> DMA_MemoryInc_Enable<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 外设数据单位    </span>    DMA_InitStructure<span class="token punctuation">.</span>DMA_PeripheralDataSize <span class="token operator">=</span>     DMA_PeripheralDataSize_Byte<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 内存数据单位</span>    DMA_InitStructure<span class="token punctuation">.</span>DMA_MemoryDataSize <span class="token operator">=</span> DMA_MemoryDataSize_Byte<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// DMA模式，一次或者循环模式</span>    <span class="token comment" spellcheck="true">//DMA_InitStructure.DMA_Mode = DMA_Mode_Normal ;</span>    DMA_InitStructure<span class="token punctuation">.</span>DMA_Mode <span class="token operator">=</span> DMA_Mode_Circular<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 优先级：中    </span>    DMA_InitStructure<span class="token punctuation">.</span>DMA_Priority <span class="token operator">=</span> DMA_Priority_VeryHigh<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 禁止内存到内存的传输</span>    DMA_InitStructure<span class="token punctuation">.</span>DMA_M2M <span class="token operator">=</span> DMA_M2M_Disable<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 配置DMA通道           </span>    <span class="token function">DMA_Init</span><span class="token punctuation">(</span>USART_RX_DMA_CHANNEL<span class="token punctuation">,</span> <span class="token operator">&amp;</span>DMA_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 清除DMA所有标志</span>    <span class="token function">DMA_ClearFlag</span><span class="token punctuation">(</span>DMA1_FLAG_TC5<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">DMA_ITConfig</span><span class="token punctuation">(</span>USART_RX_DMA_CHANNEL<span class="token punctuation">,</span> DMA_IT_TE<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使能DMA</span>    <span class="token function">DMA_Cmd</span> <span class="token punctuation">(</span>USART_RX_DMA_CHANNEL<span class="token punctuation">,</span>ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>接收完数据处理</strong></p><p>因为接收完数据之后，会产生一个idle中断，也就是空闲中断，那么我们就可以在中断服务函数中知道已经接收完了，就可以处理数据了，但是中断服务函数的上下文环境是中断，所以，尽量是快进快出，一般在中断中将一些标志置位，供前台查询。在中断中先判断我们的产生在中断的类型是不是idle中断，如果是则进行下一步，否则就无需理会。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/**  ******************************************************************  * @brief   串口中断服务函数  * @author  jiejie  * @version V1.0  * @date    2018-xx-xx  ******************************************************************  */</span> <span class="token keyword">void</span> <span class="token function">DEBUG_USART_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_USART_DMA_RX</span>    <span class="token comment" spellcheck="true">/* 使用串口DMA */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">USART_GetITStatus</span><span class="token punctuation">(</span>DEBUG_USARTx<span class="token punctuation">,</span>USART_IT_IDLE<span class="token punctuation">)</span><span class="token operator">!=</span>RESET<span class="token punctuation">)</span>    <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/* 接收数据 */</span>        <span class="token function">Receive_DataPack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 清除空闲中断标志位</span>        <span class="token function">USART_ReceiveData</span><span class="token punctuation">(</span> DEBUG_USARTx <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token macro property">#<span class="token directive keyword">else</span></span>  <span class="token comment" spellcheck="true">/* 接收中断 */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">USART_GetITStatus</span><span class="token punctuation">(</span>DEBUG_USARTx<span class="token punctuation">,</span>USART_IT_RXNE<span class="token punctuation">)</span><span class="token operator">!=</span>RESET<span class="token punctuation">)</span>    <span class="token punctuation">{</span>            <span class="token function">Receive_DataPack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Receive_DataPack()</strong></p><p>这个才是真正的接收数据处理函数，为什么我要将这个函数单独封装起来呢？因为这个函数其实是很重要的，因为我的代码兼容普通串口接收与空闲中断，不一样的接收类型其处理也不一样，所以直接封装起来更好，在源码中通过宏定义实现选择接收的方式！更考虑了兼容操作系统的，可能我会在系统中使用dma+空闲中断，所以，供前台查询的信号量就有可能不一样，可能需要修改，我就把它封装起来了。不过无所谓，都是一样的。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/************************************************************  * @brief   Uart_DMA_Rx_Data  * @param   NULL  * @return  NULL  * @author  jiejie  * @github  https://github.com/jiejieTop  * @date    2018-xx-xx  * @version v1.0  * @note    使用串口 DMA 接收时调用的函数  ***********************************************************/</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_USART_DMA_RX</span><span class="token keyword">void</span> <span class="token function">Receive_DataPack</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 接收的数据长度 */</span>    uint32_t buff_length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 关闭DMA ，防止干扰 */</span>    <span class="token function">DMA_Cmd</span><span class="token punctuation">(</span>USART_RX_DMA_CHANNEL<span class="token punctuation">,</span> DISABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 暂时关闭dma，数据尚未处理 */</span>     <span class="token comment" spellcheck="true">/* 清DMA标志位 */</span>    <span class="token function">DMA_ClearFlag</span><span class="token punctuation">(</span> DMA1_FLAG_TC5 <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* 获取接收到的数据长度 单位为字节*/</span>    buff_length <span class="token operator">=</span> USART_RX_BUFF_SIZE <span class="token operator">-</span> <span class="token function">DMA_GetCurrDataCounter</span><span class="token punctuation">(</span>USART_RX_DMA_CHANNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 获取数据长度 */</span>    Usart_Rx_Sta <span class="token operator">=</span> buff_length<span class="token punctuation">;</span>    <span class="token function">PRINT_DEBUG</span><span class="token punctuation">(</span><span class="token string">"buff_length = %d\n "</span><span class="token punctuation">,</span>buff_length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 重新赋值计数值，必须大于等于最大可能接收到的数据帧数目 */</span>    USART_RX_DMA_CHANNEL<span class="token operator">-></span>CNDTR <span class="token operator">=</span> USART_RX_BUFF_SIZE<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 此处应该在处理完数据再打开，如在 DataPack_Process() 打开*/</span>    <span class="token function">DMA_Cmd</span><span class="token punctuation">(</span>USART_RX_DMA_CHANNEL<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* (OS)给出信号 ，发送接收到新数据标志，供前台程序查询 */</span>    <span class="token comment" spellcheck="true">/* 标记接收完成，在 DataPack_Handle 处理*/</span>    Usart_Rx_Sta <span class="token operator">|</span><span class="token operator">=</span> <span class="token number">0xC000</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*     DMA 开启，等待数据。注意，如果中断发送数据帧的速率很快，MCU来不及处理此次接收到的数据，    中断又发来数据的话，这里不能开启，否则数据会被覆盖。有2种方式解决：    1. 在重新开启接收DMA通道之前，将Rx_Buf缓冲区里面的数据复制到另外一个数组中，    然后再开启DMA，然后马上处理复制出来的数据。    2. 建立双缓冲，重新配置DMA_MemoryBaseAddr的缓冲区地址，那么下次接收到的数据就会    保存到新的缓冲区中，不至于被覆盖。    */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>f1使用dma是非常简单的，我在f4用dma的时候也遇到一些问题，最后看手册解决了，打算下一篇文章就写一下调试过程，没有什么是debug不能解决的，如果有，那就两次。今天台风天气，连着舍友的WiFi更新的文章~中国电信还是强，台风天气信号一点都不虚，我的移动卡一动不动-_-.</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台回复获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> Cortex-M </tag>
            
            <tag> DMA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纯C语言写的按键驱动，将按键逻辑与按键处理事件分离~</title>
      <link href="/button/"/>
      <url>/button/</url>
      
        <content type="html"><![CDATA[<h1 id="ButtonDrive"><a href="#ButtonDrive" class="headerlink" title="ButtonDrive"></a>ButtonDrive</h1><p>自己写的一个按键驱动，支持单双击、连按、长按；采用回调处理按键事件（自定义消抖时间），使用只需3步，创建按键，按键事件与回调处理函数链接映射，周期检查按键。<br>源码地址：<a href="https://github.com/jiejieTop/ButtonDrive" target="_blank" rel="noopener">https://github.com/jiejieTop/ButtonDrive</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天写了个按键驱动，参考了<a href="https://github.com/0x1abin/MultiButton" target="_blank" rel="noopener">MulitButton</a>的数据结构的用法，逻辑实现并不一样。<br>在这里感谢所有的开源开发者，让我从中学到了很多，同时网络也是一个好平台，也希望所有的开发者能形成良性循环，从网络中学知识，回馈到网络中去。感谢<a href="https://github.com/0x1abin/MultiButton" target="_blank" rel="noopener">MulitButton</a>的作者<a href="https://github.com/0x1abin" target="_blank" rel="noopener">0x1abin</a>，感谢两位rtt的大佬：<a href="https://github.com/uestczyh222" target="_blank" rel="noopener">大法师</a>、<a href="https://github.com/liu2guang" target="_blank" rel="noopener">流光</a>。</p><h2 id="Button-drive简介"><a href="#Button-drive简介" class="headerlink" title="Button_drive简介"></a>Button_drive简介</h2><p>Button_drive是一个小巧的按键驱动，支持单击、双击、长按、连续触发等（后续可以在按键控制块中添加触发事件），理论上可无限量扩展Button，Button_drive采用按键触发事件回调方式处理业务逻辑，支持在RTOS中使用，我目前仅在<a href="https://github.com/RT-Thread/rt-thread" target="_blank" rel="noopener">RT-Thread</a>上测试过。<br>写按键驱动的目的是想要将用户按键逻辑与按键处理事件分离，用户无需处理复杂麻烦的逻辑事件。</p><h2 id="Button-drive使用效果"><a href="#Button-drive使用效果" class="headerlink" title="Button_drive使用效果"></a>Button_drive使用效果</h2><ol><li><strong>单击与长按</strong></li></ol><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20191017200917803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qaWVqaWUuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="2"><li><strong>双击</strong></li></ol><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20191017200928625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qaWVqaWUuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="3"><li><strong>连按</strong></li></ol><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20191017200939523.png" alt="在这里插入图片描述"><br>4. <strong>连按释放</strong></p><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20191017200953789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qaWVqaWUuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li><p>创建按键句柄</p><pre><code>Button_t Button1;Button_t Button2; </code></pre></li><li><p>创建按键，初始化按键信息，包括按键名字、按键电平检测函数接口、按键触发电平。</p><pre><code>Button_Create("Button1",                //按键名字             &amp;Button1,                 //按键句柄             Read_Button1_Level,     //按键电平检测函数接口             BTN_TRIGGER);               //触发电平             ......</code></pre></li><li><p>按键触发事件与事件回调函数链接映射，当按键事件被触发的时候，自动跳转回调函数中处理业务逻辑。</p><pre><code>Button_Attach(&amp;Button1,BUTTON_DOWM,Btn2_Dowm_CallBack);        //按键单击Button_Attach(&amp;Button1,BUTTON_DOUBLE,Btn2_Double_CallBack);    //双击Button_Attach(&amp;Button1,BUTTON_LONG,Btn2_Long_CallBack);        //长按             .......</code></pre></li><li><p>周期调用回调按键处理函数即可，建议调用周期20-50ms。</p><pre><code>Button_Process();     //需要周期调用按键处理函数</code></pre></li></ol><hr><p>需要用户实现的 <strong>2</strong> 个函数：</p><ul><li>按键电平检测接口：<pre><code>uint8_t Read_Button1_Level(void){return GPIO_ReadInputDataBit(BTN1_GPIO_PORT,BTN1_GPIO_PIN);}</code></pre></li></ul><p>uint8_t Read_Button2_Level(void)<br>{<br>  return GPIO_ReadInputDataBit(BTN2_GPIO_PORT,BTN2_GPIO_PIN);<br>}</p><p>// 这是我在stm32上简单测试的伪代码，以实际源码为准</p><pre><code>- 按键逻辑处理</code></pre><p>void Btn1_Dowm_CallBack(void *btn)<br>{<br>  PRINT_INFO(“Button1 单击!”);<br>}</p><p>void Btn1_Double_CallBack(void *btn)<br>{<br>  PRINT_INFO(“Button1 双击!”);<br>}</p><p>void Btn1_Long_CallBack(void *btn)<br>{<br>  PRINT_INFO(“Button1 长按!”);</p><p>  Button_Delete(&amp;Button2);<br>  PRINT_INFO(“删除Button1”);<br>  Search_Button();<br>}</p><pre><code>##  特点Button_drive开放源码，按键控制块采用数据结构方式，按键事件采用枚举类型，确保不会重复，也便于添加用户需要逻辑，采用宏定义方式定义消抖时间、连按触发时间、双击时间间隔、长按时间等，便于修改。同时所有被创建的按键采用单链表方式连击，用户只管创建，无需理会按键处理，只需调用`Button_Process()`即可，在函数中会自动遍历所有被创建的按键。支持按键删除操作，用户无需在代码中删除对应的按键创建于映射链接代码，也无需删除关于按键的任何回调事件处理函数，只需调用`Button_Delete()`函数即可，这样子，就不会处理关于被删除按键的任何状态。当然目前按键内存不会释放，如果使用os的话，建议释放按键内存。##### 按键控制块```c/*    每个按键对应1个全局的结构体变量。    其成员变量是实现消抖和多种按键状态所必须的*/typedef struct button{    /* 下面是一个函数指针，指向判断按键手否按下的函数 */    uint8_t (*Read_Button_Level)(void); /* 读取按键电平函数，需要用户实现 */  char Name[BTN_NAME_MAX];  uint8_t Button_State              :   4;      /* 按键当前状态（按下还是弹起） */  uint8_t Button_Last_State         :   4;      /* 上一次的按键状态，用于判断双击 */  uint8_t Button_Trigger_Level      :   2;    /* 按键触发电平 */  uint8_t Button_Last_Level         :   2;    /* 按键当前电平 */  uint8_t Button_Trigger_Event;     /* 按键触发事件，单击，双击，长按等 */  Button_CallBack CallBack_Function[number_of_event];  uint8_t Button_Cycle;               /* 连续按键周期 */  uint8_t Timer_Count;            /* 计时 */  uint8_t Debounce_Time;        /* 消抖时间 */  uint8_t Long_Time;          /* 按键按下持续时间 */  struct button *Next;}Button_t;</code></pre><h5 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h5><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token punctuation">{</span>  BUTTON_DOWM <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>  BUTTON_UP<span class="token punctuation">,</span>  BUTTON_DOUBLE<span class="token punctuation">,</span>  BUTTON_LONG<span class="token punctuation">,</span>  BUTTON_CONTINUOS<span class="token punctuation">,</span>  BUTTON_CONTINUOS_FREE<span class="token punctuation">,</span>  BUTTON_ALL_RIGGER<span class="token punctuation">,</span>  number_of_event<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* 触发回调的事件 */</span>  NONE_TRIGGER<span class="token punctuation">}</span>Button_Event<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="宏定义选择"><a href="#宏定义选择" class="headerlink" title="宏定义选择"></a>宏定义选择</h5><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> BTN_NAME_MAX  32     </span><span class="token comment" spellcheck="true">//名字最大为32字节</span><span class="token comment" spellcheck="true">/* 按键消抖时间40ms, 建议调用周期为20ms 只有连续检测到40ms状态不变才认为有效，包括弹起和按下两种事件*/</span><span class="token macro property">#<span class="token directive keyword">define</span> CONTINUOS_TRIGGER             0  </span><span class="token comment" spellcheck="true">//是否支持连续触发，连发的话就不要检测单双击与长按了    </span><span class="token comment" spellcheck="true">/* 是否支持单击&amp;双击同时存在触发，如果选择开启宏定义的话，单双击都回调，只不过单击会延迟响应，   因为必须判断单击之后是否触发了双击否则，延迟时间是双击间隔时间 BUTTON_DOUBLE_TIME。   而如果不开启这个宏定义，建议工程中只存在单击/双击中的一个，否则，在双击响应的时候会触发一次单击，   因为双击必须是有一次按下并且释放之后才产生的 */</span><span class="token macro property">#<span class="token directive keyword">define</span> SINGLE_AND_DOUBLE_TRIGGER     1 </span><span class="token comment" spellcheck="true">/* 是否支持长按释放才触发，如果打开这个宏定义，那么长按释放之后才触发单次长按，   否则在长按指定时间就一直触发长按，触发周期由 BUTTON_LONG_CYCLE 决定 */</span><span class="token macro property">#<span class="token directive keyword">define</span> LONG_FREE_TRIGGER             0 </span><span class="token macro property">#<span class="token directive keyword">define</span> BUTTON_DEBOUNCE_TIME       2   </span><span class="token comment" spellcheck="true">//消抖时间      (n-1)*调用周期</span><span class="token macro property">#<span class="token directive keyword">define</span> BUTTON_CONTINUOS_CYCLE  1      </span><span class="token comment" spellcheck="true">//连按触发周期时间  (n-1)*调用周期  </span><span class="token macro property">#<span class="token directive keyword">define</span> BUTTON_LONG_CYCLE       1      </span><span class="token comment" spellcheck="true">//长按触发周期时间  (n-1)*调用周期 </span><span class="token macro property">#<span class="token directive keyword">define</span> BUTTON_DOUBLE_TIME      15     </span><span class="token comment" spellcheck="true">//双击间隔时间  (n-1)*调用周期  建议在200-600ms</span><span class="token macro property">#<span class="token directive keyword">define</span> BUTTON_LONG_TIME           50        </span><span class="token comment" spellcheck="true">/* 持续n秒((n-1)*调用周期 ms)，认为长按事件 */</span><span class="token macro property">#<span class="token directive keyword">define</span> TRIGGER_CB(event)   \        if(btn->CallBack_Function[event]) \          btn->CallBack_Function[event]((Button_t*)btn)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><pre class="line-numbers language-c"><code class="language-c">  <span class="token function">Button_Create</span><span class="token punctuation">(</span><span class="token string">"Button1"</span><span class="token punctuation">,</span>              <span class="token operator">&amp;</span>Button1<span class="token punctuation">,</span>               Read_KEY1_Level<span class="token punctuation">,</span>               KEY_ON<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">Button_Attach</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button1<span class="token punctuation">,</span>BUTTON_DOWM<span class="token punctuation">,</span>Btn1_Dowm_CallBack<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//单击</span>  <span class="token function">Button_Attach</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button1<span class="token punctuation">,</span>BUTTON_DOUBLE<span class="token punctuation">,</span>Btn1_Double_CallBack<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//双击</span>  <span class="token function">Button_Attach</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button1<span class="token punctuation">,</span>BUTTON_CONTINUOS<span class="token punctuation">,</span>Btn1_Continuos_CallBack<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//连按  </span>  <span class="token function">Button_Attach</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button1<span class="token punctuation">,</span>BUTTON_CONTINUOS_FREE<span class="token punctuation">,</span>Btn1_ContinuosFree_CallBack<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//连按释放  </span>  <span class="token function">Button_Attach</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button1<span class="token punctuation">,</span>BUTTON_LONG<span class="token punctuation">,</span>Btn1_Long_CallBack<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//长按</span>  <span class="token function">Button_Create</span><span class="token punctuation">(</span><span class="token string">"Button2"</span><span class="token punctuation">,</span>              <span class="token operator">&amp;</span>Button2<span class="token punctuation">,</span>               Read_KEY2_Level<span class="token punctuation">,</span>               KEY_ON<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">Button_Attach</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button2<span class="token punctuation">,</span>BUTTON_DOWM<span class="token punctuation">,</span>Btn2_Dowm_CallBack<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//单击</span>  <span class="token function">Button_Attach</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button2<span class="token punctuation">,</span>BUTTON_DOUBLE<span class="token punctuation">,</span>Btn2_Double_CallBack<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//双击</span>  <span class="token function">Button_Attach</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button2<span class="token punctuation">,</span>BUTTON_CONTINUOS<span class="token punctuation">,</span>Btn2_Continuos_CallBack<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//连按</span>  <span class="token function">Button_Attach</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button2<span class="token punctuation">,</span>BUTTON_CONTINUOS_FREE<span class="token punctuation">,</span>Btn2_ContinuosFree_CallBack<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//连按释放</span>  <span class="token function">Button_Attach</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button2<span class="token punctuation">,</span>BUTTON_LONG<span class="token punctuation">,</span>Btn2_Long_CallBack<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//长按</span>  <span class="token function">Get_Button_Event</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">Get_Button_Event</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Button2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p><a href="https://github.com/liu2guang" target="_blank" rel="noopener">流光</a>大佬的要求，让我玩一玩RTT的<a href="https://github.com/liu2guang/buildpkg" target="_blank" rel="noopener">rtkpgs</a>，打算用Button_drive练一练手吧。</p><h2 id="ButtonDrive在env使用"><a href="#ButtonDrive在env使用" class="headerlink" title="ButtonDrive在env使用"></a>ButtonDrive在env使用</h2><p>目前我已将按键驱动做成软件包（packages），如果使用RT-Thread操作系统的话，可以在env中直接配置使用!</p><p>步骤如下：</p><ol><li><strong>选择在线软件包</strong></li></ol><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20191017201032261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qaWVqaWUuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="2"><li><strong>选择软件包属性为外设相关</strong></li></ol><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/201910172010447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qaWVqaWUuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="3"><li><strong>选择button_drive</strong></li></ol><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20191017201103483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qaWVqaWUuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="4"><li><strong>进入驱动的选项配置（自带默认属性）</strong></li></ol><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20191017201118160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qaWVqaWUuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="5"><li><p><strong>如果不懂按键的配置是什么意思，按下“shift+？”，即可有解释</strong><br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20191017201124140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qaWVqaWUuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><strong>编译生成mdk/iar工程</strong></p></li></ol><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20191017201130458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qaWVqaWUuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20191017201134524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qaWVqaWUuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="关于rtkpgs"><a href="#关于rtkpgs" class="headerlink" title="关于rtkpgs"></a>关于<a href="https://github.com/liu2guang/buildpkg" target="_blank" rel="noopener">rtkpgs</a></h2><h2 id="简介-English"><a href="#简介-English" class="headerlink" title="简介 (English)"></a>简介 (<a href="/readme.en.md">English</a>)</h2><p>buildpkg 是用于生成 RT-Thread package 的快速构建工具。</p><p>一个优秀的 package 应该是这样的：</p><ol><li>代码优雅, 规范化。</li><li>examples 例程，提供通俗易懂的使用例程。</li><li>SConscript 文件，用于和 RT-Thread 环境一起进行编译。</li><li>README.md 文档，向用户提供必要的功能说明。</li><li>docs 文件夹, 放置除了 README 之外的其他细节文档。</li><li>license 许可文件，版权说明。</li></ol><p>为了方便快速的生成 RT-Thread package 规范化模板 以及 减轻开源仓库迁移 RT-Thread 的前期准备工作的负担，基于此目的的 buildpkg 应运而生，为开发 Rt-Thread 的 package 的开发者提供辅助开发工具。</p><table><thead><tr><th align="left">序号</th><th align="left">支持功能</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">构建 package 模板</td><td align="left">创建指定名称 package , 自动添加 readme /版本号/ github ci脚本/demo/开源协议文件</td></tr><tr><td align="left">2</td><td align="left">迁移开源仓库</td><td align="left">从指定 git 仓库构建 package , 自动添加readme/版本号/ github ci脚本/demo/开源协议文件, 但是迁移的仓库需要用户自己按照实际情况修改</td></tr><tr><td align="left">3</td><td align="left">更新 package</td><td align="left">生成package后可以再次更新之前设定的版本号，开源协议或者scons脚本等</td></tr></tbody></table><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="1-构建package"><a href="#1-构建package" class="headerlink" title="1. 构建package"></a>1. 构建package</h3><blockquote><p>buildpkg.exe make pkgdemo</p></blockquote><h3 id="2-迁移开源仓库"><a href="#2-迁移开源仓库" class="headerlink" title="2. 迁移开源仓库"></a>2. 迁移开源仓库</h3><blockquote><p>buildpkg.exe make cstring <a href="https://github.com/liu2guang/cstring.git" target="_blank" rel="noopener">https://github.com/liu2guang/cstring.git</a></p></blockquote><h3 id="3-更新package"><a href="#3-更新package" class="headerlink" title="3. 更新package"></a>3. 更新package</h3><blockquote><p>buildpkg.exe update pkgname</p></blockquote><h3 id="4-可选配置"><a href="#4-可选配置" class="headerlink" title="4. 可选配置"></a>4. 可选配置</h3><table><thead><tr><th align="left">长参数</th><th align="left">短参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">–version=v1.0.0</td><td align="left">-v v1.0.0</td><td align="left">设置 package 的版本</td></tr><tr><td align="left">–license=MIT</td><td align="left">-l MIT</td><td align="left">设置 package 所遵循的版权协议</td></tr><tr><td align="left">–submodule</td><td align="left">-s</td><td align="left">删除 git 子模块</td></tr></tbody></table><h2 id="测试平台"><a href="#测试平台" class="headerlink" title="测试平台"></a>测试平台</h2><table><thead><tr><th align="left">序号</th><th align="left">测试平台</th><th align="left">测试结果</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">win10</td><td align="left">exe测试通过, py测试通过</td></tr><tr><td align="left">2</td><td align="left">win7</td><td align="left">exe待测试, py待测试</td></tr><tr><td align="left">3</td><td align="left">mac</td><td align="left">py脚本不知道是否兼容, 没有测试条件, 后面维护下</td></tr><tr><td align="left">4</td><td align="left">linux</td><td align="left">py脚本不知道是否兼容, 没有测试条件, 后面维护下</td></tr></tbody></table><h2 id="联系人"><a href="#联系人" class="headerlink" title="联系人"></a>联系人</h2><ul><li>邮箱：<a href="mailto:1004383796@qq.com" target="_blank" rel="noopener">1004383796@qq.com</a></li><li>主页：<a href="https://github.com/liu2guang" target="_blank" rel="noopener">liu2guang</a></li><li>仓库：<a href="https://github.com/liu2guang" target="_blank" rel="noopener">Github</a>, <a href="https://github.com/liu2guang" target="_blank" rel="noopener">Gitee</a> </li></ul><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> ButtonDrive </tag>
            
            <tag> STM32 </tag>
            
            <tag> 开源项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继续学习FreeRTOS消息队列</title>
      <link href="/freertos-10/"/>
      <url>/freertos-10/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写在前面：杰杰这个月很忙~所以并没有时间更新，现在健身房闭馆装修，晚上有空就更新一下！其实在公众号没更新的这段日子，每天都有兄弟在来关注我的公众号，这让我受宠若惊，在这里谢谢大家的支持啦！！谢谢^</p></blockquote><p>在这里我们就跟着火哥的书来学习一下FreeRTOS的消息队列，这本书我觉得写得很好，基本都讲解到了，关于什么是消息队列，就请大家去看书，基础知识我暂时不说了。</p><p><strong>声明：本书绝大部分内容来自《FreeRTOS 内核实现与应用开发实战指南—基于野火 STM32 全系列（M3/4/7）开发板》，如涉及侵权请联系杰杰删除</strong></p><h3 id="FreeRTOS的消息队列支持"><a href="#FreeRTOS的消息队列支持" class="headerlink" title="FreeRTOS的消息队列支持"></a>FreeRTOS的消息队列支持</h3><ul><li>FreeRTOS 中使用队列数据结构实现任务异步通信工作，具有如下特性：</li><li>消息支持先进先出方式排队，支持异步读写工作方式。</li><li>读写队列均支持超时机制。</li><li>消息支持后进先出方式排队， 往队首发送消息（LIFO） 。</li><li>可以允许不同长度（不超过队列节点最大值）的任意类型消息。</li><li>一个任务能够从任意一个消息队列接收和发送消息。</li><li>多个任务能够从同一个消息队列接收和发送消息。</li><li>当队列使用结束后，可以通过删除队列函数进行删除。</li></ul><h3 id="FreeRTOS队列的特点"><a href="#FreeRTOS队列的特点" class="headerlink" title="FreeRTOS队列的特点"></a>FreeRTOS队列的特点</h3><p>一般来说，鱼与熊掌不可兼得，如果数据太多，那数据传输的速度必然是会慢下来，而如果采用引用传递的方式，当原始数据被修改的时候，数据有变得不安全，但是FreeRTOS支持拷贝与引用的方式进行数据的传输，变得更加灵活。<br>队列是通过拷贝传递数据的，但这并不妨碍队列通过引用来传递数据。当信息的大小到达一个临界点后，逐字节拷贝整个信息是不实际的，可以定义一个指向数据区域的指针，将指针传递即可。这种方法在物联网中是非常常用的。</p><h3 id="消息队列控制块"><a href="#消息队列控制块" class="headerlink" title="消息队列控制块"></a>消息队列控制块</h3><p>其实消息队列不仅仅是用于当做消息队列，FreeRTOS还把他当做信号量的数据结构来使用</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> QueueDefinition<span class="token punctuation">{</span>    int8_t <span class="token operator">*</span>pcHead<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">/* 指向队列存储区起始位置,即第一个队列项 */</span>    int8_t <span class="token operator">*</span>pcTail<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">/* 指向队列存储区结束后的下一个字节 */</span>    int8_t <span class="token operator">*</span>pcWriteTo<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* 指向下队列存储区的下一个空闲位置 */</span>    <span class="token keyword">union</span>                       <span class="token comment" spellcheck="true">/* 使用联合体用来确保两个互斥的结构体成员不会同时出现 */</span>    <span class="token punctuation">{</span>        int8_t <span class="token operator">*</span>pcReadFrom<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 当结构体用于队列时,这个字段指向出队项目中的最后一个. */</span>        UBaseType_t uxRecursiveCallCount<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 当结构体用于互斥量时,用作计数器,保存递归互斥量被"获取"的次数. */</span>    <span class="token punctuation">}</span> u<span class="token punctuation">;</span>    List_t xTasksWaitingToSend<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* 因为等待入队而阻塞的任务列表,按照优先级顺序存储 */</span>    List_t xTasksWaitingToReceive<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 因为等待队列项而阻塞的任务列表,按照优先级顺序存储 */</span>    <span class="token keyword">volatile</span> UBaseType_t uxMessagesWaiting<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*&lt; 当前队列的队列项数目 */</span>    UBaseType_t uxLength<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* 队列项的数目 */</span>    UBaseType_t uxItemSize<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* 每个队列项的大小 */</span>    <span class="token keyword">volatile</span> BaseType_t xRxLock<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 队列上锁后,存储从队列收到的列表项数目，如果队列没有上锁，设置为queueUNLOCKED */</span>    <span class="token keyword">volatile</span> BaseType_t xTxLock<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 队列上锁后,存储发送到队列的列表项数目，如果队列没有上锁，设置为queueUNLOCKED */</span>    <span class="token comment" spellcheck="true">/* 删除部分源码 */</span><span class="token punctuation">}</span> xQUEUE<span class="token punctuation">;</span><span class="token keyword">typedef</span> xQUEUE Queue_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先过一遍消息队列的数据结构，其实没啥东西的，记不住也没啥大问题，下面会用到就行了。</p><h3 id="创建消息队列"><a href="#创建消息队列" class="headerlink" title="创建消息队列"></a>创建消息队列</h3><p>FreeRTOS创建队列API函数是xQueueCreate()，但其实这是一个宏。真正被执行的函数是xQueueGenericCreate()，我们称这个函数为通用队列创建函数。</p><pre class="line-numbers language-c"><code class="language-c">    QueueHandle_t <span class="token function">xQueueGenericCreate</span><span class="token punctuation">(</span> <span class="token keyword">const</span> UBaseType_t uxQueueLength<span class="token punctuation">,</span> <span class="token keyword">const</span> UBaseType_t uxItemSize<span class="token punctuation">,</span> <span class="token keyword">const</span> uint8_t ucQueueType <span class="token punctuation">)</span>    <span class="token punctuation">{</span>    Queue_t <span class="token operator">*</span>pxNewQueue<span class="token punctuation">;</span>    size_t xQueueSizeInBytes<span class="token punctuation">;</span>    uint8_t <span class="token operator">*</span>pucQueueStorage<span class="token punctuation">;</span>        <span class="token function">configASSERT</span><span class="token punctuation">(</span> uxQueueLength <span class="token operator">></span> <span class="token punctuation">(</span> UBaseType_t <span class="token punctuation">)</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> uxItemSize <span class="token operator">==</span> <span class="token punctuation">(</span> UBaseType_t <span class="token punctuation">)</span> <span class="token number">0</span> <span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* 如果 uxItemSize 为 0，也就是单个消息空间大小为 0，这样子就不需要申请内存了，那么 xQueueSizeInBytes 也设置为 0 即可，设置为 0 是可以的，用作信号量的时候这个就可以设置为 0。*/</span>            xQueueSizeInBytes <span class="token operator">=</span> <span class="token punctuation">(</span> size_t <span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* 分配足够消息存储空间，空间的大小为队列长度*单个消息大小 */</span>            xQueueSizeInBytes <span class="token operator">=</span> <span class="token punctuation">(</span> size_t <span class="token punctuation">)</span> <span class="token punctuation">(</span> uxQueueLength <span class="token operator">*</span> uxItemSize <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*lint !e961 MISRA exception as the casts are only redundant for some ports. */</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/* FreeRTOS 调用 pvPortMalloc()函数向系统申请内存空间，内存大小为消息队列控制块大小加上消息存储空间大小，因为这段内存空间是需要保证连续的 */</span>        pxNewQueue <span class="token operator">=</span> <span class="token punctuation">(</span> Queue_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token function">pvPortMalloc</span><span class="token punctuation">(</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span> Queue_t <span class="token punctuation">)</span> <span class="token operator">+</span> xQueueSizeInBytes <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> pxNewQueue <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* 计算出消息存储空间的起始地址 */</span>            pucQueueStorage <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span> uint8_t <span class="token operator">*</span> <span class="token punctuation">)</span> pxNewQueue <span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span> Queue_t <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token macro property">#<span class="token directive keyword">if</span>( configSUPPORT_STATIC_ALLOCATION == 1 )</span>            <span class="token punctuation">{</span>                pxNewQueue<span class="token operator">-></span>ucStaticallyAllocated <span class="token operator">=</span> pdFALSE<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">/* configSUPPORT_STATIC_ALLOCATION */</span>            <span class="token function">prvInitialiseNewQueue</span><span class="token punctuation">(</span> uxQueueLength<span class="token punctuation">,</span> uxItemSize<span class="token punctuation">,</span> pucQueueStorage<span class="token punctuation">,</span> ucQueueType<span class="token punctuation">,</span> pxNewQueue <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> pxNewQueue<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>真正的初始化在下面这个函数中：</p><pre class="line-numbers language-c"><code class="language-c">BaseType_t <span class="token function">xQueueGenericReset</span><span class="token punctuation">(</span> QueueHandle_t xQueue<span class="token punctuation">,</span> BaseType_t xNewQueue <span class="token punctuation">)</span><span class="token punctuation">{</span>Queue_t <span class="token operator">*</span> <span class="token keyword">const</span> pxQueue <span class="token operator">=</span> <span class="token punctuation">(</span> Queue_t <span class="token operator">*</span> <span class="token punctuation">)</span> xQueue<span class="token punctuation">;</span>    <span class="token function">configASSERT</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">taskENTER_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 消息队列数据结构的相关初始化 */</span>        pxQueue<span class="token operator">-></span>pcTail <span class="token operator">=</span> pxQueue<span class="token operator">-></span>pcHead <span class="token operator">+</span> <span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>uxLength <span class="token operator">*</span> pxQueue<span class="token operator">-></span>uxItemSize <span class="token punctuation">)</span><span class="token punctuation">;</span>        pxQueue<span class="token operator">-></span>uxMessagesWaiting <span class="token operator">=</span> <span class="token punctuation">(</span> UBaseType_t <span class="token punctuation">)</span> <span class="token number">0U</span><span class="token punctuation">;</span>        pxQueue<span class="token operator">-></span>pcWriteTo <span class="token operator">=</span> pxQueue<span class="token operator">-></span>pcHead<span class="token punctuation">;</span>        pxQueue<span class="token operator">-></span>u<span class="token punctuation">.</span>pcReadFrom <span class="token operator">=</span> pxQueue<span class="token operator">-></span>pcHead <span class="token operator">+</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>uxLength <span class="token operator">-</span> <span class="token punctuation">(</span> UBaseType_t <span class="token punctuation">)</span> <span class="token number">1U</span> <span class="token punctuation">)</span> <span class="token operator">*</span> pxQueue<span class="token operator">-></span>uxItemSize <span class="token punctuation">)</span><span class="token punctuation">;</span>        pxQueue<span class="token operator">-></span>cRxLock <span class="token operator">=</span> queueUNLOCKED<span class="token punctuation">;</span>        pxQueue<span class="token operator">-></span>cTxLock <span class="token operator">=</span> queueUNLOCKED<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> xNewQueue <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">listLIST_IS_EMPTY</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>xTasksWaitingToSend <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">xTaskRemoveFromEventList</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>xTasksWaitingToSend <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">!=</span> pdFALSE <span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token function">queueYIELD_IF_USING_PREEMPTION</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span>                <span class="token punctuation">{</span>                    <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* Ensure the event queues start in the correct state. */</span>            <span class="token function">vListInitialise</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>xTasksWaitingToSend <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">vListInitialise</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>xTasksWaitingToReceive <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">taskEXIT_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> pdPASS<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化完成之后，为了让大家理解，消息队列是怎么样的，就给出一个示意图，黄色部分是消息队列的控制块，而绿色部分则是消息队列的存放消息的地方，在创建的时候，我们知道的消息队列长度与单个消息空间大小。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181203194804553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppZWppZW1jdQ==,size_16,color_FFFFFF,t_70" alt="此图截自野火FreeRTOS书籍"></p><h3 id="消息队列发送"><a href="#消息队列发送" class="headerlink" title="消息队列发送"></a>消息队列发送</h3><p>任务或者中断服务程序都可以给消息队列发送消息，当发送消息时，如果队列未满或者允许覆盖入队， FreeRTOS 会将消息拷贝到消息队列队尾，否则，会根据用户指定的阻塞超时时间进行阻塞，在这段时间中，如果队列一直不允许入队，该任务将保持阻塞状态以等待队列允许入队。当其它任务从其等待的队列中读取入了数据（队列未满），该任务将自动由阻塞态转为就绪态。当任务等待的时间超过了指定的阻塞时间，即使队列中还不允许入队，任务也会自动从阻塞态转移为就绪态，此时发送消息的任务或者中断程序会收到一个错误码 errQUEUE_FULL。<br>发送紧急消息的过程与发送消息几乎一样，唯一的不同是，当发送紧急消息时，发送的位置是消息队列队头而非队尾，这样，接收者就能够优先接收到紧急消息，从而及时进行消息处理。<br>下面是消息队列的发送API接口，函数中有FromISR则表明在中断中使用的。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181203195147150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppZWppZW1jdQ==,size_16,color_FFFFFF,t_70" alt="消息队列入队（发送）的API接口"></p><pre class="line-numbers language-c"><code class="language-c"><span class="token number">1</span> <span class="token comment" spellcheck="true">/*-----------------------------------------------------------*/</span> <span class="token number">2</span> BaseType_t <span class="token function">xQueueGenericSend</span><span class="token punctuation">(</span> QueueHandle_t xQueue<span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>     <span class="token number">3</span>                               <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">const</span> pvItemToQueue<span class="token punctuation">,</span>     <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">4</span>                               TickType_t xTicksToWait<span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">5</span>                               <span class="token keyword">const</span> BaseType_t xCopyPosition <span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">6</span> <span class="token punctuation">{</span> <span class="token number">7</span>     BaseType_t xEntryTimeSet <span class="token operator">=</span> pdFALSE<span class="token punctuation">,</span> xYieldRequired<span class="token punctuation">;</span> <span class="token number">8</span>     TimeOut_t xTimeOut<span class="token punctuation">;</span> <span class="token number">9</span>     Queue_t <span class="token operator">*</span> <span class="token keyword">const</span> pxQueue <span class="token operator">=</span> <span class="token punctuation">(</span> Queue_t <span class="token operator">*</span> <span class="token punctuation">)</span> xQueue<span class="token punctuation">;</span><span class="token number">10</span> <span class="token number">11</span>     <span class="token comment" spellcheck="true">/* 已删除一些断言操作 */</span><span class="token number">12</span> <span class="token number">13</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">14</span>         <span class="token function">taskENTER_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token number">15</span>         <span class="token punctuation">{</span><span class="token number">16</span>             <span class="token comment" spellcheck="true">/* 队列未满 */</span><span class="token number">17</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>uxMessagesWaiting <span class="token operator">&lt;</span> pxQueue<span class="token operator">-></span>uxLength <span class="token punctuation">)</span><span class="token number">18</span>                  <span class="token operator">||</span> <span class="token punctuation">(</span> xCopyPosition <span class="token operator">==</span> queueOVERWRITE <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>    <span class="token number">19</span>                 <span class="token function">traceQUEUE_SEND</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">20</span>                 xYieldRequired <span class="token operator">=</span><span class="token number">21</span>           <span class="token function">prvCopyDataToQueue</span><span class="token punctuation">(</span> pxQueue<span class="token punctuation">,</span> pvItemToQueue<span class="token punctuation">,</span> xCopyPosition <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token number">22</span> <span class="token number">23</span>                 <span class="token comment" spellcheck="true">/* 已删除使用队列集部分代码 */</span><span class="token number">24</span>                 <span class="token comment" spellcheck="true">/* 如果有任务在等待获取此消息队列 */</span><span class="token number">25</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">listLIST_IS_EMPTY</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>pxQueue<span class="token operator">-></span>xTasksWaitingToReceive<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span>pdFALSE<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token number">26</span>                     <span class="token comment" spellcheck="true">/* 将任务从阻塞中恢复 */</span><span class="token number">27</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">xTaskRemoveFromEventList</span><span class="token punctuation">(</span><span class="token number">28</span>                   <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>xTasksWaitingToReceive <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token operator">!=</span>pdFALSE<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token number">29</span>                         <span class="token comment" spellcheck="true">/* 如果恢复的任务优先级比当前运行任务优先级还高，30                         那么需要进行一次任务切换 */</span><span class="token number">31</span>                         <span class="token function">queueYIELD_IF_USING_PREEMPTION</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token number">32</span>                     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">33</span>                         <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">34</span>                     <span class="token punctuation">}</span><span class="token number">35</span>                 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> xYieldRequired <span class="token operator">!=</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">36</span>                     <span class="token comment" spellcheck="true">/* 如果没有等待的任务，拷贝成功也需要任务切换 */</span><span class="token number">37</span>                     <span class="token function">queueYIELD_IF_USING_PREEMPTION</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token number">38</span>                 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">39</span>                     <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">40</span>                 <span class="token punctuation">}</span><span class="token number">41</span> <span class="token number">42</span>                 <span class="token function">taskEXIT_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token number">43</span>                 <span class="token keyword">return</span> pdPASS<span class="token punctuation">;</span><span class="token number">44</span>             <span class="token punctuation">}</span><span class="token number">45</span>             <span class="token comment" spellcheck="true">/* 队列已满 */</span><span class="token number">46</span>             <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token number">47</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span> xTicksToWait <span class="token operator">==</span> <span class="token punctuation">(</span> TickType_t <span class="token punctuation">)</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">48</span>                     <span class="token comment" spellcheck="true">/* 如果用户不指定阻塞超时时间，退出 */</span><span class="token number">49</span>                     <span class="token function">taskEXIT_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">)</span><span class="token number">50</span>                     <span class="token function">traceQUEUE_SEND_FAILED</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">51</span>                     <span class="token keyword">return</span> errQUEUE_FULL<span class="token punctuation">;</span><span class="token number">52</span>                 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> xEntryTimeSet <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token number">53</span>                     <span class="token comment" spellcheck="true">/* 初始化阻塞超时结构体变量，初始化进入54                 阻塞的时间xTickCount和溢出次数xNumOfOverflows */</span><span class="token number">55</span>                     <span class="token function">vTaskSetTimeOutState</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>xTimeOut <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token number">56</span>                     xEntryTimeSet <span class="token operator">=</span> pdTRUE<span class="token punctuation">;</span><span class="token number">57</span>                 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">58</span>                     <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">59</span>                 <span class="token punctuation">}</span><span class="token number">60</span>             <span class="token punctuation">}</span><span class="token number">61</span>         <span class="token punctuation">}</span><span class="token number">62</span>         <span class="token function">taskEXIT_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token number">63</span>         <span class="token comment" spellcheck="true">/* 挂起调度器 */</span><span class="token number">64</span>         <span class="token function">vTaskSuspendAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">65</span>         <span class="token comment" spellcheck="true">/* 队列上锁 */</span><span class="token number">66</span>         <span class="token function">prvLockQueue</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">67</span> <span class="token number">68</span>         <span class="token comment" spellcheck="true">/* 检查超时时间是否已经过去了 */</span><span class="token number">69</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">xTaskCheckForTimeOut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>xTimeOut<span class="token punctuation">,</span> <span class="token operator">&amp;</span>xTicksToWait<span class="token punctuation">)</span><span class="token operator">==</span>pdFALSE<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">(</span><span class="token number">17</span><span class="token punctuation">)</span><span class="token number">70</span>             <span class="token comment" spellcheck="true">/* 如果队列还是满的 */</span><span class="token number">71</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">prvIsQueueFull</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span> <span class="token operator">!=</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span>    <span class="token number">72</span>                 <span class="token function">traceBLOCKING_ON_QUEUE_SEND</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token number">73</span>                 <span class="token comment" spellcheck="true">/* 将当前任务添加到队列的等待发送列表中74                    以及阻塞延时列表，延时时间为用户指定的超时时间xTicksToWait */</span><span class="token number">75</span>                 <span class="token function">vTaskPlaceOnEventList</span><span class="token punctuation">(</span><span class="token number">76</span>                    <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>xTasksWaitingToSend <span class="token punctuation">)</span><span class="token punctuation">,</span> xTicksToWait <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">)</span><span class="token number">77</span>                 <span class="token comment" spellcheck="true">/* 队列解锁 */</span><span class="token number">78</span>                 <span class="token function">prvUnlockQueue</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token number">79</span> <span class="token number">80</span>                 <span class="token comment" spellcheck="true">/* 恢复调度器 */</span><span class="token number">81</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">xTaskResumeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">82</span>                     <span class="token function">portYIELD_WITHIN_API</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">83</span>                 <span class="token punctuation">}</span><span class="token number">84</span>             <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">85</span>                 <span class="token comment" spellcheck="true">/* 队列有空闲消息空间，允许入队 */</span><span class="token number">86</span>                 <span class="token function">prvUnlockQueue</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token function">87</span>                 <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span> <span class="token function">xTaskResumeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">88</span>             <span class="token punctuation">}</span><span class="token number">89</span>         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">90</span>             <span class="token comment" spellcheck="true">/* 超时时间已过，退出 */</span><span class="token number">91</span>             <span class="token function">prvUnlockQueue</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token function">92</span>             <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span> <span class="token function">xTaskResumeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">93</span> <span class="token number">94</span>             <span class="token function">traceQUEUE_SEND_FAILED</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">95</span>             <span class="token keyword">return</span> errQUEUE_FULL<span class="token punctuation">;</span><span class="token number">96</span>         <span class="token punctuation">}</span><span class="token number">97</span>     <span class="token punctuation">}</span><span class="token number">98</span> <span class="token punctuation">}</span><span class="token number">99</span> <span class="token comment" spellcheck="true">/*-----------------------------------------------------------*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果阻塞时间不为 0，任务会因为等待入队而进入阻塞， 在将任务设置为阻塞的过程中， 系统不希望有其它任务和中断操作这个队列的 xTasksWaitingToReceive 列表和 xTasksWaitingToSend 列表，因为可能引起其它任务解除阻塞，这可能会发生优先级翻转。比如任务 A 的优先级低于当前任务，但是在当前任务进入阻塞的过程中，任务 A 却因为其它原因解除阻塞了，这显然是要绝对禁止的。因此FreeRTOS 使用挂起调度器禁止其它任务操作队列，因为挂起调度器意味着任务不能切换并且不准调用可能引起任务切换的 API 函数。但挂起调度器并不会禁止中断，中断服务函数仍然可以操作队列事件列表，可能会解除任务阻塞、可能会进行上下文切换，这也是不允许的。于是，解决办法是不但挂起调度器，还要给队列上锁，禁止任何中断来操作队列。<br>再借用朱工精心制作的流程图加以理解：图片出自：<a href="https://blog.csdn.net/zhzht19861011/article/details/51510384" target="_blank" rel="noopener">https://blog.csdn.net/zhzht19861011/article/details/51510384</a><br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181203200214963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppZWppZW1jdQ==,size_16,color_FFFFFF,t_70" alt="消息队列入队流程"></p><p>消息队列出队的API函数接口：<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181203200731899.png" alt=""><br>消息队列出队过程分析，其实跟入队差不多，请看注释：</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token number">1</span> <span class="token comment" spellcheck="true">/*-----------------------------------------------------------*/</span> <span class="token number">2</span> BaseType_t <span class="token function">xQueueGenericReceive</span><span class="token punctuation">(</span> QueueHandle_t xQueue<span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>     <span class="token number">3</span>                                  <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">const</span> pvBuffer<span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">4</span>                                  TickType_t xTicksToWait<span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>     <span class="token number">5</span>                                  <span class="token keyword">const</span> BaseType_t xJustPeeking <span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">6</span> <span class="token punctuation">{</span> <span class="token number">7</span>     BaseType_t xEntryTimeSet <span class="token operator">=</span> pdFALSE<span class="token punctuation">;</span> <span class="token number">8</span>     TimeOut_t xTimeOut<span class="token punctuation">;</span> <span class="token number">9</span>     int8_t <span class="token operator">*</span>pcOriginalReadPosition<span class="token punctuation">;</span><span class="token number">10</span>     Queue_t <span class="token operator">*</span> <span class="token keyword">const</span> pxQueue <span class="token operator">=</span> <span class="token punctuation">(</span> Queue_t <span class="token operator">*</span> <span class="token punctuation">)</span> xQueue<span class="token punctuation">;</span><span class="token number">11</span> <span class="token number">12</span>     <span class="token comment" spellcheck="true">/* 已删除一些断言 */</span><span class="token number">13</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">14</span>         <span class="token function">taskENTER_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token number">15</span>         <span class="token punctuation">{</span><span class="token number">16</span>             <span class="token keyword">const</span> UBaseType_t uxMessagesWaiting <span class="token operator">=</span> pxQueue<span class="token operator">-></span>uxMessagesWaiting<span class="token punctuation">;</span> <span class="token number">17</span> <span class="token number">18</span>             <span class="token comment" spellcheck="true">/* 看看队列中有没有消息 */</span><span class="token number">19</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span> uxMessagesWaiting <span class="token operator">></span> <span class="token punctuation">(</span> UBaseType_t <span class="token punctuation">)</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>    <span class="token number">20</span>                 <span class="token comment" spellcheck="true">/*防止仅仅是读取消息，而不进行消息出队操作*/</span><span class="token number">21</span>                 pcOriginalReadPosition <span class="token operator">=</span> pxQueue<span class="token operator">-></span>u<span class="token punctuation">.</span>pcReadFrom<span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token number">22</span>                 <span class="token comment" spellcheck="true">/* 拷贝消息到用户指定存放区域pvBuffer */</span><span class="token number">23</span>                 <span class="token function">prvCopyDataFromQueue</span><span class="token punctuation">(</span> pxQueue<span class="token punctuation">,</span> pvBuffer <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token number">24</span> <span class="token number">25</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span> xJustPeeking <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token number">26</span>                     <span class="token comment" spellcheck="true">/* 读取消息并且消息出队 */</span><span class="token number">27</span>                     <span class="token function">traceQUEUE_RECEIVE</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token number">28</span> <span class="token number">29</span>                     <span class="token comment" spellcheck="true">/* 获取了消息，当前消息队列的消息个数需要减一 */</span><span class="token number">30</span>                     pxQueue<span class="token operator">-></span>uxMessagesWaiting <span class="token operator">=</span> uxMessagesWaiting <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token number">31</span>                     <span class="token comment" spellcheck="true">/* 判断一下消息队列中是否有等待发送消息的任务 */</span><span class="token number">32</span>                     <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">listLIST_IS_EMPTY</span><span class="token punctuation">(</span>            <span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token number">33</span>                              <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>xTasksWaitingToSend <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">34</span>                         <span class="token comment" spellcheck="true">/* 将任务从阻塞中恢复 */</span><span class="token number">35</span>                         <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">xTaskRemoveFromEventList</span><span class="token punctuation">(</span>        <span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token number">36</span>                                  <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>xTasksWaitingToSend <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">!=</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">37</span>                             <span class="token comment" spellcheck="true">/* 如果被恢复的任务优先级比当前任务高，会进行一次任务切换 */</span><span class="token number">38</span>                             <span class="token function">queueYIELD_IF_USING_PREEMPTION</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token number">39</span>                         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">40</span>                             <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">41</span>                         <span class="token punctuation">}</span><span class="token number">42</span>                     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">43</span>                         <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">44</span>                     <span class="token punctuation">}</span><span class="token number">45</span>                 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">)</span><span class="token number">46</span>                     <span class="token comment" spellcheck="true">/* 任务只是看一下消息（peek），并不出队 */</span>    <span class="token number">47</span>                     <span class="token function">traceQUEUE_PEEK</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">48</span> <span class="token number">49</span>                     <span class="token comment" spellcheck="true">/* 因为是只读消息 所以还要还原读消息位置指针 */</span><span class="token number">50</span>                     pxQueue<span class="token operator">-></span>u<span class="token punctuation">.</span>pcReadFrom <span class="token operator">=</span> pcOriginalReadPosition<span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token number">51</span> <span class="token number">52</span>                     <span class="token comment" spellcheck="true">/* 判断一下消息队列中是否还有等待获取消息的任务 */</span><span class="token number">53</span>                     <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">listLIST_IS_EMPTY</span><span class="token punctuation">(</span>            <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token number">54</span>                              <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>xTasksWaitingToReceive <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">55</span>                         <span class="token comment" spellcheck="true">/* 将任务从阻塞中恢复 */</span><span class="token number">56</span>                         <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">xTaskRemoveFromEventList</span><span class="token punctuation">(</span>            <span class="token number">57</span>                               <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>xTasksWaitingToReceive <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">!=</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">58</span>                             <span class="token comment" spellcheck="true">/* 如果被恢复的任务优先级比当前任务高，会进行一次任务切换 */</span><span class="token number">59</span>                             <span class="token function">queueYIELD_IF_USING_PREEMPTION</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token number">60</span>                         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">61</span>                             <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">62</span>                         <span class="token punctuation">}</span><span class="token number">63</span>                     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">64</span>                         <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">65</span>                     <span class="token punctuation">}</span><span class="token number">66</span>                 <span class="token punctuation">}</span><span class="token number">67</span> <span class="token number">68</span>                 <span class="token function">taskEXIT_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">(</span><span class="token number">17</span><span class="token punctuation">)</span><span class="token number">69</span>                 <span class="token keyword">return</span> pdPASS<span class="token punctuation">;</span><span class="token number">70</span>             <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token number">71</span>                 <span class="token comment" spellcheck="true">/* 消息队列中没有消息可读 */</span><span class="token number">72</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span> xTicksToWait <span class="token operator">==</span> <span class="token punctuation">(</span> TickType_t <span class="token punctuation">)</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">)</span>    <span class="token number">73</span>                     <span class="token comment" spellcheck="true">/* 不等待，直接返回 */</span><span class="token number">74</span>                     <span class="token function">taskEXIT_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">75</span>                     <span class="token function">traceQUEUE_RECEIVE_FAILED</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">76</span>                     <span class="token keyword">return</span> errQUEUE_EMPTY<span class="token punctuation">;</span><span class="token number">77</span>                 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> xEntryTimeSet <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token number">78</span>                     <span class="token comment" spellcheck="true">/* 初始化阻塞超时结构体变量，初始化进入79                     阻塞的时间xTickCount和溢出次数xNumOfOverflows */</span><span class="token number">80</span>                     <span class="token function">vTaskSetTimeOutState</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>xTimeOut <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token number">81</span>                     xEntryTimeSet <span class="token operator">=</span> pdTRUE<span class="token punctuation">;</span><span class="token number">82</span>                 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">83</span>                     <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">84</span>                 <span class="token punctuation">}</span><span class="token number">85</span>             <span class="token punctuation">}</span><span class="token number">86</span>         <span class="token punctuation">}</span><span class="token number">87</span>         <span class="token function">taskEXIT_CRITICAL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token number">88</span> <span class="token number">89</span>         <span class="token function">vTaskSuspendAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">90</span>         <span class="token function">prvLockQueue</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token number">91</span> <span class="token number">92</span>         <span class="token comment" spellcheck="true">/* 检查超时时间是否已经过去了*/</span><span class="token number">93</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">xTaskCheckForTimeOut</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>xTimeOut<span class="token punctuation">,</span> <span class="token operator">&amp;</span>xTicksToWait <span class="token punctuation">)</span> <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token number">94</span>             <span class="token comment" spellcheck="true">/* 如果队列还是空的 */</span><span class="token number">95</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">prvIsQueueEmpty</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span> <span class="token operator">!=</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">96</span>                 <span class="token function">traceBLOCKING_ON_QUEUE_RECEIVE</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">)</span>    <span class="token number">97</span>                 <span class="token comment" spellcheck="true">/* 将当前任务添加到队列的等待接收列表中98                    以及阻塞延时列表，阻塞时间为用户指定的超时时间xTicksToWait */</span><span class="token number">99</span>                 <span class="token function">vTaskPlaceOnEventList</span><span class="token punctuation">(</span>                <span class="token number">100</span>                     <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxQueue<span class="token operator">-></span>xTasksWaitingToReceive <span class="token punctuation">)</span><span class="token punctuation">,</span> xTicksToWait <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">101</span>                 <span class="token function">prvUnlockQueue</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">102</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">xTaskResumeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token number">103</span>                     <span class="token comment" spellcheck="true">/* 如果有任务优先级比当前任务高，会进行一次任务切换 */</span><span class="token number">104</span>                     <span class="token function">portYIELD_WITHIN_API</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token number">105</span>                 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">106</span>                     <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">107</span>                 <span class="token punctuation">}</span><span class="token number">108</span>             <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">109</span>                 <span class="token comment" spellcheck="true">/* 如果队列有消息了，就再试一次获取消息 */</span><span class="token number">110</span>                 <span class="token function">prvUnlockQueue</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token function">111</span>                 <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span> <span class="token function">xTaskResumeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">112</span>             <span class="token punctuation">}</span><span class="token number">113</span>         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">114</span>             <span class="token comment" spellcheck="true">/* 超时时间已过，退出 */</span><span class="token number">115</span>             <span class="token function">prvUnlockQueue</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token function">116</span>             <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span> <span class="token function">xTaskResumeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">117</span> <span class="token number">118</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">prvIsQueueEmpty</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span> <span class="token operator">!=</span> pdFALSE <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">119</span>                 <span class="token comment" spellcheck="true">/* 如果队列还是空的，返回错误代码errQUEUE_EMPTY */</span><span class="token number">120</span>                 <span class="token function">traceQUEUE_RECEIVE_FAILED</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">121</span>                 <span class="token keyword">return</span> errQUEUE_EMPTY<span class="token punctuation">;</span>                <span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">)</span><span class="token number">122</span>             <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">123</span>                 <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">124</span>             <span class="token punctuation">}</span><span class="token number">125</span>         <span class="token punctuation">}</span><span class="token number">126</span>     <span class="token punctuation">}</span><span class="token number">127</span> <span class="token punctuation">}</span><span class="token number">128</span> <span class="token comment" spellcheck="true">/*-----------------------------------------------------------*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS优化与错误排查方法</title>
      <link href="/freertos-9/"/>
      <url>/freertos-9/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>主要是为刚接触 FreeRTOS 的用户指出那些新手通常容易遇到的问题。这里把最主要的篇幅放在栈溢出以及栈溢出j检测上，因为栈相关的问题是初学者遇到最多的问题。</p><h3 id="printf-stdarg-c"><a href="#printf-stdarg-c" class="headerlink" title="printf-stdarg.c"></a>printf-stdarg.c</h3><p>当调用 <strong>C  标准库</strong> 的函数时，栈空间使用量可能会急剧上升，特别是 IO 与字符串处理函数，比如 sprintf()、printf()等。在 FreeRTOS 源码包中有一个名为 <strong>printf-stdarg.c</strong> 的文件。这个文件实现了一个栈效率优化版的小型 sprintf()、printf()，可以用来代替标准 C 库函数版本。在大多数情况下，这样做可以使得调用 sprintf()及相关函数的任务对栈空间的需求量小很多。<br>可能很多人都不知道freertos中有这样子的一个文件，它放在第三方资料中，路径为“<strong>FreeRTOSv9.0.0\FreeRTOS-Plus\Demo\FreeRTOS_Plus_UDP_and_CLI_LPC1830_GCC</strong>”，我们发布工程的时候就无需依赖 <strong>C 标准库</strong>，这样子就能减少栈的使用，能优化不少空间。<br>该文件源码（部分）：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">print</span><span class="token punctuation">(</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>out<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> va_list args <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">register</span> <span class="token keyword">int</span> width<span class="token punctuation">,</span> pad<span class="token punctuation">;</span>    <span class="token keyword">register</span> <span class="token keyword">int</span> pc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> scr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token operator">*</span>format <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">++</span>format<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'%'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token operator">++</span>format<span class="token punctuation">;</span>            width <span class="token operator">=</span> pad <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'\0'</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'%'</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> out<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token operator">++</span>format<span class="token punctuation">;</span>                pad <span class="token operator">=</span> PAD_RIGHT<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token operator">++</span>format<span class="token punctuation">;</span>                pad <span class="token operator">|</span><span class="token operator">=</span> PAD_ZERO<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> <span class="token operator">*</span>format <span class="token operator">>=</span> <span class="token string">'0'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>format <span class="token operator">&lt;=</span> <span class="token string">'9'</span><span class="token punctuation">;</span> <span class="token operator">++</span>format<span class="token punctuation">)</span> <span class="token punctuation">{</span>                width <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>                width <span class="token operator">+</span><span class="token operator">=</span> <span class="token operator">*</span>format <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'s'</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">register</span> <span class="token keyword">char</span> <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">va_arg</span><span class="token punctuation">(</span> args<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>                pc <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">prints</span> <span class="token punctuation">(</span>out<span class="token punctuation">,</span> s<span class="token operator">?</span>s<span class="token punctuation">:</span><span class="token string">"(null)"</span><span class="token punctuation">,</span> width<span class="token punctuation">,</span> pad<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'d'</span> <span class="token operator">||</span> <span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'i'</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>                pc <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">printi</span> <span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token function">va_arg</span><span class="token punctuation">(</span> args<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> width<span class="token punctuation">,</span> pad<span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'x'</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>                pc <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">printi</span> <span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token function">va_arg</span><span class="token punctuation">(</span> args<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> width<span class="token punctuation">,</span> pad<span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'X'</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>                pc <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">printi</span> <span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token function">va_arg</span><span class="token punctuation">(</span> args<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> width<span class="token punctuation">,</span> pad<span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'u'</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>                pc <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">printi</span> <span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token function">va_arg</span><span class="token punctuation">(</span> args<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> width<span class="token punctuation">,</span> pad<span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">*</span>format <span class="token operator">==</span> <span class="token string">'c'</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/* char are converted to int then pushed on the stack */</span>                scr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token function">va_arg</span><span class="token punctuation">(</span> args<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>                scr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>                pc <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">prints</span> <span class="token punctuation">(</span>out<span class="token punctuation">,</span> scr<span class="token punctuation">,</span> width<span class="token punctuation">,</span> pad<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>        out<span class="token punctuation">:</span>            <span class="token function">printchar</span> <span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token operator">*</span>format<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>pc<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>out<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token operator">*</span>out <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>    <span class="token function">va_end</span><span class="token punctuation">(</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> pc<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    va_list args<span class="token punctuation">;</span>    <span class="token function">va_start</span><span class="token punctuation">(</span> args<span class="token punctuation">,</span> format <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">print</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span> format<span class="token punctuation">,</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">sprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>out<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    va_list args<span class="token punctuation">;</span>    <span class="token function">va_start</span><span class="token punctuation">(</span> args<span class="token punctuation">,</span> format <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">print</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>out<span class="token punctuation">,</span> format<span class="token punctuation">,</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">snprintf</span><span class="token punctuation">(</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> count<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    va_list args<span class="token punctuation">;</span>    <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span> count<span class="token punctuation">;</span>    <span class="token function">va_start</span><span class="token punctuation">(</span> args<span class="token punctuation">,</span> format <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">print</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> format<span class="token punctuation">,</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用的例子与 C 标准库基本一样：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token string">"Hello world!"</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>np <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> bs <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mi<span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    mi <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>bs<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"printf test\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s is null pointer\n"</span><span class="token punctuation">,</span> np<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d = 5\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d = - max int\n"</span><span class="token punctuation">,</span> mi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"char %c = 'a'\n"</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hex %x = ff\n"</span><span class="token punctuation">,</span> <span class="token number">0xff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hex %02x = 00\n"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"signed %d = unsigned %u = hex %x\n"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %s(s)%"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %s(s) with %%\n"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"justif: \"%-10s\"\n"</span><span class="token punctuation">,</span> <span class="token string">"left"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"justif: \"%10s\"\n"</span><span class="token punctuation">,</span> <span class="token string">"right"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">" 3: %04d zero padded\n"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">" 3: %-4d left justif.\n"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">" 3: %4d right justif.\n"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"-3: %04d zero padded\n"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"-3: %-4d left justif.\n"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"-3: %4d right justif.\n"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="栈计算"><a href="#栈计算" class="headerlink" title="栈计算"></a>栈计算</h3><p>每个任务都独立维护自己的栈空间， 任务栈空间总量在任务创建时进行设定。<code>uxTaskGetStackHighWaterMark()</code>主要用来查询指定任务的运行历史中， 其栈空间还差多少就要溢出。这个值被称为栈空间的<strong>High Water Mark</strong>。<br><strong>函数原型：</strong></p><pre><code>UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )</code></pre><p> 想要使用它，需要将对应的宏定义打开：<code>INCLUDE_uxTaskGetStackHighWaterMark</code></p><p><strong>函数描述：</strong><br>|参数|说明|<br>|–|–|<br>| xTask  | 被查询任务的句柄如果传入 NULL 句柄，则任务查询的是自身栈空间的高水线 |<br>| 返回值| 任务栈空间的实际使用量会随着任务执行和中断处理过程上下浮动。uxTaskGetStackHighWaterMark()返回从任务启动执行开始的运行历史中，栈空间具有的最小剩余量。这个值即是栈空间使用达到最深时的剩下的未使用的栈空间。这个值越是接近 0，则这个任务就越是离栈溢出不远。|</p><p>如果不知道怎么计算任务栈大小，就使用这个函数进行统计一下，然后将任务运行时最大的栈空间作为任务栈空间的80%大小即可。即假设统计得到的任务栈大小为常量 <strong>A</strong> ，那么在创建线程的时候需要 <strong>X</strong> 大小的空间，那么 <strong>X * 80% = A</strong>，算到的 <strong>X</strong> 作为任务栈大小就差不多了。</p><h3 id="运行时栈检测"><a href="#运行时栈检测" class="headerlink" title="运行时栈检测"></a>运行时栈检测</h3><p>FreeRTOS 包含两种运行时栈j检测机制，由 FreeRTOSConfig.h 中的配置常量configCHECK_FOR_STACK_OVERFLOW 进行控制。这两种方式都会增加上下切换开销。</p><p>栈溢出钩子函数(或称回调函数)由内核在j检测到栈溢出时调用。要使用栈溢出钩子函数，需要进行以下配置：</p><ul><li>在 FreeRTOSConfig.h 中把 configCHECK_FOR_STACK_OVERFLOW 设为 <strong>1</strong> 或者 <strong>2</strong>  。</li><li>提供钩子函数的具体实现，采用下面所示的函数名和函数原型。</li></ul><pre><code>void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed portCHAR *pcTaskName );</code></pre><p>补充说明：</p><ul><li>栈溢出钩子函数只是为了使跟踪调试栈空间错误更容易，而无法在栈溢出时对其进行恢复。函数的入口参数传入了任务句柄和任务名，但任务名很可能在溢出时已经遭到破坏。</li><li>栈溢出钩子函数还可以在中断的上下文中进行调用</li><li>某些微控制器在检测到内存访问错误时会产生错误异常，很可能在内核调用栈溢出钩子函数之前就触发了错误异常中断。</li></ul><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>当 <code>configCHECK_FOR_STACK_OVERFLOW</code> 设置为 <strong>1</strong> 时选用方法 <strong>1</strong>。<br>任务被交换出去的时候，该任务的整个上下文被保存到它自己的栈空间中。这时任务栈的使用应当达到了一个峰值。当 <code>configCHECK_FOR_STACK_OVERFLOW</code> 设为<strong>1</strong> 时，内核会在任务上下文保存后检查栈指针是否还指向有效栈空间。一旦检测到栈指针的指向已经超出任务栈的有效范围，栈溢出钩子函数就会被调用。<br>方法 1 具有较快的执行速度，但栈溢出有可能发生在两次上下文保存之间，这种情况不会被检测到，因为这种检测方式仅在任务切换中检测。</p><h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>将 <code>configCHECK_FOR_STACK_OVERFLOW</code> 设为 <strong>2</strong> 就可以选用方法 <strong>2</strong>。方法 <strong>2</strong>在方法 1 的基础上进行了一些补充。<br>当创建任务时，任务栈空间中就预置了一个标记。方法 <strong>2</strong> 会检查任务栈的最后 <strong>20个字节</strong>的数据，查看预置在这里的标记数据是否被覆盖。如果最后 <strong>20 个字节的标记数据</strong>与预设值不同，则栈溢出钩子函数就会被调用。<br>方法 <strong>2</strong> 没有方法 <strong>1</strong> 的执行速度快，但测试仅仅 20 个字节相对来说也是很快的。这种方法应该可以j检测到任何时候发生的栈溢出，虽然理论上还是有可能漏掉一些情况，但这些情况几乎是不可能发生的。</p><h3 id="其它常见错误"><a href="#其它常见错误" class="headerlink" title="其它常见错误"></a>其它常见错误</h3><blockquote><p>在一个 Demo 应用程序中增加了一个简单的任务，导致应用程序崩溃</p></blockquote><p>可能的情况：</p><ol><li>任务创建时需要在内存堆中分配空间。许多 Demo 应用程序定义的<strong>堆空间</strong>大小只够用于创建 Demo 任务——所以当任务创建完成后，就没有足够的剩余空间来增加其它的<strong>任务，队列或信号量</strong>。</li><li>空闲任务是在 <code>vTaskStartScheduler()</code>调用中自动创建的。如果由于内存不足而无法创建空闲任务，<code>vTaskStartScheduler()</code>会直接返回。所以一般在调用 <code>vTaskStartScheduler()</code>后加上一条空循环<code>for(;;) / while(1)</code>可以使这种错误更加容易调试。</li></ol><p><strong>如果要添加更多的任务，可以增加内存堆空间大小（修改配置文件），或是删掉一些已存在的 Demo任务。</strong></p><blockquote><p>在中断中调用一个 API 函数，导致应用程序崩溃</p></blockquote><h4 id="需要做的第一件事是检查中断是否导致了栈溢出。"><a href="#需要做的第一件事是检查中断是否导致了栈溢出。" class="headerlink" title="需要做的第一件事是检查中断是否导致了栈溢出。"></a>需要做的第一件事是检查中断是否导致了栈溢出。</h4><p><strong>然后检查API接口是否正确</strong>，除了具有后缀为<code>FromISR</code>函数名的 API 函数，千万不要在中断服务程序中调用其它 API 函数。</p><p><strong>除此之外，还需要注意中断的优先级：</strong><br><code>FreeRTOSConfig.h</code>文件中可以配置系统可管理的最高中断优先级数值，宏定义<code>configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</code>是用于配置basepri寄存器的，当basepri设置为某个值的时候，会让系统不响应比该优先级低的中断，而优先级比之更高的中断则不受影响。就是说当这个宏定义配置为<strong>5</strong>的时候，中断优先级数值在<strong>0、1、2、3、4</strong>的这些中断是不受FreeRTOS管理的，不可被屏蔽，<strong>同时也不能调用FreeRTOS中的API函数接口</strong>，而中断优先级在5到15的这些中断是受到系统管理，可以被屏蔽的，也可以调用FreeRTOS中的API函数接口。</p><blockquote><p>临界区无法正确嵌套</p></blockquote><p>除了 taskENTER_CRITICA()和 taskEXIT_CRITICAL()，千万不要在其它地方修改控制器的中断使能位或优先级标志。这两个宏维护了一个嵌套深度计数，所以只有当所有的嵌套调用都退出后计数值才会为 0，也才会使能中断。</p><blockquote><p>在调度器启动前应用程序就崩溃了</p></blockquote><p>这个问题我也会遇到，如果一个中断会产生上下文切换，则这个中断不能在调度器启动之前使能。这同样适用于那些需要读写队列或信号量的中断。在调度器启动之前，不能进行上下文切换。<br>还有一些 API 函数不能在调度器启动之前调用。在调用 vTaskStartScheduler()之前，最好是限定只使用创建任务，队列和信号量的 API 函数。<br>比如有一些初始化需要中断的，或者在初始化完成的时候回产生一个中断，这些驱动的初始化最好放在一个任务中进行，我是这样子处理的，在<code>main</code>函数中创建一个任务，在任务中进行bsp初始化，然后再创建消息队列、信号量、互斥量、事件以及任务等操作。</p><blockquote><p>在调度器挂起时调用 API 函数，导致应用程序崩溃</p></blockquote><p>调用 vTaskSuspendAll()使得调度器挂起，而唤醒调度器调用 xTaskResumeAll()。千万不要在调度器挂起时调用其它 API 函数。</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超详细的FreeRTOS移植全教程——基于srm32</title>
      <link href="/freertos-8/"/>
      <url>/freertos-8/</url>
      
        <content type="html"><![CDATA[<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>在移植之前，我们首先要获取到FreeRTOS的官方的源码包。这里我们提供两个下载链接:</p><blockquote><p>一个是官网：<a href="http://www.freertos.org/" target="_blank" rel="noopener">http://www.freertos.org/</a><br>另外一个是代码托管网站：<a href="https://sourceforge.net/projects/freertos/files/FreeRTOS/" target="_blank" rel="noopener">https://sourceforge.net/projects/freertos/files/FreeRTOS/</a></p></blockquote><p>这里我们演示如何在代码托管网站里面下载。打开网站链接之后，我们选择FreeRTOS的最新版本V9.0.0（2016年），尽管现在FreeRTOS的版本已经更新到V10.0.1了，但是我们还是选择V9.0.0，因为内核很稳定，并且网上资料很多，因为V10.0.0版本之后是亚马逊收购了FreeRTOS之后才出来的版本，主要添加了一些云端组件，我们本书所讲的FreeRTOS是实时内核，采用V9.0.0版本足以。</p><h3 id="简单介绍FreeRTOS"><a href="#简单介绍FreeRTOS" class="headerlink" title="简单介绍FreeRTOS"></a>简单介绍FreeRTOS</h3><p>FreeRTOS包含Demo例程和内核源码（比较重要，我们就需要提取该目录下的大部分文件）。<br> <strong>Source</strong>文件夹里面包含的是FreeRTOS内核的源代码，我们移植FreeRTOS的时候就需要这部分源代码；<br><strong>Demo</strong> 文件夹里面包含了FreeRTOS官方为各个单片机移植好的工程代码，FreeRTOS为了推广自己，会给各种半导体厂商的评估板写好完整的工程程序，这些程序就放在Demo这个目录下，这部分Demo非常有参考价值。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190130131602356.png" alt=""></p><h3 id="Source文件夹"><a href="#Source文件夹" class="headerlink" title="Source文件夹"></a>Source文件夹</h3><p>这里我们再重点分析下FreeRTOS/ Source文件夹下的文件，①和③包含的是FreeRTOS的通用的头文件和C文件，这两部分的文件试用于各种编译器和处理器，是通用的。需要移植的头文件和C文件放在②portblle这个文件夹。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190130131521162.png" alt=""></p><p>portblle文件夹，是与编译器相关的文件夹，在不同的编译器中使用不同的支持文件。①中的KEIL就是我们就是我们使用的编译器，其实KEIL里面的内容跟RVDS里面的内容一样，所以我们只需要③RVDS文件夹里面的内容即可，里面包含了各种处理器相关的文件夹，从文件夹的名字我们就非常熟悉了，我们学习的STM32有M0、M3、M4等各种系列，FreeRTOS是一个软件，单片机是一个硬件，FreeRTOS要想运行在一个单片机上面，它们就必须关联在一起。MemMang文件夹下存放的是跟内存管理相关的源文件。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190130131927278.png" alt=""></p><h3 id="移植过程"><a href="#移植过程" class="headerlink" title="移植过程"></a>移植过程</h3><h4 id="提取源码"><a href="#提取源码" class="headerlink" title="提取源码"></a>提取源码</h4><ol><li>首先在我们的STM32裸机工程模板根目录下新建一个文件夹，命名为“FreeRTOS”，并且在FreeRTOS文件夹下新建两个空文件夹，分别命名为“src”与“port”，src文件夹用于保存FreeRTOS中的核心源文件，也就是我们常说的‘.c文件’，port文件夹用于保存内存管理以及处理器架构相关代码，这些代码FreeRTOS官方已经提供给我们的，直接使用即可，在前面已经说了，FreeRTOS是软件，我们的开发版是硬件，软硬件必须有桥梁来连接，这些与处理器架构相关的代码，可以称之为RTOS硬件接口层，它们位于FreeRTOS/Source/Portable文件夹下。</li><li>打开FreeRTOS V9.0.0源码，在“FreeRTOSv9.0.0\FreeRTOS\Source”目录下找到所有的‘.c文件’，将它们拷贝到我们新建的src文件夹中，</li></ol><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190130133939483.png?" alt=""></p><ol start="3"><li>打开FreeRTOS V9.0.0源码，在“FreeRTOSv9.0.0\FreeRTOS\Source\portable”目录下找到“MemMang”文件夹与“RVDS”文件夹，将它们拷贝到我们新建的port文件夹中</li></ol><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190130134041761.png?" alt=""></p><ol start="4"><li>打开FreeRTOS V9.0.0源码，在“FreeRTOSv9.0.0\ FreeRTOS\Source”目录下找到“include”文件夹，它是我们需要用到FreeRTOS的一些头文件，将它直接拷贝到我们新建的FreeRTOS文件夹中，完成这一步之后就可以看到我们新建的FreeRTOS文件夹已经有3个文件夹，这3个文件夹就包含FreeRTOS的核心文件，至此，FreeRTOS的源码就提取完成。</li></ol><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190130134127226.png" alt=""></p><h4 id="添加到工程"><a href="#添加到工程" class="headerlink" title="添加到工程"></a>添加到工程</h4><p><strong>添加FreeRTOSConfig.h文件</strong><br>FreeRTOSConfig.h文件是FreeRTOS的工程配置文件，因为FreeRTOS是可以裁剪的实时操作内核，应用于不同的处理器平台，用户可以通过修改这个FreeRTOS内核的配置头文件来裁剪FreeRTOS的功能，所以我们把它拷贝一份放在user这个文件夹下面。<br>打开FreeRTOSv9.0.0源码，在“FreeRTOSv9.0.0\FreeRTOS\Demo”文件夹下面找到“CORTEX_STM32F103_Keil”这个文件夹，双击打开，在其根目录下找到这个“FreeRTOSConfig.h”文件，然后拷贝到我们工程的user文件夹下即可，等下我们需要对这个文件进行修改。</p><p><strong>创建工程分组</strong><br>接下来我们在mdk里面新建FreeRTOS/src和FreeRTOS/port两个组文件夹，其中FreeRTOS/src用于存放src文件夹的内容，FreeRTOS/port用于存放port\MemMang文件夹 与port\RVDS\ARM_CM3文件夹的内容。<br>然后我们将工程文件中FreeRTOS的内容添加到工程中去，按照已经新建的分组添加我们的FreeRTOS工程源码。<br>在FreeRTOS/port分组中添加MemMang文件夹中的文件只需选择其中一个即可，我们选择“heap_4.c”，这是FreeRTOS的一个内存管理源码文件。<br>添加完成后：</p><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190130134709392.png" alt=""></p><p>** 添加头文件路径**<br>FreeRTOS的源码已经添加到开发环境的组文件夹下面，编译的时候需要为这些源文件指定头文件的路径，不然编译会报错。FreeRTOS的源码里面只有FreeRTOS\include和FreeRTOS\port\RVDS\ARM_CM3这两个文件夹下面有头文件，只需要将这两个头文件的路径在开发环境里面指定即可。同时我们还将FreeRTOSConfig.h这个头文件拷贝到了工程根目录下的user文件夹下，所以user的路径也要加到开发环境里面。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190130134822959.png?" alt=""></p><h3 id="修改FreeRTOSConfig-h"><a href="#修改FreeRTOSConfig-h" class="headerlink" title="修改FreeRTOSConfig.h"></a>修改FreeRTOSConfig.h</h3><p>FreeRTOSConfig.h是直接从demo文件夹下面拷贝过来的，该头文件对裁剪整个FreeRTOS所需的功能的宏均做了定义，有些宏定义被使能，有些宏定义被失能，一开始我们只需要配置最简单的功能即可。要想随心所欲的配置FreeRTOS的功能，我们必须对这些宏定义的功能有所掌握，下面我们先简单的介绍下这些宏定义的含义，然后再对这些宏定义进行修改。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">ifndef</span> FREERTOS_CONFIG_H</span><span class="token macro property">#<span class="token directive keyword">define</span> FREERTOS_CONFIG_H</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"bsp_usart.h"</span></span><span class="token comment" spellcheck="true">//针对不同的编译器调用不同的stdint.h文件</span><span class="token macro property">#<span class="token directive keyword">if</span> defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__)</span>    <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span>    <span class="token keyword">extern</span> uint32_t SystemCoreClock<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token comment" spellcheck="true">//断言</span><span class="token macro property">#<span class="token directive keyword">define</span> vAssertCalled(char,int) printf("Error:%s,%d\r\n",char,int)</span><span class="token macro property">#<span class="token directive keyword">define</span> configASSERT(x) if((x)==0) vAssertCalled(__FILE__,__LINE__)</span><span class="token comment" spellcheck="true">/************************************************************************ *               FreeRTOS基础配置配置选项  *********************************************************************/</span><span class="token comment" spellcheck="true">/* 置1：RTOS使用抢占式调度器；置0：RTOS使用协作式调度器（时间片） *  * 注：在多任务管理机制上，操作系统可以分为抢占式和协作式两种。 * 协作式操作系统是任务主动释放CPU后，切换到下一个任务。 * 任务切换的时机完全取决于正在运行的任务。 */</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_PREEMPTION                      1</span><span class="token comment" spellcheck="true">//1使能时间片调度(默认式使能的)</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_TIME_SLICING                    1        </span><span class="token comment" spellcheck="true">/* 某些运行FreeRTOS的硬件有两种方法选择下一个要执行的任务： * 通用方法和特定于硬件的方法（以下简称“特殊方法”）。 *  * 通用方法： *      1.configUSE_PORT_OPTIMISED_TASK_SELECTION 为 0 或者硬件不支持这种特殊方法。 *      2.可以用于所有FreeRTOS支持的硬件 *      3.完全用C实现，效率略低于特殊方法。 *      4.不强制要求限制最大可用优先级数目 * 特殊方法： *      1.必须将configUSE_PORT_OPTIMISED_TASK_SELECTION设置为1。 *      2.依赖一个或多个特定架构的汇编指令（一般是类似计算前导零[CLZ]指令）。 *      3.比通用方法更高效 *      4.一般强制限定最大可用优先级数目为32 * 一般是硬件计算前导零指令，如果所使用的，MCU没有这些硬件指令的话此宏应该设置为0！ */</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_PORT_OPTIMISED_TASK_SELECTION            1                       </span><span class="token comment" spellcheck="true">/* 置1：使能低功耗tickless模式；置0：保持系统节拍（tick）中断一直运行 * 假设开启低功耗的话可能会导致下载出现问题，因为程序在睡眠中,可用以下办法解决 *  * 下载方法： *      1.将开发版正常连接好 *      2.按住复位按键，点击下载瞬间松开复位按键 *      *      1.通过跳线帽将 BOOT 0 接高电平(3.3V) *      2.重新上电，下载 *     *             1.使用FlyMcu擦除一下芯片，然后进行下载 *            STMISP -> 清除芯片(z) */</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_TICKLESS_IDLE                                                    0   </span><span class="token comment" spellcheck="true">/* * 写入实际的CPU内核时钟频率，也就是CPU指令执行频率，通常称为Fclk * Fclk为供给CPU内核的时钟信号，我们所说的cpu主频为 XX MHz， * 就是指的这个时钟信号，相应的，1/Fclk即为cpu时钟周期； */</span><span class="token macro property">#<span class="token directive keyword">define</span> configCPU_CLOCK_HZ                          (SystemCoreClock)</span><span class="token comment" spellcheck="true">//RTOS系统节拍中断的频率。即一秒中断的次数，每次中断RTOS都会进行任务调度</span><span class="token macro property">#<span class="token directive keyword">define</span> configTICK_RATE_HZ                          (( TickType_t )1000)</span><span class="token comment" spellcheck="true">//可使用的最大优先级</span><span class="token macro property">#<span class="token directive keyword">define</span> configMAX_PRIORITIES                      (32)</span><span class="token comment" spellcheck="true">//空闲任务使用的堆栈大小</span><span class="token macro property">#<span class="token directive keyword">define</span> configMINIMAL_STACK_SIZE                ((unsigned short)128)</span><span class="token comment" spellcheck="true">//任务名字字符串长度</span><span class="token macro property">#<span class="token directive keyword">define</span> configMAX_TASK_NAME_LEN                    (16)</span> <span class="token comment" spellcheck="true">//系统节拍计数器变量数据类型，1表示为16位无符号整形，0表示为32位无符号整形</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_16_BIT_TICKS                    0                      </span><span class="token comment" spellcheck="true">//空闲任务放弃CPU使用权给其他同优先级的用户任务</span><span class="token macro property">#<span class="token directive keyword">define</span> configIDLE_SHOULD_YIELD                    1           </span><span class="token comment" spellcheck="true">//启用队列</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_QUEUE_SETS                      1    </span><span class="token comment" spellcheck="true">//开启任务通知功能，默认开启</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_TASK_NOTIFICATIONS    1   </span><span class="token comment" spellcheck="true">//使用互斥信号量</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_MUTEXES                            1    </span><span class="token comment" spellcheck="true">//使用递归互斥信号量                                            </span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_RECURSIVE_MUTEXES            1   </span><span class="token comment" spellcheck="true">//为1时使用计数信号量</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_COUNTING_SEMAPHORES        1</span><span class="token comment" spellcheck="true">/* 设置可以注册的信号量和消息队列个数 */</span><span class="token macro property">#<span class="token directive keyword">define</span> configQUEUE_REGISTRY_SIZE                10                                 </span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_APPLICATION_TASK_TAG          0                       </span><span class="token comment" spellcheck="true">/*****************************************************************              FreeRTOS与内存申请有关配置选项                                               *****************************************************************/</span><span class="token comment" spellcheck="true">//支持动态内存申请</span><span class="token macro property">#<span class="token directive keyword">define</span> configSUPPORT_DYNAMIC_ALLOCATION        1    </span><span class="token comment" spellcheck="true">//支持静态内存</span><span class="token macro property">#<span class="token directive keyword">define</span> configSUPPORT_STATIC_ALLOCATION                    0                    </span><span class="token comment" spellcheck="true">//系统所有总的堆大小</span><span class="token macro property">#<span class="token directive keyword">define</span> configTOTAL_HEAP_SIZE                    ((size_t)(36*1024))    </span><span class="token comment" spellcheck="true">/***************************************************************             FreeRTOS与钩子函数有关的配置选项                                            **************************************************************/</span><span class="token comment" spellcheck="true">/* 置1：使用空闲钩子（Idle Hook类似于回调函数）；置0：忽略空闲钩子 *  * 空闲任务钩子是一个函数，这个函数由用户来实现， * FreeRTOS规定了函数的名字和参数：void vApplicationIdleHook(void )， * 这个函数在每个空闲任务周期都会被调用 * 对于已经删除的RTOS任务，空闲任务可以释放分配给它们的堆栈内存。 * 因此必须保证空闲任务可以被CPU执行 * 使用空闲钩子函数设置CPU进入省电模式是很常见的 * 不可以调用会引起空闲任务阻塞的API函数 */</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_IDLE_HOOK                        0      </span><span class="token comment" spellcheck="true">/* 置1：使用时间片钩子（Tick Hook）；置0：忽略时间片钩子 *  *  * 时间片钩子是一个函数，这个函数由用户来实现， * FreeRTOS规定了函数的名字和参数：void vApplicationTickHook(void ) * 时间片中断可以周期性的调用 * 函数必须非常短小，不能大量使用堆栈， * 不能调用以”FromISR" 或 "FROM_ISR”结尾的API函数 */</span> <span class="token comment" spellcheck="true">/*xTaskIncrementTick函数是在xPortSysTickHandler中断函数中被调用的。因此，vApplicationTickHook()函数执行的时间必须很短才行*/</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_TICK_HOOK                        0           </span><span class="token comment" spellcheck="true">//使用内存申请失败钩子函数</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_MALLOC_FAILED_HOOK            0 </span><span class="token comment" spellcheck="true">/* * 大于0时启用堆栈溢出检测功能，如果使用此功能  * 用户必须提供一个栈溢出钩子函数，如果使用的话 * 此值可以为1或者2，因为有两种栈溢出检测方法 */</span><span class="token macro property">#<span class="token directive keyword">define</span> configCHECK_FOR_STACK_OVERFLOW            0   </span><span class="token comment" spellcheck="true">/********************************************************************          FreeRTOS与运行时间和任务状态收集有关的配置选项   **********************************************************************/</span><span class="token comment" spellcheck="true">//启用运行时间统计功能</span><span class="token macro property">#<span class="token directive keyword">define</span> configGENERATE_RUN_TIME_STATS            0             </span> <span class="token comment" spellcheck="true">//启用可视化跟踪调试</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_TRACE_FACILITY                      0    </span><span class="token comment" spellcheck="true">/* 与宏configUSE_TRACE_FACILITY同时为1时会编译下面3个函数 * prvWriteNameToBuffer() * vTaskList(), * vTaskGetRunTimeStats()*/</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_STATS_FORMATTING_FUNCTIONS    1                       </span><span class="token comment" spellcheck="true">/********************************************************************                FreeRTOS与协程有关的配置选项                                                *********************************************************************/</span><span class="token comment" spellcheck="true">//启用协程，启用协程以后必须添加文件croutine.c</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_CO_ROUTINES                       0                 </span><span class="token comment" spellcheck="true">//协程的有效优先级数目</span><span class="token macro property">#<span class="token directive keyword">define</span> configMAX_CO_ROUTINE_PRIORITIES       ( 2 )                   </span><span class="token comment" spellcheck="true">/***********************************************************************                FreeRTOS与软件定时器有关的配置选项      **********************************************************************/</span> <span class="token comment" spellcheck="true">//启用软件定时器</span><span class="token macro property">#<span class="token directive keyword">define</span> configUSE_TIMERS                            1                              </span><span class="token comment" spellcheck="true">//软件定时器优先级</span><span class="token macro property">#<span class="token directive keyword">define</span> configTIMER_TASK_PRIORITY                (configMAX_PRIORITIES-1)        </span><span class="token comment" spellcheck="true">//软件定时器队列长度</span><span class="token macro property">#<span class="token directive keyword">define</span> configTIMER_QUEUE_LENGTH                10                               </span><span class="token comment" spellcheck="true">//软件定时器任务堆栈大小</span><span class="token macro property">#<span class="token directive keyword">define</span> configTIMER_TASK_STACK_DEPTH          (configMINIMAL_STACK_SIZE*2)    </span><span class="token comment" spellcheck="true">/************************************************************            FreeRTOS可选函数配置选项                                                     ************************************************************/</span><span class="token macro property">#<span class="token directive keyword">define</span> INCLUDE_xTaskGetSchedulerState       1                       </span><span class="token macro property">#<span class="token directive keyword">define</span> INCLUDE_vTaskPrioritySet                 1</span><span class="token macro property">#<span class="token directive keyword">define</span> INCLUDE_uxTaskPriorityGet                 1</span><span class="token macro property">#<span class="token directive keyword">define</span> INCLUDE_vTaskDelete                           1</span><span class="token macro property">#<span class="token directive keyword">define</span> INCLUDE_vTaskCleanUpResources           1</span><span class="token macro property">#<span class="token directive keyword">define</span> INCLUDE_vTaskSuspend                       1</span><span class="token macro property">#<span class="token directive keyword">define</span> INCLUDE_vTaskDelayUntil                     1</span><span class="token macro property">#<span class="token directive keyword">define</span> INCLUDE_vTaskDelay                           1</span><span class="token macro property">#<span class="token directive keyword">define</span> INCLUDE_eTaskGetState                       1</span><span class="token macro property">#<span class="token directive keyword">define</span> INCLUDE_xTimerPendFunctionCall         1</span><span class="token comment" spellcheck="true">//#define INCLUDE_xTaskGetCurrentTaskHandle       1</span><span class="token comment" spellcheck="true">//#define INCLUDE_uxTaskGetStackHighWaterMark     0</span><span class="token comment" spellcheck="true">//#define INCLUDE_xTaskGetIdleTaskHandle          0</span><span class="token comment" spellcheck="true">/******************************************************************            FreeRTOS与中断有关的配置选项                                                 ******************************************************************/</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> __NVIC_PRIO_BITS</span>    <span class="token macro property">#<span class="token directive keyword">define</span> configPRIO_BITS               __NVIC_PRIO_BITS</span><span class="token macro property">#<span class="token directive keyword">else</span></span>    <span class="token macro property">#<span class="token directive keyword">define</span> configPRIO_BITS               4                  </span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token comment" spellcheck="true">//中断最低优先级</span><span class="token macro property">#<span class="token directive keyword">define</span> configLIBRARY_LOWEST_INTERRUPT_PRIORITY            15     </span><span class="token comment" spellcheck="true">//系统可管理的最高中断优先级</span><span class="token macro property">#<span class="token directive keyword">define</span> configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY    5 </span><span class="token macro property">#<span class="token directive keyword">define</span> configKERNEL_INTERRUPT_PRIORITY         ( configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )    </span><span class="token comment" spellcheck="true">/* 240 */</span><span class="token macro property">#<span class="token directive keyword">define</span> configMAX_SYSCALL_INTERRUPT_PRIORITY     ( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )</span><span class="token comment" spellcheck="true">/****************************************************************            FreeRTOS与中断服务函数有关的配置选项                         ****************************************************************/</span><span class="token macro property">#<span class="token directive keyword">define</span> xPortPendSVHandler     PendSV_Handler</span><span class="token macro property">#<span class="token directive keyword">define</span> vPortSVCHandler     SVC_Handler</span><span class="token comment" spellcheck="true">/* 以下为使用Percepio Tracealyzer需要的东西，不需要时将 configUSE_TRACE_FACILITY 定义为 0 */</span><span class="token macro property">#<span class="token directive keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"trcRecorder.h"</span></span><span class="token macro property">#<span class="token directive keyword">define</span> INCLUDE_xTaskGetCurrentTaskHandle               1   </span><span class="token comment" spellcheck="true">// 启用一个可选函数（该函数被 Trace源码使用，默认该值为0 表示不用）</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">/* FREERTOS_CONFIG_H */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改stm32f10x-it-c"><a href="#修改stm32f10x-it-c" class="headerlink" title="修改stm32f10x_it.c"></a>修改stm32f10x_it.c</h3><p>SysTick中断服务函数是一个非常重要的函数，FreeRTOS所有跟时间相关的事情都在里面处理，SysTick就是FreeRTOS的一个心跳时钟，驱动着FreeRTOS的运行，就像人的心跳一样，假如没有心跳，我们就相当于“死了”，同样的，FreeRTOS没有了心跳，那么它就会卡死在某个地方，不能进行任务调度，不能运行任何的东西，因此我们需要实现一个FreeRTOS的心跳时钟，FreeRTOS帮我们实现了SysTick的启动的配置：在port.c文件中已经实现vPortSetupTimerInterrupt()函数，并且FreeRTOS通用的SysTick中断服务函数也实现了：在port.c文件中已经实现xPortSysTickHandler()函数，所以移植的时候只需要我们在stm32f10x_it.c文件中实现我们对应（STM32）平台上的SysTick_Handler()函数即可。FreeRTOS为开发者考虑得特别多，PendSV_Handler()与SVC_Handler()这两个很重要的函数都帮我们实现了，在在port.c文件中已经实现xPortPendSVHandler()与vPortSVCHandler()函数，防止我们自己实现不了，那么在stm32f10x_it.c中就需要我们注释掉PendSV_Handler()与SVC_Handler()这两个函数了。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//void SVC_Handler(void)</span><span class="token comment" spellcheck="true">//{</span><span class="token comment" spellcheck="true">//}</span><span class="token comment" spellcheck="true">//void PendSV_Handler(void)</span><span class="token comment" spellcheck="true">//{</span><span class="token comment" spellcheck="true">//}</span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">xPortSysTickHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//systick中断服务函数</span><span class="token keyword">void</span> <span class="token function">SysTick_Handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token macro property">#<span class="token directive keyword">if</span> (INCLUDE_xTaskGetSchedulerState  == 1 )</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">xTaskGetSchedulerState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> taskSCHEDULER_NOT_STARTED<span class="token punctuation">)</span>      <span class="token punctuation">{</span>    <span class="token macro property">#<span class="token directive keyword">endif</span>  </span><span class="token comment" spellcheck="true">/* INCLUDE_xTaskGetSchedulerState */</span>          <span class="token function">xPortSysTickHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">#<span class="token directive keyword">if</span> (INCLUDE_xTaskGetSchedulerState  == 1 )</span>      <span class="token punctuation">}</span>    <span class="token macro property">#<span class="token directive keyword">endif</span>  </span><span class="token comment" spellcheck="true">/* INCLUDE_xTaskGetSchedulerState */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h3><p>这里，我们创建一个单任务，任务使用的栈和任务控制块是在创建任务的时候FreeRTOS动态分配的。<br>任务必须是一个死循环，否则任务将通过LR返回，如果LR指向了非法的内存就会产生HardFault_Handler，而FreeRTOS指向一个死循环，那么任务返回之后就在死循环中执行，这样子的任务是不安全的，所以避免这种情况，任务一般都是死循环并且无返回值的。<br><strong>并且每个任务循环主体中应该有阻塞任务的函数，否则就会饿死比它优先级更低的任务！！！</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* FreeRTOS头文件 */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"FreeRTOS.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"task.h"</span></span><span class="token comment" spellcheck="true">/* 开发板硬件bsp头文件 */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"bsp_led.h"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">AppTaskCreate</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* AppTask任务 */</span> <span class="token comment" spellcheck="true">/* 创建任务句柄 */</span><span class="token keyword">static</span> TaskHandle_t AppTask_Handle <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      BaseType_t xReturn <span class="token operator">=</span> pdPASS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 定义一个创建信息返回值，默认为pdPASS */</span>  <span class="token comment" spellcheck="true">/* 开发板硬件初始化 */</span>  <span class="token function">BSP_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 创建AppTaskCreate任务 */</span>  xReturn <span class="token operator">=</span> <span class="token function">xTaskCreate</span><span class="token punctuation">(</span><span class="token punctuation">(</span>TaskFunction_t <span class="token punctuation">)</span>AppTask<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">/* 任务入口函数 */</span>                        <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span>    <span class="token punctuation">)</span><span class="token string">"AppTask"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">/* 任务名字 */</span>                        <span class="token punctuation">(</span>uint16_t       <span class="token punctuation">)</span><span class="token number">512</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">/* 任务栈大小 */</span>                        <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span>          <span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">/* 任务入口函数参数 */</span>                        <span class="token punctuation">(</span>UBaseType_t    <span class="token punctuation">)</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* 任务的优先级 */</span>                        <span class="token punctuation">(</span>TaskHandle_t<span class="token operator">*</span>  <span class="token punctuation">)</span><span class="token operator">&amp;</span>AppTask_Handle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 任务控制块指针 */</span>   <span class="token comment" spellcheck="true">/* 启动任务调度 */</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>pdPASS <span class="token operator">==</span> xReturn<span class="token punctuation">)</span>    <span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 启动任务，开启调度 */</span>  <span class="token keyword">else</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 正常不会执行到这里 */</span>    <span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">AppTask</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> parameter<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        LED1_ON<span class="token punctuation">;</span>        <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 延时500个tick */</span>        LED1_OFF<span class="token punctuation">;</span>             <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 延时500个tick */</span>                     <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从单片机到操作系统⑦——深入了解FreeRTOS的延时机制</title>
      <link href="/freertos-7/"/>
      <url>/freertos-7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>没研究过操作系统的源码都不算学过操作系统</p></blockquote><h1 id="FreeRTOS-时间管理"><a href="#FreeRTOS-时间管理" class="headerlink" title="FreeRTOS 时间管理"></a>FreeRTOS 时间管理</h1><p>时间管理包括两个方面：系统节拍以及任务延时管理。</p><h2 id="系统节拍："><a href="#系统节拍：" class="headerlink" title="系统节拍："></a>系统节拍：</h2><p>在前面的文章也讲得很多，想要系统正常运行，那么时钟节拍是必不可少的，<code>FreeRTOS</code>的时钟节拍通常由<code>SysTick</code>提供，它周期性的产生定时中断，所谓的时钟节拍管理的核心就是这个定时中断的服务程序。<code>FreeRTOS</code>的时钟节拍isr中核心的工作就是调用<code>vTaskIncrementTick()</code>函数。具体见上之前的文章。</p><h2 id="延时管理"><a href="#延时管理" class="headerlink" title="延时管理"></a>延时管理</h2><p>FreeRTOS提供了两个系统延时函数：</p><ul><li>相对延时函数<code>vTaskDelay()</code></li><li>绝对延时函数<code>vTaskDelayUntil()</code>。</li></ul><p>这些延时函数可不像我们以前用裸机写代码的延时函数操作系统不允许CPU在死等消耗着时间，因为这样效率太低了。</p><p>同时，要告诫学操作系统的同学，千万别用裸机的思想去学操作系统。</p><h2 id="任务延时"><a href="#任务延时" class="headerlink" title="任务延时"></a>任务延时</h2><p>任务可能需要延时，两种情况，一种是任务被<code>vTaskDelay</code>或者<code>vTaskDelayUntil</code>延时，另外一种情况就是任务等待事件（比如等待某个信号量、或者某个消息队列）时候指定了<code>timeout</code>（即最多等待timeout时间，如果等待的事件还没发生，则不再继续等待），在每个任务的循环中都必须要有阻塞的情况出现，否则比该任务优先级低的任务就永远无法运行。</p><h2 id="相对延时与绝对延时的区别"><a href="#相对延时与绝对延时的区别" class="headerlink" title="相对延时与绝对延时的区别"></a>相对延时与绝对延时的区别</h2><p><strong>相对延时：vTaskDelay()：</strong></p><p>相对延时是指每次延时都是从任务执行函数<code>vTaskDelay()</code>开始，延时指定的时间结束</p><p><strong>绝对延时：vTaskDelayUntil()：</strong></p><p>绝对延时是指调用<code>vTaskDelayUntil()</code>的任务每隔x时间运行一次。也就是任务周期运行。</p><p><strong>相对延时：vTaskDelay()</strong></p><p>相对延时<code>vTaskDelay()</code>是从调用<code>vTaskDelay()</code>这个函数的时候开始延时，但是任务执行的时候，可能发生了中断，导致任务执行时间变长了，但是整个任务的延时时间还是1000个tick，这就不是周期性了，简单看看下面代码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vTaskA</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> pvParameters <span class="token punctuation">)</span>   <span class="token punctuation">{</span>      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">//  ...</span>         <span class="token comment" spellcheck="true">//  这里为任务主体代码</span>         <span class="token comment" spellcheck="true">//  ...</span>         <span class="token comment" spellcheck="true">/* 调用相对延时函数,阻塞1000个tick */</span>         <span class="token function">vTaskDelay</span><span class="token punctuation">(</span> <span class="token number">1000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可能说的不够明确，可以看看图解。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos-delay-1.png" alt="freertos-delay-1"></p><p>当任务运行的时候，假设被某个高级任务或者是中断打断了，那么任务的执行时间就更长了，然而延时还是延时<code>1000</code>个<code>tick</code>这样子，整个系统的时间就混乱了。</p><p>如果还不够明确，看看vTaskDelay()的源码</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vTaskDelay</span><span class="token punctuation">(</span> <span class="token keyword">const</span> TickType_t xTicksToDelay <span class="token punctuation">)</span><span class="token punctuation">{</span>    BaseType_t xAlreadyYielded <span class="token operator">=</span> pdFALSE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 延迟时间为零只会强制切换任务。 */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> xTicksToDelay <span class="token operator">></span> <span class="token punctuation">(</span> TickType_t <span class="token punctuation">)</span> 0U <span class="token punctuation">)</span>        <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">configASSERT</span><span class="token punctuation">(</span> uxSchedulerSuspended <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">vTaskSuspendAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">traceTASK_DELAY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/*将当前任务从就绪列表中移除,并根据当前系统节拍            计数器值计算唤醒时间,然后将任务加入延时列表 */</span>            <span class="token function">prvAddCurrentTaskToDelayedList</span><span class="token punctuation">(</span> xTicksToDelay<span class="token punctuation">,</span> pdFALSE <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        xAlreadyYielded <span class="token operator">=</span> <span class="token function">xTaskResumeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* 强制执行一次上下文切换 */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> xAlreadyYielded <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">portYIELD_WITHIN_API</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>(1):如果传递进来的延时时间是<code>0</code>，只能进行强制切换任务了，调用的是<code>portYIELD_WITHIN_API()</code>，它其实是一个宏，真正起作用的是<code>portYIELD()</code>，下面是它的源码：</li></ul><pre class="line-numbers language-js"><code class="language-js">#define <span class="token function">portYIELD</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                                \<span class="token punctuation">{</span>                                                                \    <span class="token comment" spellcheck="true">/* 设置PendSV以请求上下文切换。 */</span>                            \    portNVIC_INT_CTRL_REG <span class="token operator">=</span> portNVIC_PENDSVSET_BIT<span class="token punctuation">;</span>                \    <span class="token function">__dsb</span><span class="token punctuation">(</span> portSY_FULL_READ_WRITE <span class="token punctuation">)</span><span class="token punctuation">;</span>                            \    <span class="token function">__isb</span><span class="token punctuation">(</span> portSY_FULL_READ_WRITE <span class="token punctuation">)</span><span class="token punctuation">;</span>                            \<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>(2):挂起当前任务</li></ul><p>然后将当前任务从就绪列表删除，然后加入到延时列表。是调用函数<code>prvAddCurrentTaskToDelayedList()</code>完成这一过程的。由于这个函数篇幅过长，就不讲解了，有兴趣可以看看，我就简单说说过程。在<code>FreeRTOS</code>中有这么一个变量，是用来记录<code>systick</code>的值的。</p><pre class="line-numbers language-js"><code class="language-js">PRIVILEGED_DATA <span class="token keyword">static</span> volatile TickType_t xTickCount     <span class="token operator">=</span> <span class="token punctuation">(</span> TickType_t <span class="token punctuation">)</span> 0U<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在每次<code>tick</code>中断时<code>xTickCount</code>加一，它的值表示了系统节拍中断的次数，那么啥时候唤醒被加入延时列表的任务呢？其实很简单，FreeRTOS的做法将<code>xTickCount</code>(当前系统时间) + <code>xTicksToDelay</code>(要延时的时间)即可。当这个相对的延时时间到了之后就唤醒了，这个<code>(xTickCount+ xTicksToDelay)</code>时间会被记录在该任务的任务控制块中。</p><p>看到这肯定有人问，这个变量是<code>TickType_t</code>类型(32位)的，那肯定会溢出啊，没错，是变量都会有溢出的一天，可是<code>FreeRTOS</code>乃是世界第一的操作系统啊，<code>FreeRTOS</code>使用了两个延时列表：</p><p><code>xDelayedTaskList1 和 xDelayedTaskList2</code></p><p>并使用两个列表指针类型变量<code>pxDelayedTaskList</code>和<code>pxOverflowDelayedTaskList</code>分别指向上面的延时列表1和延时列表2（在创建任务时将延时列表指针指向延时列表）如果内核判断出<code>xTickCount+xTicksToDelay</code>溢出，就将当前任务挂接到列表指针 <code>pxOverflowDelayedTaskList</code>指向的列表中，否则就挂接到列表指针<code>pxDelayedTaskList</code>指向的列表中。当时间到了，就会将延时的任务从延时列表中删除，加入就绪列表中，当然这时候就是由调度器觉得任务能不能运行了，如果任务的优先级大于当前运行的任务，那么调度器才会进行任务的调度。</p><p><strong>绝对延时：vTaskDelayUntil()</strong></p><p><code>vTaskDelayUntil()</code>的参数指定了确切的滴答计数值</p><p>调用<code>vTaskDelayUntil()</code>是希望任务以固定频率定期执行，而不受外部的影响，任务从上一次运行开始到下一次运行开始的时间间隔是绝对的，而不是相对的。假设主体任务被打断<code>0.3s</code>，但是下次唤醒的时间是固定的，所以还是会周期运行。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos-delay-2.png" alt="freertos-delay-2"></p><p>下面看看<code>vTaskDelayUntil()</code>的使用方法，注意了，这<code>vTaskDelayUntil()</code>的使用方法与<code>vTaskDelay()</code>不一样：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vTaskA</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> pvParameters <span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/* 用于保存上次时间。调用后系统自动更新 */</span>    <span class="token keyword">static</span> portTickType PreviousWakeTime<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 设置延时时间，将时间转为节拍数 */</span>    <span class="token keyword">const</span> portTickType TimeIncrement <span class="token operator">=</span> <span class="token function">pdMS_TO_TICKS</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 获取当前系统时间 */</span>    PreviousWakeTime <span class="token operator">=</span> <span class="token function">xTaskGetTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">/* 调用绝对延时函数,任务时间间隔为1000个tick */</span>         <span class="token function">vTaskDelayUntil</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>PreviousWakeTime，TimeIncrement <span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//  ...</span>         <span class="token comment" spellcheck="true">//  这里为任务主体代码</span>         <span class="token comment" spellcheck="true">//  ...</span>     <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在使用的时候要将延时时间转化为系统节拍，在任务主体之前要调用延时函数。</p><p>任务会先调用<code>vTaskDelayUntil()</code>使任务进入阻塞态，等到时间到了就从阻塞中解除，然后执行主体代码，任务主体代码执行完毕。会继续调用<code>vTaskDelayUntil()</code>使任务进入阻塞态，然后就是循环这样子执行。即使任务在执行过程中发生中断，那么也不会影响这个任务的运行周期，仅仅是缩短了阻塞的时间而已。</p><p>下面来看看<code>vTaskDelayUntil()</code>的源码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vTaskDelayUntil</span><span class="token punctuation">(</span> TickType_t <span class="token operator">*</span> <span class="token keyword">const</span> pxPreviousWakeTime<span class="token punctuation">,</span> <span class="token keyword">const</span> TickType_t xTimeIncrement <span class="token punctuation">)</span><span class="token punctuation">{</span>    TickType_t xTimeToWake<span class="token punctuation">;</span>    BaseType_t xAlreadyYielded<span class="token punctuation">,</span> xShouldDelay <span class="token operator">=</span> pdFALSE<span class="token punctuation">;</span>    <span class="token function">configASSERT</span><span class="token punctuation">(</span> pxPreviousWakeTime <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">configASSERT</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> xTimeIncrement <span class="token operator">></span> 0U <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">configASSERT</span><span class="token punctuation">(</span> uxSchedulerSuspended <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">vTaskSuspendAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                 <span class="token comment" spellcheck="true">// (1)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 保存系统节拍中断次数计数器 */</span>        <span class="token keyword">const</span> TickType_t xConstTickCount <span class="token operator">=</span> xTickCount<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 生成任务要唤醒的滴答时间。*/</span>        xTimeToWake <span class="token operator">=</span> <span class="token operator">*</span>pxPreviousWakeTime <span class="token operator">+</span> xTimeIncrement<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* pxPreviousWakeTime中保存的是上次唤醒时间,唤醒后需要一定时间执行任务主体代码,            如果上次唤醒时间大于当前时间,说明节拍计数器溢出了 具体见图片 */</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> xConstTickCount <span class="token operator">&lt;</span> <span class="token operator">*</span>pxPreviousWakeTime <span class="token punctuation">)</span>        <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">/* 由于此功能，滴答计数已溢出持续呼唤。 在这种情况下，我们唯一的时间实际延迟是如果唤醒时间也溢出，              唤醒时间大于滴答时间。 当这个就是这样，好像两个时间都没有溢出。*/</span>           <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> xTimeToWake <span class="token operator">&lt;</span> <span class="token operator">*</span>pxPreviousWakeTime <span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span> xTimeToWake <span class="token operator">></span> xConstTickCount <span class="token punctuation">)</span> <span class="token punctuation">)</span>           <span class="token punctuation">{</span>               xShouldDelay <span class="token operator">=</span> pdTRUE<span class="token punctuation">;</span>           <span class="token punctuation">}</span>           <span class="token keyword">else</span>           <span class="token punctuation">{</span>               <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">/* 滴答时间没有溢出。 在这种情况下，如果唤醒时间溢出，              或滴答时间小于唤醒时间，我们将延迟。*/</span>           <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> xTimeToWake <span class="token operator">&lt;</span> <span class="token operator">*</span>pxPreviousWakeTime <span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span> xTimeToWake <span class="token operator">></span> xConstTickCount <span class="token punctuation">)</span> <span class="token punctuation">)</span>           <span class="token punctuation">{</span>               xShouldDelay <span class="token operator">=</span> pdTRUE<span class="token punctuation">;</span>           <span class="token punctuation">}</span>           <span class="token keyword">else</span>           <span class="token punctuation">{</span>               <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">/* 更新唤醒时间,为下一次调用本函数做准备. */</span>      <span class="token operator">*</span>pxPreviousWakeTime <span class="token operator">=</span> xTimeToWake<span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span> xShouldDelay <span class="token operator">!=</span> pdFALSE <span class="token punctuation">)</span>      <span class="token punctuation">{</span>          <span class="token function">traceTASK_DELAY_UNTIL</span><span class="token punctuation">(</span> xTimeToWake <span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* prvAddCurrentTaskToDelayedList（）需要块时间，而不是唤醒时间，因此减去当前的滴答计数。 */</span>          <span class="token function">prvAddCurrentTaskToDelayedList</span><span class="token punctuation">(</span> xTimeToWake <span class="token operator">-</span> xConstTickCount<span class="token punctuation">,</span> pdFALSE <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">else</span>      <span class="token punctuation">{</span>          <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  xAlreadyYielded <span class="token operator">=</span> <span class="token function">xTaskResumeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 如果xTaskResumeAll尚未执行重新安排，我们可能会让自己入睡。*/</span>  <span class="token keyword">if</span><span class="token punctuation">(</span> xAlreadyYielded <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">portYIELD_WITHIN_API</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span>  <span class="token punctuation">{</span>    <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与相对延时函数<code>vTaskDelay</code>不同，本函数增加了一个参数<code>pxPreviousWakeTime</code>用于指向一个变量，变量保存上次任务解除阻塞的时间，此后函数<code>vTaskDelayUntil()</code>在内部自动更新这个变量。由于变量<code>xTickCount</code>可能会溢出，所以程序必须检测各种溢出情况，并且要保证延时周期不得小于任务主体代码执行时间。</p><p>就会有以下3种情况，才能将任务加入延时链表中。</p><p>请记住这几个单词的含义：</p><ul><li><code>xTimeIncrement</code>：任务周期时间</li><li><code>pxPreviousWakeTime</code>：上一次唤醒的时间点</li><li><code>xTimeToWake</code>：下一次唤醒的系统时间点</li><li><code>xConstTickCount</code>：进入延时的时间点</li></ul><ol start="3"><li>第三种情况：常规无溢出的情况。</li></ol><p>以时间为横轴，上一次唤醒的时间点小于下一次唤醒的时间点，这是很正常的情况。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos-delay-3.png" alt="freertos-delay-3"></p><ol start="2"><li>第二种情况：唤醒时间计数器（<code>xTimeToWake</code>）溢出情况。</li></ol><p>也就是代码中<code>if( ( xTimeToWake &lt; *pxPreviousWakeTime ) || ( xTimeToWake &gt; xConstTickCount ) )</code></p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos-delay-4.png" alt="freertos-delay-4"></p><ol><li>第一种情况：唤醒时间（<code>xTimeToWake</code>）与进入延时的时间点（<code>xConstTickCount</code>）都溢出情况。</li></ol><p>也就是代码中<code>if( ( xTimeToWake &lt; *pxPreviousWakeTime ) &amp;&amp; ( xTimeToWake &gt; xConstTickCount ) )</code></p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos-delay-5.png" alt="freertos-delay-5"></p><p>从图中可以看出不管是溢出还是无溢出，都要求在下次唤醒任务之前，当前任务主体代码必须被执行完。也就是说任务执行的时间不允许大于延时的时间，总不能存在每<code>10ms</code>就要执行一次<code>20ms</code>时间的任务吧。计算的唤醒时间合法后，就将当前任务加入延时列表，同样延时列表也有两个。每次系统节拍中断，中断服务函数都会检查这两个延时列表，查看延时的任务是否到期，如果时间到期，则将任务从延时列表中删除，重新加入就绪列表。如果新加入就绪列表的任务优先级大于当前任务，则会触发一次上下文切换。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果任务调用相对延时，其运行周期完全是不可测的，如果任务的优先级不是最高的话，其误差更大，就好比一个必须要在<code>5ms</code>内相应的任务，假如使用了相对延时1ms，那么很有可能在该任务执行的时候被更高优先级的任务打断，从而错过<code>5ms</code>内的相应，但是调用绝对延时，则任务会周期性将该任务在阻塞列表中解除，但是，任务能不能运行，还得取决于任务的优先级，如果优先级最高的话，任务周期还是比较精确的（相对<code>vTaskDelay</code>来说），如果想要更加想精确周期性执行某个任务，可以使用系统节拍钩子函数<code>vApplicationTickHook()</code>，它在<code>tick</code>中断服务函数中被调用，因此这个函数中的代码必须简洁，并且不允许出现阻塞的情况。</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0开始学FreeRTOS-(列表&amp;列表项)-6</title>
      <link href="/freertos-6/"/>
      <url>/freertos-6/</url>
      
        <content type="html"><![CDATA[<h1 id="FreeRTOS列表-amp-列表项的源码解读"><a href="#FreeRTOS列表-amp-列表项的源码解读" class="headerlink" title="FreeRTOS列表&amp;列表项的源码解读"></a>FreeRTOS列表&amp;列表项的源码解读</h1><p>第一次看列表与列表项的时候，感觉很像是链表，虽然我自己的链表也不太会，但是就是感觉很像。</p><p>在FreeRTOS中，列表与列表项使用得非常多，是FreeRTOS的一个数据结构，学习过数据结构的同学都知道，数据结构能使我们处理数据更加方便快速，能快速找到数据，在FreeRTOS中，这种列表与列表项更是必不可少的，能让我们的系统跑起来更加流畅迅速。</p><p>言归正传，FreeRTOS中使用了大量的列表（List）与列表项（Listitem），在FreeRTOS调度器中，就是用到这些来跟着任务，了解任务的状态，处于挂起、阻塞态、还是就绪态亦或者是运行态。这些信息都会在各自任务的列表中得到。</p><p>看任务控制块（tskTaskControlBlock）中的两个列表项：</p><pre class="line-numbers language-js"><code class="language-js">ListItem_t xStateListItem<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* &lt;任务的状态列表项目引用的列表表示该任务的状态（就绪，已阻止，暂停）。*/</span>ListItem_t xEventListItem<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* &lt;用于从事件列表中引用任务。*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>一个是状态的列表项，一个是事件列表项。他们在创建任务就会被初始化，列表项的初始化是根据实际需要来初始化的，下面会说。</p><h1 id="FreeRTOS列表-amp-列表项的结构体"><a href="#FreeRTOS列表-amp-列表项的结构体" class="headerlink" title="FreeRTOS列表&amp;列表项的结构体"></a>FreeRTOS列表&amp;列表项的结构体</h1><p>既然知道列表与列表项的重要性，那么我们来解读FreeRTOS中的list.c与list.h的源码吧。从头文件lsit.h开始，看到定义了一些结构体：</p><pre class="line-numbers language-js"><code class="language-js"> struct xLIST_ITEM<span class="token punctuation">{</span>    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE <span class="token comment" spellcheck="true">/* &lt;如果configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES设置为1，则设置为已知值。*/</span>    configLIST_VOLATILE TickType_t xItemValue<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* &lt;正在列出的值。在大多数情况下，这用于按降序对列表进行排序。 */</span>    struct xLIST_ITEM <span class="token operator">*</span> configLIST_VOLATILE pxNext<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* &lt;指向列表中下一个ListItem_t的指针。 */</span>    struct xLIST_ITEM <span class="token operator">*</span> configLIST_VOLATILE pxPrevious<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* &lt;指向列表中前一个ListItem_t的指针。 */</span>    <span class="token keyword">void</span> <span class="token operator">*</span> pvOwner<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* &lt;指向包含列表项目的对象（通常是TCB）的指针。因此，包含列表项目的对象与列表项目本身之间存在双向链接。 */</span>    <span class="token keyword">void</span> <span class="token operator">*</span> configLIST_VOLATILE pvContainer<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* &lt;指向此列表项目所在列表的指针（如果有）。 */</span>    listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE <span class="token comment" spellcheck="true">/* &lt;如果configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES设置为1，则设置为已知值。*/</span><span class="token punctuation">}</span><span class="token punctuation">;</span>typedef struct xLIST_ITEM ListItem_t<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 由于某种原因，lint希望将其作为两个单独的定义。 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>列表项结构体的一些注意的地方：</p><p><strong>xItemValue</strong> 用于列表项的排序，类似1—2—3—4</p><p><strong>pxNext</strong> 指向下一个列表项的指针<br><strong>pxPrevious</strong> 指向上（前）一个列表项的指针</p><p>这两个指针实现了类似双向链表的功能</p><p><strong>pvOwner</strong> 指向包含列表项目的对象（通常是任务控制块TCB）的指针。因此，包含列表项目的对象与列表项目本身之间存在双向链接。</p><p><strong>pvContainer</strong> 记录了该列表项属于哪个列表，说白点就是这个儿子是谁生的。。。</p><p>同时定义了一个MINI的列表项的结构体，MINI列表项是删减版的列表项，因为很多时候不需要完全版的列表项。就不用浪费那么多内存空间了，这或许就是FreeRTOS是轻量级操作系统的原因吧，能省一点是一点。MINI列表项：</p><pre class="line-numbers language-js"><code class="language-js">struct xMINI_LIST_ITEM<span class="token punctuation">{</span>    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE           <span class="token comment" spellcheck="true">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span>    configLIST_VOLATILE TickType_t xItemValue<span class="token punctuation">;</span>    struct xLIST_ITEM <span class="token operator">*</span> configLIST_VOLATILE pxNext<span class="token punctuation">;</span>    struct xLIST_ITEM <span class="token operator">*</span> configLIST_VOLATILE pxPrevious<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>typedef struct xMINI_LIST_ITEM MiniListItem_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再定义了一个列表的结构体，可能看到这里，一些同学已经蒙了，列表与列表项是啥关系啊，按照杰杰的理解，是类似父子关系的，一个列表中，包含多个列表项，就像一个父亲，生了好多孩子，而列表就是父亲，列表项就是孩子。</p><pre class="line-numbers language-js"><code class="language-js">typedef struct xLIST<span class="token punctuation">{</span>    listFIRST_LIST_INTEGRITY_CHECK_VALUE <span class="token comment" spellcheck="true">/* &lt;如果configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES设置为1，则设置为已知值。*/</span>    configLIST_VOLATILE UBaseType_t uxNumberOfItems<span class="token punctuation">;</span>    ListItem_t <span class="token operator">*</span> configLIST_VOLATILE pxIndex<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* &lt;用于遍历列表。 指向由listGET_OWNER_OF_NEXT_ENTRY（）调用返回的后一个列表项。*/</span>    MiniListItem_t xListEnd<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* &lt;List item包含最大可能的项目值，这意味着它始终在列表的末尾，因此用作标记。*/</span>    listSECOND_LIST_INTEGRITY_CHECK_VALUE <span class="token comment" spellcheck="true">/* &lt;如果configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES设置为1，则设置为已知值。*/</span><span class="token punctuation">}</span> List_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>列表的结构体中值得注意的是：<br><strong>uxNumberOfItems</strong> 是用来记录列表中列表项的数量的，就是记录父亲有多少个儿子，当然女儿也行~。</p><p><strong>pxIndex</strong> 是索引编号，用来遍历列表的，调用宏listGET_OWNER_OF_NEXT_ENTRY（）之后索引就会指向返回当前列表项的下一个列表项。</p><p><strong>xListEnd</strong> 指向的是最后一个列表项，并且这个列表项是MiniListItem属性的，是一个迷你列表项。</p><h1 id="列表的初始化"><a href="#列表的初始化" class="headerlink" title="列表的初始化"></a>列表的初始化</h1><p>函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vListInitialise</span><span class="token punctuation">(</span> List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxList <span class="token punctuation">)</span><span class="token punctuation">{</span>     pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">/*lint The mini list structure is used as the list end to save RAM.  This is checked and valid. */</span>     pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd<span class="token punctuation">.</span>xItemValue <span class="token operator">=</span> portMAX_DELAY<span class="token punctuation">;</span>     pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd<span class="token punctuation">.</span>pxNext <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/*lint The mini list structure is used as the list end to save RAM.  This is checked and valid. */</span>     pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd<span class="token punctuation">.</span>pxPrevious <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*lint The mini list structure is used as the list end to save RAM.  This is checked and valid. */</span>     pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token operator">=</span> <span class="token punctuation">(</span> UBaseType_t <span class="token punctuation">)</span> 0U<span class="token punctuation">;</span>     <span class="token function">listSET_LIST_INTEGRITY_CHECK_1_VALUE</span><span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">listSET_LIST_INTEGRITY_CHECK_2_VALUE</span><span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将列表的索引指向列表中的xListEnd，也就是末尾的列表项（迷你列表项）</p><p>列表项的xItemValue数值为portMAX_DELAY，也就是0xffffffffUL，如果在16位处理器中则为0xffff。</p><p>列表项的pxNext与pxPrevious这两个指针都指向自己本身xListEnd。</p><p>初始化完成的时候列表项的数目为0个。因为还没添加列表项嘛~。</p><p><img src="./images/loading.png" data-original="https://img-blog.csdn.net/20180609234203180" alt=""></p><h1 id="列表项的初始化"><a href="#列表项的初始化" class="headerlink" title="列表项的初始化"></a>列表项的初始化</h1><p>函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vListInitialiseItem</span><span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxItem <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* Make sure the list item is not recorded as being on a list. */</span>    pxItem<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> NULL<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Write known values into the list item if    configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span>    <span class="token function">listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE</span><span class="token punctuation">(</span> pxItem <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE</span><span class="token punctuation">(</span> pxItem <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只需要让列表项的<code>pvContainer</code>指针指向<code>NULL</code>即可，这样子就使得列表项不属于任何一个列表，因为列表项的初始化是要根据实际的情况来进行初始化的。</p><p>例如任务创建时用到的一些列表项初始化：</p><pre class="line-numbers language-js"><code class="language-js">pxNewTCB<span class="token operator">-</span><span class="token operator">></span>pcTaskName<span class="token punctuation">[</span> configMAX_TASK_NAME_LEN <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>pxNewTCB<span class="token operator">-</span><span class="token operator">></span>uxPriority <span class="token operator">=</span> uxPriority<span class="token punctuation">;</span>pxNewTCB<span class="token operator">-</span><span class="token operator">></span>uxBasePriority <span class="token operator">=</span> uxPriority<span class="token punctuation">;</span>pxNewTCB<span class="token operator">-</span><span class="token operator">></span>uxMutexesHeld <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">vListInitialiseItem</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxNewTCB<span class="token operator">-</span><span class="token operator">></span>xStateListItem <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">vListInitialiseItem</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxNewTCB<span class="token operator">-</span><span class="token operator">></span>xEventListItem <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 或者是在定时器相关的初始化中：</p><pre class="line-numbers language-js"><code class="language-js">pxNewTimer<span class="token operator">-</span><span class="token operator">></span>pcTimerName <span class="token operator">=</span> pcTimerName<span class="token punctuation">;</span>pxNewTimer<span class="token operator">-</span><span class="token operator">></span>xTimerPeriodInTicks <span class="token operator">=</span> xTimerPeriodInTicks<span class="token punctuation">;</span>pxNewTimer<span class="token operator">-</span><span class="token operator">></span>uxAutoReload <span class="token operator">=</span> uxAutoReload<span class="token punctuation">;</span>pxNewTimer<span class="token operator">-</span><span class="token operator">></span>pvTimerID <span class="token operator">=</span> pvTimerID<span class="token punctuation">;</span>pxNewTimer<span class="token operator">-</span><span class="token operator">></span>pxCallbackFunction <span class="token operator">=</span> pxCallbackFunction<span class="token punctuation">;</span><span class="token function">vListInitialiseItem</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxNewTimer<span class="token operator">-</span><span class="token operator">></span>xTimerListItem <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="列表项的末尾插入"><a href="#列表项的末尾插入" class="headerlink" title="列表项的末尾插入"></a>列表项的末尾插入</h1><p>函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vListInsertEnd</span><span class="token punctuation">(</span> List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxList<span class="token punctuation">,</span> ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxNewListItem <span class="token punctuation">)</span><span class="token punctuation">{</span>    ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxIndex <span class="token operator">=</span> pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token punctuation">;</span>    <span class="token function">listTEST_LIST_INTEGRITY</span><span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listTEST_LIST_ITEM_INTEGRITY</span><span class="token punctuation">(</span> pxNewListItem <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listGET_OWNER_OF_NEXT_ENTRY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token operator">*</span><span class="token operator">/</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIndex<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  1 </span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  2</span>     <span class="token comment" spellcheck="true">/* Only used during decision coverage testing. */</span>    <span class="token function">mtCOVERAGE_TEST_DELAY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  3 </span>    pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//  4</span>    <span class="token comment" spellcheck="true">/* Remember which list the item is in. */</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> pxList<span class="token punctuation">;</span>    <span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>传入的参数：</p><ul><li><p>pxList：列表项要插入的列表。</p></li><li><p>pxNewListItem：要插入的列表项是什么。</p></li></ul><p>从末尾插入，那就要先知道哪里是头咯，我们在列表中的成员<code>pxIndex</code>就是用来遍历列表项的啊，那它指向的地方就是列表项的头，那么既然<code>FreeRTOS</code>中的列表很像数据结构中的双向链表，那么，我们可以把它看成一个环，是首尾相连的，那么函数中说的末尾，就是列表项头的前一个，很显然其结构图应该是下图这样子的（初始化结束后<code>pxIndex</code>指向了<code>xListEnd</code>）：<br><img src="./images/loading.png" data-original="https://img-blog.csdn.net/20180609234229499" alt=""></p><p>为什么是这样子的呢，一句句代码来解释：</p><p>一开始：</p><pre class="line-numbers language-js"><code class="language-js">ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxIndex <span class="token operator">=</span> pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>保存了一开始的索引列表项（xListEnd）的指向。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIndex<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//  1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新列表项的下一个指向为索引列表项，也就是绿色的箭头。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//  2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>刚开始我们初始化完成的时候pxIndex-&gt;pxPrevious的指向为自己xListEnd，那么xNewListItem-&gt;pxPrevious的指向为xListEnd。如2紫色的箭头。</p><pre class="line-numbers language-js"><code class="language-js">pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//  3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>索引列表项（xListEnd）的上一个列表项还是自己，那么自己的下一个列表项指向就是指向了pxNewListItem。</p><pre class="line-numbers language-js"><code class="language-js">pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">//  4</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这句就很容易理解啦。如图的4橙色的箭头。</p><p>插入完毕的时候标记一下新的列表项插入了哪个列表，并且将uxNumberOfItems进行加一，以表示多了一个列表项。</p><p>为什么源码要这样子写呢？因为这只是两个列表项，一个列表含有多个列表项，那么这段代码的通用性就很强了。无论原本列表中有多少个列表项，也无论pxIndex指向哪个列表项！<br><img src="./images/loading.png" data-original="https://img-blog.csdn.net/20180609234241856" alt=""><br><img src="./images/loading.png" data-original="https://img-blog.csdn.net/2018060923424853" alt=""></p><p>看看是不是按照源码中那样插入呢？</p><h1 id="列表项的插入"><a href="#列表项的插入" class="headerlink" title="列表项的插入"></a>列表项的插入</h1><p>源码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vListInsert</span><span class="token punctuation">(</span> List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxList<span class="token punctuation">,</span> ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxNewListItem <span class="token punctuation">)</span><span class="token punctuation">{</span>ListItem_t <span class="token operator">*</span>pxIterator<span class="token punctuation">;</span><span class="token keyword">const</span> TickType_t xValueOfInsertion <span class="token operator">=</span> pxNewListItem<span class="token operator">-</span><span class="token operator">></span>xItemValue<span class="token punctuation">;</span>    <span class="token function">listTEST_LIST_INTEGRITY</span><span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listTEST_LIST_ITEM_INTEGRITY</span><span class="token punctuation">(</span> pxNewListItem <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> xValueOfInsertion <span class="token operator">==</span> portMAX_DELAY <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        pxIterator <span class="token operator">=</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd<span class="token punctuation">.</span>pxPrevious<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span> pxIterator <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>xItemValue <span class="token operator">&lt;=</span> xValueOfInsertion<span class="token punctuation">;</span> pxIterator <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* There is nothing to do here, just iterating to the wanted            insertion position. */</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIterator<span class="token punctuation">;</span>    pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Remember which list the item is in.  This allows fast removal of the    item later. */</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> pxList<span class="token punctuation">;</span>    <span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>传入的参数：</p><ul><li><p>pxList：列表项要插入的列表。</p></li><li><p>pxNewListItem：要插入的列表项是什么。</p></li></ul><p>pxList决定了插入哪个列表，pxNewListItem中的xItemValue值决定了列表项插入列表的位置。</p><pre class="line-numbers language-js"><code class="language-js">ListItem_t <span class="token operator">*</span>pxIterator<span class="token punctuation">;</span>  <span class="token keyword">const</span> TickType_t xValueOfInsertion <span class="token operator">=</span> pxNewListItem<span class="token operator">-</span><span class="token operator">></span>xItemValue<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>定义一个辅助的列表项pxIterator，用来迭代找出插入新列表项的位置，并且保存获取要插入的列表项pxNewListItem的xItemValue。</p><p>如果打开了列表项完整性检查，就要用户实现configASSERT()，源码中有说明。</p><p>既然是要插入列表项，那么肯定是要知道列表项的位置了，如果新插入列表项的xItemValue是最大的话（portMAX_DELAY），就直接插入列表项的末尾。否则就需要比较列表中各个列表项的xItemValue的大小来进行排列。然后得出新列表项插入的位置。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span><span class="token punctuation">(</span> pxIterator <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>xItemValue <span class="token operator">&lt;=</span> xValueOfInsertion<span class="token punctuation">;</span> pxIterator <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面源码就是实现比较的过程。</p><p>与上面的从列表项末尾插入的源码一样，FreeRTOS的代码通用性很强，逻辑思维也很强。</p><p>如果列表中列表项的数量为0，那么插入的列表项就是在初始化列表项的后面。如下图所示：<br><img src="./images/loading.png" data-original="https://img-blog.csdn.net/20180609234309563" alt=""></p><p>过程分析：<br>新列表项的pxNext指向pxIterator-&gt;pxNext，也就是指向了xListEnd（pxIterator）。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而xListEnd（pxIterator）的pxPrevious指向则为pxNewListItem。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新列表项的（pxPrevious）指针指向xListEnd（pxIterator）</p><p>pxIterator 的 pxNext 指向了新列表项</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIterator<span class="token punctuation">;</span>pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>与从末尾插入列表项其实是一样的，前提是当前列表中列表项的数目为0。</p><p>假如列表项中已经有了元素呢，过程又是不一样的了。原来的列表是下图这样子的：</p><p><img src="./images/loading.png" data-original="https://img-blog.csdn.net/20180609234309563" alt=""><br>假设插入的列表项的xItemValue是2，而原有的列表项的xItemValue值是3，那么，按照源码，我们插入的列表项是在中间了。而pxIterator则是①号列表项。</p><p>插入后的效果：<br><img src="./images/loading.png" data-original="https://img-blog.csdn.net/20180609234320730" alt=""><br>分析一下插入的过程：</p><p>新的列表项的pxNext指向的是pxIterator-&gt;pxNext，也就是③号列表项。因为一开始pxIterator-&gt;pxNext=指向的就是③号列表项！！</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而pxNewListItem-&gt;pxNext 即③号列表项的指向上一个列表项指针（pxPrevious）的则指向新插入的列表项，也就是②号列表项了。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新插入列表项的指向上一个列表项的指针pxNewListItem-&gt;pxPrevious指向了辅助列表项pxIterator。很显然要连接起来嘛！</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIterator<span class="token punctuation">;</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同理，pxIterator列表项的指向下一个列表项的指针则指向新插入的列表项了pxNewListItem。</p><pre class="line-numbers language-js"><code class="language-js">pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而其他没改变指向的地方不需改动。（图中的两条直线做的连接线是不需要改动的）<br>当插入完成的时候，记录一下新插入的列表项属于哪个列表。并且让该列表下的列表项数目加一。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> pxList<span class="token punctuation">;</span>         <span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="删除列表项"><a href="#删除列表项" class="headerlink" title="删除列表项"></a>删除列表项</h1><p>源码：</p><pre class="line-numbers language-js"><code class="language-js">UBaseType_t <span class="token function">uxListRemove</span><span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxItemToRemove <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">/* The list item knows which list it is in.  Obtain the list from the listitem. */</span>List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxList <span class="token operator">=</span> <span class="token punctuation">(</span> List_t <span class="token operator">*</span> <span class="token punctuation">)</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pvContainer<span class="token punctuation">;</span>    pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>    pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Only used during decision coverage testing. */</span>    <span class="token function">mtCOVERAGE_TEST_DELAY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Make sure the index is left pointing to a valid item. */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">==</span> pxItemToRemove <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> NULL<span class="token punctuation">;</span>    <span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token punctuation">)</span><span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实删除是很简单的，不用想都知道，要删除列表项，那肯定要知道该列表项是属于哪个列表吧，pvContainer就是记录列表项是属于哪个列表的。</p><p>删除就是把列表中的列表项从列表中去掉，其本质其实就是把他们的连接关系删除掉，然后让删除的列表项的前后两个列表连接起来就行了，假如是只有一个列表项，那么删除之后，列表就回到了初始化的状态了。</p><pre class="line-numbers language-js"><code class="language-js">pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两句代码就实现了将删除列表项的前后两个列表项连接起来。</p><p>按照上面的讲解可以理解这两句简单的代码啦。</p><p>假如删除的列表项是当前索引的列表项，那么在删除之后，列表中的pxIndex就要指向删除列表项的上一个列表项了。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">==</span> pxItemToRemove <span class="token punctuation">)</span><span class="token punctuation">{</span>      pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当然还要把当前删除的列表项的pvContainer指向NULL，让它不属于任何一个列表，因为，删除的本质是删除的仅仅是列表项的连接关系，其内存是没有释放掉的，假如是动态内存分配的话。<br>并且要把当前列表中列表项的数目返回一下。</p><p>至此，列表的源码基本讲解完毕。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>大家还可以了解一下遍历列表的宏，它在list.h文件中：</p><pre class="line-numbers language-js"><code class="language-js">define <span class="token function">listGET_OWNER_OF_NEXT_ENTRY</span><span class="token punctuation">(</span> pxTCB<span class="token punctuation">,</span> pxList <span class="token punctuation">)</span>                                        \<span class="token punctuation">{</span>                                                                                            \List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxConstList <span class="token operator">=</span> <span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span>                                                    \    <span class="token comment" spellcheck="true">/* Increment the index to the next item and return the item, ensuring */</span>                \    <span class="token comment" spellcheck="true">/* we don't return the marker used at the end of the list.  */</span>                          \    <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span>                            \    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">==</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span> <span class="token punctuation">)</span>  \    <span class="token punctuation">{</span>                                                                                       \        <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span>                        \    <span class="token punctuation">}</span>                                                                                       \    <span class="token punctuation">(</span> pxTCB <span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token operator">-</span><span class="token operator">></span>pvOwner<span class="token punctuation">;</span>                                          \<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一个宏，用于列表的遍历，返回的是列表中列表项的pxOwner成员，每次调用这个宏（函数）的时候，其pxIndex索引会指向当前返回列表项的下一个列表项。</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0开始学FreeRTOS-(消息队列)-5</title>
      <link href="/freertos-5/"/>
      <url>/freertos-5/</url>
      
        <content type="html"><![CDATA[<h2 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h2><p>曾经有人问我，FreeRTOS那么多API，到底怎么记住呢？<br>我想说，其实API不难记，就是有点难找，因为FreeRTOS的API很多都是带参宏，所以跳来跳去的比较麻烦，而且注释也很多，要找还真不是那么容易，不过也没啥，一般都会有API手册的，我就告诉大家一下：<br><strong>FreeRTOS Kernel: Reference Manual</strong><br>FreeRTOS内核：参考手册，大家可以在<a href="https://www.freertos.org/Documentation/RTOS_book.html" target="_blank" rel="noopener">官网下载</a>，也能在后台得到。<br>当然书本是英文的，如果英语像我这样子不咋地的同学，可以用谷歌浏览器在官网直接看API手册，直接翻译一下就行了。传送门：<a href="https://www.freertos.org/a00018.html" target="_blank" rel="noopener">https://www.freertos.org/a00018.html</a><br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/2019013113211022.png?" alt="Reference Manual"><br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190131133629940.png?" alt="FreeRTOS官网的API"></p><h2 id="FreeRTOS消息队列"><a href="#FreeRTOS消息队列" class="headerlink" title="FreeRTOS消息队列"></a>FreeRTOS消息队列</h2><p>基于 FreeRTOS 的应用程序由一组独立的任务构成——每个任务都是具有独立权限的程序。这些独立的任务之间的通讯与同步一般都是基于操作系统提供的IPC通讯机制，而FreeRTOS 中所有的通信与同步机制都是基于队列实现的。<br>消息队列是一种常用于任务间通信的数据结构，队列可以在任务与任务间、中断和任务间传送信息，实现了任务接收来自其他任务或中断的不固定长度的消息。任务能够从队列里面读取消息，当队列中的消息是空时，挂起读取任务，用户还可以指定挂起的任务时间；当队列中有新消息时，挂起的读取任务被唤醒并处理新消息，消息队列是一种异步的通信方式。</p><h3 id="队列特性"><a href="#队列特性" class="headerlink" title="队列特性"></a>队列特性</h3><h4 id="1-数据存储"><a href="#1-数据存储" class="headerlink" title="1.数据存储"></a>1.数据存储</h4><p>队列可以保存有限个具有确定长度的数据单元。队列可以保存的最大单元数目被称为队列的“深度”。在队列创建时需要设定其深度和每个单元的大小。<br>通常情况下，队列被作为 FIFO(先进先出)缓冲区使用，即数据由队列尾写入，从队列首读出。当然，由队列首写入也是可能的。<br>往队列写入数据是通过字节拷贝把数据复制存储到队列中；从队列读出数据使得把队列中的数据拷贝删除。 </p><h4 id="2-读阻塞"><a href="#2-读阻塞" class="headerlink" title="2.读阻塞"></a>2.读阻塞</h4><p>当某个任务试图读一个队列时，其可以指定一个阻塞超时时间。在这段时间中，如果队列为空，该任务将保持阻塞状态以等待队列数据有效。当其它任务或中断服务例程往其等待的队列中写入了数据，该任务将自动由阻塞态转移为就绪态。当等待的时间超过了指定的阻塞时间，即使队列中尚无有效数据，任务也会自动从阻塞态转移为就绪态。<br>由于队列可以被多个任务读取，所以对单个队列而言，也可能有多个任务处于阻塞状态以等待队列数据有效。这种情况下，一旦队列数据有效，只会有一个任务会被解除阻塞，这个任务就是所有等待任务中优先级最高的任务。而如果所有等待任务的优先级相同，那么被解除阻塞的任务将是等待最久的任务。</p><blockquote><p>说些题外话，ucos中是具有广播消息的，当有多个任务阻塞在队列上，当发送消息的时候可以选择广播消息，那么这些阻塞的任务都能被解除阻塞。</p></blockquote><h4 id="3-写阻塞"><a href="#3-写阻塞" class="headerlink" title="3.写阻塞"></a>3.写阻塞</h4><p>与读阻塞想反，任务也可以在写队列时指定一个阻塞超时时间。这个时间是当被写队列已满时，任务进入阻塞态以等待队列空间有效的最长时间。<br>由于队列可以被多个任务写入，所以对单个队列而言，也可能有多个任务处于阻塞状态以等待队列空间有效。这种情况下，一旦队列空间有效，只会有一个任务会被解除阻塞，这个任务就是所有等待任务中优先级最高的任务。而如果所有等待任务的优先级相同，那么被解除阻塞的任务将是等待最久的任务。</p><h3 id="消息队列的工作流程"><a href="#消息队列的工作流程" class="headerlink" title="消息队列的工作流程"></a>消息队列的工作流程</h3><h4 id="1-发送消息"><a href="#1-发送消息" class="headerlink" title="1.发送消息"></a>1.发送消息</h4><p>任务或者中断服务程序都可以给消息队列发送消息，当发送消息时，如果队列未满或者允许覆盖入队， FreeRTOS 会将消息拷贝到消息队列队尾，否则，会根据用户指定的阻塞超时时间进行阻塞，在这段时间中，如果队列一直不允许入队，该任务将保持阻塞状态以等待队列允许入队。当其它任务从其等待的队列中读取入了数据（队列未满），该任务将自动由阻塞态转为就绪态。当任务等待的时间超过了指定的阻塞时间，即使队列中还不允许入队，任务也会自动从阻塞态转移为就绪态，此时发送消息的任务或者中断程序会收到一个错误码 errQUEUE_FULL。<br>发送紧急消息的过程与发送消息几乎一样，唯一的不同是，当发送紧急消息时，发送的位置是消息队列队头而非队尾，这样，接收者就能够优先接收到紧急消息，从而及时进行消息处理。<br>下面是消息队列的发送API接口，函数中有FromISR则表明在中断中使用的。<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181203195147150.png?" alt="消息队列入队（发送）的API接口"></p><pre><code>1 /*-----------------------------------------------------------*/ 2 BaseType_t xQueueGenericSend( QueueHandle_t xQueue,        (1)     3                               const void * const pvItemToQueue,     (2) 4                               TickType_t xTicksToWait,        (3) 5                               const BaseType_t xCopyPosition )    (4) 6 { 7     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired; 8     TimeOut_t xTimeOut; 9     Queue_t * const pxQueue = ( Queue_t * ) xQueue;10 11     /* 已删除一些断言操作 */12 13     for ( ;; ) {14         taskENTER_CRITICAL();                    (5)15         {16             /* 队列未满 */17             if ( ( pxQueue-&gt;uxMessagesWaiting &lt; pxQueue-&gt;uxLength )18                  || ( xCopyPosition == queueOVERWRITE ) ) {    (6)    19                 traceQUEUE_SEND( pxQueue );20                 xYieldRequired =21           prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ); (7)22 23                 /* 已删除使用队列集部分代码 */24                 /* 如果有任务在等待获取此消息队列 */25       if ( listLIST_IS_EMPTY(&amp;(pxQueue-&gt;xTasksWaitingToReceive))==pdFALSE){ (8)26                     /* 将任务从阻塞中恢复 */27             if ( xTaskRemoveFromEventList(28                   &amp;( pxQueue-&gt;xTasksWaitingToReceive ) )!=pdFALSE) { (9)29                         /* 如果恢复的任务优先级比当前运行任务优先级还高，30                         那么需要进行一次任务切换 */31                         queueYIELD_IF_USING_PREEMPTION();    (10)32                     } else {33                         mtCOVERAGE_TEST_MARKER();34                     }35                 } else if ( xYieldRequired != pdFALSE ) {36                     /* 如果没有等待的任务，拷贝成功也需要任务切换 */37                     queueYIELD_IF_USING_PREEMPTION();        (11)38                 } else {39                     mtCOVERAGE_TEST_MARKER();40                 }41 42                 taskEXIT_CRITICAL();                (12)43                 return pdPASS;44             }45             /* 队列已满 */46             else {                        (13)47                 if ( xTicksToWait == ( TickType_t ) 0 ) {48                     /* 如果用户不指定阻塞超时时间，退出 */49                     taskEXIT_CRITICAL();            (14)50                     traceQUEUE_SEND_FAILED( pxQueue );51                     return errQUEUE_FULL;52                 } else if ( xEntryTimeSet == pdFALSE ) {    53                     /* 初始化阻塞超时结构体变量，初始化进入54                 阻塞的时间xTickCount和溢出次数xNumOfOverflows */55                     vTaskSetTimeOutState( &amp;xTimeOut );        (15)56                     xEntryTimeSet = pdTRUE;57                 } else {58                     mtCOVERAGE_TEST_MARKER();59                 }60             }61         }62         taskEXIT_CRITICAL();                    (16)63         /* 挂起调度器 */64         vTaskSuspendAll();65         /* 队列上锁 */66         prvLockQueue( pxQueue );67 68         /* 检查超时时间是否已经过去了 */69         if (xTaskCheckForTimeOut(&amp;xTimeOut, &amp;xTicksToWait)==pdFALSE){ (17)70             /* 如果队列还是满的 */71             if ( prvIsQueueFull( pxQueue ) != pdFALSE ) {    (18)    72                 traceBLOCKING_ON_QUEUE_SEND( pxQueue );    73                 /* 将当前任务添加到队列的等待发送列表中74                    以及阻塞延时列表，延时时间为用户指定的超时时间xTicksToWait */75                 vTaskPlaceOnEventList(76                    &amp;( pxQueue-&gt;xTasksWaitingToSend ), xTicksToWait );(19)77                 /* 队列解锁 */78                 prvUnlockQueue( pxQueue );            (20)79 80                 /* 恢复调度器 */81                 if ( xTaskResumeAll() == pdFALSE ) {82                     portYIELD_WITHIN_API();83                 }84             } else {85                 /* 队列有空闲消息空间，允许入队 */86                 prvUnlockQueue( pxQueue );            (21)87                 ( void ) xTaskResumeAll();88             }89         } else {90             /* 超时时间已过，退出 */91             prvUnlockQueue( pxQueue );                (22)92             ( void ) xTaskResumeAll();93 94             traceQUEUE_SEND_FAILED( pxQueue );95             return errQUEUE_FULL;96         }97     }98 }99 /*-----------------------------------------------------------*/</code></pre><p>如果阻塞时间不为 0，任务会因为等待入队而进入阻塞， 在将任务设置为阻塞的过程中， 系统不希望有其它任务和中断操作这个队列的 xTasksWaitingToReceive 列表和 xTasksWaitingToSend 列表，因为可能引起其它任务解除阻塞，这可能会发生优先级翻转。比如任务 A 的优先级低于当前任务，但是在当前任务进入阻塞的过程中，任务 A 却因为其它原因解除阻塞了，这显然是要绝对禁止的。因此FreeRTOS 使用挂起调度器禁止其它任务操作队列，因为挂起调度器意味着任务不能切换并且不准调用可能引起任务切换的 API 函数。但挂起调度器并不会禁止中断，中断服务函数仍然可以操作队列阻塞列表，可能会解除任务阻塞、可能会进行上下文切换，这也是不允许的。于是，<strong>FreeRTOS解决办法是不但挂起调度器，还要给队列上锁，禁止任何中断来操作队列。</strong><br>下面来看看流程图：<br><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20190131164341932.png?" alt="消息队列发送流程"><br>相比在任务中调用的发送函数，在中断中调用的函数会更加简单一些， 没有任务阻塞操作。<br>函数 xQueueGenericSend中插入数据后， 会检查等待接收链表是否有任务等待，如果有会恢复就绪。如果恢复的任务优先级比当前任务高， 则会触发任务切换；但是在中断中调用的这个函数的做法是返回一个参数标志是否需要触发任务切换，并不在中断中切换任务。<br>在任务中调用的函数中有锁定和解锁队列的操作， 锁定队列的时候， 队列的事件链表不能被修改。 而在被中断中发送消息的处理是： 当遇到队列被锁定的时候， 将新数据插入到队列后， 并不会直接恢复因为等待接收的任务， 而是累加了计数， 当队列解锁的时候， 会根据这个计数， 对应恢复几个任务。<br>遇到队列满的情况， 函数会直接返回， 而不是阻塞等待， 因为在中断中阻塞是不允许的！！！</p><pre><code> 1 BaseType_t xQueueGenericSendFromISR( 2        QueueHandle_t xQueue, 3        const void * const pvItemToQueue, 4        /* 不在中断函数中触发任务切换， 而是返回一个标记 */ 5        BaseType_t * const pxHigherPriorityTaskWoken, 6        const BaseType_t xCopyPosition ) 7{ 8    BaseType_t xReturn; 9    UBaseType_t uxSavedInterruptStatus;10    Queue_t * const pxQueue = ( Queue_t * ) xQueue;1112    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();13    {14        // 判断队列是否有空间插入新内容15        if( ( pxQueue-&gt;uxMessagesWaiting &lt; pxQueue-&gt;uxLength ) || ( xCopyPosition == queueOVERWRITE ) )16        {17            const int8_t cTxLock = pxQueue-&gt;cTxLock;1819            // 中断中不能使用互斥锁， 所以拷贝函数只是拷贝数据，20            // 没有任务优先级继承需要考虑21            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );2223            // 判断队列是否被锁定24            if( cTxLock == queueUNLOCKED )25            {26            #if ( configUSE_QUEUE_SETS == 1 )27                // 集合相关代码28            #else /* configUSE_QUEUE_SETS */29                {30                    // 将最高优先级的等待任务恢复到就绪链表31                    if( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )32                    {33                        if( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE)34                        {35                            // 如果有高优先级的任务被恢复36                            // 此处不直接触发任务切换， 而是返回一个标记37                            if( pxHigherPriorityTaskWoken != NULL )38                            {39                                *pxHigherPriorityTaskWoken = pdTRUE;40                            }41                        }42                    }43                }44            #endif /* configUSE_QUEUE_SETS */45            }46            else47            {48                // 队列被锁定， 不能修改事件链表49                // 增加计数， 记录需要接触几个任务到就绪50                // 在解锁队列的时候会根据这个计数恢复任务51                pxQueue-&gt;cTxLock = ( int8_t ) ( cTxLock + 1 );52            }53            xReturn = pdPASS;54        }55        else56        {57            // 队列满 直接返回 不阻塞58            xReturn = errQUEUE_FULL;59        }60    }6162    // 恢复中断的优先级63    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );6465    return xReturn;66}</code></pre><h4 id="消息队列读取"><a href="#消息队列读取" class="headerlink" title="消息队列读取"></a>消息队列读取</h4><p><img src="./images/loading.png" data-original="https://img-blog.csdnimg.cn/20181203200731899.png" alt="消息读取"><br>任务调用接收函数收取队列消息， 函数首先判断当前队列是否有未读消息， 如果没有， 则会判断参数 xTicksToWait, 决定直接返回函数还是阻塞等待。<br>如果队列中有消息未读， 首先会把待读的消息复制到传进来的指针所指内， 然后判断函数参数 xJustPeeking == pdFALSE的时候， 符合的话， 说明这个函数读取了数据， 需要把被读取的数据做出队处理， 如果不是， 则只是查看一下（peek），只是返回数据，但是不会把数据清除。<br>对于正常读取数据的操作， 清除数据后队列会空出空位， 所以查看队列中的等待列表中是否有任务等发送数据而被挂起， 有的话恢复一个任务就绪， 并根据优先级判断是否需要出进行任务切换。<br>对于只是查看数据的， 由于没有清除数据， 所以没有空间新空出，不需要检查发送等待链表， 但是会检查接收等待链表， 如果有任务挂起会切换其到就绪并判断是否需要切换。</p><p>消息队列出队过程分析，其实跟入队差不多，请看注释：</p><pre><code> 1 /*-----------------------------------------------------------*/ 2 BaseType_t xQueueGenericReceive( QueueHandle_t xQueue,        (1)     3                                  void * const pvBuffer,        (2) 4                                  TickType_t xTicksToWait,    (3)     5                                  const BaseType_t xJustPeeking )    (4) 6 { 7     BaseType_t xEntryTimeSet = pdFALSE; 8     TimeOut_t xTimeOut; 9     int8_t *pcOriginalReadPosition;10     Queue_t * const pxQueue = ( Queue_t * ) xQueue;11 12     /* 已删除一些断言 */13     for ( ;; ) {14         taskENTER_CRITICAL();                    (5)15         {16             const UBaseType_t uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting; 17 18             /* 看看队列中有没有消息 */19             if ( uxMessagesWaiting &gt; ( UBaseType_t ) 0 ) {    (6)    20                 /*防止仅仅是读取消息，而不进行消息出队操作*/21                 pcOriginalReadPosition = pxQueue-&gt;u.pcReadFrom;    (7)22                 /* 拷贝消息到用户指定存放区域pvBuffer */23                 prvCopyDataFromQueue( pxQueue, pvBuffer );    (8)24 25                 if ( xJustPeeking == pdFALSE ) {        (9)26                     /* 读取消息并且消息出队 */27                     traceQUEUE_RECEIVE( pxQueue );    28 29                     /* 获取了消息，当前消息队列的消息个数需要减一 */30                     pxQueue-&gt;uxMessagesWaiting = uxMessagesWaiting - 1;  (10)31                     /* 判断一下消息队列中是否有等待发送消息的任务 */32                     if ( listLIST_IS_EMPTY(            (11)33                              &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE ) {34                         /* 将任务从阻塞中恢复 */35                         if ( xTaskRemoveFromEventList(        (12)36                                  &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE ) {37                             /* 如果被恢复的任务优先级比当前任务高，会进行一次任务切换 */38                             queueYIELD_IF_USING_PREEMPTION();    (13)39                         } else {40                             mtCOVERAGE_TEST_MARKER();41                         }42                     } else {43                         mtCOVERAGE_TEST_MARKER();44                     }45                 } else {                    (14)46                     /* 任务只是看一下消息（peek），并不出队 */    47                     traceQUEUE_PEEK( pxQueue );48 49                     /* 因为是只读消息 所以还要还原读消息位置指针 */50                     pxQueue-&gt;u.pcReadFrom = pcOriginalReadPosition; (15)51 52                     /* 判断一下消息队列中是否还有等待获取消息的任务 */53                     if ( listLIST_IS_EMPTY(            (16)54                              &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE ) {55                         /* 将任务从阻塞中恢复 */56                         if ( xTaskRemoveFromEventList(            57                               &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE ) {58                             /* 如果被恢复的任务优先级比当前任务高，会进行一次任务切换 */59                             queueYIELD_IF_USING_PREEMPTION();    60                         } else {61                             mtCOVERAGE_TEST_MARKER();62                         }63                     } else {64                         mtCOVERAGE_TEST_MARKER();65                     }66                 }67 68                 taskEXIT_CRITICAL();                (17)69                 return pdPASS;70             } else {                        (18)71                 /* 消息队列中没有消息可读 */72                 if ( xTicksToWait == ( TickType_t ) 0 ) {    (19)    73                     /* 不等待，直接返回 */74                     taskEXIT_CRITICAL();75                     traceQUEUE_RECEIVE_FAILED( pxQueue );76                     return errQUEUE_EMPTY;77                 } else if ( xEntryTimeSet == pdFALSE ) {        78                     /* 初始化阻塞超时结构体变量，初始化进入79                     阻塞的时间xTickCount和溢出次数xNumOfOverflows */80                     vTaskSetTimeOutState( &amp;xTimeOut );        (20)81                     xEntryTimeSet = pdTRUE;82                 } else {83                     mtCOVERAGE_TEST_MARKER();84                 }85             }86         }87         taskEXIT_CRITICAL();                    88 89         vTaskSuspendAll();90         prvLockQueue( pxQueue );                (21)91 92         /* 检查超时时间是否已经过去了*/93         if ( xTaskCheckForTimeOut( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE ) {(22)94             /* 如果队列还是空的 */95             if ( prvIsQueueEmpty( pxQueue ) != pdFALSE ) {96                 traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );    (23)    97                 /* 将当前任务添加到队列的等待接收列表中98                    以及阻塞延时列表，阻塞时间为用户指定的超时时间xTicksToWait */99                 vTaskPlaceOnEventList(                100                     &amp;( pxQueue-&gt;xTasksWaitingToReceive ), xTicksToWait );101                 prvUnlockQueue( pxQueue );102                 if ( xTaskResumeAll() == pdFALSE ) {        103                     /* 如果有任务优先级比当前任务高，会进行一次任务切换 */104                     portYIELD_WITHIN_API();            105                 } else {106                     mtCOVERAGE_TEST_MARKER();107                 }108             } else {109                 /* 如果队列有消息了，就再试一次获取消息 */110                 prvUnlockQueue( pxQueue );            (24)111                 ( void ) xTaskResumeAll();112             }113         } else {114             /* 超时时间已过，退出 */115             prvUnlockQueue( pxQueue );                (25)116             ( void ) xTaskResumeAll();117 118             if ( prvIsQueueEmpty( pxQueue ) != pdFALSE ) {119                 /* 如果队列还是空的，返回错误代码errQUEUE_EMPTY */120                 traceQUEUE_RECEIVE_FAILED( pxQueue );121                 return errQUEUE_EMPTY;                (26)122             } else {123                 mtCOVERAGE_TEST_MARKER();124             }125         }126     }127 }128 /*-----------------------------------------------------------*/</code></pre><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>如果队列存储的数据较大时，那最好是利用队列来传递数据的指针而不是数据本身，因为传递数据的时候是需要CPU一字节一字节地将数据拷贝进队列或从队列拷贝出来。而传递指针无论是在处理速度上还是内存空间利用上都更有效。但是，当利用队列传递指针时，一定要十分小心地做到以下两点：</p><h4 id="1-指针指向的内存空间的所有权必须明确"><a href="#1-指针指向的内存空间的所有权必须明确" class="headerlink" title="1.指针指向的内存空间的所有权必须明确"></a>1.指针指向的内存空间的所有权必须明确</h4><p>当任务间通过指针共享内存时，应该从根本上保证所不会有任意两个任务同时修改共享内存中的数据，或是以其它行为方式使得共享内存数据无效或产生一致性问题。原则上，共享内存在其指针发送到队列之前，其内容只允许被发送任务访问；共享内存指针从队列中被读出之后，其内容亦只允许被接收任务访问。</p><h4 id="2-指针指向的内存空间必须有效"><a href="#2-指针指向的内存空间必须有效" class="headerlink" title="2.指针指向的内存空间必须有效"></a>2.指针指向的内存空间必须有效</h4><p>如果指针指向的内存空间是动态分配的，只应该有一个任务负责对其进行内存释放。当这段内存空间被释放之后，就不应该有任何一个任务再访问这段空间。<br>并且最最最重要的是禁止使用指针访问<strong>任务栈上</strong>的空间，也就是局部变量。因为当栈发生改变后，栈上的数据将不再有效。</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0开始学FreeRTOS-(任务调度)-4</title>
      <link href="/freertos-4/"/>
      <url>/freertos-4/</url>
      
        <content type="html"><![CDATA[<p>大家晚上好，我是杰杰，最近挺忙的，好久没有更新了，今天周末就吐血更新一下吧！</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>FreeRTOS</code>是一个是实时内核，任务是程序执行的最小单位，也是调度器处理的基本单位，移植了<code>FreeRTOS</code>，则避免不了对任务的管理，在多个任务运行的时候，任务切换显得尤为重要。而任务切换的效率会决定了系统的稳定性与效率。</p><p><code>FreeRTOS</code>的任务切换是干嘛的呢，<code>rtos</code>的实际是永远运行的是具有最高优先级的运行态任务，而那些之前在就绪态的任务怎么变成运行态使其得以运行呢，这就是我们<code>FreeRTOS</code>任务切换要做的事情，它要做的是找到最高优先级的就绪态任务，并且让它获得cpu的使用权，这样，它就能从就绪态变成运行态，这样子，整个系统的实时性就会很好，响应也会很好，而不会让程序阻塞卡死。</p><p>要知道怎么实现任务切换，那就要知道任务切换的机制，在不同的<code>cpu（mcu）</code>中，触发的方式可能会不一样，现在是以Cortex-M3为例来讲讲任务的切换。为了大家能看懂本文，我就抛转引玉一下，<code>引用《Cortex-M3权威指南-中文版》的部分语句（如涉及侵权，请联系杰杰删除）</code></p><h1 id="SVC-和-PendSV"><a href="#SVC-和-PendSV" class="headerlink" title="SVC 和 PendSV"></a>SVC 和 PendSV</h1><p>SVC（系统服务调用，亦简称系统调用）和 <code>PendSV</code>（<code>Pended System Call</code>，可悬起系统调用），它们多用于在操作系统之上的软件开发中。<code>SVC</code> 用于产生系统函数的调用请求。例如，操作系统不让用户程序直接访问硬件，而是通过提供一些系统服务函数，用户程序使用 SVC 发出对系统服务函数的呼叫请求，以这种方法调用它们来间接访问硬件。因此，当用户程序想要控制特定的硬件时，它就会产生一个 <code>SVC</code> 异常，然后操作系统提供的 <code>SVC</code> 异常服务例程得到执行，它再调用相关的操作系统函数，后者完成用户程序请求的服务。</p><p>另一个相关的异常是<code>PendSV</code>（可悬起的系统调用），它和 <code>SVC</code> 协同使用。一方面，<code>SVC</code>异常是必须立即得到响应的（若因优先级不比当前正处理的高，或是其它原因使之无法立即响应，将发生硬 fault——译者注），应用程序执行 <code>SVC</code> 时都是希望所需的请求立即得到响应。另一方面，PendSV 则不同，它是可以像普通的中断一样被悬起的（不像 <code>SVC</code> 那样）。OS 可以利用它“缓期执行”一个异常——直到其它重要的任务完成后才执行动作。悬起 <code>PendSV</code> 的方法是：手工往 <code>NVIC</code> 的<code>PendSV</code> 悬起寄存器中写 1。悬起后，如果优先级不够高，则将缓期等待执行。</p><p>如果一个发生的异常不能被即刻响应，就称它被“悬起”(pending)。不过，少数 fault异常是不允许被悬起的。一个异常被悬起的原因，可能是系统当前正在执行一个更高优先级异常的服务例程，或者因相关掩蔽位的设置导致该异常被除能。对于每个异常源，在被悬起的情况下，都会有一个对应的“悬起状态寄存器”保存其异常请求，直到该异常能够执行为止，这与传统的 ARM 是完全不同的。在以前，是由产生中断的设备保持住请求信号。现在NVIC 的悬起状态寄存器的出现解决了这个问题，即使后来设备已经释放了请求信号，曾经的中断请求也不会错失。</p><h1 id="系统任务切换的工程分析"><a href="#系统任务切换的工程分析" class="headerlink" title="系统任务切换的工程分析"></a>系统任务切换的工程分析</h1><p>在系统中正常执行的任务（假设没有外部中断<code>IRQ</code>），用<code>Systick</code>直接做上下文切换是完全没有问题的，如图：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/switch.png" alt="switch"></p><p>但是问题是几乎很少嵌入式的设备会不用其丰富的中断响应，所以，直接用systick做系统的上下文切换那是不实际的，这存在很大的风险，因为假设<code>systick</code>打断了一个中断（<code>IRQ</code>），立即做出上下文切换的话，则触犯用法 <code>fault</code>异常，除了重启你没有其他办法了，这样子做出来的产品就是垃圾！！用我老板的话说就是写的什么狗屎！！！如图所示：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/IRQ-switch.png" alt="IRQ-switch"></p><p>那这么说这样不行那也不行，怎么办啊？请看看前面接介绍的<code>PendSV</code>，是不是有点豁然开朗了？<code>PendSV</code> 来完美解决这个问题。<code>PendSV</code> 异常会自动延迟上下文切换的请求，直到其它的<code>ISR</code> 都完成了处理后才放行。为实现这个机制，需要把 <code>PendSV</code> 编程为最低优先级的异常。如果<code>OS</code>检测到某 <code>IRQ</code>正在活动并且被 SysTick 抢占，它将悬起一个 <code>PendSV</code> 异常，以便缓期执行上下文切换。</p><p>懂了吗？就是说，只要将<code>PendSV</code>的优先级设为最低的，systick即使是打断了IRQ，它也不会马上进行上下文切换，而是等到IRQ执行完，<code>PendSV</code> 服务例程才开始执行，并且在里面执行上下文切换。过程如图所示：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/pendsv-switch.png" alt="pendsv-switch"></p><h1 id="任务切换的源码实现"><a href="#任务切换的源码实现" class="headerlink" title="任务切换的源码实现"></a>任务切换的源码实现</h1><p>过程差不多了解了，那看看FreeRTOS中怎么实现吧！！</p><p>FreeRTOS有两种方法触发任务切换：</p><ol><li><p>一种就是<code>systick</code>触发<code>PendSV</code>异常，这是最经常使用的。</p></li><li><p>另一种是主动进行切换任务，执行系统调用，比如普通任务可以使用taskYIELD()强制任务切换，中断服务程序中使用<code>portYIELD_FROM_ISR()</code>强制任务切换。</p></li></ol><h2 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h2><p>先说说第一种吧，就在<code>systick</code>中断中调用<code>xPortSysTickHandler()</code>;</p><p>下面是源码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">xPortSysTickHandler</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">vPortRaiseBASEPRI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Increment the RTOS tick. */</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">xTaskIncrementTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> pdFALSE <span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* A context switch is required.  Context switching is performed in            the PendSV interrupt.  Pend the PendSV interrupt. */</span>            portNVIC_INT_CTRL_REG <span class="token operator">=</span> portNVIC_PENDSVSET_BIT<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">vPortClearBASEPRIFromISR</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它的执行过程是这样子的，屏蔽所有中断，因为SysTick以最低的中断优先级运行，所以当这个中断执行时所有中断必须被屏蔽。vPortRaiseBASEPRI();就是屏蔽所有中断的。而且并不需要保存本次中断的值，因为systick的中断优先级是已知的，执行完直接恢复所有中断即可。</p><p>在<code>xTaskIncrementTick()</code>中会对<code>tick</code>的计数值进行自加，然后检查有没有处于就绪态的最优先级任务，如果有，则返回非零值，然后表示需要进行任务切换，而并非马上进行任务切换，此处要注意，它只是向中断状态寄存器<code>bit28</code>位写入<code>1</code>，只是将<code>PendSV</code>挂起，假如没有比<code>PendSV</code>更高优先级的中断，它才会进入<code>PendSV</code>中断服务函数进行任务切换。</p><pre class="line-numbers language-js"><code class="language-js">#define portNVIC_PENDSVSET_BIT        <span class="token punctuation">(</span> 1UL <span class="token operator">&lt;</span><span class="token operator">&lt;</span> 28UL <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后解除屏蔽所有中断。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">vPortClearBASEPRIFromISR</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h2><p>另一种方法是主动进行任务切换，不管是使用taskYIELD()还是portYIELD_FROM_ISR()，最终都会执行下面的代码：</p><pre class="line-numbers language-js"><code class="language-js">#define <span class="token function">portYIELD</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                                                \<span class="token punctuation">{</span>                                                                                \    <span class="token comment" spellcheck="true">/* Set a PendSV to request a context switch. */</span>                             \    portNVIC_INT_CTRL_REG <span class="token operator">=</span> portNVIC_PENDSVSET_BIT<span class="token punctuation">;</span>                             \                                                                           <span class="token function">__dsb</span><span class="token punctuation">(</span> portSY_FULL_READ_WRITE <span class="token punctuation">)</span><span class="token punctuation">;</span>                                            \    <span class="token function">__isb</span><span class="token punctuation">(</span> portSY_FULL_READ_WRITE <span class="token punctuation">)</span><span class="token punctuation">;</span>                                            \<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这<code>portYIELD()</code>其实是一个宏定义来的。同样是向中断状态寄存器<code>bit28位写入1</code>，将<code>PendSV</code>挂起，然后等待任务的切换。</p><p>具体的任务切换源码</p><p>一直在说怎么进行任务切换的，好像还没看到任务切换的源码啊，哎，下面来看看任务切换的真面目！！</p><pre class="line-numbers language-js"><code class="language-js">__asm <span class="token keyword">void</span> <span class="token function">xPortPendSVHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    extern uxCriticalNesting<span class="token punctuation">;</span>    extern pxCurrentTCB<span class="token punctuation">;</span>    extern vTaskSwitchContext<span class="token punctuation">;</span>    PRESERVE8    mrs r0<span class="token punctuation">,</span> psp    isb    ldr r3<span class="token punctuation">,</span> <span class="token operator">=</span>pxCurrentTCB       <span class="token comment" spellcheck="true">/* Get the location of the current TCB. */</span>    ldr r2<span class="token punctuation">,</span> <span class="token punctuation">[</span>r3<span class="token punctuation">]</span>    stmdb r0<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>r4<span class="token operator">-</span>r11<span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">/* Save the remaining registers. */</span>    str r0<span class="token punctuation">,</span> <span class="token punctuation">[</span>r2<span class="token punctuation">]</span>                <span class="token comment" spellcheck="true">/* Save the new top of stack into the first member of the TCB. */</span>    stmdb sp<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>r3<span class="token punctuation">,</span> r14<span class="token punctuation">}</span>    mov r0<span class="token punctuation">,</span> #configMAX_SYSCALL_INTERRUPT_PRIORITY    msr basepri<span class="token punctuation">,</span> r0    dsb    isb    bl vTaskSwitchContext    mov r0<span class="token punctuation">,</span> #<span class="token number">0</span>    msr basepri<span class="token punctuation">,</span> r0    ldmia sp<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>r3<span class="token punctuation">,</span> r14<span class="token punctuation">}</span>    ldr r1<span class="token punctuation">,</span> <span class="token punctuation">[</span>r3<span class="token punctuation">]</span>    ldr r0<span class="token punctuation">,</span> <span class="token punctuation">[</span>r1<span class="token punctuation">]</span>                <span class="token comment" spellcheck="true">/* The first item in pxCurrentTCB is the task top of stack. */</span>    ldmia r0<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>r4<span class="token operator">-</span>r11<span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">/* Pop the registers and the critical nesting count. */</span>    msr psp<span class="token punctuation">,</span> r0    isb    bx r14    nop<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不是我不想看，是我看到汇编就头大啊，这几天我也在看源码，实在是头大。</p><p>找到核心的函数看看就好啦，不管那么多，有兴趣的可以研究一下中断代码，有不懂的也很欢迎你们来问我，一起研究研究，也是不错的选择。</p><p>下面是看重点的地方了：</p><pre class="line-numbers language-js"><code class="language-js">mov r0<span class="token punctuation">,</span>             #configMAX_SYSCALL_INTERRUPT_PRIORITYmsr basepri<span class="token punctuation">,</span> r0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两句代码是关闭中断的。关中断就得干活了，嘿嘿嘿~</p><pre class="line-numbers language-js"><code class="language-js">bl vTaskSwitchContext<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>BL是跳转指令嘛，这个我还是有点懂的。</p><p>调用函数<code>vTaskSwitchContext()</code>,寻找新的任务运行,通过使变量<code>pxCurrentTCB</code>指向新的任务来实现任务切换,然后就是打开中断，退出去了。</p><p>寻找下一个要运行任务</p><p>是不是感觉没什么大不了的样子，如果你是这样子觉得的，可能还没学到家，赶紧去看看<code>FreeRTOS</code>的源码，在<code>config.h</code>配置文件中是不是有一个叫做硬件查找下一个运行的任务呢？<code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code>，这个在<code>FreeRTOS</code>中叫做特殊方法，其实也是硬件查找啦，但是并不是每种单片机都支持的，如果是不支持的话，只能选择软件查找的方法了，就是所谓的通用方法。通用方法我就不多说了，因为我用的是<code>STM32</code>，他是<code>支持硬件方法</code>的，这样子效率更高，所以我也没必要去研究他的软件方法，假如有兴趣的小伙伴可以研读一下源码，有不懂的可以向我提问，源码如下：</p><pre class="line-numbers language-js"><code class="language-js">#define <span class="token function">taskSELECT_HIGHEST_PRIORITY_TASK</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                                            \    <span class="token punctuation">{</span>                                                                                                   \    UBaseType_t uxTopPriority <span class="token operator">=</span> uxTopReadyPriority<span class="token punctuation">;</span>                                                     \                                                                                                        \        <span class="token comment" spellcheck="true">/* Find the highest priority queue that contains ready tasks. */</span>                                \        <span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token function">listLIST_IS_EMPTY</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxReadyTasksLists<span class="token punctuation">[</span> uxTopPriority <span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span>                           \        <span class="token punctuation">{</span>                                                                                               \            <span class="token function">configASSERT</span><span class="token punctuation">(</span> uxTopPriority <span class="token punctuation">)</span><span class="token punctuation">;</span>                                                              \            <span class="token operator">--</span>uxTopPriority<span class="token punctuation">;</span>                                                                            \        <span class="token punctuation">}</span>                                                                                               \                                                                                                        \        <span class="token comment" spellcheck="true">/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of                        \        the same priority get an equal share of the processor time. */</span>                                  \        <span class="token function">listGET_OWNER_OF_NEXT_ENTRY</span><span class="token punctuation">(</span> pxCurrentTCB<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxReadyTasksLists<span class="token punctuation">[</span> uxTopPriority <span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>           \        uxTopReadyPriority <span class="token operator">=</span> uxTopPriority<span class="token punctuation">;</span>                                                             \    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* taskSELECT_HIGHEST_PRIORITY_TASK */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而硬件的方法源码则在下面：</p><pre class="line-numbers language-js"><code class="language-js">    #define <span class="token function">taskSELECT_HIGHEST_PRIORITY_TASK</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                                      \    <span class="token punctuation">{</span>                                                                                               \        UBaseType_t uxTopPriority<span class="token punctuation">;</span>                                                                  \                                                                                                    \        <span class="token comment" spellcheck="true">/* Find the highest priority list that contains ready tasks. */</span>                             \        <span class="token function">portGET_HIGHEST_PRIORITY</span><span class="token punctuation">(</span> uxTopPriority<span class="token punctuation">,</span> uxTopReadyPriority <span class="token punctuation">)</span><span class="token punctuation">;</span>                              \        <span class="token function">configASSERT</span><span class="token punctuation">(</span> <span class="token function">listCURRENT_LIST_LENGTH</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxReadyTasksLists<span class="token punctuation">[</span> uxTopPriority <span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>     \        <span class="token function">listGET_OWNER_OF_NEXT_ENTRY</span><span class="token punctuation">(</span> pxCurrentTCB<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxReadyTasksLists<span class="token punctuation">[</span> uxTopPriority <span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>       \    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* taskSELECT_HIGHEST_PRIORITY_TASK() */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其方法是利用硬件提供的计算前导零指令CLZ，具体宏定义为：</p><pre class="line-numbers language-js"><code class="language-js">#define <span class="token function">portGET_HIGHEST_PRIORITY</span><span class="token punctuation">(</span> uxTopPriority<span class="token punctuation">,</span> uxReadyPriorities <span class="token punctuation">)</span> uxTopPriority <span class="token operator">=</span> <span class="token punctuation">(</span> 31UL <span class="token operator">-</span> <span class="token punctuation">(</span> uint32_t <span class="token punctuation">)</span> <span class="token function">__clz</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> uxReadyPriorities <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>静态变量<code>uxTopReadyPriority</code>包含了处于就绪态任务的最高优先级的信息，因为<code>FreeRTOS</code>运行的永远是处于最高优先级的运行态，而下个处于最高优先级的就绪态则必定会在下次任务切换的时候运行，<code>uxTopReadyPriority</code>使用每一位来表示任务是否处于就绪态，比如变量<code>uxTopReadyPriority</code>的<code>bit0为1</code>，则表示存在优先级为0的任务处于就绪态，<code>bit6为1</code>则表示存在优先级为6的任务处于就绪态。并且，由于<code>bit0</code>的优先级高于<code>bit6</code>，那么下个任务就是bit0的任务运行了（数组越低优先级越高）。由于32位整形数最多只有<code>32</code>位，因此使用这种特殊方法限定最大可用优先级数目为<code>32</code>，即优先级<code>0~31</code>。得到了下个处于最高优先级就绪态任务了，就调用<code>listGET_OWNER_OF_NEXT_ENTRY</code>来获取下一个任务的列表项，然后将该列表项的任务控制块TCB赋值给<code>pxCurrentTCB</code>，那么我们就得到下一个要运行的任务了。</p><p>至此，任务切换已经完成。</p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0开始学FreeRTOS-(列表与列表项)-3</title>
      <link href="/freertos-3/"/>
      <url>/freertos-3/</url>
      
        <content type="html"><![CDATA[<h1 id="FreeRTOS列表-amp-列表项的源码解读"><a href="#FreeRTOS列表-amp-列表项的源码解读" class="headerlink" title="FreeRTOS列表&amp;列表项的源码解读"></a>FreeRTOS列表&amp;列表项的源码解读</h1><p>第一次看列表与列表项的时候，感觉很像是链表，虽然我自己的链表也不太会，但是就是感觉很像。</p><p>在<code>FreeRTOS</code>中，列表与列表项使用得非常多，是<code>FreeRTOS</code>的一个数据结构，学习过数据结构的同学都知道，数据结构能使我们处理数据更加方便快速，能快速找到数据，在<code>FreeRTOS</code>中，这种列表与列表项更是必不可少的，能让我们的系统跑起来更加流畅迅速。</p><p>言归正传，<code>FreeRTOS</code>中使用了大量的列表<code>（List）</code>与列表项<code>（Listitem）</code>，在<code>FreeRTOS</code>调度器中，就是用到这些来跟着任务，了解任务的状态，处于挂起、阻塞态、还是就绪态亦或者是运行态。这些信息都会在各自任务的列表中得到。</p><p>看任务控制块<code>（tskTaskControlBlock）</code>中的两个列表项：</p><pre class="line-numbers language-js"><code class="language-js">ListItem_t xStateListItem<span class="token punctuation">;</span> <span class="token regex">/ * &lt;任务的状态列表项目引用的列表表示该任务的状态（就绪，已阻止，暂停）。*/</span>ListItem_t xEventListItem<span class="token punctuation">;</span> <span class="token regex">/ * &lt;用于从事件列表中引用任务。*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一个是状态的列表项，一个是事件列表项。他们在创建任务就会被初始化，列表项的初始化是根据实际需要来初始化的，下面会说。</p><h1 id="FreeRTOS列表-amp-列表项的结构体"><a href="#FreeRTOS列表-amp-列表项的结构体" class="headerlink" title="FreeRTOS列表&amp;列表项的结构体"></a>FreeRTOS列表&amp;列表项的结构体</h1><p>既然知道列表与列表项的重要性，那么我们来解读FreeRTOS中的list.c与list.h的源码吧。从头文件lsit.h开始，看到定义了一些结构体：</p><pre class="line-numbers language-js"><code class="language-js">struct xLIST_ITEM<span class="token punctuation">{</span>listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE <span class="token regex">/ * &lt;如果configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES设置为1，则设置为已知值。* /</span>configLIST_VOLATILE TickType_t xItemValue<span class="token punctuation">;</span> <span class="token regex">/ * &lt;正在列出的值。在大多数情况下，这用于按降序对列表进行排序。 * /</span>struct xLIST_ITEM <span class="token operator">*</span> configLIST_VOLATILE pxNext<span class="token punctuation">;</span> <span class="token regex">/ * &lt;指向列表中下一个ListItem_t的指针。 * /</span>struct xLIST_ITEM <span class="token operator">*</span> configLIST_VOLATILE pxPrevious<span class="token punctuation">;</span> <span class="token regex">/ * &lt;指向列表中前一个ListItem_t的指针。 * /</span><span class="token keyword">void</span> <span class="token operator">*</span> pvOwner<span class="token punctuation">;</span> <span class="token regex">/ * &lt;指向包含列表项目的对象（通常是TCB）的指针。因此，包含列表项目的对象与列表项目本身之间存在双向链接。 * /</span><span class="token keyword">void</span> <span class="token operator">*</span> configLIST_VOLATILE pvContainer<span class="token punctuation">;</span> <span class="token regex">/ * &lt;指向此列表项目所在列表的指针（如果有）。 * /</span>listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE <span class="token regex">/ * &lt;如果configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES设置为1，则设置为已知值。* /</span><span class="token punctuation">}</span><span class="token punctuation">;</span>typedef struct xLIST_ITEM ListItem_t<span class="token punctuation">;</span> <span class="token regex">/ *由于某种原因，lint希望将其作为两个单独的定义。 * /</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="列表项结构体的一些注意的地方："><a href="#列表项结构体的一些注意的地方：" class="headerlink" title="列表项结构体的一些注意的地方："></a>列表项结构体的一些注意的地方：</h2><p><code>xItemValue</code> 用于列表项的排序，类似1—2—3—4</p><p><code>pxNext</code> 指向下一个列表项的指针</p><p><code>pxPrevious</code> 指向上（前）一个列表项的指针</p><p>这两个指针实现了类似双向链表的功能</p><p><code>pvOwner</code> 指向包含列表项目的对象（<code>通常是任务控制块TCB</code>）的指针。因此，包含列表项目的对象与列表项目本身之间存在双向链接。</p><p><code>pvContainer</code> 记录了该列表项属于哪个列表，说白点就是这个儿子是谁生的。。。</p><p>同时定义了一个MINI的列表项的结构体，MINI列表项是删减版的列表项，因为很多时候不需要完全版的列表项。就不用浪费那么多内存空间了，这或许就是FreeRTOS是轻量级操作系统的原因吧，能省一点是一点。MINI列表项：</p><pre class="line-numbers language-js"><code class="language-js">struct xMINI_LIST_ITEM<span class="token punctuation">{</span>    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE           <span class="token comment" spellcheck="true">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span>    configLIST_VOLATILE TickType_t xItemValue<span class="token punctuation">;</span>    struct xLIST_ITEM <span class="token operator">*</span> configLIST_VOLATILE pxNext<span class="token punctuation">;</span>    struct xLIST_ITEM <span class="token operator">*</span> configLIST_VOLATILE pxPrevious<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>typedef struct xMINI_LIST_ITEM MiniListItem_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再定义了一个列表的结构体，可能看到这里，一些同学已经蒙了，列表与列表项是啥关系啊，按照杰杰的理解，是类似父子关系的，一个列表中，包含多个列表项，就像一个父亲，生了好多孩子，而列表就是父亲，列表项就是孩子。</p><pre class="line-numbers language-js"><code class="language-js">typedef struct xLIST<span class="token punctuation">{</span>listFIRST_LIST_INTEGRITY_CHECK_VALUE <span class="token regex">/ * &lt;如果configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES设置为1，则设置为已知值。* /</span>configLIST_VOLATILE UBaseType_t uxNumberOfItems<span class="token punctuation">;</span>ListItem_t <span class="token operator">*</span> configLIST_VOLATILE pxIndex<span class="token punctuation">;</span> <span class="token regex">/ * &lt;用于遍历列表。 指向由listGET_OWNER_OF_NEXT_ENTRY（）调用返回的后一个列表项。*/</span>MiniListItem_t xListEnd<span class="token punctuation">;</span> <span class="token regex">/ * &lt;List item包含最大可能的项目值，这意味着它始终在列表的末尾，因此用作标记。*/</span>listSECOND_LIST_INTEGRITY_CHECK_VALUE <span class="token regex">/ * &lt;如果configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES设置为1，则设置为已知值。* /</span><span class="token punctuation">}</span> List_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>列表的结构体中值得注意的是：<br><code>uxNumberOfItems</code> 是用来记录列表中列表项的数量的，就是记录父亲有多少个儿子，当然女儿也行~。</p><p><code>pxIndex</code> 是索引编号，用来遍历列表的，调用宏<code>listGET_OWNER_OF_NEXT_ENTRY（）</code>之后索引就会指向返回当前列表项的下一个列表项。</p><p><code>xListEnd</code> 指向的是最后一个列表项，并且这个列表项是<code>MiniListItem</code>属性的，是一个迷你列表项。</p><h1 id="列表的初始化"><a href="#列表的初始化" class="headerlink" title="列表的初始化"></a>列表的初始化</h1><p>  函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vListInitialise</span><span class="token punctuation">(</span> List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxList <span class="token punctuation">)</span><span class="token punctuation">{</span>    pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">/*lint The mini list structure is used as the list end to save RAM.  This is checked and valid. */</span>    pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd<span class="token punctuation">.</span>xItemValue <span class="token operator">=</span> portMAX_DELAY<span class="token punctuation">;</span>    pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd<span class="token punctuation">.</span>pxNext <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/*lint The mini list structure is used as the list end to save RAM.  This is checked and valid. */</span>    pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd<span class="token punctuation">.</span>pxPrevious <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*lint The mini list structure is used as the list end to save RAM.  This is checked and valid. */</span>    pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token operator">=</span> <span class="token punctuation">(</span> UBaseType_t <span class="token punctuation">)</span> 0U<span class="token punctuation">;</span>    <span class="token function">listSET_LIST_INTEGRITY_CHECK_1_VALUE</span><span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listSET_LIST_INTEGRITY_CHECK_2_VALUE</span><span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将列表的索引指向列表中的<code>xListEnd</code>，也就是末尾的列表项<code>（迷你列表项）</code></p><p>列表项的<code>xItemValue</code>数值为<code>portMAX_DELAY</code>，也就是<code>0xffffffffUL</code>，如果在16位处理器中则为<code>0xffff</code>。</p><p>列表项的pxNext与pxPrevious这两个指针都指向自己本身<code>xListEnd</code>。</p><p>初始化完成的时候列表项的数目为<code>0</code>个。因为还没添加列表项嘛~。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos4.png" alt="freertos4"></p><h1 id="列表项的初始化"><a href="#列表项的初始化" class="headerlink" title="列表项的初始化"></a>列表项的初始化</h1><p> 函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vListInitialiseItem</span><span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxItem <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* Make sure the list item is not recorded as being on a list. */</span>    pxItem<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> NULL<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Write known values into the list item if    configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span>    <span class="token function">listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE</span><span class="token punctuation">(</span> pxItem <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE</span><span class="token punctuation">(</span> pxItem <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只需要让列表项的pvContainer指针指向NULL即可，这样子就使得列表项不属于任何一个列表，因为列表项的初始化是要根据实际的情况来进行初始化的。</p><p>例如任务创建时用到的一些列表项初始化：</p><pre class="line-numbers language-js"><code class="language-js">pxNewTCB<span class="token operator">-</span><span class="token operator">></span>pcTaskName<span class="token punctuation">[</span> configMAX_TASK_NAME_LEN <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>pxNewTCB<span class="token operator">-</span><span class="token operator">></span>uxPriority <span class="token operator">=</span> uxPriority<span class="token punctuation">;</span>pxNewTCB<span class="token operator">-</span><span class="token operator">></span>uxBasePriority <span class="token operator">=</span> uxPriority<span class="token punctuation">;</span>pxNewTCB<span class="token operator">-</span><span class="token operator">></span>uxMutexesHeld <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">vListInitialiseItem</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxNewTCB<span class="token operator">-</span><span class="token operator">></span>xStateListItem <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">vListInitialiseItem</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxNewTCB<span class="token operator">-</span><span class="token operator">></span>xEventListItem <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>又或者是在定时器相关的初始化中：</p><pre class="line-numbers language-js"><code class="language-js">pxNewTimer<span class="token operator">-</span><span class="token operator">></span>pcTimerName <span class="token operator">=</span> pcTimerName<span class="token punctuation">;</span>pxNewTimer<span class="token operator">-</span><span class="token operator">></span>xTimerPeriodInTicks <span class="token operator">=</span> xTimerPeriodInTicks<span class="token punctuation">;</span>pxNewTimer<span class="token operator">-</span><span class="token operator">></span>uxAutoReload <span class="token operator">=</span> uxAutoReload<span class="token punctuation">;</span>pxNewTimer<span class="token operator">-</span><span class="token operator">></span>pvTimerID <span class="token operator">=</span> pvTimerID<span class="token punctuation">;</span>pxNewTimer<span class="token operator">-</span><span class="token operator">></span>pxCallbackFunction <span class="token operator">=</span> pxCallbackFunction<span class="token punctuation">;</span><span class="token function">vListInitialiseItem</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxNewTimer<span class="token operator">-</span><span class="token operator">></span>xTimerListItem <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="列表项的末尾插入"><a href="#列表项的末尾插入" class="headerlink" title="列表项的末尾插入"></a>列表项的末尾插入</h1><p>  函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vListInsertEnd</span><span class="token punctuation">(</span> List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxList<span class="token punctuation">,</span> ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxNewListItem <span class="token punctuation">)</span><span class="token punctuation">{</span>    ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxIndex <span class="token operator">=</span> pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token punctuation">;</span>    <span class="token function">listTEST_LIST_INTEGRITY</span><span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listTEST_LIST_ITEM_INTEGRITY</span><span class="token punctuation">(</span> pxNewListItem <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listGET_OWNER_OF_NEXT_ENTRY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token operator">*</span><span class="token operator">/</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIndex<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  1 </span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  2</span>    <span class="token comment" spellcheck="true">/* Only used during decision coverage testing. */</span>    <span class="token function">mtCOVERAGE_TEST_DELAY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  3 </span>    pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//  4</span>    <span class="token comment" spellcheck="true">/* Remember which list the item is in. */</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> pxList<span class="token punctuation">;</span>    <span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>传入的参数：</p><p><code>pxList</code>：列表项要插入的列表。</p><p><code>pxNewListItem</code>：要插入的列表项是什么。</p><p>从末尾插入，那就要先知道哪里是头咯，我们在列表中的成员<code>pxIndex</code>就是用来遍历列表项的啊，那它指向的地方就是列表项的头，那么既然FreeRTOS中的列表很像数据结构中的双向链表，那么，我们可以把它看成一个环，是首尾相连的，那么函数中说的末尾，就是列表项头的前一个，很显然其结构图应该是下图这样子的（初始化结束后<code>pxIndex</code>指向了<code>xListEnd</code>）：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos5.png" alt="freertos5"></p><p>为什么是这样子的呢，一句句代码来解释：</p><p>一开始：</p><pre class="line-numbers language-js"><code class="language-js">ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxIndex <span class="token operator">=</span> pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>保存了一开始的索引列表项（<code>xListEnd</code>）的指向。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIndex<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//  1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新列表项的下一个指向为索引列表项，也就是绿色的箭头。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>刚开始我们初始化完成的时候<code>pxIndex-&gt;pxPrevious</code>的指向为自己xListEnd，那么<code>xNewListItem-&gt;pxPrevious</code>的指向为xListEnd。如2紫色的箭头。</p><pre class="line-numbers language-js"><code class="language-js">pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>索引列表项（xListEnd）的上一个列表项还是自己，那么自己的下一个列表项指向就是指向了<code>pxNewListItem</code>。</p><pre class="line-numbers language-js"><code class="language-js">pxIndex<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//  4</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这句就很容易理解啦。如图的4橙色的箭头。</p><p>插入完毕的时候标记一下新的列表项插入了哪个列表，并且将<code>uxNumberOfItems</code>进行加一，以表示多了一个列表项。</p><p>为什么源码要这样子写呢？因为这只是两个列表项，一个列表含有多个列表项，那么这段代码的通用性就很强了。无论原本列表中有多少个列表项，也无论<code>pxIndex</code>指向哪个列表项！</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos6.png" alt="freertos6"></p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos7.png" alt="freertos7"></p><p>看看是不是按照源码中那样插入呢？</p><h1 id="列表项的插入"><a href="#列表项的插入" class="headerlink" title="列表项的插入"></a>列表项的插入</h1><p> 源码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token function">vListInsert</span><span class="token punctuation">(</span> List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxList<span class="token punctuation">,</span> ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxNewListItem <span class="token punctuation">)</span><span class="token punctuation">{</span>ListItem_t <span class="token operator">*</span>pxIterator<span class="token punctuation">;</span><span class="token keyword">const</span> TickType_t xValueOfInsertion <span class="token operator">=</span> pxNewListItem<span class="token operator">-</span><span class="token operator">></span>xItemValue<span class="token punctuation">;</span>    <span class="token function">listTEST_LIST_INTEGRITY</span><span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">listTEST_LIST_ITEM_INTEGRITY</span><span class="token punctuation">(</span> pxNewListItem <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span> xValueOfInsertion <span class="token operator">==</span> portMAX_DELAY <span class="token punctuation">)</span>   <span class="token punctuation">{</span>        pxIterator <span class="token operator">=</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd<span class="token punctuation">.</span>pxPrevious<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span> pxIterator <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>xItemValue <span class="token operator">&lt;=</span> xValueOfInsertion<span class="token punctuation">;</span> pxIterator <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* There is nothing to do here, just iterating to the wanted            insertion position. */</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIterator<span class="token punctuation">;</span>    pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Remember which list the item is in.  This allows fast removal of the    item later. */</span>    pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> pxList<span class="token punctuation">;</span>    <span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>传入的参数：</p><p><code>pxList</code>：列表项要插入的列表。<br><code>pxNewListItem</code>：要插入的列表项是什么。</p><p>pxList决定了插入哪个列表，<code>pxNewListItem</code>中的<code>xItemValue</code>值决定了列表项插入列表的位置。</p><pre class="line-numbers language-js"><code class="language-js">ListItem_t <span class="token operator">*</span>pxIterator<span class="token punctuation">;</span>  <span class="token keyword">const</span> TickType_t xValueOfInsertion <span class="token operator">=</span> pxNewListItem<span class="token operator">-</span><span class="token operator">></span>xItemValue<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>定义一个辅助的列表项pxIterator，用来迭代找出插入新列表项的位置，并且保存获取要插入的列表项<code>pxNewListItem</code>的xItemValue。</p><p>如果打开了列表项完整性检查，就要用户实现<code>configASSERT()</code>，源码中有说明。</p><p>既然是要插入列表项，那么肯定是要知道列表项的位置了，如果新插入列表项的<code>xItemValue</code>是最大的话<code>（portMAX_DELAY）</code>，就直接插入列表项的末尾。否则就需要比较列表中各个列表项的<code>xItemValue</code>的大小来进行排列。然后得出新列表项插入的位置。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span><span class="token punctuation">(</span> pxIterator <span class="token operator">=</span> <span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span><span class="token punctuation">;</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>xItemValue <span class="token operator">&lt;=</span> xValueOfInsertion<span class="token punctuation">;</span> pxIterator <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面源码就是实现比较的过程。</p><p>与上面的从列表项末尾插入的源码一样，FreeRTOS的代码通用性很强，逻辑思维也很强。</p><p>如果列表中列表项的数量为0，那么插入的列表项就是在初始化列表项的后面。如下图所示：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos8.png" alt="freertos8"></p><h2 id="过程分析："><a href="#过程分析：" class="headerlink" title="过程分析："></a>过程分析：</h2><p>新列表项的<code>pxNext</code>指向<code>pxIterator-&gt;pxNext</code>，也就是指向了<code>xListEnd（pxIterator）</code>。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而xListEnd（pxIterator）的pxPrevious指向则为pxNewListItem。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新列表项的<code>（pxPrevious）</code>指针指向<code>xListEnd（pxIterator）</code></p><p><code>pxIterator</code> 的 <code>pxNext</code> 指向了<code>新</code>列表项</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIterator<span class="token punctuation">;</span>pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>与从末尾插入列表项其实是一样的，前提是当前列表中列表项的数目为0。</p><p>假如列表项中已经有了元素呢，过程又是不一样的了。原来的列表是下图这样子的：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos9.png" alt="freertos9"></p><p>假设插入的列表项的<code>xItemValue</code>是<code>2</code>，而原有的列表项的<code>xItemValue</code>值是<code>3</code>，那么，按照源码，我们插入的列表项是在中间了。而pxIterator则是①号列表项。</p><p>插入后的效果：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos10.png" alt="freertos10"></p><p>分析一下插入的过程：</p><p>新的列表项的<code>pxNext</code>指向的是<code>pxIterator-&gt;pxNext</code>，也就是③号列表项。因为一开始pxIterator-&gt;pxNext=指向的就是③号列表项！！</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而pxNewListItem-&gt;pxNext 即③号列表项的指向上一个列表项指针（<code>pxPrevious</code>）的则指向新插入的列表项，也就是②号列表项了。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新插入列表项的指向上一个列表项的指针<code>pxNewListItem-&gt;pxPrevious</code>指向了辅助列表项<code>pxIterator</code>。很显然要连接起来嘛！</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxIterator<span class="token punctuation">;</span>     <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同理，<code>pxIterator</code>列表项的指向下一个列表项的指针则指向新插入的列表项了<code>pxNewListItem</code>。</p><pre class="line-numbers language-js"><code class="language-js">pxIterator<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxNewListItem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而其他没改变指向的地方不需改动。（图中的两条直线做的连接线是不需要改动的）</p><p>当插入完成的时候，记录一下新插入的列表项属于哪个列表。并且让该列表下的列表项数目加一。</p><pre class="line-numbers language-js"><code class="language-js">pxNewListItem<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> pxList<span class="token punctuation">;</span>         <span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="删除列表项"><a href="#删除列表项" class="headerlink" title="删除列表项"></a>删除列表项</h1><pre><code>源码：</code></pre><pre class="line-numbers language-js"><code class="language-js">UBaseType_t <span class="token function">uxListRemove</span><span class="token punctuation">(</span> ListItem_t <span class="token operator">*</span> <span class="token keyword">const</span> pxItemToRemove <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">/* The list item knows which list it is in.  Obtain the list from the listitem. */</span>List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxList <span class="token operator">=</span> <span class="token punctuation">(</span> List_t <span class="token operator">*</span> <span class="token punctuation">)</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pvContainer<span class="token punctuation">;</span>    pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>    pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Only used during decision coverage testing. */</span>    <span class="token function">mtCOVERAGE_TEST_DELAY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Make sure the index is left pointing to a valid item. */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">==</span> pxItemToRemove <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pvContainer <span class="token operator">=</span> NULL<span class="token punctuation">;</span>    <span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems <span class="token punctuation">)</span><span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> pxList<span class="token operator">-</span><span class="token operator">></span>uxNumberOfItems<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  其实删除是很简单的，不用想都知道，要删除列表项，那肯定要知道该列表项是属于哪个列表吧，pvContainer就是记录列表项是属于哪个列表的。</p><p>  删除就是把列表中的列表项从列表中去掉，其本质其实就是把他们的连接关系删除掉，然后让删除的列表项的前后两个列表连接起来就行了，假如是只有一个列表项，那么删除之后，列表就回到了初始化的状态了。</p><pre class="line-numbers language-js"><code class="language-js">pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token operator">-</span><span class="token operator">></span>pxPrevious <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span>pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token operator">-</span><span class="token operator">></span>pxNext <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两句代码就实现了将删除列表项的前后两个列表项连接起来。</p><p>按照上面的讲解可以理解这两句简单的代码啦。</p><p>假如删除的列表项是当前索引的列表项，那么在删除之后，列表中的pxIndex就要指向删除列表项的上一个列表项了。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span> pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">==</span> pxItemToRemove <span class="token punctuation">)</span>  <span class="token punctuation">{</span>     pxList<span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> pxItemToRemove<span class="token operator">-</span><span class="token operator">></span>pxPrevious<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当然还要把当前删除的列表项的<code>pvContainer</code>指向<code>NULL</code>，让它不属于任何一个列表，因为，删除的本质是删除的仅仅是列表项的连接关系，其内存是没有释放掉的，假如是动态内存分配的话。</p><p>并且要把当前列表中列表项的数目返回一下。</p><p>至此，列表的源码基本讲解完毕。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>大家还可以了解一下遍历列表的宏，它在list.h文件中：</p><pre class="line-numbers language-js"><code class="language-js">define <span class="token function">listGET_OWNER_OF_NEXT_ENTRY</span><span class="token punctuation">(</span> pxTCB<span class="token punctuation">,</span> pxList <span class="token punctuation">)</span>                                        \<span class="token punctuation">{</span>                                                                                            \List_t <span class="token operator">*</span> <span class="token keyword">const</span> pxConstList <span class="token operator">=</span> <span class="token punctuation">(</span> pxList <span class="token punctuation">)</span><span class="token punctuation">;</span>                                                    \    <span class="token comment" spellcheck="true">/* Increment the index to the next item and return the item, ensuring */</span>                \    <span class="token comment" spellcheck="true">/* we don't return the marker used at the end of the list.  */</span>                          \    <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span>                            \    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">==</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>xListEnd <span class="token punctuation">)</span> <span class="token punctuation">)</span>  \    <span class="token punctuation">{</span>                                                                                       \         <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex <span class="token operator">=</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token operator">-</span><span class="token operator">></span>pxNext<span class="token punctuation">;</span>                        \    <span class="token punctuation">}</span>                                                                                       \    <span class="token punctuation">(</span> pxTCB <span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span> pxConstList <span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>pxIndex<span class="token operator">-</span><span class="token operator">></span>pvOwner<span class="token punctuation">;</span>                                          \<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一个宏，用于列表的遍历，返回的是列表中列表项的<code>pxOwner</code>成员，每次调用这个宏（函数）的时候，其pxIndex索引会指向当前返回列表项的下一个列表项。</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0开始学FreeRTOS-(创建任务)-2</title>
      <link href="/freertos-2/"/>
      <url>/freertos-2/</url>
      
        <content type="html"><![CDATA[<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>开始今天的内容之前，先补充一下上篇文章<a href="https://jiejietop.gitee.io/freertos-1/" target="_blank" rel="noopener">从单片机到操作系统-1</a>的一点点遗漏的知识点。</p><pre class="line-numbers language-js"><code class="language-js"> BaseType_t <span class="token function">xTaskCreate</span><span class="token punctuation">(</span>       TaskFunction_t pvTaskCode<span class="token punctuation">,</span>                               <span class="token keyword">const</span> char <span class="token operator">*</span> <span class="token keyword">const</span> pcName<span class="token punctuation">,</span>                               uint16_t usStackDepth<span class="token punctuation">,</span>                               <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters<span class="token punctuation">,</span>                               UBaseType_t uxPriority<span class="token punctuation">,</span>                               TaskHandle_t <span class="token operator">*</span>pvCreatedTask                           <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 创建任务中的堆栈大小问题，在task.h中有这样子的描述：</p><pre class="line-numbers language-js"><code class="language-js"> <span class="token comment" spellcheck="true">/*** @param usStackDepth The size of the task stack specified as the number of variables the stack * can hold - not the number of bytes.  For example, if the stack is 16 bits wide and  * usStackDepth is defined as 100, 200 byteswill be allocated for stack storage.*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当任务创建时，内核会分为每个任务分配属于任务自己的唯一堆栈。usStackDepth 值用于告诉内核为它应该分配多大的栈空间。</p><p>这个值指定的是栈空间可以保存多少个字(word) ，而不是多少个字节(byte)。</p><p>文档也有说明，如果是16位宽度的话，假如usStackDepth = 100；那么就是200个字节（byte）。</p><p>当然，我用的是stm32，32位宽度的， usStackDepth=100；那么就是400个字节（byte）。</p><p>好啦，补充完毕。下面正式开始我们今天的主题。</p><hr><p>我自己学的是应用层的东西，很多底层的东西我也不懂，水平有限，出错了还请多多包涵。</p><p>其实我自己写文章的时候也去跟着火哥的书看着底层的东西啦，但是本身自己也是不懂，不敢乱写。所以，这个《从单片机到操作系统》系列的文章，我会讲一点底层，更多的是应用层，主要是用的方面。</p><p>按照一般的写代码的习惯，在main函数里面各类初始化完毕了，并且创建任务成功了，那么，可以开启任务调度了。</p><pre class="line-numbers language-js"><code class="language-js">int <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">NVIC_PriorityGroupConfig</span><span class="token punctuation">(</span>NVIC_PriorityGroup_4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置系统中断优先级分组4    </span>    <span class="token function">Delay_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//延时函数初始化     </span>    <span class="token function">Uart_Init</span><span class="token punctuation">(</span><span class="token number">115200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//初始化串口</span>    <span class="token function">LED_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//初始化LED</span>    <span class="token function">KEY_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//创建开始任务</span>    <span class="token function">xTaskCreate</span><span class="token punctuation">(</span><span class="token punctuation">(</span>TaskFunction_t <span class="token punctuation">)</span>start_task<span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">//任务函数</span>                <span class="token punctuation">(</span><span class="token keyword">const</span> char<span class="token operator">*</span>    <span class="token punctuation">)</span><span class="token string">"start_task"</span><span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">//任务名称</span>                <span class="token punctuation">(</span>uint16_t       <span class="token punctuation">)</span>START_STK_SIZE<span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">//任务堆栈大小</span>                <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span>          <span class="token punctuation">)</span>NULL<span class="token punctuation">,</span>                  <span class="token comment" spellcheck="true">//传递给任务函数的参数</span>                <span class="token punctuation">(</span>UBaseType_t    <span class="token punctuation">)</span>START_TASK_PRIO<span class="token punctuation">,</span>       <span class="token comment" spellcheck="true">//任务优先级</span>                <span class="token punctuation">(</span>TaskHandle_t<span class="token operator">*</span>  <span class="token punctuation">)</span><span class="token operator">&amp;</span>StartTask_Handler<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//任务句柄              </span>    <span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//开启任务调度</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>来大概看看分析一下创建任务的过程，虽然说会用就行，但是也是要知道了解一下的。</p><p>注意：下面说的创建任务均为xTaskCreate（动态创建）而非静态创建。</p><pre class="line-numbers language-js"><code class="language-js">pxStack <span class="token operator">=</span> <span class="token punctuation">(</span> StackType_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token function">pvPortMalloc</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span> size_t <span class="token punctuation">)</span> usStackDepth <span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">sizeof</span><span class="token punctuation">(</span> StackType_t <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*lint !e961 MISRA exception as the casts are only redundant for some ports. */</span>             <span class="token keyword">if</span><span class="token punctuation">(</span> pxStack <span class="token operator">!=</span> NULL <span class="token punctuation">)</span>             <span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">/* Allocate space for the TCB. */</span>                 pxNewTCB <span class="token operator">=</span> <span class="token punctuation">(</span> TCB_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token function">pvPortMalloc</span><span class="token punctuation">(</span> <span class="token function">sizeof</span><span class="token punctuation">(</span> TCB_t <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">/*lint !e961 MISRA exception as the casts are only redundant for some paths. */</span>                 <span class="token keyword">if</span><span class="token punctuation">(</span> pxNewTCB <span class="token operator">!=</span> NULL <span class="token punctuation">)</span>                 <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">/* Store the stack location in the TCB. */</span>                    pxNewTCB<span class="token operator">-</span><span class="token operator">></span>pxStack <span class="token operator">=</span> pxStack<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span>                <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">/* The stack cannot be used as the TCB was not created.  Free                    it again. */</span>                    <span class="token function">vPortFree</span><span class="token punctuation">(</span> pxStack <span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                pxNewTCB <span class="token operator">=</span> NULL<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先是利用<code>pvPortMalloc</code>给任务的堆栈分配空间，<code>if( pxStack != NULL )</code>如果内存申请成功，就接着给任务控制块申请内存。<code>pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );</code>同样是使用<code>pvPortMalloc();</code>如果任务控制块内存申请失败则释放 之前已经申请成功的任务堆栈<code>的内存vPortFree( pxStack );</code></p><p>然后就初始化任务相关的东西，并且将新初始化的任务控制块添加到列表中<code>prvAddNewTaskToReadyList( pxNewTCB );</code></p><p>  最后返回任务的状态，如果是成功了就是<code>pdPASS</code>，假如失败了就是返回<code>errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;</code></p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">prvInitialiseNewTask</span><span class="token punctuation">(</span>    pxTaskCode<span class="token punctuation">,</span>                          pcName<span class="token punctuation">,</span>                          <span class="token punctuation">(</span> uint32_t <span class="token punctuation">)</span> usStackDepth<span class="token punctuation">,</span>                         pvParameters<span class="token punctuation">,</span>                         uxPriority<span class="token punctuation">,</span>                          pxCreatedTask<span class="token punctuation">,</span>                         pxNewTCB<span class="token punctuation">,</span>                          NULL <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">prvAddNewTaskToReadyList</span><span class="token punctuation">(</span> pxNewTCB <span class="token punctuation">)</span><span class="token punctuation">;</span>            xReturn <span class="token operator">=</span> pdPASS<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            xReturn <span class="token operator">=</span> errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> xReturn<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 相关宏定义</span>#define pdPASS            <span class="token punctuation">(</span> pdTRUE <span class="token punctuation">)</span>#define pdTRUE            <span class="token punctuation">(</span> <span class="token punctuation">(</span> BaseType_t <span class="token punctuation">)</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token comment" spellcheck="true">/* FreeRTOS error definitions. */</span>#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY    <span class="token punctuation">(</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体的<code>static void prvInitialiseNewTask()</code>实现请参考<code>FreeRTOS</code>的<code>tasks.c</code>文件的<code>767</code>行代码。具体的<code>static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )</code>实现请参考<code>FreeRTOS</code>的<code>tasks.c</code>文件的<code>963</code>行代码。</p><p>因为这些是<code>tasks.c</code>中的<code>静态的函数</code>，仅供xTaskCreate创建任务内部调用的，我们无需理会这些函数的实现过程，当然如果需要请自行了解。</p><p>创建完任务就开启任务调度了：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//开启任务调度</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在任务调度里面，会创建一个空闲任务（我们将的都是动态创建任务，静态创建其实一样的）</p><pre class="line-numbers language-js"><code class="language-js">xReturn <span class="token operator">=</span> <span class="token function">xTaskCreate</span><span class="token punctuation">(</span>    prvIdleTask<span class="token punctuation">,</span>                          <span class="token string">"IDLE"</span><span class="token punctuation">,</span> configMINIMAL_STACK_SIZE<span class="token punctuation">,</span>                          <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> NULL<span class="token punctuation">,</span>                          <span class="token punctuation">(</span> tskIDLE_PRIORITY <span class="token operator">|</span> portPRIVILEGE_BIT <span class="token punctuation">)</span><span class="token punctuation">,</span>                          <span class="token operator">&amp;</span>xIdleTaskHandle <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */</span>    <span class="token punctuation">}</span>相关宏定义：#define tskIDLE_PRIORITY            <span class="token punctuation">(</span> <span class="token punctuation">(</span> UBaseType_t <span class="token punctuation">)</span> 0U <span class="token punctuation">)</span>#ifndef portPRIVILEGE_BIT    #define portPRIVILEGE_BIT <span class="token punctuation">(</span> <span class="token punctuation">(</span> UBaseType_t <span class="token punctuation">)</span> <span class="token number">0x00</span> <span class="token punctuation">)</span>#endif#define configUSE_TIMERS                        <span class="token number">1</span>                               <span class="token comment" spellcheck="true">//为1时启用软件定时器</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的代码我们可以看出，空闲任务的优先级是tskIDLE_PRIORITY为0，也就是说空闲任务的优先级最低。当CPU没事干的时候才执行空闲任务，以待随时切换优先级更高的任务。</p><p>如果使用了软件定时器的话，我们还需要创建定时器任务，创建的函数是：</p><pre class="line-numbers language-js"><code class="language-js">#<span class="token keyword">if</span> <span class="token punctuation">(</span> configUSE_TIMERS <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span>    BaseType_t <span class="token function">xTimerCreateTimerTask</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后还要把中断关一下</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">portDISABLE_INTERRUPTS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>至于为什么关中断，也有说明：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* Interrupts are turned off here, toensure a tick does not occurbefore or during the call toxPortStartScheduler().  The stacks ofthe created tasks contain a status wordwith interrupts switched onso interrupts will automatically getre-enabled when the first taskstarts to run. */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>中断在这里被关闭，以确保不会发生滴答在调用xPortStartScheduler（）之前或期间。堆栈创建的任务包含一个打开中断的状态字因此中断将在第一个任务时自动重新启用开始运行。</p><p>那么如何打开中断呢？？？？这是个很重要的问题</p><p>别担心，我们在SVC中断服务函数里面就会打开中断的</p><p>看代码：</p><pre class="line-numbers language-js"><code class="language-js">__asm <span class="token keyword">void</span> <span class="token function">vPortSVCHandler</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>         PRESERVE8         ldr    r3<span class="token punctuation">,</span> <span class="token operator">=</span>pxCurrentTCB  <span class="token comment" spellcheck="true">/* Restore the context. */</span>         ldrr1<span class="token punctuation">,</span> <span class="token punctuation">[</span>r3<span class="token punctuation">]</span>                            <span class="token comment" spellcheck="true">/* UsepxCurrentTCBConst to get the pxCurrentTCB address. */</span>         ldrr0<span class="token punctuation">,</span> <span class="token punctuation">[</span>r1<span class="token punctuation">]</span>                            <span class="token comment" spellcheck="true">/* Thefirst item in pxCurrentTCB is the task top of stack. */</span>         ldmiar0<span class="token operator">!</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>r4<span class="token operator">-</span>r11<span class="token punctuation">}</span>             <span class="token comment" spellcheck="true">/* Pop theregisters that are not automatically saved on exception entry and the criticalnesting count. */</span>         msrpsp<span class="token punctuation">,</span> r0                                   <span class="token comment" spellcheck="true">/*Restore the task stack pointer. */</span>         isb         movr0<span class="token punctuation">,</span> #<span class="token number">0</span>         msr  basepri<span class="token punctuation">,</span> r0         orrr14<span class="token punctuation">,</span> #<span class="token number">0xd</span>         bxr14<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">msr  basepri<span class="token punctuation">,</span> r0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就是它把中断打开的。看不懂没所谓，我也不懂汇编，看得懂知道就好啦。</p><pre class="line-numbers language-js"><code class="language-js">xSchedulerRunning <span class="token operator">=</span> pdTRUE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>任务调度开始运行</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* If configGENERATE_RUN_TIME_STATS isdefined then the followingmacro must be defined to configure thetimer/counter used to generatethe run time counter time base. */</span><span class="token function">portCONFIGURE_TIMER_FOR_RUN_TIME_STATS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果<code>configGENERATE_RUN_TIME_STATS</code>使用时间统计功能，这个宏为<code>1</code>，那么用户必须实现一个宏<code>portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();</code>用来配置一个定时器或者计数器。</p><p>来到我们的重点了，开启任务调度，那么任务到这了就不会返回了。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">xPortStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> pdFALSE <span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/*Should not reach here as if the scheduler is running the    functionwill not return. */</span>                    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就能开启第一个任务了，感觉好难是吧，我一开始也是觉得的，但是写了这篇文章，觉得还行吧，也不算太难，可能也是在查看代码跟别人的书籍吧，写东西其实还是蛮好的，能加深理解，写过文章的人就知道，懂了不一定能写出来，所以，我还是很希望朋友们能投稿的。杰杰随时欢迎。。。</p><p>开始任务就按照套路模板添加自己的代码就好啦，很简单的。</p><p>先创建任务：</p><pre class="line-numbers language-js"><code class="language-js"> <span class="token function">xTaskCreate</span><span class="token punctuation">(</span><span class="token punctuation">(</span>TaskFunction_t <span class="token punctuation">)</span>led0_task<span class="token punctuation">,</span>                  <span class="token punctuation">(</span><span class="token keyword">const</span> char<span class="token operator">*</span>    <span class="token punctuation">)</span><span class="token string">"led0_task"</span><span class="token punctuation">,</span>                <span class="token punctuation">(</span>uint16_t       <span class="token punctuation">)</span>LED0_STK_SIZE<span class="token punctuation">,</span>              <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span>          <span class="token punctuation">)</span>NULL<span class="token punctuation">,</span>                                                  <span class="token punctuation">(</span>UBaseType_t    <span class="token punctuation">)</span>LED0_TASK_PRIO<span class="token punctuation">,</span>                 <span class="token punctuation">(</span>TaskHandle_t<span class="token operator">*</span>  <span class="token punctuation">)</span><span class="token operator">&amp;</span>LED0Task_Handler<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//创建LED1任务</span>  <span class="token function">xTaskCreate</span><span class="token punctuation">(</span><span class="token punctuation">(</span>TaskFunction_t <span class="token punctuation">)</span>led1_task<span class="token punctuation">,</span>                  <span class="token punctuation">(</span><span class="token keyword">const</span> char<span class="token operator">*</span>    <span class="token punctuation">)</span><span class="token string">"led1_task"</span><span class="token punctuation">,</span>                <span class="token punctuation">(</span>uint16_t       <span class="token punctuation">)</span>LED1_STK_SIZE<span class="token punctuation">,</span>              <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span>          <span class="token punctuation">)</span>NULL<span class="token punctuation">,</span>              <span class="token punctuation">(</span>UBaseType_t    <span class="token punctuation">)</span>LED1_TASK_PRIO<span class="token punctuation">,</span>              <span class="token punctuation">(</span>TaskHandle_t<span class="token operator">*</span>  <span class="token punctuation">)</span><span class="token operator">&amp;</span>LED1Task_Handler<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建完任务就开启任务调度：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token number">1</span><span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//开启任务调度</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后具体实现任务函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//LED0任务函数</span><span class="token keyword">void</span> <span class="token function">led0_task</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pvParameters<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>       LED0<span class="token operator">=</span><span class="token operator">~</span>LED0<span class="token punctuation">;</span>       <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//LED1任务函数</span><span class="token keyword">void</span> <span class="token function">led1_task</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pvParameters<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>       LED1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>       <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       LED1<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>       <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好啦，今天的介绍到这了为止，后面还会持续更新，敬请期待哦~</p><p>欢迎大家一起来讨论操作系统的知识</p><p>我们的群号是：783234154</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0开始学FreeRTOS-1</title>
      <link href="/freertos-1/"/>
      <url>/freertos-1/</url>
      
        <content type="html"><![CDATA[<p>我们知道，（单核）单片机某一时刻只能干一件事，会造成单片机资源的浪费，而且还有可能响应不够及时，所以，在比较庞大的程序或者是要求实时性比较高的情况下，我们可以移植操作系统。因为这种情况下操作系统比裸机方便很多，效率也高。下面，杰杰将带你们走进FreeRTOS的世界随便看看。</p><p>下面正式开始本文内容。</p><p>在没有用到操作系统之前，单片机的运行是顺序执行，就是说，很多时候，单片机在执行这件事的时候，无法切换到另一件事。这就造成了资源的浪费，以及错过了突发的信号。那么，用上了操作系统的时候，很容易避免了这样的问题。</p><p>很简单，从感觉上，单片机像是同时在干多件事，为什么说像呢，因为单片机的执行速度很快，快到我们根本没办法感觉出来，但是同时做两件事是不可能的，在（单核）单片机中，因为它的硬件结构决定了CPU只能在一个时间段做一件事如：<br><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos-1.jpg" alt="not os"></p><p>如这张图，都是按照顺序来执行这些事的，假设每个任务（事件）的time无限小，小到我们根本没法分辨出来，那么我们也会感觉单片机在同时做这六件事。</p><p>真相就是：所有任务都好像在执行，但实际上在任何一个时刻都只有一个任务在执行</p><p>如是加上了中断系统的话，就可以将上图理解为下图：<br><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos2.png" alt="os"></p><p>通常把程序分为两部分：前台系统和后台系统。 简单的小系统通常是前后台系统，这样的程序包括一个死循环和若干个中断服务程序：应用程序是一个无限循环，循环中调用API函数完成所需的操作，这个大循环就叫做后台系统。中断服务程序用于处理系统的异步事件，也就是前台系统。前台是中断级，后台是任务级。简单来说就是程序一直按顺序执行，有中断来了就做中断（前台）的事情。处理完中断（前台）的事情，就回到大循环（后台）继续按顺序执行。</p><p>那么问题来了，这样子的系统肯定不是好的系统，我在做第一个任务的时候想做第四个任务，根本做不到啊，其实也能做到，让程序执行的指针cp指向第四个任务就行了。但是任务一旦复杂，那么整个工程的代码的结构，可移植性，及可读性，肯定会差啦。</p><p> FreeRTOS</p><p>那么操作系统的移植就是不可或缺的了。什么叫RTOS？：Real Time OS，实时操作系统，强调的是实时性，就是要规定什么时间该做什么任务。那么假如同一个时刻，需要执行两个或者多个任务怎么办。那么我们可以人为地把任务划分优先级，哪个任务重要，就先做，因为前面一直强调，单片机无法同时做两件事，在某一个时刻只能做一件事。</p><p>那么FreeRTOS是怎么操作的呢？先看看FreeRTOS的内核吧：</p><p>FreeRTOS是一个可裁剪、可剥夺型的多任务内核，而且没有任务数限制。FreeRTOS提供了实时操作系统所需的所有功能，包括资源管理、同步、任务通信等。 FreeRTOS是用C和汇编来写的，其中绝大部分都是用C语言编写的，只有极少数的与处理器密切相关的部分代码才是用汇编写的，FreeRTOS结构简洁，可读性很强！RTOS的内核负责管理所有的任务，内核决定了运行哪个任务，何时停止当前任务切换到其他任务，这个是内核的多任务管理能力。</p><p>可剥夺内核顾名思义就是可以剥夺其他任务的CPU使用权，它总是运行就绪任务中的优先级最高的那个任务。<br><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/freertos3.png" alt="freertos"></p><p>在FreeRTOS中，每个任务都是无限循环的，一般来说任务是不会结束运行的，也不允许有返回值，任务的结构一般都是</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">While</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">/****一直在循环执行*****/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果不需要这个任务了，那就把它删除。</p><p>移植的教程我就不写了，超级简单的，按照已有的大把教程来做就行了。（如果没有资源，可以在后台找我，我给一份移植的教程/源码）</p><p>其实FreeRTOS的运用及其简单，移植成功按照自己的意愿来配置即可，而且FreeRTOS有很多手册，虽然作者英语很差，但是我有谷歌翻译！！！哈哈哈</p><p>既然一直都说任务任务，那肯定要有任务啊，创建任务：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// task. h  task.c</span>BaseType_t <span class="token function">xTaskCreate</span><span class="token punctuation">(</span>      TaskFunction_t pvTaskCode<span class="token punctuation">,</span>                              <span class="token keyword">const</span> char <span class="token operator">*</span> <span class="token keyword">const</span> pcName<span class="token punctuation">,</span>                              uint16_t usStackDepth<span class="token punctuation">,</span>                              <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters<span class="token punctuation">,</span>                              UBaseType_t uxPriority<span class="token punctuation">,</span>                              TaskHandle_t <span class="token operator">*</span>pvCreatedTask                          <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数的原型都有，按照字面的理解</p><pre class="line-numbers language-js"><code class="language-js">TaskFunction_t pvTaskCode        <span class="token comment" spellcheck="true">//传递进来的是任务函数</span><span class="token keyword">const</span> char <span class="token operator">*</span> <span class="token keyword">const</span> pcName         <span class="token comment" spellcheck="true">//传递进来的是任务Name</span>uint16_t usStackDepth            <span class="token comment" spellcheck="true">//传入的是堆栈的大小</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在这里要说明一下，在裸机中开发，我们不管局部变量还是全局变量，反正定义了就能用，中断发生时，函数返回地址发哪里，我们也不管。但是在操作系统中，我们必须弄清楚我们的参数是怎么储存的，他们的大小是多大，就需要我们去定义这个堆栈的大小。它就是用来存放我们的这些东西的。太小，导致堆栈溢出，发生异常。（栈是单片机 RAM 里面一段连续的内存空间）</p><p>因为在多任务系统中，每个任务都是独立的，互不干扰的，所以要为每个任务都分配独立的栈空间。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">void</span> <span class="token operator">*</span>pvParameters              <span class="token comment" spellcheck="true">//传递给任务函数的参数</span>UBaseType_t uxPriority          <span class="token comment" spellcheck="true">//任务优先级</span>TaskHandle_t <span class="token operator">*</span>pvCreatedTask     <span class="token comment" spellcheck="true">//任务句柄</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>任务句柄也是很重要的东西，我们怎么删除任务也是要用到任务句柄，其实说白了，我操作系统怎么知道你是什么任务，靠的就是任务句柄的判断，才知道哪个任务在执行，哪个任务被挂起。下一个要执行的任务是哪个等等，靠的都是任务句柄。</p><p>那么要使用这些东西，我们肯定要实现啦，下面就是实现的定义，要定义优先级，堆栈大小，任务句柄，任务函数等。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//任务优先级</span>#define LED_TASK_PRIO           <span class="token number">2</span><span class="token comment" spellcheck="true">//任务堆栈大小     </span>#define LED_STK_SIZE             <span class="token number">50</span><span class="token comment" spellcheck="true">//任务句柄</span>TaskHandle_t LED_Task_Handler<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//任务函数</span><span class="token keyword">void</span> <span class="token function">LED_Task</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pvParameters<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建任务后，可以开启任务调度了，然后系统就开始运行。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">xTaskCreate</span><span class="token punctuation">(</span><span class="token punctuation">(</span>TaskFunction_t <span class="token punctuation">)</span>LED_Task<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//任务函数</span>            <span class="token punctuation">(</span><span class="token keyword">const</span> char<span class="token operator">*</span>    <span class="token punctuation">)</span><span class="token string">"led_task"</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">//任务名称</span>            <span class="token punctuation">(</span>uint16_t       <span class="token punctuation">)</span>LED_STK_SIZE<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//任务堆栈大小</span>            <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span>          <span class="token punctuation">)</span>NULL<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//传递给任务函数的参数</span>            <span class="token punctuation">(</span>UBaseType_t    <span class="token punctuation">)</span>START_TASK_PRIO<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//任务优先级</span>            <span class="token punctuation">(</span>TaskHandle_t<span class="token operator">*</span>  <span class="token punctuation">)</span><span class="token operator">&amp;</span>LED_Task_Handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//任务句柄 </span> <span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//开启任务调度</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个创建任务的函数 xTaskCreate 是有返回值的，其返回值的类型是BaseType_t。</p><p>我们在描述中看看：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// @return pdPASS if the task was successfully created and added to a readylist, otherwise an error code defined in the file projdefs.h</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们其实可以在任务调度的时候判断一下返回值是否为pdPASS从而知道任务创是否建成功。并且打印一个信息作为调试。因为后面使用信号量这些的时候都要知道信号量是否创建成功，使得代码健壮一些。免得有隐藏的bug。</p><p>然后就是具体实现我们的任务LED_Task是在做什么的</p><p>当然可以实现多个任务。还是很简单的。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//LED任务函数</span><span class="token keyword">void</span> <span class="token function">LED_Task</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pvParameters<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        LED0  <span class="token operator">=</span>  <span class="token operator">!</span>LED0<span class="token punctuation">;</span>        <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是一个简单的操作系统的概述。</p><p>下一篇，应该是讲述开启任务调度与任务切换的具体过程。</p><p>这个可以参考野火的书籍《从 0 到 1 教你写 uCOS-III》</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openmv学习之旅-2</title>
      <link href="/openmv-2/"/>
      <url>/openmv-2/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是杰杰。</p><p>从上一篇openmv的学习中<a href="https://jiejietop.gitee.io/openmv-1/" target="_blank" rel="noopener">openmv学习之旅-1</a></p><p>我们可以很简单运用micropython在openmv上做我们想做的事情。</p><p>Python这个东西用起来是很简单的，，下面来说说改善色块追踪的算法</p><p>先做个改善前的分析吧：</p><p>改善前：</p><pre class="line-numbers language-js"><code class="language-js">API：find_blobs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>thresholds</code> 是颜色的阈值。这个参数是一个列表，可以包含多个颜色。在返回的色块对象blob可以调用code方法，来判断是什么颜色的色块。</p><p><code>roi</code> 是“感兴趣区”。</p><p><code>x_stride</code> 就是查找的色块的x方向上最小宽度的像素，默认为2。</p><p><code>y_stride</code> 就是查找的色块的y方向上最小宽度的像素，默认为1。</p><p><code>area_threshold</code> 面积阈值，如果色块被框起来的面积小于这个值，会被过滤掉。</p><p><code>pixels_threshold</code> 像素个数阈值，如果色块像素数量小于这个值，会被过滤掉</p><p><code>merge</code> 合并，如果设置为True，那么合并所有重叠的blob为一个。 注意：这会合并所有的blob，无论是什么颜色的。如果你想混淆多种颜色的blob，只需要分别调用不同颜色阈值的find_blobs。</p><pre class="line-numbers language-js"><code class="language-js">blobs <span class="token operator">=</span> img<span class="token punctuation">.</span><span class="token function">find_blobs</span><span class="token punctuation">(</span><span class="token punctuation">[</span>red<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>find_blobs</code> 对象返回的是多个 <code>blob</code> 的列表。<br>而一个 <code>blobs</code> 列表里包含很多 <code>blob</code> 对象， <code>blobs</code> 对象就是色块，每个 <code>blobs</code> 对象包含一个色块的信息。</p><p>blob有多个方法：</p><p><code>blob.rect()</code> 返回这个色块的外框——矩形元组(x, y, w, h)，可以直接在image.draw_rectangle中使用。</p><p><code>blob.x()</code> 返回色块的外框的x坐标（int），也可以通过blob[0]来获取。</p><p><code>blob.y()</code>返回色块的外框的y坐标（int），也可以通过blob[1]来获取。</p><p><code>blob.w()</code>返回色块的外框的宽度w（int），也可以通过blob[2]来获取。</p><p><code>blob.h()</code>返回色块的外框的高度h（int），也可以通过blob[3]来获取。</p><p><code>blob.pixels()</code> 返回色块的像素数量（int），也可以通过blob[4]来获取。</p><p><code>blob.cx()</code> 返回色块的外框的中心x坐标（int），也可以通过blob[5]来获取。</p><p><code>blob.cy()</code> 返回色块的外框的中心y坐标（int），也可以通过blob[6]来获取。</p><p><code>blob.rotation()</code>返回色块的旋转角度（单位为弧度）（float）。如果色块类似一个铅笔，那么这个值为0-180°。如果色块是一个圆，那么这个值是无用的。如果色块完全没有对称性，那么你会得到0-360°，也可以通过blob[7]来获取。</p><p><code>blob.code()</code>返回一个16bit数字，每一个bit会对应每一个阈值。</p><p>（上面的知识在openmv的官网上都有说明）</p><p>下面是说说调用find_blobs来做色块的追踪的原理</p><p>它是全幅图像扫描，它有优点也有缺点</p><p>先说说优点吧:信息全面，全幅图像的搜索，把所有色块都搜索进来了</p><p>但是缺点也不少：①：运算的速度，是很慢的，有些地方我们根本不需要扫描它。</p><p>②：色块的数量，很多时候，会有很多延时差不多的色块过来干扰，导致追踪失败。</p><p>源码：</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">import</span> sensor<span class="token punctuation">,</span> image<span class="token punctuation">,</span> time red_threshold_01 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span> sensor<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>  sensor<span class="token punctuation">.</span>set_pixformat<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>RGB565<span class="token punctuation">)</span> sensor<span class="token punctuation">.</span>set_framesize<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>QVGA<span class="token punctuation">)</span>  sensor<span class="token punctuation">.</span>skip_frames<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>  sensor<span class="token punctuation">.</span>set_auto_whitebal<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span> clock <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    clock<span class="token punctuation">.</span>tick<span class="token punctuation">(</span><span class="token punctuation">)</span>    img <span class="token operator">=</span> sensor<span class="token punctuation">.</span>snapshot<span class="token punctuation">(</span><span class="token punctuation">)</span>     blobs <span class="token operator">=</span> img<span class="token punctuation">.</span>find_blobs<span class="token punctuation">(</span><span class="token punctuation">[</span>red_threshold_01<span class="token punctuation">]</span><span class="token punctuation">,</span>                             area_threshold<span class="token operator">=</span><span class="token number">150</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> blobs<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#如果找到了目标颜色</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>blobs<span class="token punctuation">)</span>        <span class="token keyword">for</span> b <span class="token keyword">in</span> blobs<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#迭代找到的目标颜色区域</span>            <span class="token comment" spellcheck="true"># Draw a rect around the blob.</span>            img<span class="token punctuation">.</span>draw_rectangle<span class="token punctuation">(</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># rect</span>            <span class="token comment" spellcheck="true">#用矩形标记出目标颜色区域</span>            img<span class="token punctuation">.</span>draw_cross<span class="token punctuation">(</span>b<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># cx, cy</span>            <span class="token comment" spellcheck="true">#在目标颜色区域的中心画十字形标记</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>clock<span class="token punctuation">.</span>fps<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果图：<br><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/openmv1.png" alt="openmv1"></p><p>运算速度：<br><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/openmv2.png" alt="openmv2"></p><p>从拍摄完到扫描完，每秒只能处理二十多帧图像，而且是简单的处理。</p><p>虽然脱机运行速度可以快一倍。但是还是比较慢的。</p><p>肯定要改进啊。</p><p>以下是改进扫描算法的思想：</p><p>①：首先做一次全幅图像的扫描，找到我们需要的色块。</p><p>②：我们得到色块的信息：如色块的长、宽、及色块的位置</p><p>③：我们只扫描色块周围的区域（ROI）</p><p>④：假设在新的ROI找不到我们需要的色块，就重新来。</p><p>这个方法类似于飞思卡尔的边缘检测。</p><p>其实这个改进是非常简单的。因为我们需要的东西在microPython中全部都有。</p><p>只需要拿到find_blobs的返回的东西就好啦。</p><p>算法示意图<br><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/openmv3.jpg" alt="openmv3"></p><p>绿色的是我们追踪的色块，</p><p>而红色的框是我们第一次全局扫描得到的东西</p><p>那么我们只需在红色的框之外做一次扫描就能得到绿色块啦</p><p>实现的源码</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">import</span> sensor<span class="token punctuation">,</span> image<span class="token punctuation">,</span> time <span class="token comment" spellcheck="true">#red_threshold_01 = (45, 100, -60, 80, 34, 91)</span> red_threshold_01 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">72</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">)</span> sensor<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>  sensor<span class="token punctuation">.</span>set_pixformat<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>RGB565<span class="token punctuation">)</span> sensor<span class="token punctuation">.</span>set_framesize<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>QVGA<span class="token punctuation">)</span>  sensor<span class="token punctuation">.</span>skip_frames<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>  sensor<span class="token punctuation">.</span>set_auto_whitebal<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#关闭白平衡。白平衡是默认开启的，在颜色识别中，需要关闭白平衡</span>clock <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span> img <span class="token operator">=</span> sensor<span class="token punctuation">.</span>snapshot<span class="token punctuation">(</span><span class="token punctuation">)</span>blobs <span class="token operator">=</span> img<span class="token punctuation">.</span>find_blobs<span class="token punctuation">(</span><span class="token punctuation">[</span>red_threshold_01<span class="token punctuation">]</span><span class="token punctuation">,</span>                         area_threshold<span class="token operator">=</span><span class="token number">150</span><span class="token punctuation">)</span>last_blobs <span class="token operator">=</span> blobs<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    clock<span class="token punctuation">.</span>tick<span class="token punctuation">(</span><span class="token punctuation">)</span>     img <span class="token operator">=</span> sensor<span class="token punctuation">.</span>snapshot<span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token keyword">if</span> last_blobs<span class="token punctuation">:</span>         <span class="token keyword">for</span> b <span class="token keyword">in</span> blobs<span class="token punctuation">:</span>            x1 <span class="token operator">=</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">7</span>            y1 <span class="token operator">=</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">7</span>            w1 <span class="token operator">=</span> b<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">12</span>            h1 <span class="token operator">=</span> b<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">12</span>            <span class="token comment" spellcheck="true">#print(b.cx(),b.cy())</span>         roi2 <span class="token operator">=</span> <span class="token punctuation">(</span>x1<span class="token punctuation">,</span>y1<span class="token punctuation">,</span>w1<span class="token punctuation">,</span>h1<span class="token punctuation">)</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>roi2<span class="token punctuation">)</span>         blobs <span class="token operator">=</span> img<span class="token punctuation">.</span>find_blobs<span class="token punctuation">(</span><span class="token punctuation">[</span>red_threshold_01<span class="token punctuation">]</span><span class="token punctuation">,</span>                                    roi <span class="token operator">=</span> roi2<span class="token punctuation">,</span>                                    area_threshold<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">)</span>         last_blobs <span class="token operator">=</span> blobs    <span class="token keyword">else</span><span class="token punctuation">:</span>        blobs <span class="token operator">=</span> img<span class="token punctuation">.</span>find_blobs<span class="token punctuation">(</span><span class="token punctuation">[</span>red_threshold_01<span class="token punctuation">]</span><span class="token punctuation">,</span>                                    area_threshold<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">)</span>        last_blobs <span class="token operator">=</span> blobs    <span class="token keyword">if</span> last_blobs<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#如果找到了目标颜色</span>        <span class="token comment" spellcheck="true">#  print(blobs)</span>        <span class="token keyword">for</span> b <span class="token keyword">in</span> last_blobs<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#迭代找到的目标颜色区域</span>            img<span class="token punctuation">.</span>draw_rectangle<span class="token punctuation">(</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>             img<span class="token punctuation">.</span>draw_cross<span class="token punctuation">(</span>b<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"帧率 : "</span><span class="token punctuation">,</span>clock<span class="token punctuation">.</span>fps<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改善后的帧率的确是快了不少的：基本能快一倍以上，当然，物体在图片越大，处理的速度会越慢。</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/openmv4.png" alt="openmv4"></p><p>帧率达到了  45  ，并且，对于运动中的物体，也能很好的追踪出来，减少无关物体的干扰。</p><p>按照这个思想，我们还能把这个物体分成四条边来扫描：</p><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/openmv5.jpg" alt="openmv5"></p><p>那么是不是只需要扫描到这个物体的四条边，并且证明四条边的点都有重合，那么，我们就能知道这个物体是一个整体从而得到物体的位置。。。。</p><p>当然，这只是想法。对于程序员任何的功能想法的实现都需要代码的实现，这代码我就不实现了，有兴趣的可以试试。。。</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openmv学习之旅-1</title>
      <link href="/openmv-1/"/>
      <url>/openmv-1/</url>
      
        <content type="html"><![CDATA[<p>最近入手了个OpenMv。<br>装IDE这种小事就不说了。说说真正入门的操作吧。对Python也没啥要求。我也是这样子马上上手的，当然在过程我是学习了Python的。</p><h1 id="1：绘制矩形"><a href="#1：绘制矩形" class="headerlink" title="1：绘制矩形"></a>1：绘制矩形</h1><p>函数说明</p><pre class="line-numbers language-python"><code class="language-python">image<span class="token punctuation">.</span>draw_rectangle（rect_tuple，颜色<span class="token operator">=</span>白色）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数</p><p><code>rect_tuple</code></p><p>格式（x，y，w，h）</p><p>矩阵的起始坐标，（x，y），即矩形的左上角坐标</p><p><code>w</code>：矩形的宽度</p><p><code>h</code>：矩形的高度</p><p><code>x，y，w，h</code>均为整数</p><p><code>颜色</code></p><p>颜色，填入灰度值<code>（0-255）</code>，或者 RGB 值<code>（r，g，b）</code></p><h1 id="下面简单画个矩形"><a href="#下面简单画个矩形" class="headerlink" title="下面简单画个矩形"></a>下面简单画个矩形</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/openmv-1-openmv.png" alt="openmv-1-openmv"></p><h1 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h1><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sensor<span class="token punctuation">,</span> image<span class="token punctuation">,</span> timesensor<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>                      <span class="token comment" spellcheck="true"># Reset and initialize the sensor.</span>sensor<span class="token punctuation">.</span>set_pixformat<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>RGB565<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># Set pixel format to RGB565 (or GRAYSCALE)</span>sensor<span class="token punctuation">.</span>set_framesize<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>QVGA<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Set frame size to QVGA (320x240)</span>sensor<span class="token punctuation">.</span>skip_frames<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># Wait for settings take effect.</span>clock <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># Create a clock object to track the FPS.</span>x <span class="token operator">=</span> <span class="token number">100</span>y <span class="token operator">=</span> <span class="token number">100</span>width <span class="token operator">=</span> <span class="token number">100</span>height <span class="token operator">=</span> <span class="token number">100</span>rect_tuple <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">)</span>rgb_white <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># (r=255, g=255, b=255) -> white color</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    clock<span class="token punctuation">.</span>tick<span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true"># Update the FPS clock.</span>    img <span class="token operator">=</span> sensor<span class="token punctuation">.</span>snapshot<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true"># Take a picture and return the image.</span>    img<span class="token punctuation">.</span>draw_string<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token string">"(%d, %d)"</span><span class="token operator">%</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> color<span class="token operator">=</span>rgb_white<span class="token punctuation">)</span>    img<span class="token punctuation">.</span>draw_rectangle<span class="token punctuation">(</span>rect_tuple<span class="token punctuation">,</span> color<span class="token operator">=</span>rgb_white<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>clock<span class="token punctuation">.</span>fps<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Note: OpenMV Cam runs about half as fast when connected</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是简单画矩形的图像，想要改变矩形位置就改变的x，y（图像左上角起点）</p><p>想要改变矩形面积就改变宽度，高度（图像宽＆高）改变线条颜色就改变 rgb_white</p><p>2：绘制十字</p><p>函数说明</p><pre class="line-numbers language-python"><code class="language-python">image<span class="token punctuation">.</span>draw_cross（x，y，size <span class="token operator">=</span> <span class="token number">5</span>，color <span class="token operator">=</span> White）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数</p><p><code>X</code></p><p>十字中心的 X 坐标</p><p><code>Y</code></p><p>十字中心的 y 坐标</p><p><code>尺寸</code></p><p>十字的长度</p><p><code>颜色</code></p><p>颜色，填入灰度值（0-255），或者 RGB 值（r，g，b）</p><p>样例代码</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sensor<span class="token punctuation">,</span> image<span class="token punctuation">,</span> timesensor<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>                      <span class="token comment" spellcheck="true"># Reset and initialize the sensor.</span>sensor<span class="token punctuation">.</span>set_pixformat<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>RGB565<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Set pixel format to RGB565 (or GRAYSCALE)</span>sensor<span class="token punctuation">.</span>set_framesize<span class="token punctuation">(</span>sensor<span class="token punctuation">.</span>QVGA<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Set frame size to QVGA (320x240)</span>sensor<span class="token punctuation">.</span>skip_frames<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># Wait for settings take effect.</span>clock <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># Create a clock object to track the FPS.</span>x <span class="token operator">=</span> <span class="token number">150</span>y <span class="token operator">=</span> <span class="token number">150</span>size <span class="token operator">=</span> <span class="token number">20</span>rgb_white <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># (r=255, g=255, b=255) -> white color</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    clock<span class="token punctuation">.</span>tick<span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true"># Update the FPS clock.</span>    img <span class="token operator">=</span> sensor<span class="token punctuation">.</span>snapshotA<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true"># Take a picture and return the image.</span>    img<span class="token punctuation">.</span>draw_string<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token string">"(%d, %d)"</span><span class="token operator">%</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> color<span class="token operator">=</span>rgb_white<span class="token punctuation">)</span>    img<span class="token punctuation">.</span>draw_cross<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> size<span class="token operator">=</span>size<span class="token punctuation">,</span> color<span class="token operator">=</span>rgb_white<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>clock<span class="token punctuation">.</span>fps<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># Note: OpenMV Cam runs about half as fast when connected</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>学会简单画图，就可以使用 openmv 来做色彩追踪了。</p><p>未完待续……下篇用openmv来做色彩追踪</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机C语言知识用法之#define</title>
      <link href="/c-define/"/>
      <url>/c-define/</url>
      
        <content type="html"><![CDATA[<h1 id="define的定义："><a href="#define的定义：" class="headerlink" title="#define的定义："></a>#define的定义：</h1><p>#define是C语言中的一个预处理指令，其中的“#”表示这是一条预处理命令·。凡是以“#”开头的均为预处理命令，“define”为宏定义命令，“标识符”为所定义的宏名。</p><pre class="line-numbers language-js"><code class="language-js">#define TIME_NUM  <span class="token number">1000</span>  <span class="token comment" spellcheck="true">//定义一个时间数</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一个简单的TIME_NUM 就定义好了，它代表1000，如果在程序里面写:</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>TIME_NUM <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token punctuation">.</span>    <span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译器在处理这个代码之前会对TIME_NUM 进行处理替换为1000。这样的定义看起来类似于普通的常量定义CONST，但也有着不同，因为define的定义更像是简单的文本替换，而不是作为一个量来使用。</p><h1 id="define的语法："><a href="#define的语法：" class="headerlink" title="#define的语法："></a>#define的语法：</h1><h2 id="语法一"><a href="#语法一" class="headerlink" title="语法一:"></a>语法一:</h2><pre class="line-numbers language-js"><code class="language-js">#define      标识符    被标识符代表的字符串      <span class="token comment" spellcheck="true">//这种用法很简单,就是一种替换.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="语法二"><a href="#语法二" class="headerlink" title="语法二:"></a>语法二:</h2><pre class="line-numbers language-js"><code class="language-js">#define     标识符<span class="token punctuation">[</span><span class="token punctuation">(</span>参数<span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>参数n<span class="token punctuation">)</span><span class="token punctuation">]</span>      被标识符代表的字符串        <span class="token comment" spellcheck="true">//其中,在 "被标识符代表的字符串" 中出现的形参将在使用时被实参替代. 就像写函数一样.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-js"><code class="language-js">#define    ADD_NUM     <span class="token number">10</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以这样子用:</p><pre class="line-numbers language-js"><code class="language-js">#define    <span class="token function">ADD</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>     <span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个定义就将返回两个数中较大的那个，看到了吗？<br>因为这个“函数”没有类型检查，就好像一个函数模板似的，当然，它绝对没有模板那么安全就是了。可以作为一个简单的模板来使用而已。<br>但是这样做的话存在隐患，例子如下：</p><pre class="line-numbers language-js"><code class="language-js">#define <span class="token function">ADD</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>   a<span class="token operator">+</span>b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在一般使用的时候是没有问题的，但是如果遇到如：c * Add(a,b) * d的时候就会出现问题，代数式的本意是a+b然后去和c，d相乘，但是因为使用了define（它只是一个简单的替换），所以式子实际上变成了  c<em>a + b</em>d 所以，用#define要注意顺序</p><p>一般我个人用#define在单片机程序上的话，我一般只做简单的替换。</p><pre class="line-numbers language-js"><code class="language-js">#define TIME_NUM   <span class="token punctuation">(</span><span class="token number">60</span><span class="token operator">*</span><span class="token number">60</span><span class="token operator">*</span><span class="token number">24</span><span class="token punctuation">)</span>UL<span class="token comment" spellcheck="true">//定义一个一天时间有多少秒</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外举一个例子：</p><pre class="line-numbers language-js"><code class="language-js">#define pin <span class="token punctuation">(</span>int<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pin a<span class="token punctuation">,</span>b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>本意是a和b都是int型指针，但是实际上变成int* a,b;<br>a是int型指针，而b是int型变量。<br>这是应该使用typedef来代替define，这样a和b就都是int型指针了。<br>所以我们在定义的时候，养成一个良好的习惯，建议所有的层次都要加括号。</p><p>而且，宏在单片机代码中用的很多，常数的替换、地址的偏移，等等都用得上<br>用宏来修改移植代码更加便捷，代码更容易使人读懂。。。。</p><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hellolo world</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="hello"><a href="#hello" class="headerlink" title="hello"></a>hello</h1><blockquote><p>网络的好朋友，你好，我是杰杰！如果我的博客有什么不足的地方，欢迎向我反馈；如果我的博客对你有帮助，那是我的荣幸！如果觉得文章很好，欢迎动动小手指，点个赞或者转发        —–杰杰。</p></blockquote><p>欢迎关注我个人微信公众号，来一起全栈开发~<br><img src="./images/loading.png" data-original="https://imgconvert.csdnimg.cn/aHR0cDovL2ppZWppZTAxLnRvcC9Mb2dvL0daLnBuZw?x-oss-process=image/format,png" alt=""></p><h1 id="网络协议栈-【推荐】"><a href="#网络协议栈-【推荐】" class="headerlink" title="网络协议栈 【推荐】"></a>网络协议栈 【推荐】</h1><ol><li><a href="https://blog.csdn.net/jiejiemcu/article/details/85233198" target="_blank" rel="noopener">lwip源码下载地址</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88024614" target="_blank" rel="noopener">TCP/IP协议栈扫盲班</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88204770" target="_blank" rel="noopener">网络底层知识</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88406088" target="_blank" rel="noopener">ARP协议原理</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88879553" target="_blank" rel="noopener">LwIP中的ARP实现（1）之ARP缓存表的数据结构</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88887437" target="_blank" rel="noopener">LwIP中的ARP实现（2）之ARP缓存表的超时处理</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88887466" target="_blank" rel="noopener">LwIP中的ARP实现（3）之发送ARP请求包</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88887494" target="_blank" rel="noopener">LwIP中的ARP实现（4）之ARP数据包接收</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/88887520" target="_blank" rel="noopener">LwIP中的ARP实现（5）之ARP数据包发送 </a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/89072812" target="_blank" rel="noopener">IP协议基础扫盲班</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/89072834" target="_blank" rel="noopener">IP地址相关知识深入了解~</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/89072573" target="_blank" rel="noopener">IP数据报格式分析</a></li></ol><p>未完待续…</p><h1 id="RTOS操作系统相关"><a href="#RTOS操作系统相关" class="headerlink" title="RTOS操作系统相关"></a>RTOS操作系统相关</h1><ol><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/86701792" target="_blank" rel="noopener">FreeRTOS移植——基于stm32f1</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80308052" target="_blank" rel="noopener">【连载】从单片机到操作系统③——走进FreeRTOS</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80463911" target="_blank" rel="noopener">【连载】从单片机到操作系统④——FreeRTOS创建任务&amp;开启调度详解</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80637559" target="_blank" rel="noopener">【连载】从单片机到操作系统⑤——FreeRTOS列表&amp;列表项的源码解读</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/81039707" target="_blank" rel="noopener">【连载】从单片机到操作系统⑥——FreeRTOS任务切换机制详解</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/81515788" target="_blank" rel="noopener">【连载】从单片机到操作系统⑦——深入了解FreeRTOS的延时机制</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82534974" target="_blank" rel="noopener">RTOS的临界段知识详解</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/86715766" target="_blank" rel="noopener">FreeRTOS消息队列</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/87174666" target="_blank" rel="noopener">FreeRTOS优化与错误排查方法</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/84778522" target="_blank" rel="noopener">继续学习FreeRTOS~</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82588304" target="_blank" rel="noopener">RT-Thread内核实现的思维导图——线程&amp;调度器</a></p><p>未完待续…</p></li></ol><h1 id="STM8"><a href="#STM8" class="headerlink" title="STM8"></a>STM8</h1><ol><li><a href="https://blog.csdn.net/jiejiemcu/article/details/80543012" target="_blank" rel="noopener"> STM8L051F3_0d_基础介绍</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/80219795" target="_blank" rel="noopener">STM8L051F3_0b_开发环境搭建</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/80219830" target="_blank" rel="noopener">STM8L051F3_0c_新建工程</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/80543043" target="_blank" rel="noopener">STM8L051F3_01_GPIO应用</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/80574810" target="_blank" rel="noopener">STM8L051F3_02_EXTI应用</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/80629051" target="_blank" rel="noopener">STM8L051F3_03_CLK应用</a></li><li><a href="https://blog.csdn.net/jiejiemcu/article/details/80659610" target="_blank" rel="noopener">STM8L051F3_04_PWR应用</a></li></ol><p>未完待续…</p><h1 id="STM32"><a href="#STM32" class="headerlink" title="STM32"></a>STM32</h1><ol><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80179096" target="_blank" rel="noopener">【干货】老外的GitHub整理的stm32f4驱动库</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80542667" target="_blank" rel="noopener">【重写】简析stm32启动过程</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80563422" target="_blank" rel="noopener">STM32进阶之串口环形缓冲区实现</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80565426" target="_blank" rel="noopener">嵌入式重定向 printf</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82227824" target="_blank" rel="noopener">数据处理相关源码</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82743945" target="_blank" rel="noopener">STM32之串口DMA接收不定长数据</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82898387" target="_blank" rel="noopener">基于Linux的kfifo移植到STM32（支持os的互斥访问）</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/83685631" target="_blank" rel="noopener">纯C语言写的按键驱动，将按键逻辑与按键处理事件分离~</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/83932913" target="_blank" rel="noopener">一种Cortex-M内核中的精确延时方法</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/87615397" target="_blank" rel="noopener">CmBacktrace: ARM Cortex-M 系列 MCU 错误追踪库</a></p><p>未完待续…</p></li></ol><h1 id="学习随笔"><a href="#学习随笔" class="headerlink" title="学习随笔"></a>学习随笔</h1><ol><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82049104" target="_blank" rel="noopener">git常用命令</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82262712" target="_blank" rel="noopener">vs code 随笔</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/82430157" target="_blank" rel="noopener">STM32等处理器的MDK离线支持包下载地址</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/84857382" target="_blank" rel="noopener">mdk5.26、5.27下载地址</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/85165949" target="_blank" rel="noopener">mdk工程的批量操作文件</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/87340868" target="_blank" rel="noopener">PDF Drive</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/87904149" target="_blank" rel="noopener">基于腾讯云Ubuntu主机搭建ghost</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/88097620" target="_blank" rel="noopener">基于ubuntu腾讯云主机搭建书库</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/88070640" target="_blank" rel="noopener">http客户端</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80543529" target="_blank" rel="noopener">基于小程序、单片机与PLC组合的共享车库信息平台平台【已经实现】</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/79307249" target="_blank" rel="noopener">超声波测距原理与实现</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/79469682" target="_blank" rel="noopener">openmv学习之旅①</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80579893" target="_blank" rel="noopener">openmv学习之旅②之色块追踪算法的改善</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80537935" target="_blank" rel="noopener">【野火®】i.MX RT1052评测——移植RT-Thread</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80495612" target="_blank" rel="noopener">开源一个串口上位机源码</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80543069" target="_blank" rel="noopener">win10 64位JLink v8固件丢失修复经验</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/79307319" target="_blank" rel="noopener">如何阅读看懂datasheet</a></p><p>未完待续…</p></li></ol><h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><ol><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/80861760" target="_blank" rel="noopener">C语言字符串匹配与数据提取源码</a></p></li><li><p><a href="https://blog.csdn.net/jiejiemcu/article/details/79307332" target="_blank" rel="noopener">单片机C语言知识用法之#define</a></p><p>未完待续…</p></li></ol><h1 id="喜欢就关注我吧！"><a href="#喜欢就关注我吧！" class="headerlink" title="喜欢就关注我吧！"></a>喜欢就关注我吧！</h1><p><img src="./images/loading.png" data-original="http://qiniu.jiejie01.top/gzh.jpg" alt="欢迎关注我公众号"></p><p>相关代码可以在公众号后台获取。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
